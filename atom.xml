<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Horb7&#39;s blog</title>
  
  <subtitle>一日事，一日毕</subtitle>
  <link href="https://horb7.github.io/atom.xml" rel="self"/>
  
  <link href="https://horb7.github.io/"/>
  <updated>2022-03-11T02:49:02.552Z</updated>
  <id>https://horb7.github.io/</id>
  
  <author>
    <name>Horb7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字图像处理实验</title>
    <link href="https://horb7.github.io/2022/03/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <id>https://horb7.github.io/2022/03/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</id>
    <published>2022-03-10T07:45:32.000Z</published>
    <updated>2022-03-11T02:49:02.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h1><h2 id="A-设置Python-OpenCV环境"><a href="#A-设置Python-OpenCV环境" class="headerlink" title="A. 设置Python+OpenCV环境"></a>A. 设置Python+OpenCV环境</h2><p>在命令行终端，输入 <code>pip install opencv-python</code> ，使用 $pip$ 安装 opencv ，注意 $pip$ 必须为最新版。</p><p>如果下载速度太慢，可以换成清华源进行下载：<code>pip3 install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple</code> 。</p><p>安装后，可以在 Pycharm专业版中输入 ：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'avatar.jpg'</span>)</span><br><span class="line">cv2.imshow(<span class="string">'My Avatar'</span>, img)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyWindow(<span class="string">'My Avatar'</span>)</span><br></pre></td></tr></tbody></table></figure><p>测试结果：</p><p><img src="\images\photo_change\image-20220310155554977.png" alt="image-20220310155554977"></p><p>其中：</p><p><code>cv2.imread</code> 函数表示读取一张图像，返回一个三维 <code>ndarray</code> ，前两维分别表示图像的长和宽，第三维表示图像的通道。</p><p><code>cv2.imshow</code> 可以展示一张图像，第一个参数为窗口名称，第二个参数为需要展示的图像(以<code>ndarray</code>表示)。</p><p><code>cv2.waitkey</code> 是一个窗口绑定函数，等待键盘符号的读入，并返回对应的 Ascii 码。</p><p><code>cv2.destroyAllWindows</code> 可以销毁所有窗口，也可以使用 <code>cv2.destroyWindow</code> 来销毁具体的某个窗口。</p><p><a href="https://blog.csdn.net/silence2015/article/details/53789748?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164696222516780269881044%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164696222516780269881044&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-53789748.article_score_rank&amp;utm_term=%E9%80%9A%E9%81%93&amp;spm=1018.2226.3001.4187">RGB图像之灰度级和通道的理解</a></p><hr><h2 id="B-练习图像分离、截取、转换等函数"><a href="#B-练习图像分离、截取、转换等函数" class="headerlink" title="B. 练习图像分离、截取、转换等函数"></a>B. 练习图像分离、截取、转换等函数</h2><h3 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h3><p><code>cv2.split</code> 函数可以分离图像的蓝、绿、红三种颜色，分离后的形成一个三个元素的列表，分别表示蓝、绿、红三种颜色在图像每个像素点的信息，为二维 <code>ndarray</code> 类型，可以对其进行展示等。</p><p>使用 <code>cv2.merge</code> 函数可以将三个分离的通道合并形成图像，在这之前可以对单独的通道进行修改等。</p><p><img src="\images\photo_change\image-20220310160804950.png" alt="image-20220310160804950"></p><p>我们也可以使用内置的方法进行图像的分离，比如使用 <code>cvtColor</code> 将图像进行转换。</p><p>下面为使用 <code>cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)</code> 将图像转换为灰度图的例子。</p><p><img src="\images\photo_change\image-20220310161128452.png" alt="image-20220310161128452"></p><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>上面提到了 <code>cv2.imread</code> 将图像转变为三维 <code>ndarray</code> 进行存储。我们可以提取出某一部分子矩阵作为新的图像，使用 <code>cv2.imwrite</code> 进行图像保存。</p><p><img src="\images\photo_change\image-20220310161558143.png" alt="image-20220310161558143"></p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>使用 <code>cv2.flip</code> 可以对图像进行转换，如垂直翻转，水平翻转，垂直+水平翻转。</p><div class="table-container"><table><thead><tr><th>param</th><th>效果</th></tr></thead><tbody><tr><td>1</td><td>水平翻转</td></tr><tr><td>0</td><td>垂直翻转</td></tr><tr><td>-1</td><td>垂直+水平翻转</td></tr></tbody></table></div><p>注意<code>cv2.flip</code> 返回的是新图像的存储，而不是对传进去的图像进行直接修改，可以使用 <code>new_img = cv2.flip(img, 1)</code> 来存储。</p><hr><h2 id="C-图像颜色变换"><a href="#C-图像颜色变换" class="headerlink" title="C. 图像颜色变换"></a>C. 图像颜色变换</h2><p>根据上述图像的图像截取，我们可以将一部分图像截取，然后修改其通道信息即可修改部分图像的颜色。</p><p><img src="\images\photo_change\image-20220310162402281.png" alt="image-20220310162402281"></p><hr><h2 id="D-计算和显示直方图"><a href="#D-计算和显示直方图" class="headerlink" title="D. 计算和显示直方图"></a>D. 计算和显示直方图</h2><p><code>cv2.calcHist</code> 函数用于计算图像直方图。</p><p>函数原型：<code>cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) #返回hist</code></p><p>其中：</p><ul><li>images:：输入的图像</li><li>channels：选择图像的通道</li><li>mask：掩码，是一个大小的iamges一样的 $ndarray$ 数组，其中把需要处理的部分指定为 $1$ ，不需要处理的部分指定为 $0$ 。一般设置为 $None$ ，表示处理整幅图像</li><li>histSize：使用多少个bin(柱子)，一般为256</li><li>ranges：像素值的范围，一般为 $[0, 255]$ 表示 $0 \sim 255$ </li></ul><p>后面两个参数基本不用输入，注意除了mask，其他四个参数都要带 [] 号。</p><p><img src="\images\photo_change\image-20220311094726897.png" alt="image-20220311094726897"></p><p><strong>计算灰度图像的直方图，输出 $100-128$ 的灰度值的像素数目：</strong></p><p><img src="\images\photo_change\image-20220311100346300.png" alt="image-20220311100346300"></p><p><strong>搜索查找具有最多像素数目的灰度级：</strong></p><p><img src="\images\photo_change\image-20220311101808970.png" alt="image-20220311101808970"></p><p><strong>使用 matplotlib 包画出直方图：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/37959111">教程</a></p><p>效果：</p><p><img src="\images\photo_change\image-20220311103036544.png" alt="image-20220311103036544"></p><h2 id="E-图像统计处理"><a href="#E-图像统计处理" class="headerlink" title="E. 图像统计处理"></a>E. 图像统计处理</h2><p><code>cv2.minMaxLoc</code> 函数可以在数组中寻找全局最小值和全局最大值，以及他们所处的位置。</p><p>由 <code>cv2.split</code> 分离出的通道属于二维 <code>ndarray</code> ，我们可以结合起来求出某一个通道中图像的最大值和最小值。</p><p><img src="\images\photo_change\image-20220310162827328.png" alt="image-20220310162827328"></p><p><code>cv2.meanStdDev</code> 函数可以统计矩阵的均值和标准偏差。</p><p>同理，我们可以结合 <code>cv2.split</code> ，求出绿色通道的图像矩阵的均值和标准差。</p><p><img src="\images\photo_change\image-20220310163112777.png" alt="image-20220310163112777"></p><hr><h2 id="F-图像缩放处理"><a href="#F-图像缩放处理" class="headerlink" title="F. 图像缩放处理"></a>F. 图像缩放处理</h2><p><code>cv2.resize</code> 函数可以用来处理图像的缩放。</p><p>函数需要用到的形参：</p><ol><li>原图片</li><li>dsize ：代表期望的输出图像的尺寸</li><li>fx, fy ：表示沿 x, y 轴的缩放比例</li><li>interpolation ：插值方式，默认为线性插值。</li></ol><p>注意，如果 $dsize$ 设置为 $None$ ，则以 $fx \times fy$ 作为输出图片的尺寸。</p><p><img src="\images\photo_change\image-20220310164145972.png" alt="image-20220310164145972"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验1&quot;&gt;&lt;a href=&quot;#实验1&quot; class=&quot;headerlink&quot; title=&quot;实验1&quot;&gt;&lt;/a&gt;实验1&lt;/h1&gt;&lt;h2 id=&quot;A-设置Python-OpenCV环境&quot;&gt;&lt;a href=&quot;#A-设置Python-OpenCV环境&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="数字图像处理" scheme="https://horb7.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>动态开点线段树+线段树合并</title>
    <link href="https://horb7.github.io/2022/03/09/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    <id>https://horb7.github.io/2022/03/09/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/</id>
    <published>2022-03-09T05:52:35.000Z</published>
    <updated>2022-03-09T05:52:59.668Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树上差分+动态开点线段树合并 */</span></span><br><span class="line"><span class="comment">// 线段树维护最大值和最大值所在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span> <span class="keyword">int</span> l, r, Max, Pos; } t[N * <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>]; <span class="comment">// 求lca</span></span><br><span class="line"><span class="keyword">int</span> X[N], Y[N], Z[N], Ans[N]; <span class="comment">// 离线查询</span></span><br><span class="line"><span class="keyword">int</span> root[N], idx;</span><br><span class="line"><span class="keyword">int</span> R; <span class="comment">// R为救济品编号最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- lca --------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* --------- lca --------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 动态开点线段树，维护区间最大值及对应的位置 --------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[t[p].l].Max &gt;= t[t[p].r].Max)</span><br><span class="line">        t[p].Max = t[t[p].l].Max, t[p].Pos = t[t[p].l].Pos;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t[p].Max = t[t[p].r].Max, t[p].Pos = t[t[p].r].Pos;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++ idx; <span class="comment">// 没有点，创建新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].Max += v; t[p].Pos = l; <span class="keyword">return</span> p; }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) t[p].l = <span class="built_in">update</span>(t[p].l, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> t[p].r = <span class="built_in">update</span>(t[p].r, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* --------- 线段树 --------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 树上差分求子树前缀和，线段树合并 --------- */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 把q线段树合并到p线段树上</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> q; <span class="keyword">if</span> (!q) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].Max += t[q].Max; t[p].Pos = l; <span class="keyword">return</span> p; }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    t[p].l = <span class="built_in">merge</span>(t[p].l, t[q].l, l, mid);</span><br><span class="line">    t[p].r = <span class="built_in">merge</span>(t[p].r, t[q].r, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Redfs</span>(v, u);</span><br><span class="line">        root[u] = <span class="built_in">merge</span>(root[u], root[v], <span class="number">1</span>, R);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (t[root[u]].Max) Ans[u] = t[root[u]].Pos;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 树上差分求子树前缀和，线段树合并 --------- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 预处理倍增数组求lca</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; X[i] &gt;&gt; Y[i] &gt;&gt; Z[i];</span><br><span class="line">        R = <span class="built_in">max</span>(Z[i], R);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 每个点都有一棵线段树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> Lca = <span class="built_in">lca</span>(X[i], Y[i]);</span><br><span class="line">        root[X[i]] = <span class="built_in">update</span>(root[X[i]], <span class="number">1</span>, R, Z[i], <span class="number">1</span>);</span><br><span class="line">        root[Y[i]] = <span class="built_in">update</span>(root[Y[i]], <span class="number">1</span>, R, Z[i], <span class="number">1</span>);</span><br><span class="line">        root[Lca] = <span class="built_in">update</span>(root[Lca], <span class="number">1</span>, R, Z[i], <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> gfa = f[Lca][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (gfa) root[gfa] = <span class="built_in">update</span>(root[gfa], <span class="number">1</span>, R, Z[i], <span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Redfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; Ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>扫描线</title>
    <link href="https://horb7.github.io/2022/03/07/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <id>https://horb7.github.io/2022/03/07/%E6%89%AB%E6%8F%8F%E7%BA%BF/</id>
    <published>2022-03-07T15:56:09.000Z</published>
    <updated>2022-03-07T16:27:49.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><p>扫描线是一种ACM中矩阵面积交以及矩阵周长和问题的解法，通常使用线段树解决。</p><h2 id="矩阵面积交"><a href="#矩阵面积交" class="headerlink" title="矩阵面积交"></a>矩阵面积交</h2><p><a href="https://www.luogu.com.cn/problem/P5490">[模板]扫描线</a></p><p>在进行矩阵面积运算时，我们将一条垂直与 $x$ 轴的直线，从 $y$ 轴 $-\infty$ 向 $+\infty$ 扫描，可以将所有矩阵交分割为若干个规则矩阵，如图所示：</p><p><img src="\images\problem\saomiao.png" alt=""></p><p>计算所有矩阵面积交，只需要算出每个规则矩阵的面积和即可。</p><p>对于每个规则矩阵，我们可以知道它的宽为 $x_i - x_{i-1}$ ，只需要知道它的高即可。</p><p>比如，对于 $[x_1, x_2]$ 区间内的规则矩阵，他们的高为两个矩阵的高之和，这个距离我们可以使用线段树维护。</p><p>具体来说，需要维护 $y$ 轴上有多少长度为区间内矩阵的高。</p><p>对于每个规则矩阵，我们设它的左边为入边，右边为出边，那么对于左边，给对应 $y$ 轴上所有点（规则矩阵的高上的所有点）加上权值 $1$ ，当扫描线扫出这个矩阵，也就是经过出边，就同理减去权值 $1$ 。</p><p>由于我们在查询的时候，只需要知道整个 $y$ 轴上有多少长度被覆盖，也就是只查询线段树第一个节点的信息，不需要知道线段树内部节点，那么就可以不使用PushDown操作。整个线段树自下往上传递信息，不需要自上往下传递信息。</p><p>由于 $y$ 轴上的点范围很大，可以对其离散化后，在离散化区间上作线段树，注意对于线段树所维护的区间，它的每个点表示的是与后面的点的边的覆盖次数，也就是把点映射为边。</p><p>剩下的有时间再写。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> {</span> <span class="keyword">int</span> x, y1, y2, k; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid (t[p].l + t[p].r &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> len, cover;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Y;</span><br><span class="line">Line line[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Node t[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p] = { l, r, <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line">    <span class="keyword">if</span> (l != r) { <span class="built_in">build</span>(lc, l, mid); <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r); }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].cover) t[p].len = Y[t[p].r + <span class="number">1</span>] - Y[t[p].l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t[p].l == t[p].r) t[p].len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> t[p].len = t[lc].len + t[rc].len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r)</span><br><span class="line">    {</span><br><span class="line">        t[p].cover += k;</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(lc, l, r, k);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)  <span class="built_in">update</span>(rc, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        line[j ++ ] = { x1, y1, y2, <span class="number">1</span> };</span><br><span class="line">        line[j ++ ] = { x2, y1, y2, <span class="number">-1</span> };</span><br><span class="line">        Y.<span class="built_in">push_back</span>(y1), Y.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(Y.<span class="built_in">begin</span>(), Y.<span class="built_in">end</span>());</span><br><span class="line">    Y.<span class="built_in">erase</span>(<span class="built_in">unique</span>(Y.<span class="built_in">begin</span>(), Y.<span class="built_in">end</span>()), Y.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> <span class="built_in">lower_bound</span>(Y.<span class="built_in">begin</span>(), Y.<span class="built_in">end</span>(), x) - Y.<span class="built_in">begin</span>(); };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(line + <span class="number">1</span>, line + n * <span class="number">2</span> + <span class="number">1</span>, [&amp;](Line a, Line b){ <span class="keyword">return</span> a.x &lt; b.x; });</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, Y.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 在Y轴上建立线段树,点映射为边，最后的点无用</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans = ans + (<span class="keyword">long</span> <span class="keyword">long</span>)t[<span class="number">1</span>].len * (line[i].x - line[i<span class="number">-1</span>].x);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="built_in">find</span>(line[i].y1), <span class="built_in">find</span>(line[i].y2) - <span class="number">1</span>, line[i].k);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;扫描线&quot;&gt;&lt;a href=&quot;#扫描线&quot; class=&quot;headerlink&quot; title=&quot;扫描线&quot;&gt;&lt;/a&gt;扫描线&lt;/h1&gt;&lt;p&gt;扫描线是一种ACM中矩阵面积交以及矩阵周长和问题的解法，通常使用线段树解决。&lt;/p&gt;
&lt;h2 id=&quot;矩阵面积交&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数据结构" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="线段树" scheme="https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 774(Div.2)</title>
    <link href="https://horb7.github.io/2022/03/05/Codeforces-Round-774-Div-2/"/>
    <id>https://horb7.github.io/2022/03/05/Codeforces-Round-774-Div-2/</id>
    <published>2022-03-05T03:42:20.000Z</published>
    <updated>2022-03-05T04:35:10.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Factorials-and-Powers-of-Two"><a href="#C-Factorials-and-Powers-of-Two" class="headerlink" title="C. Factorials and Powers of Two"></a>C. Factorials and Powers of Two</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定数字 $n$ ，它可以由 $k$ 个<strong>不同的</strong>阶乘数和 $2$ 的幂次数组成。求出最小的 $k$ 。</p><p>其中 $1 \le n \le 10^{12}$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于在 $10^{12}$ 内直接只有 $0 \sim 15$ 的阶乘，所以可以二进制枚举需要累加哪些阶乘。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popll(x) (ll)__builtin_popcountll(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">ll fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n, k = <span class="number">2e9</span> + <span class="number">10</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>); s ++ )</span><br><span class="line">    {</span><br><span class="line">        ll now = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) now -= fac[i];</span><br><span class="line">        <span class="keyword">if</span> (now &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        k = <span class="built_in">min</span>(k, <span class="built_in">popll</span>(s) + <span class="built_in">popll</span>(now));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i ++ ) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="D-Weight-the-Tree"><a href="#D-Weight-the-Tree" class="headerlink" title="D.  Weight the Tree"></a>D.  Weight the Tree</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $n$ 个节点的树，为每个节点赋一个正数，使得树上好点最多。如果有多种方案，输出点权和最小的一种方案。</p><p>好点：点权等于邻接点的点权之和的点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>对于 $n = 2$ 的树，明显两个点都可以作为好点，并且每个点点权为 $1$ 。</p><p>对于 $n \gt 2$ 的树，对于任意一条边 $(u, v)$ ，<strong>至多只有一个点为好点</strong>。</p><p>使用树形DP，$dp(i, 0)$ 表示以 $i$ 为根的树，且 $i$ 不作为好点时，最大的好点数量，以及对应的所有好点的边权。同理 $dp(i, 1) $ 表示 $i$ 作为好点。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, val[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp[N][<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dp[u][<span class="number">0</span>] = { <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line">    dp[u][<span class="number">1</span>] = { <span class="number">1</span>, -(<span class="keyword">int</span>)g[u].<span class="built_in">size</span>() };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        dp[u][<span class="number">1</span>].first += dp[v][<span class="number">0</span>].first;</span><br><span class="line">        dp[u][<span class="number">1</span>].second += dp[v][<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">auto</span> M = <span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]); <span class="comment">// 在好点相同的情况下，要选择权值小的</span></span><br><span class="line">        dp[u][<span class="number">0</span>].first += M.first;</span><br><span class="line">        dp[u][<span class="number">0</span>].second += M.second;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_val</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) val[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> val[u] = g[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="built_in">get_val</span>(v, <span class="number">0</span>, u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (dp[v][<span class="number">0</span>] &gt; dp[v][<span class="number">1</span>]) <span class="built_in">get_val</span>(v, <span class="number">0</span>, u);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">get_val</span>(v, <span class="number">1</span>, u);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"2 2\n1 1\n"</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> M = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; M.first &lt;&lt; <span class="string">' '</span> &lt;&lt; -M.second + n - M.first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (M == dp[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">get_val</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">get_val</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; val[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="E-Power-Board"><a href="#E-Power-Board" class="headerlink" title="E. Power Board"></a>E. Power Board</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定 $n \times m$ 的矩阵，其中 $(i, j)$ 位置上的数字为 $i^j$ 。问矩阵中不同的数字的个数。</p><p>其中 $1 \le n, m \le 10^6$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>首先，第一列的元素一定为 $[1, 2, 3, \ldots, n]$ 。</p><p>对于第 $2, 4, 8$ 行，他们是有公共元素的。</p><p>比如第 $2$ 行为 $2, 4, 8, 16, \ldots, 2^m$ 。</p><p>第 $4$ 行为 $4, 16, 64, \ldots, 4^m$ 。</p><p>第 $8$ 行为 $8, 64, 512, \ldots , 8^m$ 。</p><p>我们把他们都按照 $2$ 的幂次方来表示：</p><script type="math/tex; mode=display">\begin{aligned}&2^1, 2^2, 2^3, \ldots, 2^m \\&2^2, 2^4, 2^6, \ldots, 2^{2m} \\&2^3, 2^6, 2^{12}, \ldots, 2^{3m}\end{aligned}</script><p>那么不同的数字仅仅区别于他们的指数，也就是说，我们只需要知道这里有多少个不同的指数即可。</p><p>而上面的指数，在不同的底数情况下都是一样的，他们的答案仅仅区别于行数的多少( $3, 9, 27$ 的指数也是如此)。</p><p>也就是说，我们只需要对于 $n$ 的所有质数行进行分解，然后算出他们在 $n$ 行内有多少倍数(行)。行数最多为 $log_2n$ （即以 $2$ 为底数时所有的倍数行）， 大概在 $20$ 左右，所以只需要预处理最多 $20$ 行不同的指数数量即可。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> del[N], rows[N], cnt[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">bool</span> used[N * <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (ll p = i * i; p &lt;= n; p *= i) del[p] = <span class="literal">true</span>, ++ rows[i];</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!used[i * j]) ++ c, used[i * j] = <span class="literal">true</span>;</span><br><span class="line">        cnt[i] = c;</span><br><span class="line">    }</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!del[i]) ans = ans + cnt[rows[i] + <span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-Factorials-and-Powers-of-Two&quot;&gt;&lt;a href=&quot;#C-Factorials-and-Powers-of-Two&quot; class=&quot;headerlink&quot; title=&quot;C. Factorials and Powers of Two&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>小白月赛45F.交换</title>
    <link href="https://horb7.github.io/2022/03/04/%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B45F-%E4%BA%A4%E6%8D%A2/"/>
    <id>https://horb7.github.io/2022/03/04/%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B45F-%E4%BA%A4%E6%8D%A2/</id>
    <published>2022-03-04T14:14:10.000Z</published>
    <updated>2022-03-04T14:54:04.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个操作指令和 $m$ 个查询。</p><p>每个操作指令形如 $x \ \ y$ ，表示交换下标为 $x \ 、 \ y$  的数字。</p><p>对于每个查询，给出一段长度为 $k$ 的序列，你可以选择操作指令中的<strong>一段连续区间</strong>，使得操作完后，这个序列为升序。</p><p>对于每个查询，输出使得序列变为升序所需要的最小连续操作区间的长度，否则输出 $-1$ 。</p><p>其中， $1 \le n \le 2 \times 10^3, 1 \le m \le 10^4, 1 \le x, y, k \le 10$ 。保证每个查询给出的序列为 $[1, k]$ 的排列。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于每个连续的指令区间，一定有且仅有一个排列使得操作完后变为升序。（这里指长度最小的排列，因为任何以它为前缀的排列也一定可以变为升序）。</p><p>假设这个排列为 $P$ ，执行的指令区间为 $[l, r]$ ，那么有：$P -&gt; [l, r] -&gt; [1, 2, \ldots, k]$ 。</p><p>那么，反过来就是：$[1, 2, \ldots , k] -&gt; [r, l] -&gt; P$ 。</p><p>也就是说，对于每个连续指令区间，我们可以预处理出这个 $P$ 。</p><p>所以可以使用 $map \lt vector \lt int \gt , int \gt $ 来存储对于每个 $P$ ，能使它变升序的最小指令区间的长度。</p><p>或者把 $P$ 看作字符串，使用 $map \lt string, int \gt$ 存储。</p><p>这里有一个问题，预处理是 $O(n^3)$ 的。因为需要枚举 $l, r$ ，还要对于 $[l, r]$ 模拟指令来获得 $P$ 。</p><p>一种好的方法是，先正序枚举 $r$ ，再倒序枚举 $l$ ，这样模拟指令就是 $O(1)$ 了，预处理复杂度降为 $O(n^2)$ 。</p><p><del>本来本题到此为止了，但是由于出题人太毒瘤，使用 $map$ 被卡常了，所以还需要换一种策略。</del></p><p>我们可以使用 $Trie$ 树，把所有的查询都存储起来(离线)，记录每个查询所在的节点位置。</p><p>按照上述方法模拟所有区间的指令，预处理出来 $P$ 的最小升序所需区间长度。</p><p>注意如果长度最小的排列被 $[l, r]$ 满足，那么任意以它为前缀的排列也一定满足，所以在 $Trie$ 上要更新到底。</p><p>在查询中可能有本来就是升序的序列，需要特殊处理一下。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">12</span>], ans[N], qid[N], idx; <span class="comment">// ans(i)表示Trie上i节点的答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span> <span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> len, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x = s[i];</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][x]) trie[p][x] = ++ idx;</span><br><span class="line">        p = trie[p][x];</span><br><span class="line">    }</span><br><span class="line">    qid[id] = p; <span class="comment">// 查询次序为id，它所在的Trie树上的位置</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i ++ ) <span class="comment">// 注意更新所有长度</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x = s[i];</span><br><span class="line">        <span class="keyword">if</span> (trie[p][x])</span><br><span class="line">        {</span><br><span class="line">            p = trie[p][x];</span><br><span class="line">            ans[p] = <span class="built_in">min</span>(ans[p], len);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x[N], y[N], q[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(ans, INF, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> k; cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j ++ ) cin &gt;&gt; q[j];</span><br><span class="line">        <span class="built_in">ins</span>(q, k, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; r ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i ++ ) p[i] = i;</span><br><span class="line">        <span class="built_in">update</span>(p, <span class="number">0</span>); <span class="comment">// 特殊处理本来就是升序的查询</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = r; l &gt;= <span class="number">1</span>; l -- )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">swap</span>(p[x[l]], p[y[l]]);</span><br><span class="line">            <span class="built_in">update</span>(p, r - l + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (ans[qid[i]] == INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans[qid[i]] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交换&quot;&gt;&lt;a href=&quot;#交换&quot; class=&quot;headerlink&quot; title=&quot;交换&quot;&gt;&lt;/a&gt;交换&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021浙江省赛题解</title>
    <link href="https://horb7.github.io/2022/03/02/2021%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>https://horb7.github.io/2022/03/02/2021%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</id>
    <published>2022-03-02T05:38:31.000Z</published>
    <updated>2022-03-02T08:50:21.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D-Shortest-Path-Query"><a href="#D-Shortest-Path-Query" class="headerlink" title="D. Shortest Path Query"></a>D. Shortest Path Query</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;ll, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">vector&lt;T&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> n, m, vis[N];</span><br><span class="line">ll f[N][<span class="number">21</span>]; <span class="comment">// f(i, j)表示i点删了j个后面的数字的点走过的最短路</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">// 以root点作为前缀，在它后面加数字，与其他各数字的最短路</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; q;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    q.<span class="built_in">push</span>({<span class="number">0</span>, root});</span><br><span class="line">    <span class="keyword">int</span> j; f[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        T t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ll dist = t.first, u = t.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>; c.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; (u &gt;&gt; j) != root; ++ j);</span><br><span class="line">        f[u][j] = <span class="built_in">min</span>(f[u][j], dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, w]: g[u])</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; v &gt;= root)</span><br><span class="line">                q.<span class="built_in">push</span>({w + dist, v});</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: c) vis[v] = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ll u, v, w, j; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>({v, w});</span><br><span class="line">        g[v].<span class="built_in">push_back</span>({u, w});</span><br><span class="line">        <span class="comment">// v删除j个末尾数字，到达u</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; (v &gt;&gt; j) != u; ++ j);</span><br><span class="line">        f[v][j] = <span class="built_in">min</span>(f[v][j], w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, j = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        ll ans = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 枚举u和v的公共前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">28</span>; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>((v &gt;&gt; i) &lt; (u &gt;&gt; j)) ++ j;</span><br><span class="line">            <span class="keyword">if</span> ((v &gt;&gt; i) == (u &gt;&gt; j)) ans = <span class="built_in">min</span>(ans, <span class="number">1ll</span> * f[u][j] + f[v][i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">60ll</span> * <span class="number">1e9</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-Fair-Distribution"><a href="#F-Fair-Distribution" class="headerlink" title="F. Fair Distribution"></a>F. Fair Distribution</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个数字 $a, b$ ，每次操作可以使 $a - 1$ ，或者 $b + 1$ ，问使 $b \% a == 0$ 的最小操作数量。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假设 $a$ 减小了 $x$ ，那么有 $x \in [0, a-1]$ ，即 $a - x \in [1, a]$ 。</p><p>那么对于 $b$ ，它为了使 $b \% a == 0$ 的最小步数为 $\lceil \dfrac b {a-x} \rceil \times (a - x)$ ，注意 $b$ 只能向上增加，所以要向上取整。</p><p>令 $a - x = i$ ，那么有 $i \in [1, a]$ 。</p><p>总操作数为：</p><script type="math/tex; mode=display">\begin{aligned}&x + \lceil \dfrac b i \rceil \times i - b \\= &a - i + \lceil \dfrac b i \rceil \times i - b \\= &a - i + \lfloor\dfrac {b + i - 1} i \rfloor \times i - b \\= &(a - b) + \lfloor\dfrac {b - 1} i \rfloor \times i\end{aligned}</script><p>可以使用整除分块，枚举 $i$ 的值。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span>(cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a, b, ans = <span class="number">2e9</span>; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b) { cout &lt;&lt; a - b &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= a; l = r + <span class="number">1</span> )</span><br><span class="line">        {</span><br><span class="line">            r = <span class="built_in">min</span>(a, (b - <span class="number">1</span>) / ((b - <span class="number">1</span>) / l));</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (b - <span class="number">1</span>) / l * l + a - b);</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-Wall-Game"><a href="#G-Wall-Game" class="headerlink" title="G. Wall Game"></a>G. Wall Game</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p><img src="\images\problem\Wall_Game.png" alt="image-20220302163515869"></p><p>如图，有 $n$ 个操作，每个操作为：</p><ol><li>在图上添加点（图中单个的的六边形），并和相邻的点联通。</li><li>查询这个点所在的联通块与外界的边的数量。</li></ol><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>使用并查集维护集合内的边的数量。</p><p>由于直接维护边不好维护，可以开两个数组，一个维护集合点的数量，一个维护集合内失效边的数量。</p><p>在合并集合时，遍历点所在的六个相邻点，查询是否已经在同一个联通块，如果在，则失效边增加 $2$ ，否则需要合并两个集合，且失效边加 $2$ 。</p><p>由于点是二维的，可以使用 $map$ 来把点映射为数值。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; Map; <span class="comment">// 把点映射为数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], siz[N], decr[N]; <span class="comment">// decr表示联通块有多少边无效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    Map[{x, y}] = ++ cnt;</span><br><span class="line">    siz[cnt] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++ ) <span class="comment">// 枚举他的6个相邻块</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> dx = x + dr[i], dy = y + dc[i];</span><br><span class="line">        <span class="keyword">if</span> (!Map.<span class="built_in">count</span>({dx, dy})) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> pdx = <span class="built_in">find</span>(Map[{dx, dy}]);</span><br><span class="line">        <span class="keyword">if</span> (pdx != cnt)</span><br><span class="line">        {</span><br><span class="line">            siz[cnt] += siz[pdx];</span><br><span class="line">            decr[cnt] += decr[pdx] + <span class="number">2</span>;</span><br><span class="line">            p[pdx] = cnt;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> decr[cnt] += <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">merge</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> key = <span class="built_in">find</span>(Map[{x, y}]);</span><br><span class="line">            cout &lt;&lt; siz[key] * <span class="number">6</span> - decr[key] &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;D-Shortest-Path-Query&quot;&gt;&lt;a href=&quot;#D-Shortest-Path-Query&quot; class=&quot;headerlink&quot; title=&quot;D. Shortest Path Query&quot;&gt;&lt;/a&gt;D. Shortest Path Query</summary>
      
    
    
    
    
    <category term="区域赛" scheme="https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Namomo Spring Camp 2022每日一题</title>
    <link href="https://horb7.github.io/2022/02/26/Namomo-Spring-Camp-2022%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>https://horb7.github.io/2022/02/26/Namomo-Spring-Camp-2022%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-02-26T11:54:39.000Z</published>
    <updated>2022-03-09T08:40:45.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子串的最大差"><a href="#子串的最大差" class="headerlink" title="子串的最大差"></a>子串的最大差</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义序列的最大差为序列中最大数与最小数的差。比如 $(3,1,4,5,6)$ 的最大差为 $6−1=5 , (2,2)$ 的最大差为 $2−2=0$  。</p><p>定义一个序列的子串为该序列中连续的一段序列。</p><p>给定一个长度为 $n$ 的数组 $a_1,a_2, \ldots ,a_n$，请求出这个序列的所有子串的最大差之和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>所有子串的最大差之和 = 所有子串最大值之和 - 所有子串最小值之和。</p><p>所以可以单独算出最大值之和与最小值之和。</p><p>考虑每个元素作为最大值/最小值的贡献，以最大值为例，假设它前面最近的大于它的元素位置为 $lmax$ ，同理右边为 $rmax$ ，则左边可作为端点的数量为 $i - (lmax-1) + 1$ ，同理右边为 $(rmax-1) - i + 1$ 。那么当前点作为最大值的贡献为 $((rmax-1)-i+1) * (i-(lmax-1)+1) - 1$ 。</p><p>计算每个点的 $lmax$ 和 $rmax$ 可以使用单调栈，具体可参考<a href="https://www.acwing.com/problem/content/832/">这里</a>。</p><p><strong>注意点</strong>：在最大值有多个的区间，如 $[5, 1, 5]$ ，对于所有的 $5$ ，对这个区间一共只能有一个贡献，我们可以让最后面的元素产生贡献，为此，在计算 $lmax$ 时，应该使其取非单调上升序列，而 $rmax$ 取严格下降序列。</p><p>小Trick，在计算完最大值后将所有元素乘上 $-1$ ，这样就又是求最大值，可以复用代码。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], stk[N], top, lmax[N], rmax[N], lmin[N], rmin[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单调栈解决离元素最近且大于它的元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> *left, <span class="keyword">int</span> *right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// left</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; a[stk[top]] &lt; a[i]) -- top;</span><br><span class="line">        left[i] = (top ? stk[top] + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        stk[++ top] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// right</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; a[stk[top]] &lt;= a[i]) -- top;</span><br><span class="line">        right[i] = (top ? stk[top] - <span class="number">1</span>: n);</span><br><span class="line">        stk[++ top] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">calc</span>(lmax, rmax);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) a[i] *= <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">calc</span>(lmin, rmin);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) a[i] *= <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans += <span class="number">1ll</span> * a[i] * (rmax[i] - i + <span class="number">1</span>) * (i - lmax[i] + <span class="number">1</span>);</span><br><span class="line">        ans -= <span class="number">1ll</span> * a[i] * (rmin[i] - i + <span class="number">1</span>) * (i - lmin[i] + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="no-crossing"><a href="#no-crossing" class="headerlink" title="no crossing"></a>no crossing</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个<strong>有向图</strong>，找一条恰好经过 $k$ 个点的最短路径，要求每次选的边<strong>不能越过</strong>之前选择的点，即：对于路径中的边 $x -&gt; y$ ，不存在以前经过的点使得三者关系为：$min(x, y) \le t \le max(x, y)$ 。</p><p>其中 $1 \le n, k \le 100, 0 \le m \le 2000, 1 \le a_i, b_i \le n, 1 \le c_i \le 1000$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>区间DP，记 $f(l, r, dir, step)$ 表示 $[l, r]$ 区间，且方向为 $dir$ ，走过的步数为 $step$ 时最短的路径。</p><p>$dir$ ：$dir$ 为 $0$ 时表示从 $l$ 跳到 $[l+1, r-1]$ 中的某个点，为 $1$ 时表示从 $r$ 跳到 $[l+1, r-1]$ 的某个点。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m, ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N][<span class="number">2</span>][N]; <span class="comment">// dp(l, r, dir, step) 表示[l, r]，方向为dir，步数为step的最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> dir, <span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (step == k - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;ans = dp[l][r][dir][step];</span><br><span class="line">    <span class="keyword">if</span> (~ans) <span class="keyword">return</span> ans; <span class="keyword">else</span> ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 转移</span></span><br><span class="line">    <span class="keyword">int</span> from = dir ? r : l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = l + <span class="number">1</span>; to &lt; r; to ++ )</span><br><span class="line">        <span class="keyword">if</span> (g[from][to])</span><br><span class="line">        {</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(to, r, <span class="number">0</span>, step + <span class="number">1</span>) + g[from][to]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(l, to, <span class="number">1</span>, step + <span class="number">1</span>) + g[from][to]);</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span> (g[u][v]) g[u][v] = <span class="built_in">min</span>(g[u][v], w);</span><br><span class="line">        <span class="keyword">else</span> g[u][v] = w;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(<span class="number">0</span>, i, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(i, n+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">2e9</span>) ans = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="Dis"><a href="#Dis" class="headerlink" title="Dis"></a>Dis</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出 $n$ 个点的一棵树，每个点有各自的点权，多次询问两个点简单路径所构成的点集的异或和。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>$Xor(u, v) = Xor(u, root) \bigoplus Xor(v, root) \bigoplus LCA(u, v)$ 。</p><p>$dfs$ 或者 $bfs$ 求出根节点到每个点的路径上点权异或和，同时预处理 $lca$ 的倍增数组即可。</p><p>也可以使用 $Tarjan$ 离线求 $lca$ ，单次处理复杂度降到 $O(1)$ 。</p><p>如果题目要求点权可以修改，则可以使用树链刨分转换为序列，使用线段树或者树状数组维护。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p><strong>倍增LCA求法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>], Xor[N]; <span class="comment">// Xor(i)表示从根节点到i的路径上的异或和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>; Xor[u] = Xor[fa] ^ a[u];</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 以1为树的根</span></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Xor[u] ^ Xor[v] ^ a[<span class="built_in">lca</span>(u, v)]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>离线Tarjan求法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span> <span class="keyword">int</span> id, u, v, _lca; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], Xor[N];</span><br><span class="line"><span class="keyword">int</span> p[N], st[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line">vector&lt;A&gt; ans;</span><br><span class="line">vector&lt;T&gt; query[N]; <span class="comment">// query(i) 表示以i为某一点的所有lca查询</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    st[u] = <span class="number">1</span>; <span class="comment">// 正在搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (!st[v]) { Xor[v] ^= Xor[u]; <span class="built_in">Tarjan</span>(v); p[v] = u; }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, id]: query[u]) <span class="keyword">if</span> (st[v] == <span class="number">2</span>) ans.<span class="built_in">push_back</span>(A{ id, u, v, <span class="built_in">find</span>(v) });</span><br><span class="line">    st[u] = <span class="number">2</span>; <span class="comment">// 完成搜索，回溯</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), Xor[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        query[u].<span class="built_in">push_back</span>({v, i});</span><br><span class="line">        query[v].<span class="built_in">push_back</span>({u, i});</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), [&amp;](A a, A b){ <span class="keyword">return</span> a.id &lt; b.id; });</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[id, u, v, _lca]: ans) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Xor[u] ^ Xor[v] ^ a[_lca]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>树链刨分求法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwick</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] ^= v; }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ans ^= c[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">query</span>(r) ^ <span class="built_in">query</span>(l - <span class="number">1</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line">fenwick F;</span><br><span class="line"><span class="keyword">int</span> son[N], top[N], depth[N], siz[N], father[N], id[N], wt[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    father[u] = fa;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u); siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span> (siz[v] &gt; maxson) son[u] = v, maxson = siz[v];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> topfather)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    top[u] = topfather;</span><br><span class="line">    id[u] = ++ cnt;</span><br><span class="line">    wt[cnt] = a[u]; F.<span class="built_in">add</span>(cnt, wt[cnt]);</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topfather);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (v != son[u] &amp;&amp; v != father[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (depth[top[u]] &lt; depth[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        ans ^= F.<span class="built_in">query</span>(id[top[u]], id[u]);</span><br><span class="line">        u = father[top[u]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (depth[u] &gt; depth[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    ans ^= F.<span class="built_in">query</span>(id[u], id[v]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 第一次dfs求出depth, siz, father, son</span></span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 第二次dfs链接重链, 求出top, id, wt</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">query</span>(u, v));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="选数"><a href="#选数" class="headerlink" title="选数"></a>选数</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定 $N$ 个正整数 $a_1, a_2, \ldots , a_n$ 。要求从其中选出若干个数字，使得这些数字的和 $sum \equiv 0 \pmod N$ ，对于每个下标只能选择一次。若存在则输出选择的数字个数及其下标，否则输出 $-1$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>对于 $n$ 个数字，作前缀和，一共有 $n + 1$  个模数(注意还有全不选的情况)，根据鸽巢原理一定有两个模数相等，假设其在前缀和中的下标为 $i, j$ ，则对于 $[i+1, j]$ 区间的数字，它们的和一定 $sum \equiv 0 \pmod N$ 。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], pre[i] = (pre[i<span class="number">-1</span>] + a[i]) % n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; exist{{<span class="number">0</span>, <span class="number">0</span>}}; <span class="comment">// 记录模数是否出现过，以及出现的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (exist.<span class="built_in">count</span>(pre[i]))</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; i - exist[pre[i]] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = exist[pre[i]] + <span class="number">1</span>; j &lt;= i; j ++ ) cout &lt;&lt; j &lt;&lt; <span class="string">" \n"</span>[j == i];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        exist[pre[i]] = i;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的序列 $a_1, a_2 , \ldots , a_n$ 。</p><p>你需要进行两种操作：</p><ol><li>$1 \ \ x \ \ y$ ，表示将第 $x$ 个数字变为 $y$</li><li>$2 \ \ y$ ，表示将所有小于 $y$ 的数字修改为 $y$ </li></ol><p>一共进行 $q$ 次操作，输出执行完所有操作后的序列。</p><p>其中 $1 \le n , q \le 10^6, 0 \le a \le 10^9, 1 \le x \le n, 0 \le y \le 10^9$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p><strong>离线+ST表</strong></p><p>操作 $1$ 的优先级大于 $2$ ，对于每个数字，当执行操作 $1$ 时，前面所有对这个数字的操作 $2$ 都无效。</p><p>所以对于每个数字，我们只需要知道，所有在它最后一次操作 $1$ 之后的操作 $2$ ，对它的影响即可。</p><p>可以把操作 $2$ 存储起来，然后记录每个数字最后一次操作 $1$ 的位置，二分找到对应的操作 $2$ ，然后查询之后所有操作 $2$ 的最大值，与当前数字取最大值即可。</p><p><strong>(</strong>看了一眼题解emmm….. 我是SB，每次查询区间最大值都是以最后一个操作 $2$ 为右端点，所以只需要做一个后缀最大值计算即可</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> {</span> <span class="keyword">int</span> id, x; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SparseTable</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> n, st[N][<span class="number">21</span>], Lg[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, Q *a)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) Lg[i] = Lg[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) st[i][<span class="number">0</span>] = a[i].x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">                st[i][j] = <span class="built_in">max</span>(st[i][j<span class="number">-1</span>], st[i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> k = Lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], ans[N], last[N]; <span class="comment">// last统计每个下标最后更改的位置</span></span><br><span class="line">Q q[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line">SparseTable ST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y), last[x] = i, a[x] = y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>) q[++ cnt] = { i, x };</span><br><span class="line">    }</span><br><span class="line">    ST.<span class="built_in">init</span>(cnt, q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!last[i]) a[i] = <span class="built_in">max</span>(a[i], ST.<span class="built_in">query</span>(<span class="number">1</span>, cnt));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">lower_bound</span>(q + <span class="number">1</span>, q + cnt + <span class="number">1</span>, last[i], [](Q a, <span class="keyword">int</span> val){ <span class="keyword">return</span> a.id &lt; val; }) - q;</span><br><span class="line">            <span class="keyword">if</span> (pos != cnt + <span class="number">1</span>) a[i] = <span class="built_in">max</span>(a[i], ST.<span class="built_in">query</span>(pos, cnt));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="数数"><a href="#数数" class="headerlink" title="数数"></a>数数</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>在给定 $N$ 长的数组 $\{A\}$ 中进行 $Q$ 次查询 $[L_i, R_i]$ 区间中不大于 $H_i$ 的元素个数。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>离线处理，把所有元素和查询按照权值排序，对于查询 $i$ ，只需要统计之前的数字在 $[L_i, R_i]$ 区间出现多少次即可，可以使用树状数组维护前缀和。</p><p>数据有锅， $L_i$ 可以为 $0$ ，还需要特判一下。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> {</span> <span class="keyword">int</span> id, l, r, h; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwick</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>{ <span class="built_in">fill</span>(c, c + n + <span class="number">1</span>, <span class="number">0</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v; }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ans += c[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[N];</span><br><span class="line">T a[N];</span><br><span class="line">Q query[N];</span><br><span class="line">fenwick F;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    F.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i].first, a[i].second = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; query[i].l &gt;&gt; query[i].r &gt;&gt; query[i].h;</span><br><span class="line">        <span class="keyword">if</span> (!query[i].l) ++ query[i].l;</span><br><span class="line">        query[i].id = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(query + <span class="number">1</span>, query + m + <span class="number">1</span>, [&amp;](Q a, Q b){ <span class="keyword">return</span> a.h &lt; b.h; });</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= n &amp;&amp; a[j].first &lt;= query[i].h) F.<span class="built_in">add</span>(a[j].second, <span class="number">1</span>), ++ j;</span><br><span class="line">        ans[query[i].id] = F.<span class="built_in">query</span>(query[i].l, query[i].r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == m];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="Minimum-Or-Spanning-Tree"><a href="#Minimum-Or-Spanning-Tree" class="headerlink" title="Minimum Or Spanning Tree"></a>Minimum Or Spanning Tree</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个点和 $m$ 条边的无向图，每条边连接 $u,v$ 两个端点，边权为 $w$ ，问图的生成树的最小代价。</p><p>这里，我们定义一棵生成树的代价为它所有边的边权<strong>按位或</strong>得到的值。</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>贪心，由于位运算的每个位都是独立运算的，所以我们一定要让高位尽量小。</p><p>从高到低枚举每个位，如果在当前位为 $0$ 的边可以生成树，那么这一位就可以不用作贡献，否则这一位一定会产生贡献。</p><p><strong>注意</strong>，如果某一位不作贡献，那么我们要把其他作贡献的 $ban$ 掉，在接下来考虑低位时，不能使用不作贡献但在低位为 $0$ 的边。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> {</span> <span class="keyword">int</span> u, v, w; <span class="keyword">bool</span> ban; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line">T e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[i] = { -- u, -- v, w, <span class="number">0</span> };</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!e[j].ban &amp;&amp; !(e[j].w &gt;&gt; i &amp; <span class="number">1</span>)) vis[e[j].u] = vis[e[j].v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis != vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">true</span>)) ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) <span class="keyword">if</span> (e[j].w &gt;&gt; i &amp; <span class="number">1</span>) e[j].ban = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="函数求和"><a href="#函数求和" class="headerlink" title="函数求和"></a>函数求和</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个整数 $a_1, a_2, \ldots, a_n$ 和正整数 $k$ 满足 $(0 \le a_i \le 2^k - 1)$ 。</p><p>定义函数 $f(x)$ 为满足 $a_i \&amp; x != a_i$ 的最小的 $i$ ，当满足条件的 $i$ 不存在时 $f(x) = 0$ 。</p><p>求 $\sum_{i=0}^{2^k-1} f(x)$ 。由于答案可能很大，输出答案取模 $998244353$ 后的值。</p><p>其中 $1 \le n \le 100, 1 \le k \le 60$ 。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>考虑每个数字对答案的贡献。</p><p>对于第一个数字，假设它二进制为 $00101$  ，那么，只要它上面的 $1$ ，在 $x$ 的二进制同样的位上为 $0$ ，就会将 $a_1$ 上的 $0$ 变为 $1$ ，则 $a_1 \&amp; x != a_1$ 。所以贡献为 $(2^{cnt} - 1) \times 2^{leave} \times i$ ，其中 $cnt$ 为二进制下为 $1$ 的数量，$leave$ 表示 $0$ 的数量。</p><p>对于第二个数字，想要让它产生贡献，就必须满足 $a_1 \&amp; x == a_1$ ，即 $a_1$ 二进制上的 $1$ ，在 $x$ 中也同样出现。</p><p>比如 $a_2 = 10101$ ，那么只有第一个位会让 $a_2$ 产生贡献，即 $(2^{new\_cnt} - 1) * 2^{k - new\_cnt - cnt}\times i $ 。其中 $cnt$ 指前面的数字出现的 $1$ 的位数。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    bitset&lt;60&gt; bit;</span><br><span class="line">    <span class="keyword">int</span> n, k, ans = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> &amp;v: a) cin &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;&gt; j &amp; <span class="number">1</span> &amp;&amp; !bit[j]) ++ cnt;</span><br><span class="line">        ans = (ans + (((<span class="number">1ll</span> &lt;&lt; cnt) - <span class="number">1</span>) % P) * ((<span class="number">1ll</span> &lt;&lt; k - bit.<span class="built_in">count</span>() - cnt) % P) * (i + <span class="number">1</span>) % P) % P;</span><br><span class="line">        bit |= a[i];</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Closest-Equals"><a href="#Closest-Equals" class="headerlink" title="Closest Equals"></a>Closest Equals</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>给定一个下标从 $1 \sim n$ 的序列 $a$ ，然后进行 $m$ 次询问。</p><p>每次询问给出一对 $[l, r]$ ，找到区间中数值相等的且距离最近的两个数字 $a_i, a_j$ ，求出他们的距离。</p><p>换言之找到一组数 $(a_i, a_j)$ 满足：</p><ul><li>$a_i = a_j$ </li><li>$l \le i, j \le r \ \  (i != j)$</li></ul><p>求出 $|i - j|$ 的最小值，如果区间不存在两个相等的数字，则输出 $-1$ 。</p><p>其中 $1 \le n, m \le 5 \times 10^5, 1 \le a_i \le 10^9$ 。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>距离最近的两个相同数字，在所有与他们相同的数字中一定是相邻的。</p><p>对于在位置 $i$ 上的数字 $a_i$ ，与它相等的前一个数字为 $pre_i$ ，那么如果询问区间包括这两个位置，则产生 $i - pre_i$ 的贡献，换言之，对于区间 $[l, r]$ ，我们只需要找出所有这样的贡献的最小值即可。</p><p>考虑使用线段树， $i$ 位置的贡献(权值)为 $i - pre_i$ ，那么对于区间 $[1, r]$， <strong>只需要找出区间最小值。</strong></p><p>考虑区间的左端点 $l$ ，位置 $[1, l]$ 上的数字<strong>不会和他们后面的数字产生贡献</strong>，令<strong>他们后面的数字</strong>贡献为 $+ \infty$ 。</p><p>也就是说，我们的线段树需要支持单点修改和区间查询。</p><p>进行 $m$ 次 $[1, l]$ 的单点修改会 $Tle$ ，可以把查询离线下来，这样每次只需要改 $[last_l, now_l-1]$ 的元素即可，每个点只会被修改一次。</p><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (t[p].l + t[p].r &gt;&gt; 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span> <span class="keyword">int</span> l, r, Min; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> {</span> <span class="keyword">int</span> l, r, id; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d[N], ans[N]; <span class="comment">// d(i)表示i位置元素与前面相同元素位置的差值</span></span><br><span class="line"><span class="keyword">int</span> post[N]; <span class="comment">// 和下标为i的数字相等的后面的数字的位置</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; idx;</span><br><span class="line">Q q[N];</span><br><span class="line">Node t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>{ t[p].Min = <span class="built_in">min</span>(t[lc].Min, t[rc].Min); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l != r) <span class="built_in">build</span>(lc, l, mid), <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) { t[p].Min = v; <span class="keyword">return</span> ; }</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(lc, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].Min;</span><br><span class="line">    <span class="keyword">int</span> Min = INF;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) Min = <span class="built_in">min</span>(Min, <span class="built_in">query</span>(lc, l, r));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)  Min = <span class="built_in">min</span>(Min, <span class="built_in">query</span>(rc, l, r));</span><br><span class="line">    <span class="keyword">return</span> Min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">count</span>(x)) d[i] = i - idx[x], post[idx[x]] = i;</span><br><span class="line">        idx[x] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">update</span>(<span class="number">1</span>, i, d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        q[i] = { l, r, i };</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, [&amp;](Q a, Q b){ <span class="keyword">return</span> a.l &lt; b.l; });</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">max</span>(<span class="number">1</span>, q[i<span class="number">-1</span>].l); k &lt;= q[i].l - <span class="number">1</span>; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (post[k]) <span class="built_in">update</span>(<span class="number">1</span>, post[k], INF);</span><br><span class="line">        ans[q[i].id] = <span class="built_in">query</span>(<span class="number">1</span>, q[i].l, q[i].r);</span><br><span class="line">        <span class="keyword">if</span> (ans[q[i].id] == INF) ans[q[i].id] = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子串的最大差&quot;&gt;&lt;a href=&quot;#子串的最大差&quot; class=&quot;headerlink&quot; title=&quot;子串的最大差&quot;&gt;&lt;/a&gt;子串的最大差&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="每日一题" scheme="https://horb7.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Django入门</title>
    <link href="https://horb7.github.io/2022/02/25/Django%E5%85%A5%E9%97%A8/"/>
    <id>https://horb7.github.io/2022/02/25/Django%E5%85%A5%E9%97%A8/</id>
    <published>2022-02-25T15:31:21.000Z</published>
    <updated>2022-02-26T06:38:35.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.imooc.com/learn/1110">Imooc教程：三小时带你入门Django</a></p><p><a href="https://docs.djangoproject.com/zh-hans/4.0/">Django中文文档</a></p><hr><h1 id="Django-介绍"><a href="#Django-介绍" class="headerlink" title="Django 介绍"></a>Django 介绍</h1><p><strong>基本介绍</strong>：Django 是一个由Python编写的Web应用框架，本身基于MVT模型，即：模型层(Model) ，模板层(Template)，视图层(View)。</p><p>除了上面三层，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template。</p><p>用户操作流程图：<img src="\images\Django\introduction.png" alt=""></p><p>解析：</p><p>用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数：</p><ol><li>如果不涉及函数调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。</li><li>如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。</li></ol><h1 id="Django-基本命令"><a href="#Django-基本命令" class="headerlink" title="Django 基本命令"></a>Django 基本命令</h1><p><code>django-admin</code>是Django用于管理任务的命令行工具，使用<code>django-admin</code>查看其他命令。</p><p><img src="\images\Django\django_admin.png" alt=""></p><p><strong>其中重要的命令有：</strong></p><ol><li><code>startproject</code>  # 用于创建Django的一个项目</li><li><code>startapp</code>  # 用于创建Django的一个应用（软件包）</li><li><code>check</code>  # 校验项目的完整性</li><li><code>runserver</code>  # 进入Django项目环境并启用Django项目</li><li><code>shell</code>  # 进入Django项目的 Python Shell环境</li><li><code>test</code>  # 执行Django用例测试</li><li><code>makemigrations</code>  # 创建模型变更的迁移文件</li><li><code>migrate</code>  # 执行上一个命令创建的迁移文件，即把模型等导入到数据库</li><li><code>dumpdate</code>  # 把数据库数据导出到文件</li><li><code>loaddate</code>  # 把文件数据导入到数据库</li></ol><h1 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h1><p>使用<code>django-admin startproject django_study</code> 创建第一个项目，我们会发现django_study作为文件被创建，且目录下有若干个初始文件：</p><p><img src="\images\Django\startproject.png" alt=""></p><p>其中 <code>manage.py</code> 为项目管理文件，项目中的<code>django_study</code>文件夹包含此<strong>项目</strong>的所有配置。</p><p>其中：<code>settings.py</code>为项目的总设置，<code>urls.py</code> 为Django项目的总路由文件，<code>wsgi.py</code> 为Django作为wsgi应用所需要的内容。</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>使用 <code>python3 manage.py runserver</code> 运行Django项目。</p><ol><li><p>如果你的项目在本地开发</p><p>直接在浏览器输入<code>127.0.0.1:8000</code> 即可，如果成功则显示Django的初始化界面。</p></li><li><p>如果你的项目在服务器上开发</p><p>在命令后面加上<code>0.0.0.0:8000</code>，即<code>python3 manage.py runserver 0.0.0.0:8000</code> (如果是Docker环境需要把端口改为映射的端口，比如我的是8080)，注意服务器的8000端口需要打开，可以去购买服务器的网站上打开，在本地使用<code>ip:8000</code>查看，你会发现没有成功：</p><p><img src="\images\Django\error_start.png" alt=""></p><p>这是因为Django具有保护机制，不会使其他ip地址来访问项目，如果想在本地调试，需要去<code>\django_study\settings.py</code> 文件中，设置ip为可访问ip：</p><p><img src="\images\Django\allowed_host.png" alt=""></p><p>再次使用<code>python3 manage.py runserver 0.0.0.0:8000</code> 重新部署Django项目即可。</p></li></ol><p>以下都用本地开发的ip为例子，服务器开发只需要换自己的服务器的ip即可。</p><h2 id="Django应用介绍"><a href="#Django应用介绍" class="headerlink" title="Django应用介绍"></a>Django应用介绍</h2><p><strong>Django应用 VS Django项目：</strong></p><ul><li><p>一个Django项目就是一个基于Django的Web应用</p></li><li><p>一个Django应用就是一个<strong>可重用</strong>的Python软件包（即可出现在若干个项目中）</p></li><li>每个应用可以自己管理模型、视图、模板、路由和静态文件等</li><li>一个Django项目包含一组配置和若干个Django应用</li></ul><p><img src="\images\Django\appvspro.png" alt=""></p><h3 id="创建一个Django应用"><a href="#创建一个Django应用" class="headerlink" title="创建一个Django应用"></a>创建一个Django应用</h3><p>使用<code>python3 manage.py startapp blog</code> 创建一个应用。</p><p>此时项目文件中新建了一个<code>blog</code>应用(文件夹)，它有以下目录：</p><p><img src="\images\Django\firstapp.png" alt=""></p><p><strong>Django应用目录介绍：</strong></p><ul><li><code>views.py</code>  # 视图处理的地方</li><li><code>models.py</code>  # 定义应用模型的地方</li><li><code>admin.py</code>  # 定义Admin模块管理对象的地方</li><li><code>apps.py</code>  # 声明应用的地方</li><li><code>tests.py</code>  # 编写应用测试用例的地方</li></ul><p>除此之外，还需要创建<code>urls.py</code>文件来管理应用的路由，使用<code>touch urls.py</code>。</p><h2 id="Django-HelloWorld"><a href="#Django-HelloWorld" class="headerlink" title="Django HelloWorld"></a>Django HelloWorld</h2><h3 id="Django视图"><a href="#Django视图" class="headerlink" title="Django视图"></a>Django视图</h3><p>在没有框架的时代，如果要写一个hello,world网页，只需要写出html元素，但对于一个复杂的网页，不可能通过html来表达网页中所有的元素。</p><p>在一个网页中产生内容，就是Django视图的工作。</p><p>具体来说，我们在视图文件中编写一个个的逻辑函数，接受html的请求，并根据请求来生成响应数据并返回。Django视图主要用于处理项目的业务逻辑部分。</p><hr><p>在<code>blog</code>应用中，我们编写其视图函数，在<code>views.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">request</span>):</span>  <span class="comment"># request参数就是http请求的对象</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="Django路由"><a href="#Django路由" class="headerlink" title="Django路由"></a>Django路由</h3><p>在编写完上述代码，重新部署项目，却仍然是Django的欢迎页面。</p><p>这是因为Django视图仅仅是对http的请求做出相应，而我们并没有发出这样的请求，所以没办法到达刚才的视图函数。</p><p>配置路由，可以将http以url的形式发出请求并获得响应，譬如，对于<code>"ip/hello_world"</code>，就是向服务器发出了”hello_world”这个请求。</p><p>我们需要配置应用级别的路由和项目级别的路由。</p><p><strong>对于应用级别的路由</strong>，在<code>blog/urls.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>对于项目级别的路由</strong>，在<code>django_study/urls</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'blog/'</span>, include(<span class="string">'blog.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>它表示，如果我们的请求为<code>blog</code>的子目录，那么通过<code>include</code>转发到<code>blog.urls</code>这个文件中（继续寻找）。</p><p><strong>注意这里的引用模块，都是按照django_study这个项目文件来相对引用的</strong> 。</p><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>我们在<code>django_study</code>项目中创建了一个应用，要想让这个项目使用<code>blog</code>这个应用，需要在项目文件中的<code>settings</code>注册应用。</p><p><img src="\images\Django\add_app.png" alt=""></p><p>这里的<code>BlogConfig</code>是<code>blog/apps</code>文件中的结构体，它代表着这个应用的实体。</p><p><img src="\images\Django\app_name.png" alt=""></p><p>接下来重新部署运行Django项目，在浏览器中输入<code>127.0.0.1:8000/blog/hello_world</code>，发现正确响应了http的请求。</p><p><img src="\images\Django\print_hello_world.png" alt=""></p><p><strong>一张表解释应用路由和项目路由的关系：</strong></p><p><img src="\images\Django\view_url.png" alt=""></p><h1 id="Django模型层"><a href="#Django模型层" class="headerlink" title="Django模型层"></a>Django模型层</h1><h2 id="模型层介绍"><a href="#模型层介绍" class="headerlink" title="模型层介绍"></a>模型层介绍</h2><ul><li>位于Django视图层和数据库之间</li><li>Python对象和数据库表之间的转换</li></ul><p><img src="\images\Django\models.png" alt="image-20220226102117930"></p><p>在项目运行过程，不可避免地需要使用数据来交互，通过视图层，与数据库交互得到数据，然后通过返回到前端渲染。模型层夹在视图层和数据库之间，使用模型层可以屏蔽不同数据库之间的差异，让开发者更加注重业务逻辑。同时模型层提供很多便捷工具来开发。</p><p>简单来说，模型就是抽象数据类型，我们可以把它作为视图与数据库的交互对象。</p><h2 id="模型层配置"><a href="#模型层配置" class="headerlink" title="模型层配置"></a>模型层配置</h2><p>在项目设置<code>django_study/settings.py</code>中，可以看到项目的模型层数据库的相关配置。</p><p><img src="\images\Django\sqlite.png" alt="image-20220226102903267"></p><p>其中<code>ENGINE</code>表示模型层所交互的数据库，默认为Django自带的sqlite3数据库，<code>NAME</code>为数据库名字，作为文件存储在项目文件中。</p><h2 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h2><p>要创建博客文章，需要以下操作：</p><ol><li>设计博客模型</li><li>模型层定义字段</li></ol><h3 id="设计博客模型"><a href="#设计博客模型" class="headerlink" title="设计博客模型"></a>设计博客模型</h3><p>博客模型有以下几个属性：</p><ul><li>文章标题(title)   文本类型</li><li>文章摘要(brief_context)   文本类型</li><li>文章内容(context)   文本类型</li><li>唯一ID标记(article_id)   int，自增，主键</li><li>发布日期(date)  日期类型</li></ul><h3 id="模型层定义字段"><a href="#模型层定义字段" class="headerlink" title="模型层定义字段"></a>模型层定义字段</h3><ul><li>数字类型:  IntegerField</li><li>文本类型:  TextField</li><li><p>日期类型:  DateTimeField</p></li><li><p>自增ID:  AutoField</p></li><li>主键定义:  primary_key属性</li></ul><p>进入应用文件<code>blog/models.py</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span> <span class="comment"># 继承models模型</span></span><br><span class="line">    article_id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.TextField()</span><br><span class="line">    brief_content = models.TextField()</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    publish_date = models.DateTimeField(auto_now=<span class="literal">True</span>) <span class="comment"># auto_now=True 表示文章的发布日期即创建时的日期</span></span><br></pre></td></tr></tbody></table></figure><p>使用<code>python3 manage.py makemigrations</code>，将模型的变更生成迁移文件。</p><p><img src="\images\Django\create_model.png" alt="image-20220226104443577"></p><p>再使用<code>python3 manage.py migrate</code>，运行迁移文件，将迁移内容同步到数据库中。</p><h2 id="Django-Shell"><a href="#Django-Shell" class="headerlink" title="Django Shell"></a>Django Shell</h2><h3 id="Django-Shell-介绍"><a href="#Django-Shell-介绍" class="headerlink" title="Django Shell 介绍"></a>Django Shell 介绍</h3><p>类似于Python Shell，Django Shell可以进入Django项目环境，操作项目中的某些对象或者方法。</p><p>对于某些临时性操作，使用Django Shell可以更加方便，比如对于创建的Article字段，我们并不清楚它是否真的可以使用，Django Shell就是调试的最好工具。</p><p>同时，Django Shell使得小范围Debug更加简单，不需要写测试文件，运行整个项目来测试。</p><h3 id="Django-Shell操作"><a href="#Django-Shell操作" class="headerlink" title="Django Shell操作"></a>Django Shell操作</h3><p>使用<code>python3 manage.py shell</code>来启动Django Shell，引入Article模块来测试。</p><p><img src="\images\Django\django_shell.png" alt="image-20220226105600861"></p><p>其中<code>a.save</code>表示将a对象存入数据库中，使用<code>Article.objects.all()</code>即可获得数据库所有<code>Article</code>对象。</p><p><a href="https://blog.csdn.net/qq_38582906/article/details/106791656">这篇博客</a>详细介绍了Django Shell的使用操作。</p><h1 id="Django-Admin模块"><a href="#Django-Admin模块" class="headerlink" title="Django Admin模块"></a>Django Admin模块</h1><h2 id="Django-Admin模块介绍"><a href="#Django-Admin模块介绍" class="headerlink" title="Django Admin模块介绍"></a>Django Admin模块介绍</h2><p>Django Admin是Django的后台管理工具，它可以读取定义的模型元数据(也就是具体的数据)，提供强大的管理使用页面。</p><p>使用Django Shell创建数据，不仅复杂还容易出错，尤其对于复杂的模型而言。</p><p>使用Django Admin模块，可以在后台管理增加、删除、改变模型元数据，它是基础设施中重要的部分。</p><h2 id="Django-Admin模块的使用"><a href="#Django-Admin模块的使用" class="headerlink" title="Django Admin模块的使用"></a>Django Admin模块的使用</h2><p>使用<code>python3 manage.py createsuperuser</code>来创建超级管理员。</p><p><img src="\images\Django\createsuperuser.png" alt="image-20220226110941610"></p><p>在浏览器中输入<code>127.0.0.1:8000/admin</code>进入后台管理页面。</p><p><img src="\images\Django\admin.png" alt="image-20220226111506880"></p><p>其中Groups和users是默认的模型，但是我们定义的Article模型没有出现，这是因为没有在Admin模块注册Article模型。</p><p>进入<code>blog/admin.py</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article</span><br><span class="line"></span><br><span class="line">admin.site.register(Article)</span><br></pre></td></tr></tbody></table></figure><p>刷新admin页面，就会发现多出了一个模型：</p><p><img src="\images\Django\register_admin.png" alt="image-20220226111841717"></p><p>点击Article，进入Article模型的数据管理页面，发现存在一个数据元，这就是之前在Django Shell中注册的Article对象。</p><p><img src="\images\Django\Article_0.png" alt="image-20220226112028602"></p><p><img src="\images\Django\article_test.png" alt="image-20220226112058253"></p><p>在Admin页面，点击Article模型右边的<code>+</code>号，存储第二个数据：</p><p><img src="\images\Django\article_add.png" alt="image-20220226112257443"></p><p>点击右下方的<code>save</code>，完成在数据库中的存储。</p><p><img src="\images\Django\article_save.png" alt="image-20220226112400431"></p><p>我们发现，这里的数据并没有显示其文章的标题(title)，这不方便之后的管理。</p><p>进入<code>blog/models.py</code>，为Article模型添加方法 <strong>\_\_str\_\_</strong> ：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    article_id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.TextField()</span><br><span class="line">    brief_content = models.TextField()</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    publish_date = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br></pre></td></tr></tbody></table></figure><p>重新部署项目，刷新浏览器：</p><p><img src="\images\Django\add_str.png" alt="image-20220226112802438"></p><p>发现数据可以根据其标题显示了。</p><h1 id="实现博客数据返回页面"><a href="#实现博客数据返回页面" class="headerlink" title="实现博客数据返回页面"></a>实现博客数据返回页面</h1><p>进入<code>blog/views.py</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article_content</span>(<span class="params">request</span>):</span></span><br><span class="line">    article = Article.objects.<span class="built_in">all</span>()[<span class="number">0</span>]</span><br><span class="line">    title = article.title</span><br><span class="line">    brief_content = article.brief_content</span><br><span class="line">    content = article.content</span><br><span class="line">    article_id = article.article_id</span><br><span class="line">    publish_date = article.publish_date</span><br><span class="line">    return_str = <span class="string">'title: %s, brief_content: %s, '</span> \</span><br><span class="line">                 <span class="string">'content: %s, article_id: %s, publish_date: %s'</span> % (title,</span><br><span class="line">                                                                    brief_content,</span><br><span class="line">                                                                    content,</span><br><span class="line">                                                                    article_id,</span><br><span class="line">                                                                    publish_date)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(return_str)</span><br></pre></td></tr></tbody></table></figure><p>配置应用级别路由，进入<code>blog/urls</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">    path(<span class="string">'content'</span>, blog.views.article_content),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>由于项目级别已经配置，这里不需要再配置。</p><p>打开浏览器，输入<code>127.0.0.1:8000/blog/content</code>，成功返回文章内容。</p><p><img src="\images\Django\article_content.png" alt="image-20220226113801311"></p><h1 id="使用Bootstrap实现静态博客布局"><a href="#使用Bootstrap实现静态博客布局" class="headerlink" title="使用Bootstrap实现静态博客布局"></a>使用Bootstrap实现静态博客布局</h1><p><strong>博客主页设计</strong></p><p><img src="\images\Django\blog_design1.png" alt="image-20220226114157328"></p><p>其中上方为博客标题，左下方为博客文章，右下方为最新的文章。</p><p><strong>文章页面设计</strong></p><p><img src="\images\Django\blog_design2.png" alt="image-20220226114409529"></p><p>其中上方为文章标题，下方为文章内容。</p><h2 id="Bootstrap以及Bootstrap的栅格系统"><a href="#Bootstrap以及Bootstrap的栅格系统" class="headerlink" title="Bootstrap以及Bootstrap的栅格系统"></a>Bootstrap以及Bootstrap的栅格系统</h2><p><strong>Bootstrap</strong>是来自美国Twitter的前端框架，它提供了非常多的控件并附带源码。</p><p>进入<a href="https://v3.bootcss.com/">BootsTrap中文官网</a> 。</p><p>点击上方的<strong>组件</strong> ，即可查看各组件及其源码。</p><p>点击上方<strong>全局CSS样式</strong>，也可以查看其中的各个样式。</p><p><strong>Bootstrap</strong> 中的栅格系统，将页面按照横坐标分割为12等分，对于博客主页，使用9:3来分割：</p><p><img src="\images\Django\blog_bootstrap_1.png" alt="image-20220226115328759"></p><p>在<code>blog</code>下创建<code>templates</code>文件夹，用于存放模板。</p><p>在<code>blog/templates</code>下创建<code>index.html</code>作为博客主页，写入：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Django Study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Django Study Web</span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span> ---- by Horb7<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span> <span class="attr">role</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body-main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span> <span class="attr">rold</span>=<span class="string">"complementary"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>最新文章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章6<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章7<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章8<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章9<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章10<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其中前面的引入在Bootstrap官网<code>入门</code>中：</p><p><img src="\images\Django\boots_start.png" alt="image-20220226121019232"></p><p>效果：</p><p><img src="\images\Django\boots_1.png" alt="image-20220226121327336"></p><p>对于文章主页，在<code>blog/templates</code>下创建<code>detail.html</code>来写入文章主页的html：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Django Study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题1</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body-main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Django-模板系统"><a href="#Django-模板系统" class="headerlink" title="Django 模板系统"></a>Django 模板系统</h1><h2 id="模板系统简介"><a href="#模板系统简介" class="headerlink" title="模板系统简介"></a>模板系统简介</h2><p>如果对于http的某一个请求，我们需要返回一个html，我们可以在视图函数中(views.py) 直接使用html元素。</p><p>但是视图文件本身不适合编写html，并且，如果html写在视图文件，那么在页面设计改变时就需要修改Python源代码，这样很不方便。</p><p>另外，页面逻辑(view)和页面视图(html)本身应该分开设计，使得视图文库可以从html中解放出来。</p><p>模板系统的表现形式为文本(字符串)，即html文件。它分离了文档了表现形式和表现内容，为此，模板系统定义了独有的标签占位符。</p><h2 id="模板系统基本语法"><a href="#模板系统基本语法" class="headerlink" title="模板系统基本语法"></a>模板系统基本语法</h2><ul><li><p>变量标签：<code>{{ 变量 }}</code> ，如<code>&lt;html&gt;&lt;body&gt;{{ now }}&lt;/body&gt;&lt;/html&gt;</code></p></li><li><p>for循环标签：<code>{% for x in list %},{% endfor %}</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  {% for item in list %}</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>{{ item }}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  {% endfor %}</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>if-else分支标签：<code>{% if %}, {% else %}, {% endif %}</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if true %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> it is a true part. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">{% else %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> it is a false part. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="使用模板系统渲染博客页面"><a href="#使用模板系统渲染博客页面" class="headerlink" title="使用模板系统渲染博客页面"></a>使用模板系统渲染博客页面</h2><p>根据模板系统的语法，我们在<code>blog/templates/index.html</code>中重新写入：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Django Study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Django Study Web</span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span> ---- by Horb7<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span> <span class="attr">role</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body-main"</span>&gt;</span></span><br><span class="line">            {% for article in article_list %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>{{ article.title }}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{ article.content }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            {% endfor %}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span> <span class="attr">rold</span>=<span class="string">"complementary"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>最新文章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            {% for article in article_list %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>{{ article.title }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            {% endfor %}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样就完成了一个模板，那么里面的变量如何获取呢？由于模板是视图函数所返回的html元素，所以我们需要在视图函数中获取变量。</p><p>在<code>blog/views.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index_page</span>(<span class="params">request</span>):</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/index.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'article_list'</span>: all_article</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><p>其中<code>render</code>函数可以返回经过模板渲染后的HttpResponse对象。</p><p>为了方便管理，我们将<code>index.html</code>和<code>detail.html</code>文件放入<code>blog/templates</code> 新创建的文件<code>blog</code>中。</p><p><img src="\images\Django\new_place.png" alt="image-20220226124857810"></p><p>然后进入<code>blog/urls.py</code>中写入路由：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">    path(<span class="string">'content'</span>, blog.views.article_content),</span><br><span class="line">    path(<span class="string">'index'</span>, blog.views.get_index_page),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>最后重新部署项目，打开浏览器，输入<code>127.0.0.1:8000/blog/index</code>，即可到达<code>index.html</code>渲染后的网页。</p><p><img src="\images\Django\index_render.png" alt="image-20220226132216119"></p><p>同理修改文章主页的模板和url即可。</p><p>在<code>blog/views.py</code>加入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_page</span>(<span class="params">request, article_id</span>):</span></span><br><span class="line">    curr_article = Article.objects.<span class="built_in">all</span>()[<span class="number">0</span>]</span><br><span class="line">    section_list = curr_article.content.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/detail.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'curr_article'</span>: curr_article,</span><br><span class="line">                      <span class="string">'section_list'</span>: section_list</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><h2 id="实现文章详情页面的跳转"><a href="#实现文章详情页面的跳转" class="headerlink" title="实现文章详情页面的跳转"></a>实现文章详情页面的跳转</h2><p>在上述实验中，我们的<code>ip/blog/detail</code>只能跳转到第一篇博客，如何根据<code>detail/id</code>来实现根据id跳转到对应的博客？</p><p>我们可以在<code>urls.py</code>中获取id参数，在<code>blog/urls.py</code>重新写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">    path(<span class="string">'content'</span>, blog.views.article_content),</span><br><span class="line">    path(<span class="string">'index'</span>, blog.views.get_index_page),</span><br><span class="line">    <span class="comment"># path('detail', blog.views.get_detail_page),</span></span><br><span class="line">path(<span class="string">'detail/&lt;int:article_id&gt;'</span>,blog.views.get_detail_page)</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>blog/views.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_page</span>(<span class="params">request, article_id</span>):</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    curr_article = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> all_article:</span><br><span class="line">        <span class="keyword">if</span> article.article_id == article_id:</span><br><span class="line">            curr_article = article</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    section_list = curr_article.content.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/detail.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'curr_article'</span>: curr_article,</span><br><span class="line">                      <span class="string">'section_list'</span>: section_list</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><p>据此，我们可以在博客首页的文章标题加上跳转链接：</p><p><img src="\images\Django\ahref.png" alt="image-20220226132015689"></p><p><img src="\images\Django\add_href.png" alt="image-20220226131922264"></p><h1 id="实现上下篇文章跳转"><a href="#实现上下篇文章跳转" class="headerlink" title="实现上下篇文章跳转"></a>实现上下篇文章跳转</h1><p>在BootsTrap中文官网，选择<strong>组件</strong>中的分页，选择默认实例作为上下篇反转按钮：</p><p><img src="\images\Django\findbottom.png" alt="image-20220226132720409"></p><p>在文章主页最下方加入上述代码。</p><p><img src="\images\Django\addd_pd.png" alt="image-20220226132833664"></p><p>根据模板占用标签修改：</p><p><img src="\images\Django\modify_bt.png" alt="image-20220226133140145"></p><p>然后进入<code>blog/views.py</code>修改视图函数，返回<code>previous_article</code>和<code>next_article</code>即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_page</span>(<span class="params">request, article_id</span>):</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    curr_article_index = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> index, article <span class="keyword">in</span> <span class="built_in">enumerate</span>(all_article): <span class="comment"># 迭代器</span></span><br><span class="line">        <span class="keyword">if</span> article.article_id == article_id:</span><br><span class="line">            curr_article_index = index</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    curr_article = all_article[curr_article_index]</span><br><span class="line">    previous_article = all_article[curr_article_index - <span class="number">1</span>]</span><br><span class="line">    next_article = all_article[curr_article_index + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> curr_article_index == <span class="number">0</span>:</span><br><span class="line">        previous_article = curr_article</span><br><span class="line">    <span class="keyword">if</span> curr_article_index == <span class="built_in">len</span>(all_article) - <span class="number">1</span>:</span><br><span class="line">        next_article = curr_article</span><br><span class="line">    section_list = curr_article.content.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/detail.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'curr_article'</span>: curr_article,</span><br><span class="line">                      <span class="string">'section_list'</span>: section_list,</span><br><span class="line">                      <span class="string">'previous_article'</span>: previous_article,</span><br><span class="line">                      <span class="string">'next_article'</span>: next_article</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><h1 id="实现文章的分页功能"><a href="#实现文章的分页功能" class="headerlink" title="实现文章的分页功能"></a>实现文章的分页功能</h1><p><strong>Django 分页组件介绍</strong>：</p><p>在Django中有一个分页组件 <strong>Paginator</strong> ，可以在Django Shell中调试入门Paginator。</p><p><img src="\images\Django\test_paginator.png" alt="image-20220226140807054"></p><p>在博客主页<code>index.html</code>的文章块下方，加入一个分页块(使用<code>div</code>，与文章块并列)。</p><p>在Bootstrap中文官网的<strong>组件</strong>中找到分页，拷贝下来放入分页块中。</p><p>刷新浏览器，即可看到分页组件：</p><p><img src="\images\Django\fenye.png" alt="image-20220226135357224"></p><p>在路由中，我们采用<code>/blog/index?page=1</code>来实现文章的分页。</p><p>在<code>blog/views.py</code>中修改：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index_page</span>(<span class="params">request</span>):</span></span><br><span class="line">    page = request.GET.get(<span class="string">'page'</span>)</span><br><span class="line">    <span class="comment"># 如果没有page参数，则page为1</span></span><br><span class="line">    <span class="keyword">if</span> page:</span><br><span class="line">        page = <span class="built_in">int</span>(page)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="number">1</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    paginator = Paginator(all_article, <span class="number">3</span>)</span><br><span class="line">    page_num = paginator.num_pages</span><br><span class="line">    page_article_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">if</span> page_article_list.has_next():</span><br><span class="line">        next_page = page + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        next_page = page</span><br><span class="line">    <span class="keyword">if</span> page_article_list.has_previous():</span><br><span class="line">        previous_page = page - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        previous_page = page</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/index.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'article_list'</span>: page_article_list,</span><br><span class="line">                      <span class="string">'page_num'</span>: <span class="built_in">range</span>(<span class="number">1</span>, page_num + <span class="number">1</span>),</span><br><span class="line">                      <span class="string">'curr_page'</span>: page,</span><br><span class="line">                      <span class="string">'next_page'</span>: next_page,</span><br><span class="line">                      <span class="string">'previous_page'</span>: previous_page</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>index.html</code>中修改每个分页按钮的链接：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">aria-label</span>=<span class="string">"Page navigation"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog/index?page={{ previous_page }}"</span> <span class="attr">aria-label</span>=<span class="string">"Previous"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            {% for num in page_num %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog/index?page={{ num }}"</span>&gt;</span>{{ num }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            {% endfor %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog/index?page={{ next_page }}"</span> <span class="attr">aria-label</span>=<span class="string">"Next"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>刷新浏览器即可查看效果：</p><p><img src="\images\Django\allfianl.png" alt="image-20220226142024599"></p><h1 id="实现最新文章列表"><a href="#实现最新文章列表" class="headerlink" title="实现最新文章列表"></a>实现最新文章列表</h1><p>最新文章在所有文章中取得<code>publish_date</code>最大的5个，由于在分页后，每个页面(即<code>index?page=x</code>)的<code>all_article</code>为当前页面的所有文章，所以不能从这里取。</p><p>在<code>blog/views.py</code>修改，使其返回数据库所有文章最新的五个：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加</span></span><br><span class="line">top5_article = Article.objects.order_by(<span class="string">'-publish_date'</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># return reder()中加</span></span><br><span class="line"><span class="string">'top5_article'</span>: top5_article</span><br></pre></td></tr></tbody></table></figure><p>最后再修改<code>index.html</code>内容，将for范围修改即可。</p><p><img src="\images\Django\modify_new.png" alt="image-20220226143427317"></p><p><strong>最后的成品：</strong></p><p><img src="\images\Django\finalxiaoguo.png" alt="image-20220226143555836"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h</summary>
      
    
    
    
    <category term="项目学习" scheme="https://horb7.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Django" scheme="https://horb7.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>牛客秋季算法班LCA-E-华华和月月种树</title>
    <link href="https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/"/>
    <id>https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/</id>
    <published>2022-02-20T08:48:28.000Z</published>
    <updated>2022-02-24T16:57:27.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="华华和月月种树"><a href="#华华和月月种树" class="headerlink" title="华华和月月种树"></a>华华和月月种树</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>维护一个动态有根树，每个点都有一个权值，开始时只有一个 $0$ 号节点，权值为 $0$ 。有以下操作：</p><ol><li>$1 \ \ i$ ，表示 $i$ 节点长出一个新的子节点，权值为 $0$ ，编号为目前最大编号 $+1$ 。</li><li>$2 \ \ i \ \ a$ ，表示节点 $i$ 的子树的所有节点 (包括 $i$ 节点) 权值 $+a$ 。</li><li>$3 \ \ i$ ，表示查询节点 $i$ 此时的权值。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>离线 + 树状数组</strong></p><p>先根据所有的操作建立一棵树，求得所有节点的dfs序，即可在区间上操作。</p><p>树状数组维护差分的前缀。</p><p>对于操作1，记录它在权值为 $0$ 的时候（刚被开辟出来）它的前缀和，查询该点时减去这个值即可。</p><p>对于操作2，只需要在 $[l[i], r[i]]$ 上所有点权值 $+a$ 即可，使用差分。其中 $l[i]$ 和 $r[i]$ 表示 $i$ 点的进出栈时间(dfs序) 。</p><p>对于操作3，查询前缀和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> op[N], a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> val[N], c[N], l[N], r[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 一开始有一个节点0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    l[u] = ++ cnt; <span class="comment">// 最早的timestamp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (u != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    r[u] = cnt; <span class="comment">// 最晚的timestamp</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) res += c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; op[i] &gt;&gt; a[i];</span><br><span class="line">        ++ a[i]; <span class="comment">// 注意树状数组只能维护[1, n]的区间，不能包括0</span></span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            g[a[i]].<span class="built_in">push_back</span>(++ cnt);</span><br><span class="line">            b[i] = cnt; <span class="comment">// b[i]表示第i个操作后，新的节点编号</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>) cin &gt;&gt; b[i]; <span class="comment">// b[i]表示加多少</span></span><br><span class="line">    }</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 转化为dfs序，进行区间运算</span></span><br><span class="line">    <span class="comment">// 树状数组的区间加+单点查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>) <span class="comment">// 加新的节点</span></span><br><span class="line">        {</span><br><span class="line">            val[l[b[i]]] += <span class="built_in">query</span>(l[a[i]]); <span class="comment">// val(i)表示i点加了多少</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">update</span>(l[a[i]], b[i]);</span><br><span class="line">            <span class="built_in">update</span>(r[a[i]] + <span class="number">1</span>, -b[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(l[a[i]]) - val[l[a[i]]] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;华华和月月种树&quot;&gt;&lt;a href=&quot;#华华和月月种树&quot; class=&quot;headerlink&quot; title=&quot;华华和月月种树&quot;&gt;&lt;/a&gt;华华和月月种树&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="数据结构" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树状数组" scheme="https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客秋季算法班LCA-D.Alliances</title>
    <link href="https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/"/>
    <id>https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/</id>
    <published>2022-02-20T07:40:34.000Z</published>
    <updated>2022-02-20T07:52:22.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alliances"><a href="#Alliances" class="headerlink" title="Alliances"></a>Alliances</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>链接：<a href="https://ac.nowcoder.com/acm/contest/27836/D">https://ac.nowcoder.com/acm/contest/27836/D</a></p><p>  树国是一个有 $n$ 个城市的国家，城市编号为 $1 \sim n$ 。连接这些城市的道路网络形如一棵树， </p><p>  即任意两个城市之间有恰好一条路径。城市中有k个帮派，编号为 $1 \sim k$ 。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。 </p><p>  当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。 </p><p>  shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于选定的首都 $V$ 和选定的帮派，假设他们所有占领的城市的 lca 为 LCA ，那么有下面两个情况：</p><ol><li><p>lca(V, LCA) != LCA</p><p>那么被占据城市距离 $V$ 的最短距离为 $Dist(V, LCA)$ 。</p></li><li><p>lca(V, LCA) == LCA</p><p>即首都在 LCA 的子树中。对这棵子树作 dfs 序，那么距离 $V$ 最短的为 dfn 第一个在 $V$ 前面的或者第一个在 $V$ 后面的，取最小值即可。可以使用二分降低复杂度。</p><p>这里需要注意的是被占据的城市路径上的所有城市也都被占领，他们不会影响每个帮派城市lca的预处理，但会影响第二种情况，所以求的时候还需要加一个lca。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N]; <span class="comment">// 整图</span></span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; q[N]; <span class="comment">// 帮派图</span></span><br><span class="line"><span class="keyword">int</span> dfn[N], timestamp;</span><br><span class="line"><span class="keyword">int</span> top[N]; <span class="comment">// top(i) 表示i帮派占领的城市的lca</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> <span class="comment">// 根据dfs求出dfn和st表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[u] = ++ timestamp; depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> depth[a] + depth[b] - <span class="number">2</span> * depth[<span class="built_in">lca</span>(a, b)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 求出帮派图，邻接表按照dfn排序</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u); q[i].<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">if</span> (!j) top[i] = u;</span><br><span class="line">            <span class="keyword">else</span> top[i] = <span class="built_in">lca</span>(top[i], u);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 按照dfn排序</span></span><br><span class="line">        <span class="built_in">sort</span>(q[i].<span class="built_in">begin</span>(), q[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b){</span><br><span class="line">            <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> V, LCA, u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;u); <span class="comment">// LCA为被选择的帮派的lca</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; x; <span class="comment">// x存储被选择的帮派</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v); x.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (!i) LCA = top[v];</span><br><span class="line">            <span class="keyword">else</span> LCA = <span class="built_in">lca</span>(LCA, top[v]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果V和LCA的lca不是LCA，那么他们的最短距离即为V和LCA的距离</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lca</span>(V, LCA) != LCA)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">dist</span>(V, LCA));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则离V最近的一定是dfn序中靠近V的前面一个或者后面一个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : x)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> siz = q[e].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = siz;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfn[q[e][mid]] &gt;= dfn[V]) r = mid;</span><br><span class="line">                    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="number">0</span>) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r - <span class="number">1</span>])));</span><br><span class="line">                <span class="keyword">if</span> (r != siz) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r])));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Alliances&quot;&gt;&lt;a href=&quot;#Alliances&quot; class=&quot;headerlink&quot; title=&quot;Alliances&quot;&gt;&lt;/a&gt;Alliances&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="图论" scheme="https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="LCA" scheme="https://horb7.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营5</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/</id>
    <published>2022-02-17T10:24:12.000Z</published>
    <updated>2022-02-25T02:30:07.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-疫苗小孩"><a href="#A-疫苗小孩" class="headerlink" title="A. 疫苗小孩"></a>A. 疫苗小孩</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的01字符串，可以选择至多三个 $0$ ，假设它们的位置为 $i, j, k$ ，则 $W_j = w - |k-p|\times q$ ，$W_k = w - |k-p| \times q$ 。求问 $W_j + W_k$ 最大为多少。</p><p>其中 $p$ 表示与前一个选定的 $0$ 的位置差，$w, k, q$ 为给定值。</p><p>其中 $n \le 10^6, 1\le k, w, q \le 10^9$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于 $W_j$ ，要使其最大需要使 $p$ 最小，即 $i$ 与 $j$ 的差值尽量接近 $k$ ，$W_k$ 同理。</p><p>枚举 $j$ 的位置，然后使用二分求得最接近 $j-k$ 的位置（有两个可能的位置），同理求出 $j+k$ 的位置即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; zeros; <span class="comment">// 存储所有0的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) zeros.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> best, w, q; cin &gt;&gt; best &gt;&gt; w &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">0</span> || x &gt;= zeros.<span class="built_in">size</span>(); };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zeros.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] - best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] + best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// 注意pos1为第一个大于等于j-k的位置，pos1-1也可能最接近j-k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// pos2同理</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos1+k) || pos1+k &gt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> now = w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[i]-zeros[pos1+k])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 只选择前两个0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos2+l) || pos2+l &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                now = now + w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[pos2+l]-zeros[i])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 选择三个0</span></span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-战旗小孩"><a href="#C-战旗小孩" class="headerlink" title="C. 战旗小孩"></a>C. 战旗小孩</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 局游戏和原始分数 $start$，每局游戏可以选择两个英雄中的一个，使用礼遇可以选择多两个可选择英雄。</p><p>每局游戏结束后的分数为原始分数加上英雄强度。</p><p>给出每局游戏结束后上榜需要的分数，以及 $m$ 次至多能够使用的礼遇次数，和每局游戏的可选英雄强度。</p><p>游戏的顺序可以任意调整，问进行 $n$ 局游戏后，最多能够上榜几次？</p><p>$1 \le m \le n \le 20$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>二进制枚举哪些局需要使用礼遇，求出每局游戏结束后所选择的英雄强度。</p><p>由于游戏顺序可以任意调整，所以一定是先选择英雄强度高的那一局游戏，在选择低的，这样能尽量满足上榜分数。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">score</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : score) cin &gt;&gt; x;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">all</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ )</span><br><span class="line">            cin &gt;&gt; all[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ ) <span class="comment">// 枚举哪些局需要使用礼遇</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(i) &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) v.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(all[j].<span class="built_in">begin</span>(), all[j].<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="built_in">max</span>(all[j][<span class="number">0</span>], all[j][<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, st = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            st += v[i];</span><br><span class="line">            <span class="keyword">if</span> (st &gt;= score[i]) ++ now;</span><br><span class="line">        }</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-复苏小孩"><a href="#E-复苏小孩" class="headerlink" title="E. 复苏小孩"></a>E. 复苏小孩</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>三只鬼的力量分别为 $1, 1, 1$ ，遍历由 $123$ 构成的字符串时，走到 ‘$i$’ 则第 $i$ 只鬼吸收其他两只鬼一半的力量。</p><p>给定长度为 $n$ 的字符串和 $m$ 次查询，查询有以下两个操作：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个位置的字符改为 $y$ 。</li><li>$2 \ l \ r$ ，询问遍历 $[l, r]$ 子串后三只鬼的力量分别为多少。</li></ol><p>其中 $1 \le n, m \le 10^5$ 。</p><p>答案对 998244353 取模。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>假设走到 ‘1’ 位置，则相当于三只鬼的力量乘上矩阵：</p><script type="math/tex; mode=display">\left[\begin{matrix}    1 & 0 & 0 \\    \dfrac 1 2 & \dfrac 1 2 & 0 \\    \dfrac 1 2 & 0 & \dfrac 1 2 \\\end{matrix}\right]</script><p>‘2’和’3’同理，所以可以使用线段树维护区间上矩阵的乘积。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= P; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, P<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> {</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() { <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) { a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">0</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) { a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span>) { a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">2</span>] = inv; }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildI</span> <span class="params">()</span> </span>{ <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) a[i][i] = <span class="number">1</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>* (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b) {</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                ans.a[i][j] = (ans.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line">    Matrix mt; <span class="comment">// mt为[l, r]区间矩阵相乘的结果</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">};</span><br><span class="line">seg_tree t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">    t[p].mt = t[<span class="built_in">lc</span>(p)].mt * t[<span class="built_in">rc</span>(p)].mt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(s[l] - <span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(v<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Matrix ret; ret.<span class="built_in">buildI</span>();</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].mt;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    Matrix root = t[<span class="number">1</span>].mt;</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Matrix ret = <span class="built_in">query</span>(<span class="number">1</span>, x, y);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++, v = <span class="number">0</span> )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                    v = (v + ret.a[j][i]) % P;</span><br><span class="line">                cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-疫苗小孩&quot;&gt;&lt;a href=&quot;#A-疫苗小孩&quot; class=&quot;headerlink&quot; title=&quot;A. 疫苗小孩&quot;&gt;&lt;/a&gt;A. 疫苗小孩&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法训练营4</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/</id>
    <published>2022-02-17T07:04:12.000Z</published>
    <updated>2022-02-17T04:30:00.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-进制"><a href="#B-进制" class="headerlink" title="B. 进制"></a>B. 进制</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的数字串 $s$ (只有 ‘0’ ~ ‘9’ 这十种字符) ，给定 $q$ 次询问，每次询问有以下两种：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个字符修改为 $y$ ，即令 $s_x = y$ 。</li><li>$2 \ x \ y$ ，查询区间 $[l, r]$ 串能够代表的某个进制的最小值，输出其十进制表示，结果对 $1e9+7$ 取模。</li></ol><p>其中 $1 \le n, q \le 10^5$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于某个固定的区间，其每个位的数码是不变的，那么位权越小，能够表示的数字越小。所以使其最小的进制为其 $max + 1$， $max$ 表示区间最大值。</p><p>所以我们可以使用线段树维护两个信息：区间的最大值、区间数字按照九种进制运算得到的十进制数值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">2</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">11</span>], maxv;</span><br><span class="line">} t[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ )</span><br><span class="line">        t[p].d[i] = ((ll)t[<span class="built_in">lc</span>(p)].d[i] * <span class="built_in">quick_power</span>(i, t[<span class="built_in">rc</span>(p)].r - t[<span class="built_in">rc</span>(p)].l + <span class="number">1</span>) % mod + t[<span class="built_in">rc</span>(p)].d[i]) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = a[l];</span><br><span class="line">        t[p].maxv = a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        a[x] = v;</span><br><span class="line">        t[p].maxv = v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].maxv;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> (ll)t[p].d[v] * <span class="built_in">quick_power</span>(v, r - t[p].r) % mod;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) (ret += <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) (ret += <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r, <span class="built_in">query</span>(<span class="number">1</span>, l, r) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-在这冷漠的世界里光光哭哭"><a href="#L-在这冷漠的世界里光光哭哭" class="headerlink" title="L. 在这冷漠的世界里光光哭哭"></a>L. 在这冷漠的世界里光光哭哭</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的仅由小写字母构成的字符串 $s$ ，给出 $q$ 次查询，每次查询给出一个区间 $[l, r]$ 和一个长度为 $3$ 的字符串 $abc$ ，问：在 $[l, r]$ 中有多少个 $abc$ 的子序列？</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>设 $f3(k, i, j)$ 表示前 $k$ 个字符中，有多少个 $i, s[k], j$ 这样的子序列。</p><p>对于每次查询，二分算出 $b$ 字符在 $[l, r]$ 中出现的第一次位置 $pos1$ 和最后一次位置 $pos2$。</p><p>那么 $f3(pos2, a, c) - f3(pos1-1, a, c)$ 即为，当 $k$ 在 $[l, r]$ 时的所有 $abc$ 的子序列个数。</p><p>根据容斥，再将其减去 $ (a) [bc], (a) [b] (c), [ab] (c) $ 即可。其中$[ \quad ]$ 表示其在 $[l, r]$ 范围内。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80010</span>, M = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> n, q; <span class="keyword">char</span> s[N];</span><br><span class="line">ll f1[N][M]; <span class="comment">// f(i, j)表示前i个字符中有多少个j</span></span><br><span class="line">ll f2[N][M][M]; <span class="comment">// f(i, j, k)表示前i个字符中有多少个 "jk"</span></span><br><span class="line">ll f3[N][M][M]; <span class="comment">// f(k, i, j)表示前k个字符中，有多少个"i s[k] j"，注意k为最后一个字符</span></span><br><span class="line">ll tmp[M][M][M]; <span class="comment">// tmp(k, i, j)表示前k个字符中，有多少个 "i k j"</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[M]; <span class="comment">// g(c)存储字符c的所有位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 计算[l, r]有多少个"ab"</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> f2[r][a][b] - f2[l<span class="number">-1</span>][a][b] - f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        g[id].<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ ) f1[i][j] = f1[i<span class="number">-1</span>][j] + (j == s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                f2[i][j][k] = f2[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (k == s[i] - <span class="string">'a'</span> + <span class="number">1</span>) f2[i][j][k] += f1[i<span class="number">-1</span>][j];</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// "j s[i] k"</span></span><br><span class="line">                <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">                tmp[id][j][k] += f1[i<span class="number">-1</span>][j] * (f1[n][k] - f1[i][k]);</span><br><span class="line">                f3[i][j][k] = tmp[id][j][k];</span><br><span class="line">            }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="keyword">static</span> <span class="keyword">char</span> op[<span class="number">4</span>]; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;l, &amp;r, op + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = op[<span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = op[<span class="number">2</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = op[<span class="number">3</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f1[r][b] - f1[l<span class="number">-1</span>][b] == <span class="number">0</span>) { cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), l) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">upper_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), r) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        ll ans = f3[g[b][pos2<span class="number">-1</span>]][a][c] - f3[g[b][pos1<span class="number">-1</span>]][a][c]; <span class="comment">// b在[l, r]时，所有的"abc"的数量</span></span><br><span class="line">        <span class="comment">// 容斥，减去(a)[bc],(a)[b](c),[ab](c)</span></span><br><span class="line">        ans -= f1[l<span class="number">-1</span>][a] * <span class="built_in">cal</span>(l, r, b, c) + </span><br><span class="line">            f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]) * (f1[n][c] - f1[r][c]) + </span><br><span class="line">            <span class="built_in">cal</span>(l, r, a, b) * (f1[n][c] - f1[r][c]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-进制&quot;&gt;&lt;a href=&quot;#B-进制&quot; class=&quot;headerlink&quot; title=&quot;B. 进制&quot;&gt;&lt;/a&gt;B. 进制&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营3</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/</id>
    <published>2022-02-17T05:34:23.000Z</published>
    <updated>2022-02-17T04:29:51.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-智乃买瓜-another-version"><a href="#C-智乃买瓜-another-version" class="headerlink" title="C. 智乃买瓜(another version)"></a>C. 智乃买瓜(another version)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>智乃来到水果摊前买瓜，水果摊上贩卖着若干个不同的西瓜，第 $i$ 个西瓜的重量为 $w_i$ ，智乃可以买整个瓜 $w_i$ 或者把瓜劈开买半个瓜，半个瓜的重量为 $\dfrac {w_i} 2$ 。</p><p>也就是说对于每个瓜，智乃都有三种不同的决策：</p><ol><li>购买一整个重量为 $w_i$ 的西瓜。</li><li>把瓜劈开，购买半个重量为 $\dfrac {w_i} 2$ 的西瓜。</li><li>不进行购买操作。</li></ol><p>注意，每个瓜的重量都为正偶数。</p><p>现在智乃知道，购买西瓜的重量和分别为 $k = 1, 2, 3 \ldots M$ 时，购买西瓜的方案数（对 $1e9+7$ 取模）。</p><p>请构造出一个水果摊上 $N$ 个西瓜的重量，使得满足所要求的方案数量。保证数据存在 $N \le 10^3$ 的合法解。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于<strong>西瓜的重量为正偶数</strong>，所以对于重量为 $1$ 的方案，它只能由重量为 $2$ 的西瓜劈开得到。</p><p>那么我们就可以根据 $k=1$ 的情况，<strong>去除掉所有方案数中重量为 $2$ 的西瓜对其造成的影响。</strong></p><p>去除后，所有的方案数都不会和重量为 $2$ 的西瓜有关，那么 $k=2$ 时的方案数就只能由重量为 $4$ 的西瓜构成。</p><p>依次去除所有的西瓜即可，把去除的西瓜加到结果数组即可。</p><p><strong>注意点</strong>：</p><ol><li>正向dp的枚举顺序是从后往前，目的是沿用上一层的原始数据。逆向dp也需要减去原始数据，所以要从前往后，否则减去的是这一层的数据。</li><li>正向dp时 $dp[0] = 1$ ，逆向dp也需要加上去。</li></ol><p>本题提示了西瓜的质量为正偶数，如果没有提示，也要往构造所有正偶数质量西瓜去思考。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> (x % p + p) % p; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; dp[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">while</span>(dp[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 把 2*i 的西瓜去除</span></span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">2</span> * i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">            {</span><br><span class="line">                dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j-i]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">2</span> * i) dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j<span class="number">-2</span>*i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-智乃的树旋转-hard-version"><a href="#H-智乃的树旋转-hard-version" class="headerlink" title="H. 智乃的树旋转(hard version)"></a>H. 智乃的树旋转(hard version)</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $N$ 个节点的二叉树，智乃将其做了若干次旋转将其打乱，她想要将其还原，要求旋转操作次数不超过 $N^2$ 次。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote><p>第一行输入正整数 $N$ ($1 \le N \le 10^3$) ，表示二叉树的节点数量。</p><p>接下来 $N$ 行输入二叉树一开始的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为 $0$ 时，则表示该节点无右子树。</p><p>接下来 $N$ 行输入二叉树被打乱后的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为$0$时，则表示该节点无右子树。</p><p>要求你将打乱后的二叉树通过一系列旋转操作还原</p></blockquote><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote><p>首先输出一个整数 $K$ ，表示你还原二叉树进行旋转的次数，要求你给出 $K$ 的范围在 $[0,N2]$ ，接下来 $K$ 行，依次输出旋转操作的旋转轴。</p><p>由于旋转轴只能进行左旋转或者右旋转其中的一种，裁判程序将会自己判断当前需要进行的是左旋转还是右旋转。</p><p>注意：旋转过程中的根节点无法作为旋转轴进行旋转，如果你指定旋转过程中的根节点作为旋转轴，则裁判程序将直接给出WA的结果。</p></blockquote><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>如何将打乱的树还原？可以按照原来的树的先序遍历，依次把每个节点在打乱的树上做splay，单旋情况下，每个节点最多旋转 $n-1$ 次，总次数不超过 $n^2$ 的 数量级。</p><p>所以只需要记录每次旋转时的旋转轴即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span> <span class="keyword">int</span> fa, ch[<span class="number">2</span>]; } a[N], t[N]; <span class="comment">// 原树和打乱后的树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 把u节点向上旋转一次</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> fa = t[u].fa;</span><br><span class="line">    <span class="keyword">int</span> gfa = t[fa].fa;</span><br><span class="line">    <span class="keyword">int</span> t1 = (u != t[fa].ch[<span class="number">0</span>]); <span class="comment">// u是fa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> t2 = (fa != t[gfa].ch[<span class="number">0</span>]); <span class="comment">// fa是gfa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> ch = t[u].ch[t1 ^ <span class="number">1</span>]; <span class="comment">// 需要被用来和fa交换的u的孩子</span></span><br><span class="line">    t[u].fa = gfa;</span><br><span class="line">    t[u].ch[t1 ^ <span class="number">1</span>] = fa;</span><br><span class="line">    t[fa].ch[t1] = ch;</span><br><span class="line">    t[fa].fa = u;</span><br><span class="line">    t[ch].fa = fa;</span><br><span class="line">    t[gfa].ch[t2] = u;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入树，返回这个树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_tree</span> <span class="params">(tree * t, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        t[i].ch[<span class="number">0</span>] = u; t[i].ch[<span class="number">1</span>] = v;</span><br><span class="line">        vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (u) t[u].fa = i;</span><br><span class="line">        <span class="keyword">if</span> (v) t[v].fa = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N] = { <span class="literal">true</span> }; <span class="comment">// 当前点是否被旋转到根过，0设置为true，因为0是树根的fa</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">int</span> n, root_a, <span class="keyword">root_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(!st[t[u].fa]) <span class="comment">// 父节点还没有被旋转，也就是还没有修正</span></span><br><span class="line">    {</span><br><span class="line">        ret.<span class="built_in">push_back</span>(u); <span class="comment">// u需要旋转</span></span><br><span class="line">        <span class="built_in">rot</span>(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 先序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">splay</span>(u); st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">0</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">1</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    root_a = <span class="built_in">input_tree</span>(a, n);</span><br><span class="line">    <span class="keyword">root_t</span> = <span class="built_in">input_tree</span>(t, n);</span><br><span class="line">    <span class="built_in">dfs</span>(root_a); <span class="comment">// 对原树进行先序遍历，依次对打乱的树进行splay</span></span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-智乃的C语言模除方程"><a href="#J-智乃的C语言模除方程" class="headerlink" title="J. 智乃的C语言模除方程"></a>J. 智乃的C语言模除方程</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$x \ \% \ P = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>模除方程 $x \ \% \ P = Q$ ，即 $x = k \times P + Q$ ，$Q &lt; P$ 。</p><p>由于 $Q$ 是 $[l, r]$ 的任意整数，所以显然 $x$ 的定义域为若干个连续子段。</p><p>对于 $[L, R]$ 的查询，设 $f(X)$ 表示 $[0, abs(X)]$ 中满足条件的 $x$ 数量。</p><p>然后需要根据 $L, R$ 的大小分类。</p><ol><li><p>$0 \le L \le R$ </p><p>答案为 $f(R) - f(L - 1)$ 。</p></li><li><p>$L \le 0 \le R$</p><p>答案为 $f(R) + f(L) - f(0)$ 。</p></li><li><p>$L \le R \le 0$ </p><p>答案为 $f(L) - f(R + 1)$ 。</p></li></ol><p>所以接下来需要求出 $f(x)$ 。这里又需要对 $x$ 的大小分类。</p><ol><li><p>$x \ge 0$ </p><p>$f(x)$ 表示 $[0, x]$ 范围，算出所有子段与 $[0, x]$ 的交集。</p><p>整段一共有 $x/P$ 个，注意每一段都要和 $[l, r]$ 取交集 ，然后算出最后一段 $[0, x\%P]$ 和 $[l, r]$ 的交集。</p><p>取交集：$x \% P$ 的余数范围 $[0, P-1]$ ，而 $Q$ 范围 $[l, r]$ ，需要取交集。</p></li><li><p>$x \lt 0$ </p><p>$f(x)$ 表示 $[-x, 0]$ 的范围，也需要算出所有子段与 $[-x, 0]$ 的交集。</p><p>但是由于C语言模除的结果与被除数相同，所以最后的答案也为负数，所以余数范围为负数 $[-P+1, 0]$ 。</p></li></ol><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="comment">// [l, r] 与 [a, b] 的交集</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, <span class="built_in">min</span>(r, b) - <span class="built_in">max</span>(a, l) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(u/p) * <span class="built_in">get</span>(-p+<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">get</span>(u%p,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u/p * <span class="built_in">get</span>(<span class="number">0</span>, p<span class="number">-1</span>) + <span class="built_in">get</span>(<span class="number">0</span>, u%p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    p = <span class="built_in">abs</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= <span class="number">0</span> &amp;&amp; R &gt;= <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(L) + <span class="built_in">f</span>(R) - <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; <span class="number">0</span> &amp;&amp; R &gt; <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(R) - <span class="built_in">f</span>(L<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">f</span>(L) - <span class="built_in">f</span>(R+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-智乃的C语言模除方程-another-version"><a href="#K-智乃的C语言模除方程-another-version" class="headerlink" title="K. 智乃的C语言模除方程(another version)"></a>K. 智乃的C语言模除方程(another version)</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$P \ \% \ x = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>本题和上题唯一的区别在于 $x$ 和 $P$ 在方程的位置交换。</p><p>对于 $P \ \% \ x = Q$ ，有 $P - \lfloor \dfrac P x \rfloor \times x = Q$ 。</p><p>枚举 $x$ 的值，则可以知道 $\lfloor \dfrac P x \rfloor$ 的值，令其为 $c$ ，则变为 $P - c \times x = Q$ 。其中 $P - c \times x$ 为等差数列。</p><p>则问题变为：给定等差数列，问其第 $L$ 项到第 $R$ 项，有多少项在 $[l, r]$ 中。</p><p>根据 $\lfloor \dfrac P x \rfloor$ 的性质，可以使用整除分块来枚举 $x$ 的值。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">ll P, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">intersect</span> <span class="params">(ll l0, ll r0, ll l1, ll r1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(l0, l1);</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(r0, r1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, ansr - ansl + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(ll k, ll cl, ll cr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(cr,(P-l)/k);</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(cl,(P-r+k<span class="number">-1</span>)/k);</span><br><span class="line">  </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ans += <span class="built_in">intersect</span>(ansl,ansr,L,R);</span><br><span class="line">    ans += <span class="built_in">intersect</span>(-ansr,-ansl,L,R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="keyword">if</span> (P &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        P = -P;</span><br><span class="line">        <span class="built_in">swap</span>(l, r);</span><br><span class="line">        l = -l;</span><br><span class="line">        r = -r;</span><br><span class="line">    }</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">0ll</span>, l);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先枚举x的值绝对值在P范围内的情况，即[1, P]</span></span><br><span class="line">    <span class="keyword">for</span> (ll cl = <span class="number">1</span>, cr; cl &lt;= P; cl = cr + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ll k = P / cl;</span><br><span class="line">        cr = P / k;</span><br><span class="line">        ans += <span class="built_in">cal</span>(k, cl, cr); <span class="comment">// 计算x的倍数为k，且x位于[cl, cr]时的情况</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= P &amp;&amp; r &gt;= P)</span><br><span class="line">    {</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, P+<span class="number">1</span>, (ll)(<span class="number">1e10</span>));</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, -(ll)(<span class="number">1e10</span>), -(P+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-智乃买瓜-another-version&quot;&gt;&lt;a href=&quot;#C-智乃买瓜-another-version&quot; class=&quot;headerlink&quot; title=&quot;C. 智乃买瓜(another version)&quot;&gt;&lt;/a&gt;C. 智乃买瓜(another ve</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营2</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/</id>
    <published>2022-02-17T04:09:12.000Z</published>
    <updated>2022-02-17T04:29:38.529Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="A-小沙的炉石"><a href="#A-小沙的炉石" class="headerlink" title="A. 小沙的炉石"></a>A. 小沙的炉石</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 张法术攻击牌和 $m$ 张法术恢复牌，每次攻击消耗一点法力，造成 $1$ 点伤害，恢复牌不消耗法力，可以恢复一点法力。小沙一开始有 $1$ 点法力，法力没有上限。</p><p>每次使用一张法力牌，都会使后面的攻击伤害 $+1$ 。</p><p>给出 $q$ 次询问，每次给出敌人的血量，问能否将其<strong>恰好斩杀</strong>？</p><p>恰好斩杀：正好使得敌方血量变为 $0$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果使用的攻击牌和恢复牌的数量一定，那么可以造成的伤害一定是一个连续的区间。</p><blockquote><p>假设使用 $a$ 张攻击牌和 $b$ 张恢复牌，注意 $a \le b + 1$ 。</p><p>此时最小攻击伤害为：攻击、恢复、攻击、恢复…… ，伤害为 $\sum_{i=1}^a{2 \times i - 1} = a ^ 2$ 。</p><p>每次可以将序列中的一对 [攻击，恢复] 组合调换，造成伤害 $+1$ 。</p><p>最大伤害为：恢复、恢复、恢复、……、攻击、攻击。伤害为 $\sum_{i=1}^{a} b + i = \dfrac {((b + 1) + (b + a)) * a} 2$ 。 </p></blockquote><p>对于每次询问，由于需要恰好斩杀，因此<strong>最多</strong>能够使用的攻击牌是 $min(min(n, m+1), sqrt(hp))$ 。</p><p>由于造成伤害的区间是连续的，因此只需要看最大能造成的伤害是否超过 $hp$ 即可。</p><p>不需要判断最小造成的伤害，因为取到的攻击牌数一定 $\le$ $sqrt(hp)$ 。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    n = <span class="built_in">min</span>(n, m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> hp; cin &gt;&gt; hp;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">min</span>(n, (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(hp));</span><br><span class="line">        <span class="keyword">int</span> maxv = (m + <span class="number">1</span> + m + R) * R / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxv &gt;= hp) cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-小沙的魔法"><a href="#B-小沙的魔法" class="headerlink" title="B. 小沙的魔法"></a>B. 小沙的魔法</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个点和 $m$ 条边，初始时每个点权值为 $x_i = 0$ 。初始时图上无边，每次可以进行以下操作中的一种：</p><ol><li>在 $m$ 条边中选择一条没有被选择过的边加入图中。</li><li>将图中的一个极大连通子图的每个点权值 $+1$ 。</li></ol><p>给定边可能出现重边，自环。</p><p>问最少操作多少次操作2，才能使对于任意点有 $x_i = a_i$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>要使区间增加到目标值，等价于区间每个值初始为 $a_i$ ，每次使得区间值 $-1$ ，最终使区间值全部为 $0$ 。</p><p>优先减去权值最大的，在减去权值最大点的同时，可以顺带减去和它在同一个连通子图的所有点的权值，这整个连通子图全部变为 $0$ ，代价就是权值最大的那个点的权值。</p><p>按权值对每个点的位置排序，从大到小依次遍历当前点的相邻点，把当前点和权值比它大的点合并，先把权值大的点减到和当前点相同的权值，代价为 $a_{gt} - a_{cur}$ 。</p><p>这样最后的图会形成若干个连通子图，再把这些连通子图最小的权值加起来就是最少需要的操作2，加最小权值是因为我们先把比它大的权值点先减到和它权值相同。这也意味这合并时要以权值小的点为根。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[N], id[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">iota</span>(f, f + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">iota</span>(id, id + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) {</span><br><span class="line">        <span class="keyword">return</span> a[x] &gt; a[y]; </span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = id[i]; i &lt;= n; i ++, u = id[i] )</span><br><span class="line">    {</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = h[u]; ~k; k = ne[k])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[k];</span><br><span class="line">            <span class="keyword">int</span> pu = <span class="built_in">find</span>(u), pj = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (vis[j] &amp;&amp; pu != pj)</span><br><span class="line">            {</span><br><span class="line">                res += a[pj] - a[u];</span><br><span class="line">                f[pj] = pu;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i) res += a[i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-小沙的长路"><a href="#E-小沙的长路" class="headerlink" title="E. 小沙的长路"></a>E. 小沙的长路</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>规定有向完全图每条边只能走一次，问：$n$ 个点的有向完全图的最长路径的最大值和最小值分别为多少？</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>$n$ 个点的有向完全图，最长路径一定经过了 $n$ 个点。</p><p>对于最小：如果图上有环，那么经过环一定比不经过环更长，所以我们要使图上无环，这样每个点只走一次，最短为 $n-1$ 。</p><p>对于最长：尽可能走完所有边，等价于给定有向完全图，删除尽可能少的边，使得剩下的图为欧拉图。如果 $n$ 为奇数，那么每个点连接偶数条边，一定存在一个有向无环图为欧拉图。如果 $n$ 为偶数，每个点连接奇数条边，欧拉图至多有 $2$ 个奇数点，也就是要使得 $n-2$ 个点变成偶数，删除一条边改变两个点度的奇偶性，所以需要删除 $\dfrac {n-2} 2$ 条边。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxv;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span> - (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; maxv &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-小沙的算数"><a href="#F-小沙的算数" class="headerlink" title="F. 小沙的算数"></a>F. 小沙的算数</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个算数式（只包含加法和乘法），每次询问把一个数字替换为其他数字，问替换完后的结果为多少？（询问不独立，上一次的修改会影响下一次询问）。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于算数式只包含加法和乘法，而乘法具有连乘性质，所以需要维护乘法区间的乘积。</p><p>对于乘法，只需要修改连乘区间的结果即可。对于加法，直接修改即可。</p><p>维护每个区间的乘法结果，可以使用并查集，开一个 $prod$ 数组表示每个集合的乘积。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, ret;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], prod[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="built_in">quick_power</span>(x, mod<span class="number">-2</span>); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mod</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>{ <span class="keyword">return</span> (x % mod + mod) % mod; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    prod[y] = <span class="built_in">Mod</span>((ll)prod[y] * prod[x]);</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], prod[i] = a[i];</span><br><span class="line">    <span class="comment">// 把乘积合并起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, ans = a[i];</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans = <span class="built_in">Mod</span>((ll)ans * a[j + <span class="number">1</span>]);</span><br><span class="line">            vis[j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">merge</span>(j, j + <span class="number">1</span>);</span><br><span class="line">            ++ j;</span><br><span class="line">        }</span><br><span class="line">        ret = <span class="built_in">Mod</span>((ll)ret + ans);</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) ret = <span class="built_in">Mod</span>((ll)ret + a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id, to; cin &gt;&gt; id &gt;&gt; to;</span><br><span class="line">        <span class="keyword">if</span> (id != n &amp;&amp; s[id] == <span class="string">'*'</span> || id &gt; <span class="number">1</span> &amp;&amp; s[id<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于乘法区间</span></span><br><span class="line">            <span class="keyword">int</span> par = <span class="built_in">find</span>(id);</span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret + <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * <span class="built_in">Mod</span>((ll)to - a[id])));</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            prod[par] = <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * to);</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于加法区间</span></span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret - a[id] + to);</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-小沙的身法"><a href="#G-小沙的身法" class="headerlink" title="G. 小沙的身法"></a>G. 小沙的身法</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个节点的无根无向树，每个节点有权值 $a_i$ ，规定从 $i$ 节点跳到其相邻节点 $j$ 的代价为 $max(0, a_j - a_i)$ 。即从权值低的点跳到权值高的点，代价为其权值差；从权值高的点跳到权值低的点，代价为 $0$ 。</p><p>给定 $m$ 次询问，每次询问：从地面(权值为 $0$)跳到 $u$ 节点，再从 $u$ 节点跳到 $v$ 节点，再从 $v$ 节点跳到地面，最少消耗的代价为多少？</p><p>其中 $1 \le n \le 10^6$ ，$1 \le m \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>对于无向树而言，两个节点之间只有一条简单路径。所以要消耗体力最小，就是走这条简单路径，即路径是唯一的。</p><p>从地面跳到 $u$ 节点，从 $v$ 节点跳到地面的代价为 $a_u$ 。</p><p>从 $u$ 点跳到 $v$ 点的代价，等价于从 $u$ 点跳到根节点的代价，加上从根节点跳到 $v$ 节点的代价，再减去从其 $lca$ 跳到根节点的代价，以及从根节点跳到 $lca$ 的代价。</p><p>由于代价不具有对称性，即从 $u$ 跳到根节点和从根节点跳到 $u$ 节点不是对称的，所以要dfs两次算出从根节点出发到其他点的代价，以及从其他点到达根节点的代价。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, M = N &lt;&lt; <span class="number">2</span>;</span><br><span class="line">ll a[N], d[N], rd[N];</span><br><span class="line"><span class="keyword">namespace</span> LCA {</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> n, h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> fa[N][SIZE + <span class="number">1</span>], depth[N];</span><br><span class="line">    <span class="keyword">int</span> q[N]; <span class="keyword">bool</span> st[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">fill</span>(h, h + n + <span class="number">1</span>, <span class="number">-1</span>); idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="built_in">fill</span>(fa[i], fa[i] + SIZE + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fill</span>(depth, depth + n + <span class="number">1</span>, <span class="number">0</span>); <span class="built_in">fill</span>(st, st + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ; }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = root; depth[root] = <span class="number">1</span>; st[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt) {</span><br><span class="line">            <span class="keyword">int</span> u = q[hh ++ ];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) {</span><br><span class="line">                <span class="keyword">int</span> j = e[i]; <span class="keyword">if</span> (st[j]) <span class="keyword">continue</span>;</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                depth[j] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                fa[j][<span class="number">0</span>] = u;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= SIZE; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">                fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i];</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">        <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    d[u] = d[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &gt; a[fa]) d[u] += a[u] - a[fa];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rd[u] = rd[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &lt; a[fa]) rd[u] += a[fa] - a[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">rdfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n - <span class="number">1</span> &amp;&amp; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v); i ++ ) <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">rdfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y; <span class="keyword">int</span> f = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[x] + rd[x] + d[y] - rd[f] - d[f]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-amp-M-小沙的remake"><a href="#L-amp-M-小沙的remake" class="headerlink" title="L &amp; M. 小沙的remake"></a>L &amp; M. 小沙的remake</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，选择若干个数字组成最长不下降子序列，使得被选中的每个元素，设其位置为 $i$ ，它前面 $b_i$ 个元素至少也有一个被选择。问这样的子序列有多少种？</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>树状数组维护：对于每个位置而言，以它为结尾至少有多少种满足条件的子序列个数。</p><p>按元素权值从小到大排序，从前往后遍历，对于每个元素，设位置为 $i$，查询 $[i-b_i, i)$ 中每个位置的值，相加即为以当前元素为结尾的子序列的方案数。</p><p>这里的Code不按照题目要求的生成数据，方便参照。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b[N];</span><br><span class="line">T a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N]; <span class="comment">// 树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) c[x] = ((ll)c[x] + v) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x ) sum = ((ll)sum + c[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i].x &gt;&gt; b[i], a[i].y = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ll val = <span class="built_in">query</span>(a[i].y - <span class="number">1</span>) - <span class="built_in">query</span>(a[i].y - b[a[i].y] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        val %= mod;</span><br><span class="line">        res = (res + val + mod) % mod;</span><br><span class="line">        <span class="built_in">add</span>(a[i].y, val);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;A-小沙的炉石&quot;&gt;&lt;a href=&quot;#A-小沙的炉石&quot; class=&quot;headerlink&quot; title=&quot;A. 小沙的炉石&quot;&gt;&lt;/a&gt;A. 小沙的炉石&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营1</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/</id>
    <published>2022-02-17T03:00:00.000Z</published>
    <updated>2022-02-17T04:29:29.455Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="A-九小时九个人九扇门"><a href="#A-九小时九个人九扇门" class="headerlink" title="A. 九小时九个人九扇门"></a>A. 九小时九个人九扇门</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个数字和编号为 $1 \sim 9$ 的九扇门，规定：$k$ 个数字的组合能够打开编号为 $f$ 的门，当且仅当这 $k$ 个数字之和的数字根等于 $f$ 。问对于每一扇门，有几种组合可以打开？</p><p>其中 $1 \le n \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><p>数字根：不断将数字 $m$ 各个位上的数字相加，直到 $m$ 为一位数。一位数的数字根就是本身。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%A0%B9">数字根的性质</a></p><p>求数字根：根据<strong>任何数字加 $9$ 的数字的数字根不变</strong>的性质，只需要模 $9$ 即可算出数字根。</p><p>设 $dp(i)$ 表示打开模 $9$ 为 $i$ 号门的组合数量。由于状态转移时，依赖关系不好找，而被依赖的关系容易找到，所以对于每个状态，更新被这个状态依赖的关系。注意DP的初始条件，为了启动DP要使 $dp(0)$ 为 $1$ ，最后要减去。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">9</span>)</span></span>; dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> nxt = dp;</span><br><span class="line">        <span class="keyword">int</span> a; cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++ )</span><br><span class="line">            (nxt[(k + a) % <span class="number">9</span>] += dp[k]) %= mod;</span><br><span class="line">        dp.<span class="built_in">swap</span>(nxt);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i ++ ) cout &lt;&lt; dp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    cout &lt;&lt; (dp[<span class="number">0</span>] + mod - <span class="number">1</span>) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-炸鸡块君与FIFA22"><a href="#B-炸鸡块君与FIFA22" class="headerlink" title="B. 炸鸡块君与FIFA22"></a>B. 炸鸡块君与FIFA22</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的由 ‘W’, ‘L’, ‘D’ 构成的字符串表示若干场次的结果。</p><p>‘W’表示胜利，分数加一；’L’表示失败，分数减一；’D’表示平局，分数不变。</p><p>特别的，当分数为 $3$ 的整数倍时，失败不会减少分数。</p><p>给定 $q$ 次查询，每次查询给出 $l, r, s$ ，问，在初始分数为 $s$ 时，经过 $[l, r]$ 场次后，最终的分数为多少？</p><p>其中 $1 \le n, q \le 2 \times 10^5$ ，$1 \le l, r \le n$ ，$0 \le s \le 10^9$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到如果起始分数在模 $3$ 意义下相等，那么经历区间 $[l, r]$ 后，<strong>分数的变化量</strong>是不变的。</p><p>可以使用 ST 表，倍增实现查询，复杂度为 $O(max(q, n)\times log n))$ 。其中查询复杂度为 $q log n$ ，初始化复杂度为 $n log n$ 。</p><p>设 $st[k][i][j]$ 表示初始分数模 $3$ 意义下为 $k$ ，经历区间 $[l, r]$ 后<strong>分数的变化量</strong>。</p><p>预处理：$st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j]) \% 3][i + (1 &lt;&lt; j)][j-1]$ ，注意经过 $2^{j-1}$ 区间后初始分数在后面的区间要变化。</p><p>对于每次查询，我们可以每次走最大的二次幂，直到走完区间。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][<span class="number">21</span>], Lg[N];</span><br><span class="line"><span class="comment">/* 预处理,st[k][i][j] 表示初始分数模3为k时，经过[i, i + 2^j - 1]区间后分数的变化量 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) Lg[i] = Lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'W'</span>) st[j][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'L'</span> &amp;&amp; j) st[j][i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n ; j ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                st[k][i][j] = st[k][i][j<span class="number">-1</span>] + st[(k + st[k][i][j<span class="number">-1</span>]) % <span class="number">3</span>][i + (<span class="number">1</span> &lt;&lt; j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;] (<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> g = Lg[r - l + <span class="number">1</span>];</span><br><span class="line">            ret += st[k][l][g];</span><br><span class="line">            (k += st[k][l][g]) %= <span class="number">3</span>;</span><br><span class="line">            l = l + (<span class="number">1</span> &lt;&lt; g);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; k + <span class="built_in">query</span>(k % <span class="number">3</span>, l, r) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-Baby’s-first-attempt-on-CPU"><a href="#C-Baby’s-first-attempt-on-CPU" class="headerlink" title="C. Baby’s first attempt on CPU"></a>C. Baby’s first attempt on CPU</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出 $n$ 个程序语句 $(3 \le n \le 100)$ ，其中某些程序语句有先写后读的制约关系，如果两条程序语句存在先读后写，那么这两条语句中间至少需要三条语句来使程序不出错。我们可以加入空语句来占位。</p><p>问，要使程序不出错，至少需要加入多少条空语句？</p><p>给出的数据保证第 $i$ 行输入 $i, j, f$ ，如果 $f = 1$ ，表示第 $i$ 条语句和第 $i - j$ 条语句有先写后读的关系。并且 $i - j &lt;= 0$ 的情况始终有 $f = 0$ 。即不存在后面的语句先写，前面的语句再读。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>贪心，设 $has(i)$ 表示第 $i$ 条语句后加入多少条空语句。</p><p>对于第 $i$ 条语句，假设它与第 $i-j$ 条语句有先读后写的关系，判断间隔有没有三条语句，如果没有，那么只需要在第 $i-1$ 条语句后加入空语句即可。</p><p>证明也很简单，对于后面的语句 $k$ ，如果有制约关系的语句 $k - k_j \le i - j \quad or \quad k - k_j \ge i$ ，那么加在哪条语句后都不会影响，反之，我们加在第 $i-1$ 条语句后一定更好，它能最大限度地包含于 $[k - k_j, k]$ 的位置。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> has[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> f; cin &gt;&gt; f; <span class="keyword">if</span> (!f) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="built_in">accumulate</span>(has + i - j, has + i, j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) has[i<span class="number">-1</span>] += <span class="number">3</span> - cnt;</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(has + <span class="number">1</span>, has + n, <span class="number">0ll</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="D-牛牛做数论"><a href="#D-牛牛做数论" class="headerlink" title="D. 牛牛做数论"></a>D. 牛牛做数论</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定数字 $n$ 和函数 $H(x) = \dfrac {\phi(x)} x$ ，问：</p><ol><li>回答一个 $x_0 \in [2, n]$ ，使得 $H(x_0)$ 最小。如果存在多个，输出 $x_0$ 最小的那个。</li><li>回答一个 $x_0 \in [2, n]$ ，使得 $H(x_0)$ 最大。如果存在多个，输出 $x_0$ 最大的那个。</li></ol><p>其中 $1 \le n \le 10^9$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>根据欧拉函数定义 ：$\phi(x) = x \times \prod_{i=1}^n (1 - \dfrac 1 p_i)$ 。其中 $n$ 为 $x$ 质因子个数，$p_i$ 为$x$ 的各个质因子。</p><p>于是，函数 $H(x) = \prod_{i=1}^n (1 - \dfrac 1 p_i)$ 。</p><p>所以，求最小值，只需要把所有可能的质因子都加进去累乘即可，因为每个因子都小于 $1$ 。</p><p>求最大值，一定是只有一项因子，且这项因子的 $p_i$ 尽可能大，所以取不大于 $n$ 的最大质数，暴力求出即可，因为质数在 $[1, 10^9]$ 内浓度很大。(相邻质数最多相差 $282$) 。</p><p>注意 $n \le 10^9$ ，在这个范围内最多有 $10$ 个不同的质因子。所以只需要枚举这几个就可以。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> p[] = { <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span> };</span><br><span class="line">    <span class="keyword">auto</span> is_prime = [&amp;] (<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">2</span>) <span class="keyword">return</span> x == <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ --; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = p[<span class="number">0</span>], pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">long</span> <span class="keyword">long</span>)ans * p[pos] &lt;= n) ans *= p[pos ++ ];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        </span><br><span class="line">        ans = n;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">is_prime</span>(ans)) -- ans;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-炸鸡块君的高中回忆"><a href="#E-炸鸡块君的高中回忆" class="headerlink" title="E. 炸鸡块君的高中回忆"></a>E. 炸鸡块君的高中回忆</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个人想要进入学校，但是只有 $m$ 个校园卡，于是他们有如下方案：先让 $m$ 个人进入学校，再由一个人带着 $m$ 个校园卡出来。反复直到全部人进入学校。</p><p>每次进入或出去学校需要 $1$ 个单位时间，问所有人进入学校至少需要多少单位时间？</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先有两个特判：</p><ol><li>$n \le m$ ，可以一次进去完，只需要 $1$ 个单位时间。</li><li>$m == 1$ ，一定无法让所有人进去学校，因为每轮实际上只有 $m-1$ 个人进入学校。</li></ol><p>否则，我们可以先让这 $n$ 个人进入第一轮循环，之后，他们需要循环的次数为 $\lceil \dfrac {n - m} {m-1} \rceil$ ，注意最后一次不需要再有人出来送校园卡，因此总时间为 $2 + 2 \times \lceil \dfrac {n - m} {m-1} \rceil - 1$ 。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= m) { cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> d = (n - m + m - <span class="number">1</span> - <span class="number">1</span>) / (m - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> + d * <span class="number">2</span> - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-中位数切分"><a href="#F-中位数切分" class="headerlink" title="F. 中位数切分"></a>F. 中位数切分</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列 $a$ ，将其划分为若干个子段，使得其中每个段的<strong>数值的中位数</strong>不小于 $m$ ，问最多能划分多少段？</p><p>（偶数长度字段的中位数为两个中较小的那一个。）</p><p>不存在任意划分策略则输出 $-1$ 。</p><p>其中 $1 \le n \le 10^5$ ，$1 \le m \le 10^9$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>首先，我们按照题意将序列划分若干个子段，使得每个字段数值的中位数不小于 $m$ 。</p><p><img src="/images/problem/cutArray.png" alt=""></p><p>根据题目，我们发现<strong>对于每一个子段，不小于 $m$ 的数字个数一定大于 小于 $m$ 的数字个数。</strong></p><p>贪心考虑，如果当前枚举的区间，已经满足大于关系，即 <strong>不小于 $m$ 的数字个数比小于 $m$ 的数字个数多 $1$</strong> 。那么我们就可以把这块区间划分出来。</p><p>可以证明这样贪心一定是最优的，因为如果在这个区间之后加入 不小于 $m$ 的数字数量小于 小于 $m$ 的数字个数，那么不满足题意；如果大于，那么不必要合并，因为两个都是满足条件的子段。当然如果等于，那么还是要加上的，但是这不影响结果，因为这个区间还是满足如上条件。</p><p>我们发现，对于划分好的最优解子段，每个子段都满足 $\ge m$ 的数字数量比 $&lt; m$ 的数字数量多 $1$ ，所以只需要统计一下区间的两个数量差即可。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ --; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m, cnt = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m) ++ cnt; <span class="keyword">else</span> -- cnt;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; (cnt &lt;= <span class="number">0</span> ? <span class="number">-1</span> : cnt) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-ACM-is-all-you-need"><a href="#G-ACM-is-all-you-need" class="headerlink" title="G. ACM is all you need"></a>G. ACM is all you need</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列 $a$ ，可以选择任意整数值 $b$ ，使得序列 $a$ 中每个元素 $a_i$ 变为 $|a_i - b| + b$ 。问经过一次变换后，序列中的极小值点的数量最少为多少？</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>变换中 $+b$ 的操作是对整个序列都加上 $b$ ，不会改变相对大小，因此无用，可以看作变换为 $a_i = |a_i - b|$ 。</p><p>同时， $b$ 的值小于等于 $0$ 的情况是完全一样的，同样不改变相对大小，我们可以用 $b = 0$ 代替所有 $b \le 0$ 的情况。</p><p>所以确定 $b$ 的值为 $[0, inf]$ 。</p><p>对于序列中每个元素而言，如果让它变成极小值点，取得 $b$ 值的范围是连续的，可以算出所有 $n-2$ 个 $b$ 范围的区间，那么问题就变成了：给定 $n-2$ 个区间，求被区间覆盖最小次数的点的覆盖次数。</p><p>对于区间 $[l, r]$ ，可以在每个位置上 $+1$ ，那么就是求 $[0, inf]$ 上每个位置的最小值。</p><p>可以使用差分来快速实现区间加，范围比较大，使用map离散化处理即可。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp; x : a) cin &gt;&gt; x;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; m[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 注意0位置是需要考虑的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : { a[i<span class="number">-1</span>], a[i+<span class="number">1</span>] })</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (x &gt; a[i]) r = <span class="built_in">min</span>(r, a[i] + (x - a[i] - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (x &lt; a[i]) l = <span class="built_in">max</span>(l, x + (a[i] - x) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == a[i]) r = l - <span class="number">1</span>; <span class="comment">// 这个点不可能成为极小值点</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">            ++ m[l]; <span class="keyword">if</span> (r != INF) -- m[r + <span class="number">1</span>]; <span class="comment">// 注意正无穷没有右端点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ret = INF, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : m) ret = <span class="built_in">min</span>(ret, sum += v);</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-牛牛看云"><a href="#H-牛牛看云" class="headerlink" title="H. 牛牛看云"></a>H. 牛牛看云</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列 $a$ ，求出 $\sum_{i=1}^n\sum_{j=i}^n|a_i + a_j - 1000|$ 。</p><p>其中 $3 \le n \le 10^6$ ，$0 \le a_i \le 1000$ 。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>题目简化一下就是求 $|a_i + a_j - 1000|$ ，其中 $1 \le i \le j \le n$ 。</p><p>容易发现，对于 $i \lt j$ 的情况， 把 $i$ 、$j$ 调换一下式子依然不变，所以式子对 $i$ 、$j$ 有对称性。</p><p>那么我们只需要对称地求出所有情况，再除以二即可。</p><p>注意点：</p><ol><li>式子对 $i = j$ 不具有对称性，所以在求式子结果的时候，需要给这种情况加上。</li><li>$n$ 很大， $a_i$ 很小，可以在值域上做暴力。</li></ol><blockquote><p>为什么 $i = j$ 不具有对称性？</p><p>对于 $1, 1, 2, 2$ 这个样例，我们枚举 $1$ 和 $2$ 的时候，把前和后的状态都算了，所以有对称性。</p><p>对于 $1, 1$ ，我们枚举 $1$ 和 $1$ 的时候，对于每一个 $1$ ，在计算加自己的时候，只计算了一次，根据对称性我们要加两次，这样最后除以二的时候才算出来一次。所以我们对每个 $1$ 都要再加一遍自己的情况。</p><p>其实本质上就是，$i=j$ 代表同一个式子，而 $i != j$ 代表了两种式子，一个定义域为 $i &lt; j$ ，一个定义域为 $i &gt; j$ 。</p></blockquote><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="keyword">int</span> x; cin &gt;&gt; x; ++ c[x]; }</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1000</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i == j) ret = ret + c[i] * (c[j] + <span class="number">1</span>) * <span class="built_in">abs</span>(i + j - <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">else</span> ret = ret + c[i] * c[j] * <span class="built_in">abs</span>(i + j - <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="I-B站与各唱各的"><a href="#I-B站与各唱各的" class="headerlink" title="I. B站与各唱各的"></a>I. B站与各唱各的</h1><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>有 $n$ 个UP主和 $m$ 句歌词，现在他们每个人要独立完成这 $m$ 句歌词，对于每一句歌词，他们可以选择唱或者不唱。完成后，将它们拼接起来。</p><p>如果一句歌词没有人唱或者被所有人唱过，那么这句歌词算失败的，否则是成功的。</p><p>问唱成功的歌词数量的期望为多少？</p><p>若答案为分数，需要在模数为 $10^9 + 7$ 下取逆。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>由于每个UP都是独立完成 $m$ 句歌词，所以对于每句歌词唱与不唱的概率都为 $\dfrac 1 2$ 。</p><p>对于任意一句歌词，没有人唱或者全部人都唱的概率为 $(\dfrac 1 2)^n$ 。</p><p>所以每一句歌词唱成功的概率为 $1 - (\dfrac 1 2)^n \times 2 = 1 - (\dfrac 1 2)^{n - 1}$ 。</p><p>每一句成功的概率乘以总歌词数量即为唱成功的歌词数量的期望，即 $(1 - (\dfrac 1 2)^{n - 1}) \times m$ 。</p><h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">auto</span> quick_power = [&amp;] (<span class="keyword">int</span> a, <span class="keyword">int</span> k) -&gt; <span class="keyword">int</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (a %= p; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % p)</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll) res * a % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, p<span class="number">-2</span>);</span><br><span class="line">        cout &lt;&lt; (ll)(<span class="number">1</span> - <span class="built_in">quick_power</span>(inv, n<span class="number">-1</span>) + p) % p * m % p &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-小朋友做游戏"><a href="#J-小朋友做游戏" class="headerlink" title="J. 小朋友做游戏"></a>J. 小朋友做游戏</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>班级里有 $A$ 个安静的小朋友和 $B$ 个吵闹的小朋友，现在要选出 $n$ 个小朋友围成一圈，满足不存在两个吵闹的小朋友相邻。每个小朋友有一个幸福度，选中即可为班级增加幸福度，问最大幸福度为多少？</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>为了满足条件，安静的小朋友至少要选出 $(n + 1) / 2$ 个，否则一定存在吵闹的小朋友相邻。</p><p>可以先选出这 $(n + 1) / 2$ 个小朋友，再双指针贪心选最大的幸福度。</p><p>双指针判断比较麻烦，要先判断是否有选完的，再贪心选。可以把剩下的小朋友放在一个容器中，选出最大的幸福度即可。</p><h2 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> A, B, n; cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(A)</span>, <span class="title">b</span><span class="params">(B)</span>, all</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : a) cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : b) cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span> (A &lt; n - A) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n + <span class="number">1</span>) / <span class="number">2</span>; i &lt; A; i ++ ) all.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B; i ++ ) all.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">        <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; i ++ ) ret += a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - (n + <span class="number">1</span>) / <span class="number">2</span>; i ++ ) ret += all[i];</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-冒险公社"><a href="#K-冒险公社" class="headerlink" title="K. 冒险公社"></a>K. 冒险公社</h1><h2 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h2><p>数轴上有 $n$ 座连续的岛屿，玩家从第一座岛屿出发，依次经过所有岛屿直到到达第 $n$ 座岛屿。</p><p>岛屿有三种类型：绿岛、红岛和黑岛。</p><p>在玩家到达第 $i$ 座岛屿时，如果第 $i, i-1, i-2$ 中绿岛数量大于红岛，则罗盘发出绿色；如果红岛数量大于绿岛，则发出红光；否则发出黑光。</p><p>给出在 $n$ 座岛屿上，罗盘发出的光，问这 $n$ 座岛屿最多有几座绿岛？(第 $1, 2$ 座岛屿不发光，规定为 ‘X’) 。</p><p>其中 $1 \le n \le 10^5$ ，发出的光的颜色为长度 $n$ 的字符串，由 ‘R’、’G’、’B’ 构成。</p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>为了方便，我们设绿岛为 $0$ ，红岛为 $1$ ，黑岛为 $2$ 。</p><p>设 $dp(i, j, k, l)$ 表示对于前 $i$ 座岛屿，且最后三座岛屿为 $(j, k, l)$ 时，绿岛的最大数量。</p><p>转移方程为 $dp(i, j, k, l) = max(dp(i, j, k, l), dp(i-1, t, j, k))$ ，其中 $0 \le t \le 2$ 。</p><p>注意在转移前判断 $(j, k, l)$ 是否合法，以及 $dp(i-1, t, j, k)$ 是否合法。$dp = -1$ 表示这种状态是不合法的。</p><p>坑点：注意一定用 $dp(i-1, t, j, k)$ 判断，不要用 $(t, j, k)$ 判断是否为 $s[i-1]$ ，因为即使等于，也不一定合法，还和前面的岛屿有联系。</p><h2 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">/* dp(i, j, k, l) 表示考虑前i个字符，此时最后三个岛屿为(j, k, l)时的最大绿岛数量</span></span><br><span class="line"><span class="comment"> * 其中0表示绿岛，1表示红岛，2表示黑岛</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">get_color</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x1 = (a == <span class="number">0</span>) + (b == <span class="number">0</span>) + (c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x2 = (a == <span class="number">1</span>) + (b == <span class="number">1</span>) + (c == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) <span class="keyword">return</span> <span class="string">'G'</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) <span class="keyword">return</span> <span class="string">'R'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_color</span>(i, j, k) == s[<span class="number">3</span>]) dp[<span class="number">3</span>][i][j][k] = !i + !j + !k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; t ++ )</span><br><span class="line">                        <span class="keyword">if</span> (~dp[i<span class="number">-1</span>][t][j][k] &amp;&amp; <span class="built_in">get_color</span>(j, k, l) == s[i])</span><br><span class="line">                            dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i<span class="number">-1</span>][t][j][k] + !l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp[n][i][j][k]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-牛牛学走路"><a href="#L-牛牛学走路" class="headerlink" title="L. 牛牛学走路"></a>L. 牛牛学走路</h1><h2 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h2><p>给出字符串 $s$ ，牛牛会按照字符串给的方向走一遍，问走的位置里原点最远为多少？</p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>签到题，维护一下当前的位置即可，设原点为 $(0, 0)$ 。</p><h2 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> }, dc[] = { <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line">    d[<span class="string">'U'</span>] = <span class="number">0</span>; d[<span class="string">'D'</span>] = <span class="number">1</span>; d[<span class="string">'R'</span>] = <span class="number">2</span>; d[<span class="string">'L'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        x += dr[d[s[i]]]; y += dc[d[s[i]]];</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, dis);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ret);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;A-九小时九个人九扇门&quot;&gt;&lt;a href=&quot;#A-九小时九个人九扇门&quot; class=&quot;headerlink&quot; title=&quot;A. 九小时九个人九扇门&quot;&gt;&lt;/a&gt;A. 九小时九个人九扇门&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; clas</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>康托展开</title>
    <link href="https://horb7.github.io/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <id>https://horb7.github.io/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2022-01-01T11:51:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><blockquote><p>康托展开是一个全排列与自然数的双射，常用于构建hash表时的空间压缩。假设有 $n$ 个数(1, 2, 3, 4 …) ，  可以有 $n!$ 的排列组合，康托展开表示在某一个全排列在这些组合的名次（以0开始）。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个全排列 $A$ 的名次为 $a_1 \times (n-1)! + a_2 \times (n-2)! \ldots + a_n \times 0!$ 。</p><p>其中 $a_i$ 表示第 $i$ 个数字，$A_i &gt; A_j \ and \ i &lt; j$ 。即比当前数字小但是在它后面的数字的个数。</p><p>因为对这个位置而言，我们选择 $a_i$ 中任意一个数字填充这个位置，后面的数字任意排列都可以比原来的小，所以比它小的名次的排列数量为 $a_i \times (n - i)!$ 。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++ ) x += A[j] &lt; A[i];</span><br><span class="line">    id += x * fac[n - i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><p>由于康托展开是一个全排列和自然数的双射，因此我们也可以根据名次得出全排列。</p><p>从前往后，对于第 $i$ 个数字，我们可以得到 $a_i = id / (n-i)!$ 。</p><p>由于 $a_i$ 表示在其后面且小于它的数值的数量，所以我们要遍历得到这个位置的值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id; cin &gt;&gt; id;</span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// st(i) 表示i数字有没有出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> a = id / fac[n - i];</span><br><span class="line">    id %= fac[n - i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 没有出现过</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (!a) <span class="comment">// 已经找到a个数字比它小</span></span><br><span class="line">            { A[i] = j; st[i] = <span class="literal">true</span>; <span class="keyword">break</span>; }</span><br><span class="line">            <span class="keyword">else</span> -- a;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.luogu.com.cn/problem/P3014">洛谷 P3014 Cow Line S</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="康托展开-1"><a href="#康托展开-1" class="headerlink" title="康托展开"></a>康托展开</h3><p>注意到内层循环的目的是为了找出后面有几个数字小于当前位置的数字，我们可以采用树状数组维护，从后往前遍历即可。这样查询只需要 $O(logn)$ 的时间，总复杂度降至 $O(nlogn)$ 。</p><p><a href="https://www.luogu.com.cn/problem/P5367">洛谷P5367 模板 康托展开</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll c[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) ++ c[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">    ll id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="built_in">add</span>(a[i]), id = (id + fac[n-i] * <span class="built_in">query</span>(a[i] - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (id + <span class="number">1</span>) % mod);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="逆康托展开-1"><a href="#逆康托展开-1" class="headerlink" title="逆康托展开"></a>逆康托展开</h3><p>注意到内层循环的目的是为了找出剩下没有被选上的数字中的第 $a_i+1$ 个数字，我们可以采用线段树维护，复杂度 $O(logn)$ ，总复杂度为 $O(nlogn)$ 。</p><p>具体来说，我们维护 $[l, r]$ 中有多少数字是有效的（未被删除），每次查询找出全局第 $a_i + 1$ 小的数字即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll st; <span class="comment">// st 表示当前这个区间有多少数字未被删除</span></span><br><span class="line">};</span><br><span class="line">node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].st = t[<span class="built_in">ls</span>(p)].st + t[<span class="built_in">rs</span>(p)].st;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r; t[p].st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    -- t[p].st; <span class="comment">// 在这个区间查询后需要删除那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) <span class="keyword">return</span> t[p].l;</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].st &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), k - t[<span class="built_in">ls</span>(p)].st);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.luogu.com.cn/problem/P3014">洛谷 P3014 Cow Line S优化版</a> </p><p>记得每次初始化~</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll c[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) ++ c[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll st; <span class="comment">// st 表示当前这个区间有多少数字未被删除</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].st = t[<span class="built_in">ls</span>(p)].st + t[<span class="built_in">rs</span>(p)].st;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r; t[p].st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    -- t[p].st; <span class="comment">// 在这个区间查询后需要删除那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) <span class="keyword">return</span> t[p].l;</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].st &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), k - t[<span class="built_in">ls</span>(p)].st);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, n) c[i] = <span class="number">0</span>;</span><br><span class="line">            ll id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="built_in">add</span>(a[i]), id += fac[n-i] * <span class="built_in">query</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, id + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            ll id; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;id); id -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> x = id / fac[n - i];</span><br><span class="line">                id %= fac[n - i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, <span class="built_in">query</span>(<span class="number">1</span>, x+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2021.12.31</strong> 更新，使用树状数组模板和<a href="https://horb7.github.io/2021/12/30/zkw%E6%A0%91/">zkw树</a>实现康托展开和逆康托展开。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll fac[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> {</span></span><br><span class="line">  <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">  <span class="keyword">int</span> n; ll a[N];</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x &amp; -x; }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{ <span class="keyword">this</span>-&gt;n = n; <span class="built_in">fill</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>, <span class="number">0</span>); }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">1</span>)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) a[x] += v; }</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ ll res = <span class="number">0</span>; <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x)) res += a[x]; <span class="keyword">return</span> res; }</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">ask</span>(r) - <span class="built_in">ask</span>(l<span class="number">-1</span>); }</span><br><span class="line">};</span><br><span class="line">BIT&lt;N&gt; bit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* zkw树 */</span></span><br><span class="line"></span><br><span class="line">ll M, t[N &lt;&lt; <span class="number">1</span>]; <span class="comment">// t(i) 表示i节点表示的区间内有多少剩余的1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (ll i = M; i &lt; M + n; i ++ ) t[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = M - <span class="number">1</span>; i; i -- ) t[i] = t[i&lt;&lt;<span class="number">1</span>] + t[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span> <span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll r;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; M; )</span><br><span class="line">    {</span><br><span class="line">        -- t[r];</span><br><span class="line">        <span class="keyword">if</span> (t[r&lt;&lt;<span class="number">1</span>] &gt;= x) r &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x -= t[r&lt;&lt;<span class="number">1</span>], (r &lt;&lt;= <span class="number">1</span>) |= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -- t[r], r - M + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q); <span class="keyword">for</span> (M = <span class="number">1</span>; M &lt; n; M &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            bit.<span class="built_in">init</span>(n);</span><br><span class="line">            ll id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            <span class="built_in">per</span>(i, n, <span class="number">1</span>) bit.<span class="built_in">add</span>(a[i]), id += fac[n-i] * bit.<span class="built_in">ask</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, id + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            ll id; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;id); id -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> x = id / fac[n - i];</span><br><span class="line">                id %= fac[n - i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, <span class="built_in">ask</span>(x+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;康托展开&quot;&gt;&lt;a href=&quot;#康托展开&quot; class=&quot;headerlink&quot; title=&quot;康托展开&quot;&gt;&lt;/a&gt;康托展开&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;康托展开是一个全排列与自然数的双射，常用于构建hash表时的空间压缩。假设有 $n$ 个数(1, </summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>扩展中国剩余定理</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-21T15:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>对于同余方程组：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\x \equiv a_3 \pmod {m_3} \\..... \\x \equiv a_n \pmod {m_n} \\\end{cases}</script><p>求出满足上述同余方程组的 $x$ 的一组解，<strong>公式满足 $m_1,m_2, m_3 … m_n$ 互质。</strong></p><p>令 $M = \prod_{i=1}^{n}m_i , M_i = M / m_i, M_i \times M_i^{-1} \equiv 1 \pmod {m_i}$ 。</p><p>中国剩余定理构造出了这样一组解:</p><script type="math/tex; mode=display">x = \sum_{i=1}^{n} M_i * M_i^{-1} * a_i</script><p>对于每一组解 $x \equiv a_i \pmod {m_i}$ ，$x$ 除了 $M_i \times M_i ^ {-1} \times a_i$ 项之外，其余都能被 $m_i$ 整除，所以只剩下这一项。</p><p>又因为 $M_i \times M_i^{-1} \equiv 1 \pmod {m_i}$ 。所以 $x \equiv a_i \pmod {m_i}$ 。</p><h2 id="扩展中国剩余定理-1"><a href="#扩展中国剩余定理-1" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h2><p>传统的中国剩余定理限制性太强，必须要满足 $m_1, m_2, m_3 … m_n$ 互质。如何求出不满足模数不互质的同余方程组的解？</p><p>先从两个柿子看起：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\\end{cases}</script><p>首先可以得到 $x = k_1 \times m_1 + a_1 = k_2 \times m_2 + a_2$ 。</p><p>对这个柿子化简： $k_1 \times m_1 + k_2 \times (-m_2) = a_2 - a_1$ 。</p><p>对于这个柿子，我们可以用扩展欧几里得求出一组满足 $k_1 \times m_1 + k_2 \times (-m_2) = gcd(m_1, -m_2)$ 的 $k_1, k_2$ 解。</p><p>记 $gcd(m1, -m2) = d$ 。</p><p>根据贝祖定理，如果不满足 $d | a_2 - a_1$ ，那么不存在解。否则，我们只需要扩大 $(a_2 - a_1) / d$ 倍即可得到 $k_1$ 的一组解。</p><p>由于这是个不定方程，在求出 $k_1$ 后，我们可以得到其他满足的解一定为 $k_1 = k_1 + k \times (m_2 / d)$ 。</p><p>我们把这个通解 $k_1$ 带入原来的柿子：$x = (k_1 + k \times (m_2 / d)) \times m_1 + a_1$ 。</p><p>得到：</p><p>$x = k_1 \times m_1 + a_1 + k \times (m_1 \times m_2) / d$ 。</p><p>$x = k_1 \times m_1 + a_1 + k \times lcm(m_1, m_2)$ 。</p><p>令 $m_0 = lcm(m1, m2), a_0 = k_1 \times m_1 + a_1$ 。</p><p>那么，我们得到 $x = k \times m_0 + a_0$ ，这个柿子满足这两个同余方程组解。</p><p>通过这样的方式，我们就可以把两个同余方程组化简成一个，最终达到化简 $n$ 个同余方程组的效果。</p><p>那么最终可以算出 $x = k \times m + a$ ，其中 $m = lcm(m_1, m_2 … m_n)$ ，所以在 $\pmod m$ 的意义下， $x = a$ 。</p><p>例题:<a href="https://www.acwing.com/problem/content/description/206/">Acwing 204 表达整数的奇怪方式</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, x - (a / b) \times y);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = ((a % b) + b) % b;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a1, m1; cin &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a2, m2, k1, k2; cin &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(a1, -a2, k1, k2);</span><br><span class="line">        <span class="keyword">if</span> ((m1 - m2) % r) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl, <span class="number">0</span>;</span><br><span class="line">        k1 = <span class="built_in">mod</span>(k1 \<span class="built_in">times</span> (m2 - m1) / r, <span class="built_in">abs</span>(a2 / r));</span><br><span class="line">        m1 = k1 \times a1 + m1;</span><br><span class="line">        a1 = <span class="built_in">abs</span>(a1 \times a2 / r);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于为什么取 $abs$ 的原因:</p><ol><li>由于 $a \% b$ 和 $a \% -b$ 是相同的，所以我们在计算 $k_1$ 时 需要加上 $abs(a_2 / r)$ ，防止在 $mod$ 过程中加上负数，结果仍然是负数。</li><li>下一个阶段的 $a_1$ 实际上一个的 $lcm(a_1,a_2)$ ，但是在计算 $gcd(a_1, a_2)$ 时可能出现负数，导致计算 $lcm$ 时会出现负数，这里要取 $abs$ 。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;扩展中国剩余定理&quot;&gt;&lt;a href=&quot;#扩展中国剩余定理&quot; class=&quot;headerlink&quot; title=&quot;扩展中国剩余定理&quot;&gt;&lt;/a&gt;扩展中国剩余定理&lt;/h1&gt;&lt;h2 id=&quot;中国剩余定理&quot;&gt;&lt;a href=&quot;#中国剩余定理&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-20T01:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h1><p>在拓展欧几里得定理之前，先介绍以下<strong>贝祖定理</strong>：</p><blockquote><p>如果方程式 $ax + by = m$ 成立，那么 $gcd(a, b) | m$</p></blockquote><p>显然，我们可以把原方程式写作：$m = k1 \times g \times x + k2 \times g \times y = g(k1 \times x + k2 \times y)$</p><p>根据贝祖定理，如果有 $ax + by = 1$ ，那么 $gcd(a, b) = 1$， 即 $a$ 与 $b$ 互质。</p><p>我们可以使用著名的辗转相除法算出来 $gcd(a, v=b)$ :</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拓展欧几里得-1"><a href="#拓展欧几里得-1" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><p>给出 $ax + by = m$ ，如何求出他的一组解？</p><p>根据贝祖定理，只要我们求出 $ax + by = gcd(a, b)$ 即可，由于 $gcd(a, b) | m$ ，所以可以求出原式的一组因子，只需要乘上 $m / gcd(a, b)$ 即为原式的一组解。</p><p>那么问题就转化为了，求 $ax + by = gcd(a, b)$ 的一组 $(a, b)$ 。</p><p>$gcd(a, b)$ 可以用欧几里得辗转相除求出，而 $a, b$ 可以在求的过程中得出。</p><p>假设我们到达了终点，此时 $a = gcd(a, b), b = 0$ ，那么有 $x = 1, y = 0$ 。</p><p>由于$gcd(a, b)$ 是递归的，当我们想要求得 $ax + by = m$ 时，我们已经求出了 $bx + (a \% b)y = m$ 的一组解。</p><p>$a \% b = a - \lfloor \dfrac a b \rfloor \times b$</p><p>把已有的式子化作：$bx + (a - \lfloor \dfrac a b \rfloor \times b)y = m$</p><p>那么，可以得到：$ay + b(x - \lfloor \dfrac a b \rfloor \times y) = m$</p><p>所以我们发现，如果从上一层状态推下来，那么：$x = y, y = x - \lfloor \dfrac a b \rfloor \times y$</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, x - (a / b) * y);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 $ax + by \equiv m \pmod p$ 有无穷多组，而我们只计算出了一种，那么如何得到其他解？</p><p>假设我们得到解为 $x_0, y_0$ ，还有另外一组解为 $x_1, y_1$ ，那么可以得到：</p><p>$ax_0 + by_0 \equiv m \pmod p$</p><p>$ax_1 + by_1 \equiv m \pmod p$ </p><p>两个柿子相减，得到 $a(x_0 - x_1) \equiv -b(y_0 - y_1) \pmod p$ </p><p>两边同时除以 $gcd(a, b)$ ，有 $a / gcd(a, b) (x_0 - x_1) \equiv -b / gcd(a, b)(y_0 - y_1) \pmod p$</p><p>此时 $a / gcd$ 与 $b / gcd$ 互质，所以一定有 $a / gcd(a, b) | (y_0 - y_1), b / gcd(a, b) | (x_0 - x_1)$</p><p>我们记 $x_1 = x_0 + k \times \dfrac{b}{gcd(a, b)}$ ，同理 $y_1 = y_0 + k \times \dfrac{a}{gcd(a, b)}$ 。</p><h3 id="欧几里得用途"><a href="#欧几里得用途" class="headerlink" title="欧几里得用途"></a>欧几里得用途</h3><h5 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h5><p> $a \times a^{-1} \equiv 1 \pmod p$ ，可以写成 $a \times a^{-1} \equiv kp + 1 \pmod p$ ，</p><p>这样，我们就可以得到柿子 : $a \times a^{-1} + kp \equiv 1 \pmod p$ 。</p><p>这就是拓展欧几里得公式，由于 $a, p$ 都已知，只需要用拓展欧几里得算出 $(a^{-1}, k)$ 即可。</p><p><strong>注意拓展欧几里得可以计算 $p$ 与 $a$ 非互质情况下的逆元，而欧拉定理不能算出。</strong></p><h5 id="计算同余方程组"><a href="#计算同余方程组" class="headerlink" title="计算同余方程组"></a>计算同余方程组</h5><p><a href="http://localhost:4000/2021/12/19/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">扩展中国剩余定理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拓展欧几里得&quot;&gt;&lt;a href=&quot;#拓展欧几里得&quot; class=&quot;headerlink&quot; title=&quot;拓展欧几里得&quot;&gt;&lt;/a&gt;拓展欧几里得&lt;/h1&gt;&lt;p&gt;在拓展欧几里得定理之前，先介绍以下&lt;strong&gt;贝祖定理&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>整除分块</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-23T13:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><h2 id="一维分块引入"><a href="#一维分块引入" class="headerlink" title="一维分块引入"></a>一维分块引入</h2><p>给定一个整数，求出</p><script type="math/tex; mode=display">\sum_{i=1}^n \lfloor \dfrac n i \rfloor</script><p>其中: $1 \le n \le 10^9$ 。</p><p>对于上述题目，$O(n)$ 的解法是很显然的，但是对于 $n$ 很大或者有多组测试样例时，这样的复杂度是不能接受的。我们需要找出更优秀的复杂度来解决上述题目。</p><p>容易发现，由于 $\dfrac n i$ 是向下取整的，因此在某一个连续的区间， $\dfrac n i$ 取值是相同的，比如 $n = 10$ 时：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">n/i</td><td style="text-align:center">10</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>每一个取值都是一个连续的块，那么只要我们直到某一个块的左右端点，就可以 $O(1)$ 地算出这个块的总和。</p><p><strong>定理1</strong>： $\dfrac n i$ 中最多有 $2 \times \sqrt{n}$ 个块。</p><blockquote><p>我们把 $\dfrac n 1, \dfrac n 2, \ldots \dfrac n n$ 分成 $2$ 个部分，前一部分为 $\dfrac n 1, \dfrac n 2, \ldots \dfrac {n} {\lfloor \sqrt n \rfloor }$ ，后一部分为 $\dfrac n {\lfloor \sqrt n \rfloor + 1}, \dfrac n {\lfloor \sqrt n \rfloor + 2}, \ldots \dfrac n n$ 。</p><p>对于前一部分，有 $\sqrt n$ 项，对于后一部分，它所有的取值为 $1, 2, \ldots \sqrt n$ ，因此不同的取值有 $\sqrt n$ 项，所以最多有 $2 \times \sqrt n$ 项不同的取值。</p></blockquote><p> 根据定理1，我们根据最好的情况，即把每一个块都 $O(1)$ 地算出结果，那么复杂度就是 $O(\sqrt n)$ 的。</p><p><strong>定理2</strong>： 如果第 $k$ 块，如果它的左端点为 $l$ ，那么它的右端点为 $\dfrac n {\lfloor \dfrac n l \rfloor}$ 。</p><blockquote><p>假设第 $k$ 段的取值为 $t$ ，取 $i$ 为 $l \le i \le r$ ，那么显然有 $\dfrac n i = \dfrac n l = t$ ，即 $i \times t \le n$ ，$i \le \dfrac n t$，由于 $r = max(i)$ ，那么 $r = \dfrac n t = \dfrac n {\lfloor \dfrac n l \rfloor}$ 。</p></blockquote><p>如此，我们便可以求出所有块的左右端点进行运算，复杂度为 $O(\sqrt n)$ 。</p><hr><p>给出整除分块模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ret += (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="约数研究"><a href="#约数研究" class="headerlink" title="约数研究"></a><a href="https://www.luogu.com.cn/problem/P1403">约数研究</a></h3><p>由于直接求 $i$ 的约数个数不好求，我们可以枚举所有的因子。</p><p>假设因子为 $i$ ，那么在 $[1, n]$ 中，因数含有 $i$ ，即 $i$ 的倍数有 $\lfloor \dfrac n i \rfloor$ 个。</p><p>因此问题转化为求 $\sum_{i=1}^n \lfloor \dfrac n i \rfloor$ ，这就是基本整除分块。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ret += (<span class="keyword">long</span> <span class="keyword">long</span>) (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="余数求和"><a href="#余数求和" class="headerlink" title="余数求和"></a><a href="https://www.luogu.com.cn/problem/P2261">余数求和</a></h3><p>首先由于 $k \ \ mod \ \ i = k - \lfloor \dfrac k i \rfloor \times i$ 。</p><p>于是我们可以把原式转化成 $\sum_{i=1}^n k - \lfloor \dfrac k i \rfloor \times i = n \times k - \sum_{i=1}^n \lfloor \dfrac k i \rfloor \times i$ 。</p><p>其中 $\lfloor \dfrac k i \rfloor$ 我们可以使用整除分块处理，这样对于每一个块而言， $\lfloor \dfrac k i \rfloor$ 都是一个常数，那么我们要求它乘以一个等差数列的值，只需要求 $i$ 在这个块的累加和即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = n * k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = <span class="built_in">min</span>(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        ret -= (<span class="keyword">long</span> <span class="keyword">long</span>)(l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span> * (k / l);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二维分块"><a href="#二维分块" class="headerlink" title="二维分块"></a>二维分块</h2><p>给定两个整数 $n, m$ ，求：</p><script type="math/tex; mode=display">\sum_{i=1}^{min(n, m)} \lfloor \dfrac n i \rfloor \times \lfloor \dfrac m i \rfloor</script><p>由一维分块，我们可以得到块数最多为 $2 \times \sqrt n + 2 \times \sqrt m$ 。</p><p>我们记 $k = min(n, m)$ 。</p><p>对于其中一个块，假设左端点为 $l$ ，那么其右端点为 $r = min(k, min(n / (n / l), m / (m / l)))$ 。因为我们要保证块里的元素相同，必须要保证 $\lfloor \dfrac n i \rfloor$ 元素相同且 $\lfloor \dfrac m i \rfloor$ 元素相同。</p><p>二维分块模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    r = <span class="built_in">min</span>(k, <span class="built_in">min</span>(n / (n / l), m / (m / l)));</span><br><span class="line">    ret += (n / l) * (m / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整除分块&quot;&gt;&lt;a href=&quot;#整除分块&quot; class=&quot;headerlink&quot; title=&quot;整除分块&quot;&gt;&lt;/a&gt;整除分块&lt;/h1&gt;&lt;h2 id=&quot;一维分块引入&quot;&gt;&lt;a href=&quot;#一维分块引入&quot; class=&quot;headerlink&quot; title=&quot;一维分块引</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2022-02-17T14:24:19.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树介绍"><a href="#最小生成树介绍" class="headerlink" title="最小生成树介绍"></a>最小生成树介绍</h1><p><img src="/images/ds/mst.png" alt=""></p><p>在介绍最小生成树前，先介绍一下生成树：在一张联通无向图中，我们取图上的所有点，并取最少的边将其相连使其连通生成一棵树，这个树就被称作这张图的生成树。因为树的边数一定是点数-1，所以就是取 $n-1$ 条边来连通 $n$ 个点。</p><p>那么最小生成树(Minimum Spanning Tree)，是最小权重生成树的简称。规定树的权值为树上所有边的权值和，那么它就是一张连通加权无向图中一颗权值最小的生成树，如上图。由定义可以看出，<strong>最小生成树不一定唯一</strong>。</p><hr><p>对于如何生成最小生成树的问题，我们有两种常见的解决方法，分别是Prim算法和Kruskal算法，两者都基于贪心。</p><h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>给定图 $G(V, E)$ ，我们逐步进行Prim算法，假设在过程中，$V_{new}$ 表示已经选中作为生成树上的结点，$E_{new}$ 表示已经选中作为最小生成树上的边。</p><p>规定Prim算法如下：</p><ol><li>初始化一个结点 $x$ 加入 $V_{new}$ ，则 $V_{new} = {x}$ 。由于最小生成树包含所有节点，我们可以用任意一个结点初始化。</li><li>从集合 $E$ 中选择权值最小的边 $(u, v)$ ，满足 $u \in V_{new}$ 且 $v \notin V_{new}$ ，将 $v$ 加入集合 $V_{new}$ 中，把 $(u, v)$ 加入 $E_{new}$ 中。</li><li>重复操作，直到所有点都已经被选中加入最小生成树中，即 $V_{new} = V$ 。</li><li>根据 $V_{new}$ 和 $E_{new}$ 所得到的新图 $G_{new}(V_{new}, E_{new})$ 即为原图 $G(V, E)$ 的最小生成树。</li></ol><p>只需要证明根据第二步所得到边一定为最优解即可。</p><ol><li><p>按照Prim算法得到的第一条边一定是最小生成树上的边。</p><p>如果不是，我们把这一条边加入到最小生成树中，形成回路，我们让最小的边取代回路中比它大的边，得到权值更小的生成树。所以第一条边一定是最小生成树上的边。</p></li><li><p>假设在某一个步骤中，Prim得到的点集为 $V_{new} = \{v1, v2, v3 \ldots vs-1\}$ 。 根据Prim算法，我们应该选择与这些点有交集的边中，权值最小的边。</p><p>假设这个权值最小的边连接 $V_{new}$ 中的 $vk$ ，如果不选择这条边，那么我们把这条边加入最小生成树中，形成一个回路，且这个回路包含 $vk$ ，我们假设连接 $vk$ 的那条边另一端为 $vi$ ，我们用权值最小的边替换掉 $(vk, vi)$ ，得到的生成树权值一定不大于最小生成树，因此选择这条边为最优边。</p></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx; <span class="comment">// 邻接表存图</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// st(x) 表示x点已经加入生成树中</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">// dist(x) 表示x点距离已经生成的树的最小距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span> <span class="params">()</span> <span class="comment">// 返回最小生成树的权值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d); d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始化从1开始，最开始生成树上的V和E都为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 要加入n个点，迭代n次，每次放进一个点</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 找出距离当前生成树最近的点</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[k] &amp;&amp; (t == <span class="number">-1</span> || dist[k] &lt; dist[t])) t = k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把选择的点加入生成树中</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        ret += dist[t];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于加入了一个点，那么其他点也可以通过连接这个点到达生成树，更新dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], w[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有没有觉得Prim算法和Dijkstra算法雷同？没错，它们都是根据同样的贪心思想，唯一的区别仅仅在于更新的时候。</p><p><strong>Prim算法复杂度</strong>：根据上述代码，复杂度为 $O(n^2 + 2E)$ ，由于图上每个点至多被更新 $1$ 次，所以图的所有边至多被更新 $2$ 次。</p><p>与Dijsktra算法一样，Prim算法可以使用二叉堆优化，复杂度降到 $O((n + 2E)logn)$ 。</p><hr><h1 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h1><p>如果说Prim算法是小树长成大树的过程，那么Kruskal算法就是拼图的过程。</p><p>Prim算法基于点来扩大树，而Kruskal基于边来扩大，具体来说，该算法的过程如下：</p><ol><li>将图 $G(V, E)$ 的所有边按权值进行非递减排序。</li><li>初始化每个点都为单独的连通分量。（因为此时我们还没有选择边作为最小生成树的一部分）</li><li>从后往前检查所有边$(u, v)$ 。<ul><li>$u$ 和 $v$ 在同一个连通分量里，那么加入 $(u, v)$ 会产生环，因此不能选择。</li><li>$u$ 和 $v$ 不在一个连通分量里，那么加入 $(u, v)$ 一定是最优的。如果不加入，形成生成树 $T$ ，把 $(u, v)$ 加入 $T$ 中，会形成环，环中包含 $(u, v)$ 和另外一条权值不小于 $(u, v)$ 的边，我们把这条边用 $(u, v)$ 替换，不会使结果变差，因此 $(u, v)$ 是最优的选择。</li></ul></li></ol><p>因为会考虑所有边，因此一定能构成一颗完整的最小生成树（除非原图不连通）。</p><p>在Kruskal算法中，最关键的地方在于“连通”分量的查询和合并，需要知道两个点是否在一个连通分量中，以及如果不是在一个连通分量，需要将其合并，我们可以使用<a href="https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/"><strong>并查集</strong></a>来支持此操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span></span><br><span class="line">    <span class="keyword">int</span> u, v, d; <span class="comment">// 表示边两端的点以及边权</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp; rhs) <span class="keyword">const</span> { <span class="comment">// 重载小于号，支持比较</span></span><br><span class="line">        <span class="keyword">return</span> d &lt; rhs.d;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">Edge edges[M];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edges + <span class="number">1</span>, edges + m + <span class="number">1</span>); <span class="comment">// 假设边集从1开始存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, cnt = <span class="number">0</span>; <span class="comment">// cnt表示目前已经选择了多少条边（生成树只需要n-1条边）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; cnt &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u = edges[i].u, v = edges[i].v, d = edges[i].d;</span><br><span class="line">        u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        ++ cnt, res += d, p[u] = v;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 原图不连通，没有生成树，何谈最小</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小生成树介绍&quot;&gt;&lt;a href=&quot;#最小生成树介绍&quot; class=&quot;headerlink&quot; title=&quot;最小生成树介绍&quot;&gt;&lt;/a&gt;最小生成树介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/ds/mst.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在介绍最小</summary>
      
    
    
    
    <category term="图论" scheme="https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="生成树" scheme="https://horb7.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
</feed>
