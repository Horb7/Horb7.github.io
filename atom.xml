<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Horb7&#39;s blog</title>
  
  <subtitle>一日事，一日毕</subtitle>
  <link href="https://horb7.github.io/atom.xml" rel="self"/>
  
  <link href="https://horb7.github.io/"/>
  <updated>2022-04-19T01:09:41.936Z</updated>
  <id>https://horb7.github.io/</id>
  
  <author>
    <name>Horb7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022昆明</title>
    <link href="https://horb7.github.io/2022/04/19/2022%E6%98%86%E6%98%8E/"/>
    <id>https://horb7.github.io/2022/04/19/2022%E6%98%86%E6%98%8E/</id>
    <published>2022-04-19T01:09:19.000Z</published>
    <updated>2022-04-19T01:09:41.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-King-of-Games"><a href="#K-King-of-Games" class="headerlink" title="K. King of Games"></a>K. King of Games</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个系数 $x = \dfrac a b$ 。</p><p>进行 $n$ 次比赛，如果对于当前比赛，在之前进行过 $m$ 次比赛，已经产生 $k$ 次胜场，则：</p><ol><li>$\dfrac k m \le x$ ，则当前比赛胜利。</li><li>否则当前比赛失败。</li></ol><p>给定 $n, a, b$ ，求进行 $n$ 局后，一共有多少胜场。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结论是 $(n-1) \times a / b + 1$ ，不能取 $double$ ，具体原因还不清楚，等之后再更新。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T; <span class="keyword">while</span>( T -- ) {</span><br><span class="line">        <span class="keyword">int</span> n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">long</span> <span class="keyword">long</span>) (n - <span class="number">1</span>) * a / b + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="D-Divisions"><a href="#D-Divisions" class="headerlink" title="D. Divisions"></a>D. Divisions</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>对于长度为 $n$ 的序列 $S$ ，将其划分为两个子序列 $S_1, S_2$ ，一共有 $2^n$ 种划分方式。</p><p>定义序列的权值 $k$ 为：有 $k$ 种方式划分两个子序列，使得 $S_1, S_2$ 满足：</p><p>$S_1$ 单调不下降，$S_2$ 单调不上升。</p><p>给定 $k$ ，构造出 $S$ ，要求 $|S| \le 365$ 。</p><p>其中 $0 \le k \le 10^8$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>因为划分其中一个之后，还要判断剩下的是否满足另外一个条件，这样很不好判断。</p><p>我们可以 “固定” 其中一个子序列 $S_1$ ：构造出如 “112233344……” 这样的形式。</p><p><strong>那么，对于任意一种划分，$S_1$ 一定满足，有 $2^n &gt; k$ ，那么只需要构造 $k$ 个$S_2$ 即可</strong> 。</p><p>由于构造的是最长不下降序列，那么 <strong>$S_2$ 一定是在某一个数字段上选择，即选择相同的数字</strong> 。</p><p>对于每一段数字段，假设长度为 $n$ ，那么会产生 $2^n - 1$ 个对 $S_2$ 的贡献。</p><p>注意： $S_2$ 可以取空集，所有要使 $k -= 1$ ，即构造 $k-1$ 个非空 $S_2$ 。</p><p><strong>坑点</strong>：由于每次只能构造 $2^n - 1$ 的贡献，因此不能根据 “每个数字能被若干个二次幂表示，所以要使用 while” ，具体看代码。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k; cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"6\n1 1 4 5 1 4\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"8\n1 2 3 1 2 3 1 2\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans; <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    k -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">1</span>; i -- ) {</span><br><span class="line">        <span class="comment">// 这里是产生 2^n-1 的贡献，注意要使用while, 比如 k = 30, 只能取 2^4-1，需要取两次，因为 [1, 3] 的幂不能构造出剩下的 15</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>) {</span><br><span class="line">            k -= (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) {</span><br><span class="line">                ans.<span class="built_in">push_back</span>(now);</span><br><span class="line">            }</span><br><span class="line">            ++ now;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: ans) cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="F-Find-the-Maximum"><a href="#F-Find-the-Maximum" class="headerlink" title="F. Find the Maximum"></a>F. Find the Maximum</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $n$ 节点的树，选出一条简单路径，求 $\max \dfrac {\sum_{u \in V} (-x^2 + b_ux)} {|V|}$ 。其中 $V$ 表示路径上的点集，$x$ 为任意实数。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>假设 $|V| = j$ 。</p><p>那么有</p><script type="math/tex; mode=display">\begin{equation}\dfrac {\sum_{u \in V} (-x^2 + b_ux)} {|V|} \\= \dfrac {-jx^2 + (\sum_{i=1}^j b_i)x} {j} \\ = -x^2 + \dfrac {(\sum_{i=1}^j b_i)x} {j} \\= -(x - \dfrac {\sum_{i=1}^j b_i} {2j})^2 + (\dfrac {\sum_{i=1}^j b_i} {2j})^2 \\= -(x - \dfrac {\sum_{i=1}^j b_i} {2j})^2 + (\dfrac {\sum_{i=1}^j b_i} {j})^2 \times \dfrac 1 4\end{equation}</script><p>关于 $x$ 的项一定 $\le 0$ ，取其为 $0$ 即可。</p><p>那么最大值就是取得的所有点值的平均值，平方后再乘上 $\dfrac 1 4$ 。</p><p>因为要取平方，所以要取的应该是平均值的绝对最大值。</p><p>对于平均值的最大值，它一定出现在选 $2$ 个点或者 $3$ 个点的情况下，所以枚举选哪个即可。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, b[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) {</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j: g[i]) v.<span class="built_in">push_back</span>(b[j]);</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;&gt;());</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (v[<span class="number">0</span>] + b[i]) / <span class="number">2.0</span>);</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) ans = <span class="built_in">max</span>(ans, (v[<span class="number">0</span>] + v[<span class="number">1</span>] + b[i]) / <span class="number">3.0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] = -b[i];</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">solve</span>());</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; (ans * ans / <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="B-Blocks"><a href="#B-Blocks" class="headerlink" title="B. Blocks"></a>B. Blocks</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个矩形，最初整个二维平面都是白色的。</p><p>每次随机从 $n$ 个矩形中选择一个，将其涂成黑色（已经涂过的也可能被选择）。</p><p>问：将 $[(0, 0), (W, H)]$ 矩形填满的期望次数是多少，答案对 $998244353$ 取模。</p><p>其中 $1 \le n \le 10$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于 $n$ 很小，可以考虑使用状态压缩，即状压dp。</p><p>使用 $dp$ 来记录到达目标状态的期望步数，那么只需要输出 $dp[0]$ 即可。</p><p>能够将给定矩形涂满的状态有多个，我们可以使用 $good$ 数组记录所有这样的状态。</p><p>从目标状态出发，即倒着枚举所有的状态，进行状态转移。</p><p>对于当前状态，我们记录 $1$ 的个数为 $cnt$ 。</p><p>那么有转移公式：</p><script type="math/tex; mode=display">\begin{equation}dp[i] = 1 + \dfrac {cnt} n \times dp[i] + \sum_{第j位为0} \dfrac {dp[i|(1<<j)]} n \\ n \times dp[i] = n + cnt \times dp[i] + \sum_{第j位为0} dp[i|(1<<j)] \\ (n - cnt) \times dp[i] = n + \sum_{第j位为0}dp[i|(1<<j)] \\dp[i] = \dfrac {n + \sum_{第j位为0}dp[i|(1<<j)]} {n - cnt}\end{equation}</script><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N][<span class="number">4</span>], W, H;</span><br><span class="line"><span class="keyword">bool</span> good[<span class="number">1</span> &lt;&lt; N]; <span class="comment">// 此状态是否可以把WH填满</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; N]; <span class="comment">// 走到 st 状态的期望步长</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= P; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="built_in">quick_power</span>(x, P - <span class="number">2</span>); }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出所有的目标状态，即能够涂满大矩阵的所有状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="built_in">memset</span>(good, <span class="number">0</span>, <span class="keyword">sizeof</span> good);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ ) {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> g[<span class="number">50</span>][<span class="number">50</span>]; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ ) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = p[j][<span class="number">0</span>]; k &lt; p[j][<span class="number">2</span>]; k ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r = p[j][<span class="number">1</span>]; r &lt; p[j][<span class="number">3</span>]; r ++ )</span><br><span class="line">                        g[k][r] += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; W; k ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; H; r ++ )</span><br><span class="line">                <span class="keyword">if</span> (!g[k][r]) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) good[i] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> good[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    alls.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; W &gt;&gt; H;</span><br><span class="line">    alls.<span class="built_in">push_back</span>(<span class="number">0</span>); alls.<span class="built_in">push_back</span>(W); alls.<span class="built_in">push_back</span>(H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) {</span><br><span class="line">        cin &gt;&gt; p[i][<span class="number">0</span>] &gt;&gt; p[i][<span class="number">1</span>] &gt;&gt; p[i][<span class="number">2</span>] &gt;&gt; p[i][<span class="number">3</span>];</span><br><span class="line">        alls.<span class="built_in">push_back</span>(p[i][<span class="number">0</span>]); alls.<span class="built_in">push_back</span>(p[i][<span class="number">1</span>]);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(p[i][<span class="number">2</span>]); alls.<span class="built_in">push_back</span>(p[i][<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> <span class="built_in">lower_bound</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>(), x) - alls.<span class="built_in">begin</span>(); };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) {</span><br><span class="line">        p[i][<span class="number">0</span>] = <span class="built_in">find</span>(p[i][<span class="number">0</span>]); p[i][<span class="number">1</span>] = <span class="built_in">find</span>(p[i][<span class="number">1</span>]);</span><br><span class="line">        p[i][<span class="number">2</span>] = <span class="built_in">find</span>(p[i][<span class="number">2</span>]); p[i][<span class="number">3</span>] = <span class="built_in">find</span>(p[i][<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    W = <span class="built_in">find</span>(W); H = <span class="built_in">find</span>(H);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">init</span>()) <span class="keyword">return</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) {</span><br><span class="line">        <span class="keyword">if</span> (good[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>; <span class="comment">// 记录1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ ) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) {</span><br><span class="line">                ++ cnt;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                res = (res + dp[i|<span class="number">1</span>&lt;&lt;j]) % P;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dp[i] = (ll)(res + n) * <span class="built_in">inv</span>(n - cnt) % P;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="E-Easy-String-Problem"><a href="#E-Easy-String-Problem" class="headerlink" title="E. Easy String Problem"></a>E. Easy String Problem</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列 $A$ ，有 $q$ 次询问，每次给出 $[l, r]$ ，问：</p><p>将 $[l, r]$ 删除后，将两端 $A$ 拼接为字符串，可得到多少个不同的字符串(包含空集)？</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>容斥，删除 $[L, R]$ 后，剩下一共可以组成 $L \times (n - R + 1)$ 种字符串，减去产生重复的。</p><p>如果产生重复，首先删除的长度一定是相同的($R-L+1$) 。</p><p>设 $[L, R]$ 表示删除 $[L, R]$ 子区间后的字符串。</p><p>考虑两个临近的区间 $[L, R]$ 和 $[L + 1, R + 1]$ ，如果产生重复，那么一定有 $a_L = a_{R+1}$ 。</p><p>进一步，如果有 $[L + 1, R + 1] = [L + 2, R + 2]$ ，那么有 $[L, R] = [L + 2, R + 2]$ 。</p><p>那么可以得到 $[L, R] = [L + K, R + K] \ iff \ [L, R] = [L + 1, R + 1] = \ldots$  ，这样会产生 $K$ 个相同字符串，我们计算其中 $K - 1$ 个为重复量。</p><p>那么，我们只需要知道有多少个 $[L, R] = [L + 1, R + 1]$ 即可，因为根据上述式子，可以得到 $K - 1$ 个。</p><p>整理一下，当前询问为 $[L, R]$ ，那么对于 $l \le L, R \le r$ ，只需要知道<strong>有多少种</strong> $[l, r] = [l+1, r+1]$ 即可。</p><p>由 $[l, r] = [l+1, r+1]$ 得到 $a_{l} = a_{r+1}$ ，那么问题变成了：</p><p>求 $l \le L-1, R + 1 \le r$ ，有多少数对满足 $a_l = a_r$ 。</p><blockquote><p>为什么值域是 $[1, L-1], [R+1, n]$ ？</p><p>首先 $l, l+1 \le L$ ，所以有 $l \in [1, L - 1]$ ，同理有 $r \in [R, n]$ 。</p><p>但是求的实际上是 $a_l = a_{r+1}$ ，所以 $r+1 \in [R + 1, n]$ 。</p><p>把 $r+1$ 换成 $r$ ，那么就是：</p><p>求 $l \in [1, L - 1], r \in [R + 1, n]$ ，求 $a_l = a_r$ 的数对个数。</p></blockquote><p>使用莫队解决，注意初始区间为 $l = 1, r = n$ ，这样转移到某个 $[L, R]$ 时，我们就知道了左右两边的各个数字的数量，虽然为负数，但和式本质是两边相乘，因此结果依然为正。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转化：有多少个 l &lt;= L - 1, R + 1 &lt;= r 满足 a[l] = a[r] */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> m, maxn;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> {</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> query &amp;rhs) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">if</span> (l / maxn != rhs.l / maxn) <span class="keyword">return</span> l &lt; rhs.l;</span><br><span class="line">        <span class="keyword">if</span> (l / maxn &amp; <span class="number">1</span>) <span class="keyword">return</span> r &lt; rhs.r;</span><br><span class="line">        <span class="keyword">return</span> r &gt; rhs.r;</span><br><span class="line">    }</span><br><span class="line">} Q[N];</span><br><span class="line"><span class="keyword">int</span> cnt_left[N], cnt_right[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N], Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> left)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left) {</span><br><span class="line">        Ans = Ans + cnt_right[x];</span><br><span class="line">        ++ cnt_left[x];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        Ans = Ans + cnt_left[x];</span><br><span class="line">        ++ cnt_right[x];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> left)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left) {</span><br><span class="line">        Ans = Ans - cnt_right[x];</span><br><span class="line">        -- cnt_left[x];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        Ans = Ans - cnt_left[x];</span><br><span class="line">        -- cnt_right[x];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n; maxn = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) {</span><br><span class="line">        <span class="keyword">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        Q[i] = { l, r, i };</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(Q + <span class="number">1</span>, Q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) {</span><br><span class="line">        <span class="keyword">while</span>(l &gt; Q[i].l) <span class="built_in">add</span>(a[-- l], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r &lt; Q[i].r) <span class="built_in">add</span>(a[++ r], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; Q[i].l) <span class="built_in">del</span>(a[l ++ ], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r &gt; Q[i].r) <span class="built_in">del</span>(a[r -- ], <span class="number">0</span>);</span><br><span class="line">        ans[Q[i].id] = <span class="number">1ll</span> * l * (n - r + <span class="number">1</span>) - Ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K-King-of-Games&quot;&gt;&lt;a href=&quot;#K-King-of-Games&quot; class=&quot;headerlink&quot; title=&quot;K. King of Games&quot;&gt;&lt;/a&gt;K. King of Games&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="区域站" scheme="https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理复习</title>
    <link href="https://horb7.github.io/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://horb7.github.io/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-03-24T04:35:43.000Z</published>
    <updated>2022-03-24T04:35:43.247Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 659(Div.2)</title>
    <link href="https://horb7.github.io/2022/03/23/Codeforces-Round-659-Div-2/"/>
    <id>https://horb7.github.io/2022/03/23/Codeforces-Round-659-Div-2/</id>
    <published>2022-03-23T08:05:10.000Z</published>
    <updated>2022-03-23T08:37:34.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Common-Prefixed"><a href="#A-Common-Prefixed" class="headerlink" title="A. Common Prefixed"></a>A. Common Prefixed</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>构造一个字符串数组，使得对于给定的序列 $a$ ，满足第 $i$ 个和第 $i+1$ 个字符串的最长公共前缀为 $a_i$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>初始构造一个足够长的字符串，每次只需要修改 $a_i$ 的位置上的字符即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string now = <span class="built_in">string</span>(<span class="number">55</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (now[x] == <span class="string">'a'</span>) now[x] = <span class="string">'b'</span>;</span><br><span class="line">        <span class="keyword">else</span> now[x] = <span class="string">'a'</span>;</span><br><span class="line">        cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="B-Koa-and-the-Beach"><a href="#B-Koa-and-the-Beach" class="headerlink" title="B. Koa and the Beach"></a>B. Koa and the Beach</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的数组 $d$ ，在一个长度为 $2 \times k$ 的循环周期内，前 $k$ 秒中的每一秒，$d_i = d_i + 1$，后 $k$ 秒中的每一秒，$d_i = d_i - 1$ ，从数组左端点(第一个元素的左边)出发，每次可以选择走到下一个位置或者等待，需要满足任意时刻所在的元素 $d_i \le l$ ，问最少需要多少秒才能走出这个数组(最后一个元素的右边) 。</p><p>其中 $1 \le n \le 3 \times 10^5, 1 \le k, l \le 10^9$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>贪心，从所有<strong>绝对安全点</strong>（即满足 $d_i + k &lt;= l$ 的点）出发，此时最好的情况一定是从第 $k$ 秒出发，这样后面的元素都是往下的。</p><p>注意 $0$ 号点和 $n + 1$ 号点，即起点和终点也是绝对安全点。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, l;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">safe</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 初始点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (a[i] + k &lt;= l) safe.<span class="built_in">push_back</span>(i);</span><br><span class="line">    safe.<span class="built_in">push_back</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; safe.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> down = <span class="literal">true</span>, tide = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = safe[i<span class="number">-1</span>] + <span class="number">1</span>; j &lt; safe[i]; j ++ )</span><br><span class="line">        {</span><br><span class="line">            tide += down ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 需要在前面的位置等待多少秒</span></span><br><span class="line">            <span class="keyword">if</span> (down) tide -= <span class="built_in">max</span>(<span class="number">0</span>, a[j] + tide - l);</span><br><span class="line">            <span class="keyword">if</span> (tide &lt; <span class="number">0</span> || a[j] + tide &gt; l) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"NO\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">            <span class="keyword">if</span> (tide == <span class="number">0</span>) down = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="C-String-Transformation-1"><a href="#C-String-Transformation-1" class="headerlink" title="C. String Transformation 1"></a>C. String Transformation 1</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的两个字符串 $a, b$ 。每次可以选择 $a$ 字符串中的若干个相同的字符，将他们统一变成<strong>更大的</strong>字符。</p><p>问最少需要操作多少次才能使 $a = b$ ？</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>首先，如果可以在若干次操作后使得 $a = b$ ，那么对于任意位置 $i$ ，满足 $a_i \le b_i$ 。</p><p>从小的字符开始转换，<strong>把他们全部转化为最小的 $b_i$</strong> 。比如对于 $a-c, a-f, a-t$ ，把 $a$ 全部变为最小的 $c$ 。</p><p>这样不会使结果更差。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">string s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s1[i] &gt; s2[i]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"-1\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">if</span> (s1[i] &lt; s2[i]) f[s1[i]-<span class="string">'a'</span>][s2[i]-<span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">        <span class="built_in">rep</span>(j, i + <span class="number">1</span>, <span class="number">25</span>)</span><br><span class="line">            <span class="keyword">if</span> (f[i][j])</span><br><span class="line">            {</span><br><span class="line">                ++ans;</span><br><span class="line">                <span class="built_in">rep</span>(k, j + <span class="number">1</span>, <span class="number">25</span>) f[j][k] |= f[i][k];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="D-GameGame"><a href="#D-GameGame" class="headerlink" title="D. GameGame"></a>D. GameGame</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，两位选手每次选择其中一个元素，并把该元素从序列中删除。</p><p>两位选手最后的得分为所选择的元素的异或和，问是否先手必胜，或者平局。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>异或操作不会产生进位，对于每一位，异或操作都是独立的，那么我们可以对于每一位独立分析。</p><p>从高位到低位分析，<strong>对于当前位</strong>：</p><p>假设有 $c1$ 个 $1$ ，$c0$ 个 $0$ 。那么有如下结论:</p><ol><li><p>$c1 \ \ \% \ \ 2 \ \ = \ \ 0$ ：一定为平局。</p><p>记两个选手拿的 $1$ 数量为 $k_1, k_2$ ，那么显然有 $k_1$ 和 $k_2$ 同奇同偶，在这一位异或值相同。</p></li><li><p>$c1 \ \ \% \ \ 4 \ \ = \ \ 3 \ \ \&amp;\&amp; \ \ c0 \ \ \% \ \ 2 \ \ = \ \ 0$ ：先手必败</p><p>后手模仿先手的动作，最后一定会等价于 $(c1=3, c0=0)$ 的状态，那么先手拿 $2$ 个 $1$ ，异或为 $0$ ，后手拿 $1$ 个 $1$ ，异或为 $1$ 。</p></li><li><p>$c1 \ \ \% \ \ 4 \ \ = \ \ 3 \ \ \&amp;\&amp; \ \ c0 \ \ \% \ \ 2 \ \ != \ \ 0 \ \ || \ \ c1 \ \ \% \ \ 4 \ \ = \ \ 1$ ：先手必胜</p><p>对于前面的情况，最后等价于 $(c1=3, c0=1)$ 的状态，先手拿一个 $0$ ，转化为先手必败。</p><p>对于后面的情况，先手先拿 $1$ 个 $1$ ，再模仿后手的动作，即最后先手拿到 $2 \times k + 1$ 个 $1$ ，异或为 $1$ ，后手拿到 $2 \times k$ 个 $1$ ，异或为 $0$ 。</p></li></ol><p>当某一位确定必胜或者必败后，剩下的位不需要再判断，否则继续向低位判断即可。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">bool</span> win = <span class="number">0</span>, lose = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="built_in">count_if</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &gt;&gt; i &amp; <span class="number">1</span>; });</span><br><span class="line">        <span class="keyword">int</span> c0 = n - c1;</span><br><span class="line">        <span class="keyword">if</span> (c1 % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (c1 % <span class="number">4</span> == <span class="number">3</span> &amp;&amp; c0 % <span class="number">2</span> == <span class="number">0</span>) lose = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> win = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (win || lose) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (win) cout &lt;&lt; <span class="string">"WIN\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lose) cout &lt;&lt; <span class="string">"LOSE\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">"DRAW\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-Common-Prefixed&quot;&gt;&lt;a href=&quot;#A-Common-Prefixed&quot; class=&quot;headerlink&quot; title=&quot;A. Common Prefixed&quot;&gt;&lt;/a&gt;A. Common Prefixed&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;</summary>
      
    
    
    
    
    <category term="codeforces" scheme="https://horb7.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 717(Div.2)</title>
    <link href="https://horb7.github.io/2022/03/18/Codeforces-Round-717-Div-2/"/>
    <id>https://horb7.github.io/2022/03/18/Codeforces-Round-717-Div-2/</id>
    <published>2022-03-18T09:26:05.000Z</published>
    <updated>2022-03-23T08:07:23.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-AGAGA-XOOORRR"><a href="#B-AGAGA-XOOORRR" class="headerlink" title="B. AGAGA XOOORRR"></a>B. AGAGA XOOORRR</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列，每次操作可以选择两个相邻的元素 $a, b$ ，将其合并为一个数字 $a \bigoplus b$ 。</p><p>问：若干次操作后，能否使得序列长度不为 $1$ 且所有数字都相同？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于 $n = 2$ 的情况，直接判断两个元素是否相同即可。</p><p>当 $n &gt; 2$ 时，由于 $\bigoplus$ 具有交换性，即 $a \bigoplus b = c$ ，则 $a = b \bigoplus c$ ，所以如果所有元素异或和为 $0$ ，就一定可以使操作后序列长度为 $2$ 且元素相等。</p><p>如果元素异或和不为 $0$ ，要想使最后所有元素相等，即最后一定剩下奇数个相等的元素，其值就是所有元素的异或和，直接模拟判断即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i], sum ^= a[i];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> cout &lt;&lt; (a[<span class="number">1</span>] == a[<span class="number">2</span>] ? <span class="string">"YES\n"</span> : <span class="string">"NO\n"</span>), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">if</span> (!sum) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"YES\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    {</span><br><span class="line">        now ^= a[i];</span><br><span class="line">        <span class="keyword">if</span> (now == sum) ++ ans, now = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; (ans &gt;= <span class="number">2</span> ? <span class="string">"YES\n"</span>: <span class="string">"NO\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="C-Baby-Ehab-Partitions-Again"><a href="#C-Baby-Ehab-Partitions-Again" class="headerlink" title="C. Baby Ehab Partitions Again"></a>C. Baby Ehab Partitions Again</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，定义 $good$ 序列为：</p><p>将序列划分为任意两个<strong>子序列</strong> $s_1, s_2$ ，都不存在 $sum_{s_1} = sum_{s_2}$ ，则称这个序列为 $good$ 序列。</p><p>问：需要删除最少多少个元素，可以使得给定序列为 $good$ 序列？</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><ol><li><p>序列和为奇数，那么一定为 $good$ 序列，因为不可能存在两个划分的子序列和相等。</p></li><li><p>序列和为偶数：</p><ul><li><p>如果这个序列为 $good$ 序列，输出 $0$ 即可。</p></li><li><p>否则我们可以每次将序列里元素除以 $2$ ，因为这不会改变非 $good$ 序列的性质，也就是元素和一定也为偶数。如果有一个元素为奇数，那么直接将这个元素删除即可。</p></li></ul></li></ol><p>接下来只需要知道如何判断原始序列是否为 $good$ 序列了。</p><p>设 $f(i)$ 表示取序列若干元素可以达到 $i$ 这个元素和，那么考虑所有元素对 $f$ 的影响，也就是01背包，判断 $f(sum/2)$ 是否可以就行了。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i], sum += a[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"0\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    bitset&lt;200010&gt; bit;</span><br><span class="line">    bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) bit |= bit &lt;&lt; a[i];</span><br><span class="line">    <span class="keyword">if</span> (!bit[sum / <span class="number">2</span>]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"0\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &amp; <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"1\n"</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">            <span class="keyword">else</span> a[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="D-Cut"><a href="#D-Cut" class="headerlink" title="D. Cut"></a>D. Cut</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，给定 $q$ 次询问，每次询问如下：</p><p>给定 $l, r$ ，问：将 $[l, r]$ 划分为若干<strong>子区间</strong>，使每个子区间的乘积等于子区间元素的最小公倍数，问划分子区间数量最小为多少？</p><p>其中 $1 \le n, q \le 10^5, 1 \le a_i \le 10^5$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>从区间为 $2$ 分析：$LCM(a, b) = a \times b / GCD(a, b)$  ，所以如果要满足区间元素乘积等于区间元素最小公倍数，<strong>必须要满足区间内所有元素互质</strong> 。</p><p>设 $go(i)$ 表示 $i$ 位置之后与 $a_i$ <strong>不互质</strong> 的元素的位置，每一次都往 $go(i)$ 跳，即跳到下一个区间的第一个元素位置，一定可以使得子区间划分数量最小。</p><p>在最坏情况下，所有元素都是不互质的，那么每次询问都是 $O(n)$ 的复杂度，会超时。</p><p>可以采用倍增思想，设 $st(i, j)$ 表示 $i$ 位置元素跳了 $2^j$ 步后到达的位置，每一次跳都是跳不互质的下一个位置。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> a[N], go[N], st[N][<span class="number">21</span>], nxt[N]; <span class="comment">// nxt记录质因子出现的最近位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// go记录每个数字跳到下一个与其不互质的数字的位置，也就是下一个区间第一个数字</span></span><br><span class="line">    <span class="built_in">memset</span>(nxt, INF, <span class="keyword">sizeof</span> nxt);</span><br><span class="line">    <span class="built_in">memset</span>(go, INF, <span class="keyword">sizeof</span> go);</span><br><span class="line">    <span class="built_in">memset</span>(st, INF, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求go数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -- ) {</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= t / j; j ++ ) {</span><br><span class="line">            <span class="keyword">if</span> (t % j) <span class="keyword">continue</span>;</span><br><span class="line">            go[i] = <span class="built_in">min</span>(go[i], nxt[j]);</span><br><span class="line">            <span class="keyword">while</span>(t % j == <span class="number">0</span>) t /= j;</span><br><span class="line">            nxt[j] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">1</span>) {</span><br><span class="line">            go[i] = <span class="built_in">min</span>(go[i], nxt[t]);</span><br><span class="line">            nxt[t] = i;</span><br><span class="line">        }</span><br><span class="line">        go[i] = <span class="built_in">min</span>(go[i], go[i+<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理st表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) st[i][<span class="number">0</span>] = go[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) {</span><br><span class="line">            <span class="keyword">if</span> (st[i][j<span class="number">-1</span>] &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            st[i][j] = st[st[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出答案</span></span><br><span class="line">    <span class="keyword">while</span>(q -- ) {</span><br><span class="line">        <span class="keyword">int</span> l, r, ans = <span class="number">1</span>; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span> (st[l][i] &lt;= r) {</span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                l = st[l][i];</span><br><span class="line">            }</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-AGAGA-XOOORRR&quot;&gt;&lt;a href=&quot;#B-AGAGA-XOOORRR&quot; class=&quot;headerlink&quot; title=&quot;B. AGAGA XOOORRR&quot;&gt;&lt;/a&gt;B. AGAGA XOOORRR&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="codeforces" scheme="https://horb7.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 692(Div.2)</title>
    <link href="https://horb7.github.io/2022/03/17/Codeforces-Round-692-Div-2/"/>
    <id>https://horb7.github.io/2022/03/17/Codeforces-Round-692-Div-2/</id>
    <published>2022-03-17T15:44:51.000Z</published>
    <updated>2022-03-23T08:06:54.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Peaceful-Rooks"><a href="#C-Peaceful-Rooks" class="headerlink" title="C. Peaceful Rooks"></a>C. Peaceful Rooks</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在 $n \times n$ 的棋盘上有 $m$ 个车，每辆车都能对同行或者同列的其他车造成攻击。</p><p>给定 $m$ 个棋盘的初始状态（保证不互相攻击），每次操作都可以移动一次车到同行或者同列的位置，但要保证放置后不能处在可以被攻击的位置上。</p><p>问：至少需要操作几次，可以使得每辆车都处在正对角线上。</p><p>其中 $2 \le n \le 2 \times 10^5, 1 \le m \lt n$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在不考虑移动的位置会造成攻击的情况下，由于初始位置保证互相不处在攻击位置，所以每辆车，如果不处在主对角线上，那么将其 $(x, y)$  移动到 $(y, y)$ ，即每辆车都向 $y$ 移动，这样保证不会有冲突，那么最少的移动次数就是不在主对角线的车的数量。</p><p>考虑移动会造成冲突的情况，由于每辆车都是沿 $y$ 轴移动的，我们把 $x -&gt; y$ 这样的移动看作一条边，那么当图出现环的时候，比如 $1-&gt;2-&gt;3-&gt;1$ ，那么我们可以选择一个点移动到不产生冲突的位置，破坏环，然后环上的每辆车都可以只移动一次，比如移动 $1$ ，那么就可以把 $y=3$ 移动到 $y=1$ ，然后把 $y=2$ 移动到 $y=3$ ，再移动 $y = 1$ 到 $y=3$ 即可。</p><p>也就是说，对于每个环，都会多产生一次移动，只需要求出有多少环即可。</p><p>由于这一题的环只可能是简单环，那么可以使用并查集求联通块，如果 $x-&gt;y$ 且 $x$ 和 $y$ 在一个联通块，就是形成了环。（可以画图理解形成环的过程）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">        ++ ans;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) ++ ans;</span><br><span class="line">        <span class="keyword">else</span> p[x] = y;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="D-Grime-Zoo"><a href="#D-Grime-Zoo" class="headerlink" title="D. Grime Zoo"></a>D. Grime Zoo</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出由 $0, 1, ?$ 组成的字符串 $s$ ，你可以向每个 $?$ 填入 $0$ 或 $1$ 。</p><p>定义字符串的价值为 $x \times a + y \times b$ ，其中 $x, y$ 为给定的系数，$a, b$ 分别表示 $01$ 和 $10$ 子序列的数量。</p><p>求出字符串 $s$ 的<strong>最小</strong>价值。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>当字符串的 $0$ 的数量和 $1$ 的数量固定时，<strong>$01$ 子序列数量 $+$ $10$ 子序列的数量是相等的</strong>。</p><p>当 $x \le y$ 时，我们要尽量让 $01$ 子序列出现的次数多，也就是要让 $1$ 尽量出现在后面，那么在问号里填的数字一定是 $0$ 在前面， $1$ 在后面。</p><p>同理，当 $x \gt y$ 时，我们要尽量让 $10$ 子序列出现的次数多，也就是让 $0$ 尽量出现在后面，那么在问号里填的数字一定是 $1$ 在前面，$0$ 在后面。</p><p>虽然不知道问号里 $0$ 和 $1$ 的数量，但是它们都是全部出现在一侧的，所以我们可以先假设问号全为 $1$ ，然后枚举某一侧 $0$ 的数量 (就是把 $1$ 改为 $0$) 。</p><p>比如现在 $x \le y$ ，那么从前往后枚举 $?$ 序列的各位置，把当前数字改为 $0$ ，我们可以先求出一开始（问号全为 $1$）的价值，然后减去当前问号为 $1$ 时对价值的贡献(前面有多少个 $0$ 和已经修改过的 $?$， 以及后面有多少 $0$)，再加上当前问号为 $0$ 时对价值的贡献，这样就求出了到这个位置所有问号都为 $0$ 且后面问号都为 $1$ 时的价值。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; all_qus; <span class="comment">// 所有问号的位置</span></span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">3</span>], ed[N][<span class="number">3</span>]; <span class="comment">// st记录前缀，ed记录后缀</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="comment">// 预处理每个元素的前缀和后缀数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'?'</span>) st[i][<span class="number">2</span>] = <span class="number">1</span>, all_qus.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> st[i][s[i]-<span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ ) st[i][j] += st[i<span class="number">-1</span>][j];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'?'</span>) ed[i][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ed[i][s[i]-<span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ ) ed[i][j] += ed[i+<span class="number">1</span>][j];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 一开始把所有的？当作1处理，最后枚举分割线的时候，其实就是把某一段变成0的过程</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) ans += (ll)(st[i<span class="number">-1</span>][<span class="number">1</span>] + st[i<span class="number">-1</span>][<span class="number">2</span>]) * y;</span><br><span class="line">        <span class="keyword">else</span> ans += (ll)st[i<span class="number">-1</span>][<span class="number">0</span>] * x;</span><br><span class="line">    }</span><br><span class="line">    ll ret = ans; <span class="comment">// res为最终的答案</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)<span class="comment">// 假如01的代价小，那么尽量把1放在后面，问号整体分为01</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 枚举分割点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all_qus.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> p = all_qus[i];</span><br><span class="line">            <span class="comment">// 把当前点改为0，减去当前点为1的贡献</span></span><br><span class="line">            ans -= (ll)(st[p<span class="number">-1</span>][<span class="number">0</span>]+st[p<span class="number">-1</span>][<span class="number">2</span>]) * x + (ll)ed[p+<span class="number">1</span>][<span class="number">0</span>] * y;</span><br><span class="line">            <span class="comment">// 增加当前点为0的贡献</span></span><br><span class="line">            ans += (ll)st[p<span class="number">-1</span>][<span class="number">1</span>] * y + (ll)(ed[p+<span class="number">1</span>][<span class="number">1</span>] + ed[p+<span class="number">1</span>][<span class="number">2</span>]) * x;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, ans);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 把问号分割为10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = all_qus.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> p = all_qus[i];</span><br><span class="line">            <span class="comment">// 把当前点改为0，减去当前点为1的贡献</span></span><br><span class="line">            ans -= (ll)st[p<span class="number">-1</span>][<span class="number">0</span>] * x + (ll)(ed[p+<span class="number">1</span>][<span class="number">2</span>] + ed[p+<span class="number">1</span>][<span class="number">0</span>]) * y;</span><br><span class="line">            <span class="comment">// 增加当前点为0的贡献</span></span><br><span class="line">            ans += (ll)(st[p<span class="number">-1</span>][<span class="number">1</span>] + st[p<span class="number">-1</span>][<span class="number">2</span>]) * y + (ll)ed[p+<span class="number">1</span>][<span class="number">1</span>] * x;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, ans);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="E-Poman-Numbers"><a href="#E-Poman-Numbers" class="headerlink" title="E. Poman Numbers"></a>E. Poman Numbers</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的字符串 $s$ (小写字符组成)，定义字符串区间为 $[l, r]$ 的价值 $f([l, r])$ 为：</p><ul><li>$f[l, r] = f[m+1, r] - f[l, m]$ ，当 $l \ \ != \ \ r$</li><li>$f[l, l] = 2^k$ ，其中 $k$ 为 $s[l]$ 在字符集的次序，即 $k = s[i] - ‘a’$ 。</li></ul><p>其中 $m$ 为你自己选择的数字，介于 $[l, r]$ 之间。</p><p>问能否在每次决策的时候都选择合适的 $m$ 值，使得 $f(1, n) = T$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>首先，根据递归性质，每个字符都会造成绝对值为 $2^{k_i}$ 的贡献，但是系数有正有负。</p><p>注意到<strong>最后一个字符</strong>造成的贡献一定为正的，因为它一定是每次选择右区间才能达到。</p><p>同时<strong>倒数第二个字符</strong>造成的贡献一定是负的，因为它一定是恰好选择一次左区间达到的。</p><p><strong>而前面 $n-2$ 个字符的系数都是可正可负的，都是合法的。</strong></p><p>证明：</p><ol><li>当 $s$ 只有一个字符造成正贡献，那么对于每一段，取 $m = l$ 即可。</li><li>假设 $s$ 有至少两个正贡献，由于前面分析了对于合法方案的序列，最后两个符号一定是 $-+$ ，也就是对于选定的 $m$ ，一定有 $s[m-1] = ‘+’, s[m] = ‘-‘$ （这是因为倒数第二个字符一定为 $’-‘$，所以一定可以构造）。然后划分成两个子问题，从而递归地证明。</li></ol><p>那么问题就变成了：给定 $n$ 个数字，最后两个数字的系数为 $-+$ ，前面 $n-2$ 个数字系数可正可负，问能否构造 $T$ 。</p><p>先令 $T = T - a[n] + a[n-1]$ ，去除后面两个数字的影响。</p><p>然后对前面 $n-2$ 个数字降序排序，贪心地构造：当 $T &lt; 0$ 时，取当前数字为正数，否则取负数。</p><p>证明：当 $T &lt; 0$ 时取当前数字为负数，并且可以使最后 $T = 0$ ，那么可以简化为：</p><p><img src="\images\problem\image-20220318004053717.png" alt="image-20220318004053717"></p><p>发现这就是前后顺序的关系，但是这样很难知道是否后面一定能构造，所以选前面的方案不会更差。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n, t; cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; ((<span class="number">1</span> &lt;&lt; (s[n] - <span class="string">'a'</span>) == t ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>)), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    t = t - (<span class="number">1</span> &lt;&lt; (s[n] - <span class="string">'a'</span>)) + (<span class="number">1</span> &lt;&lt; (s[n<span class="number">-1</span>] - <span class="string">'a'</span>));</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n<span class="number">-2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n<span class="number">-2</span>) a.<span class="built_in">push_back</span>(<span class="number">1</span> &lt;&lt; (s[i] - <span class="string">'a'</span>));</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    forr(x, a) <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t += x; <span class="keyword">else</span> t -= x;</span><br><span class="line">    cout &lt;&lt; (t ? <span class="string">"No\n"</span> : <span class="string">"Yes\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-Peaceful-Rooks&quot;&gt;&lt;a href=&quot;#C-Peaceful-Rooks&quot; class=&quot;headerlink&quot; title=&quot;C. Peaceful Rooks&quot;&gt;&lt;/a&gt;C. Peaceful Rooks&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="codeforces" scheme="https://horb7.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 695(Div.2)</title>
    <link href="https://horb7.github.io/2022/03/16/Codeforces-Round-695-Div-2/"/>
    <id>https://horb7.github.io/2022/03/16/Codeforces-Round-695-Div-2/</id>
    <published>2022-03-15T16:37:05.000Z</published>
    <updated>2022-03-15T17:21:38.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Wizard-Orz"><a href="#A-Wizard-Orz" class="headerlink" title="A. Wizard Orz"></a>A. Wizard Orz</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，初始每个元素都为 $0$ ，每一时刻过后，每个元素值加一（模10意义下）。</p><p>选择一个下标 $index$ ，将其在某个时刻时间暂停，与他距离为 $d$ 的元素会在 $d$ 时刻后时间暂停。</p><p>在所有元素都暂停后，可以得到一个新序列。</p><p>输出这个序列的字典序最大值。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为所有可能的序列的长度都是相等的，所以只需要让前面的元素尽量大即可。</p><p>第一个元素必须为 $9$ ，如果在这个下标暂停，那么第二个元素为 $0$ 。</p><p>否则，第二个元素为 $8$ ，在这里暂停，可以使第三个元素为 $9$ ，由于前两个都是固定的，而第三个又是最大，所以这种情况字典序最大。</p><p>也就是输出 $989012345 \ldots$ 即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"9\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"98\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"989"</span>;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; i % <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="B-Hills-And-Valleys"><a href="#B-Hills-And-Valleys" class="headerlink" title="B. Hills And Valleys"></a>B. Hills And Valleys</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列。</p><p>我们将值大于两边的元素称为谷峰，值小于两边的元素称为谷底。</p><p><strong>至多修改一个元素</strong>，使序列的谷峰+谷底的数量最小，输出这个最小值。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>每个元素要么不改，要么改为左边元素，要么改为右边元素。</p><p>直接模拟每个数字对两边元素的影响即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ok</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (a[i] &gt; a[i<span class="number">-1</span>] &amp;&amp; a[i] &gt; a[i+<span class="number">1</span>]) || (a[i] &lt; a[i<span class="number">-1</span>] &amp;&amp; a[i] &lt; a[i+<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>, ans;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n<span class="number">-1</span>) tot += <span class="built_in">is_ok</span>(i);</span><br><span class="line">    ans = tot;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">2</span> &amp;&amp; <span class="built_in">is_ok</span>(i<span class="number">-1</span>)) ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_ok</span>(i)) ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (i != n<span class="number">-1</span> &amp;&amp; <span class="built_in">is_ok</span>(i+<span class="number">1</span>)) ++ cnt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// del</span></span><br><span class="line">        <span class="keyword">int</span> st = a[i];</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">2</span> &amp;&amp; <span class="built_in">is_ok</span>(i<span class="number">-1</span>)) ++ c;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_ok</span>(i)) ++ c;</span><br><span class="line">        <span class="keyword">if</span> (i != n<span class="number">-1</span> &amp;&amp; <span class="built_in">is_ok</span>(i+<span class="number">1</span>)) ++ c;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, tot - cnt + c);</span><br><span class="line"></span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">2</span> &amp;&amp; <span class="built_in">is_ok</span>(i<span class="number">-1</span>)) ++ c;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_ok</span>(i)) ++ c;</span><br><span class="line">        <span class="keyword">if</span> (i != n<span class="number">-1</span> &amp;&amp; <span class="built_in">is_ok</span>(i+<span class="number">1</span>)) ++ c;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, tot - cnt + c);</span><br><span class="line"></span><br><span class="line">        a[i] = st;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line">    <span class="function">multiCase</span></span><br><span class="line"><span class="function">        <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="C-Tree-Bags"><a href="#C-Tree-Bags" class="headerlink" title="C. Tree Bags"></a>C. Tree Bags</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定三个背包，每个背包存储若干个元素。</p><p>重复以下操作，直到三个背包只剩下一个元素：</p><ul><li>选择两个背包，每个背包选择一个元素 $a, b$ </li><li>将 $b$ 从所属背包删除，将 $a$ 变为 $a - b$ </li></ul><p>输出剩下的元素的最大值。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>假设三个背包为：</p><script type="math/tex; mode=display">\begin{aligned}&a_1 a_2 a_3 a_4 \ldots \\&b_1 b_2 b_3 b_4 \ldots \\&c_1 c_2 c_3 c_4 \ldots \\\end{aligned}</script><p>假设最后剩下的元素为 $c_1$ 。</p><p>观察性质可以发现：一个数字移动偶数次到达 $c$ 背包，那么这个元素为正贡献，否则为负贡献。每次移动需要一个介质。</p><p>首先大的数字一定优先产生正贡献，所以对每个背包排序。</p><ol><li><p>我们可以选择将 $b_1$ 到 $b_n$ 全部通过 $a_1$ 到达 $c$ 背包，产生正贡献，那么剩下的所有 $a$ 背包元素都只能产生负贡献。这样产生的总贡献就是 $- s_a + s_b + s_c$ 。其中 $s_a$ 表示 $a$ 背包的总值。</p></li><li><p>或者将 $a_2$ 到 $a_n$ 通过 $b_1$ 到达 $c$ ，然后将 $b_2$ 到 $b_n$ 通过 $a_1$ 到达 $c$ ，这样就是 $a_1$ 和 $b_1$ 产生负贡献。总贡献为 $s_a + s_b + s_c - a_1 - b_1$ </p></li></ol><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">998244353</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n1, n2, n3; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; n3;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n1)</span>, <span class="title">b</span><span class="params">(n2)</span>, <span class="title">c</span><span class="params">(n3)</span></span>;</span><br><span class="line">    ll s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line">    forr(&amp;x, a) cin &gt;&gt; x, s1 += x;</span><br><span class="line">    forr(&amp;x, b) cin &gt;&gt; x, s2 += x;</span><br><span class="line">    forr(&amp;x, c) cin &gt;&gt; x, s3 += x;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a)); <span class="built_in">sort</span>(<span class="built_in">all</span>(b)); <span class="built_in">sort</span>(<span class="built_in">all</span>(c));</span><br><span class="line">    ll sub = <span class="built_in">min</span>({s1, s2, s3});</span><br><span class="line">    sub = <span class="built_in">min</span>({sub, a[<span class="number">0</span>] + b[<span class="number">0</span>], a[<span class="number">0</span>] + c[<span class="number">0</span>], b[<span class="number">0</span>] + c[<span class="number">0</span>]});</span><br><span class="line">    cout &lt;&lt; s1 + s2 + s3 - sub * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="D-Sum-of-Paths"><a href="#D-Sum-of-Paths" class="headerlink" title="D. Sum of Paths"></a>D. Sum of Paths</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，robot一开始可以站在任意位置，并且需要走<strong>正好</strong> $k$ 次，每次向左走或者向右走，但不能出界。行走 $k$ 次将停留在 $k+1$ 个位置上，贡献为这些位置的元素值的和。</p><p>一共有 $q$ 次询问：修改某个位置的元素值，求出所有合法的行走路径的贡献和为多少。答案对 $1e9+7$ 取模。</p><p>其中 $1 \le n, k \le 5000$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>根据数据范围可以往dp方向想。</p><p>对于元素值的修改，只需要求出每个点的贡献，就可以求出修改了多少贡献和。</p><p>记 $dp[j][i]$ 表示走了 $j$ 步，到达 $i$ 位置的方案数量。</p><p>注意这个状态是可逆的，即也可以表示从 $i$ 位置出发，走了 $j$ 步的方案数量。</p><p>记 $cnt[i]$ 表示 $i$ 位置的贡献数，有 $cnt[i] = \sum_{j=0}^{k}dp[j][i] \times dp[k-j][i]$ 。</p><p>这是因为在走了 $j$ 步到达 $i$ 后，因为需要走 $k$ 步，所以还有 $k-j$ 步没有走，而从 $i$ 走 $k-j$ 的方案数量为 $dp[k-j][i]$ 。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], dp[N][N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, k, q; cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, k) <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) dp[j][i] = dp[j<span class="number">-1</span>][i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n) dp[j][i] = dp[j<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> dp[j][i] = (dp[j<span class="number">-1</span>][i<span class="number">-1</span>] + dp[j<span class="number">-1</span>][i+<span class="number">1</span>]) % mod;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// calc cnt</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, <span class="number">0</span>, k) (cnt[i] += (ll)dp[j][i] * dp[k-j][i]) %= mod;</span><br><span class="line">    <span class="comment">// calc sum</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) ((sum += (ll) cnt[i] * a[i]) %= mod);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id, x; cin &gt;&gt; id &gt;&gt; x;</span><br><span class="line">        sum = ((sum + (ll)(x - a[id]) * cnt[id]) % mod + mod) % mod;</span><br><span class="line">        a[id] = x;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="E-Distinctive-Roots-in-a-Tree"><a href="#E-Distinctive-Roots-in-a-Tree" class="headerlink" title="E. Distinctive Roots in a Tree"></a>E. Distinctive Roots in a Tree</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $n$ 个节点的树，每个节点有权值 $a_i$ ，问有多少个节点满足：</p><ul><li>以这个点为根时，它到达其他任何节点的路径上不出现重复数字。</li></ul><p>其中 $1 \le n \le 2 \times 10^5, 1 \le a_i \le a_i$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>我们假设这棵树以 $1$ 为根。</p><p>直接求满足的不好求，可以求出哪些不满足，剩下的就是满足的了。</p><p>对于 $u$ 节点而言，假如它的子树 $v$ 里出现 $a_u$ ，那么除了 $v$ 子树里的点外，其他任何点都一定不能满足。</p><p>同时，如果除了 $u$ 树外还有 $a_u$ ，那么这个 $u$ 树上任何节点都不能满足。</p><p>记 $d_u$ 表示以 $u$ 为根的树是否满足（$0$ 为满足，非 $0$ 为不满足），只需要树上差分一下就行。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> multiCase int _; for (cin &gt;&gt; _; _ -- ; )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, a) for (auto x: a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rall(a) rbegin(a), rend(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>{cerr&lt;&lt;<span class="string">'\n'</span>;}<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;<span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x,Args... args)</span></span>{cerr&lt;&lt;<span class="string">"[ "</span>&lt;&lt;x&lt;&lt; <span class="string">" ] , "</span>;<span class="built_in">debug</span>(args...);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = N &lt;&lt; <span class="number">1</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, a[N], d[N]; <span class="comment">// d为树上差分数组</span></span><br><span class="line"><span class="keyword">int</span> cnt[N], now_cnt[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> c1 = now_cnt[a[u]];</span><br><span class="line">    ++ now_cnt[a[u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> c2 = now_cnt[a[u]];</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="keyword">if</span> (c2 != now_cnt[a[u]]) <span class="comment">// v子树上有a[u]元素</span></span><br><span class="line">            ++ d[<span class="number">1</span>], -- d[v]; <span class="comment">// 做树上差分</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (now_cnt[a[u]] - c1 != cnt[a[u]]) <span class="comment">// 全部的a[u]元素不都在u树上</span></span><br><span class="line">        ++ d[u]; <span class="comment">// 这一个树都不能使用</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ans += !now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">redfs</span>(v, u, now + d[v]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i], alls.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离散化</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(alls));</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(alls)), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(alls), x) - alls.<span class="built_in">begin</span>() + <span class="number">1</span>; };</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) a[i] = <span class="built_in">find</span>(a[i]), ++ cnt[a[i]];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">redfs</span>(<span class="number">1</span>, <span class="number">0</span>, d[<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IOS</span><br><span class="line"><span class="comment">//    init();</span></span><br><span class="line"><span class="comment">//    multiCase</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-Wizard-Orz&quot;&gt;&lt;a href=&quot;#A-Wizard-Orz&quot; class=&quot;headerlink&quot; title=&quot;A. Wizard Orz&quot;&gt;&lt;/a&gt;A. Wizard Orz&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class</summary>
      
    
    
    
    
    <category term="Codeforces" scheme="https://horb7.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理实验</title>
    <link href="https://horb7.github.io/2022/03/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <id>https://horb7.github.io/2022/03/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</id>
    <published>2022-03-10T07:45:32.000Z</published>
    <updated>2022-03-11T02:52:57.203Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://1zlab.com/wiki/python-opencv-tutorial/"><strong>Opencv-Python 教程</strong></a> </p><h1 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h1><h2 id="A-设置Python-OpenCV环境"><a href="#A-设置Python-OpenCV环境" class="headerlink" title="A. 设置Python+OpenCV环境"></a>A. 设置Python+OpenCV环境</h2><p>在命令行终端，输入 <code>pip install opencv-python</code> ，使用 $pip$ 安装 opencv ，注意 $pip$ 必须为最新版。</p><p>如果下载速度太慢，可以换成清华源进行下载：<code>pip3 install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple</code> 。</p><p>安装后，可以在 Pycharm专业版中输入 ：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'avatar.jpg'</span>)</span><br><span class="line">cv2.imshow(<span class="string">'My Avatar'</span>, img)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyWindow(<span class="string">'My Avatar'</span>)</span><br></pre></td></tr></tbody></table></figure><p>测试结果：</p><p><img src="\images\photo_change\image-20220310155554977.png" alt="image-20220310155554977"></p><p>其中：</p><p><code>cv2.imread</code> 函数表示读取一张图像，返回一个三维 <code>ndarray</code> ，前两维分别表示图像的长和宽，第三维表示图像的通道。</p><p><code>cv2.imshow</code> 可以展示一张图像，第一个参数为窗口名称，第二个参数为需要展示的图像(以<code>ndarray</code>表示)。</p><p><code>cv2.waitkey</code> 是一个窗口绑定函数，等待键盘符号的读入，并返回对应的 Ascii 码。</p><p><code>cv2.destroyAllWindows</code> 可以销毁所有窗口，也可以使用 <code>cv2.destroyWindow</code> 来销毁具体的某个窗口。</p><p><a href="https://blog.csdn.net/silence2015/article/details/53789748?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164696222516780269881044%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164696222516780269881044&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-53789748.article_score_rank&amp;utm_term=%E9%80%9A%E9%81%93&amp;spm=1018.2226.3001.4187">RGB图像之灰度级和通道的理解</a></p><hr><h2 id="B-练习图像分离、截取、转换等函数"><a href="#B-练习图像分离、截取、转换等函数" class="headerlink" title="B. 练习图像分离、截取、转换等函数"></a>B. 练习图像分离、截取、转换等函数</h2><h3 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h3><p><code>cv2.split</code> 函数可以分离图像的蓝、绿、红三种颜色，分离后的形成一个三个元素的列表，分别表示蓝、绿、红三种颜色在图像每个像素点的信息，为二维 <code>ndarray</code> 类型，可以对其进行展示等。</p><p>使用 <code>cv2.merge</code> 函数可以将三个分离的通道合并形成图像，在这之前可以对单独的通道进行修改等。</p><p><img src="\images\photo_change\image-20220310160804950.png" alt="image-20220310160804950"></p><p>我们也可以使用内置的方法进行图像的分离，比如使用 <code>cvtColor</code> 将图像进行转换。</p><p>下面为使用 <code>cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)</code> 将图像转换为灰度图的例子。</p><p><img src="\images\photo_change\image-20220310161128452.png" alt="image-20220310161128452"></p><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>上面提到了 <code>cv2.imread</code> 将图像转变为三维 <code>ndarray</code> 进行存储。我们可以提取出某一部分子矩阵作为新的图像，使用 <code>cv2.imwrite</code> 进行图像保存。</p><p><img src="\images\photo_change\image-20220310161558143.png" alt="image-20220310161558143"></p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>使用 <code>cv2.flip</code> 可以对图像进行转换，如垂直翻转，水平翻转，垂直+水平翻转。</p><div class="table-container"><table><thead><tr><th>param</th><th>效果</th></tr></thead><tbody><tr><td>1</td><td>水平翻转</td></tr><tr><td>0</td><td>垂直翻转</td></tr><tr><td>-1</td><td>垂直+水平翻转</td></tr></tbody></table></div><p>注意<code>cv2.flip</code> 返回的是新图像的存储，而不是对传进去的图像进行直接修改，可以使用 <code>new_img = cv2.flip(img, 1)</code> 来存储。</p><hr><h2 id="C-图像颜色变换"><a href="#C-图像颜色变换" class="headerlink" title="C. 图像颜色变换"></a>C. 图像颜色变换</h2><p>根据上述图像的图像截取，我们可以将一部分图像截取，然后修改其通道信息即可修改部分图像的颜色。</p><p><img src="\images\photo_change\image-20220310162402281.png" alt="image-20220310162402281"></p><hr><h2 id="D-计算和显示直方图"><a href="#D-计算和显示直方图" class="headerlink" title="D. 计算和显示直方图"></a>D. 计算和显示直方图</h2><p><code>cv2.calcHist</code> 函数用于计算图像直方图。</p><p>函数原型：<code>cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) #返回hist</code></p><p>其中：</p><ul><li>images:：输入的图像</li><li>channels：选择图像的通道</li><li>mask：掩码，是一个大小的iamges一样的 $ndarray$ 数组，其中把需要处理的部分指定为 $1$ ，不需要处理的部分指定为 $0$ 。一般设置为 $None$ ，表示处理整幅图像</li><li>histSize：使用多少个bin(柱子)，一般为256</li><li>ranges：像素值的范围，一般为 $[0, 255]$ 表示 $0 \sim 255$ </li></ul><p>后面两个参数基本不用输入，注意除了mask，其他四个参数都要带 [] 号。</p><p><img src="\images\photo_change\image-20220311094726897.png" alt="image-20220311094726897"></p><p><strong>计算灰度图像的直方图，输出 $100-128$ 的灰度值的像素数目：</strong></p><p><img src="\images\photo_change\image-20220311100346300.png" alt="image-20220311100346300"></p><p><strong>搜索查找具有最多像素数目的灰度级：</strong></p><p><img src="\images\photo_change\image-20220311101808970.png" alt="image-20220311101808970"></p><p><strong>使用 matplotlib 包画出直方图：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/37959111">教程</a></p><p>效果：</p><p><img src="\images\photo_change\image-20220311103036544.png" alt="image-20220311103036544"></p><h2 id="E-图像统计处理"><a href="#E-图像统计处理" class="headerlink" title="E. 图像统计处理"></a>E. 图像统计处理</h2><p><code>cv2.minMaxLoc</code> 函数可以在数组中寻找全局最小值和全局最大值，以及他们所处的位置。</p><p>由 <code>cv2.split</code> 分离出的通道属于二维 <code>ndarray</code> ，我们可以结合起来求出某一个通道中图像的最大值和最小值。</p><p><img src="\images\photo_change\image-20220310162827328.png" alt="image-20220310162827328"></p><p><code>cv2.meanStdDev</code> 函数可以统计矩阵的均值和标准偏差。</p><p>同理，我们可以结合 <code>cv2.split</code> ，求出绿色通道的图像矩阵的均值和标准差。</p><p><img src="\images\photo_change\image-20220310163112777.png" alt="image-20220310163112777"></p><hr><h2 id="F-图像缩放处理"><a href="#F-图像缩放处理" class="headerlink" title="F. 图像缩放处理"></a>F. 图像缩放处理</h2><p><code>cv2.resize</code> 函数可以用来处理图像的缩放。</p><p>函数需要用到的形参：</p><ol><li>原图片</li><li>dsize ：代表期望的输出图像的尺寸</li><li>fx, fy ：表示沿 x, y 轴的缩放比例</li><li>interpolation ：插值方式，默认为线性插值。</li></ol><p>注意，如果 $dsize$ 设置为 $None$ ，则以 $fx \times fy$ 作为输出图片的尺寸。</p><p><a href="http://1zlab.com/wiki/python-opencv-tutorial/opencv-interpolation-algrithm/">插值算法</a></p><p><img src="\images\photo_change\image-20220310164145972.png" alt="image-20220310164145972"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://1zlab.com/wiki/python-opencv-tutorial/&quot;&gt;&lt;strong&gt;Opencv-Python 教程&lt;/strong&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h1 id=&quot;实验1&quot;&gt;&lt;a href=&quot;#实验1&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="数字图像处理" scheme="https://horb7.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>动态开点线段树+线段树合并</title>
    <link href="https://horb7.github.io/2022/03/09/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    <id>https://horb7.github.io/2022/03/09/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/</id>
    <published>2022-03-09T05:52:35.000Z</published>
    <updated>2022-03-09T05:52:59.668Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树上差分+动态开点线段树合并 */</span></span><br><span class="line"><span class="comment">// 线段树维护最大值和最大值所在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span> <span class="keyword">int</span> l, r, Max, Pos; } t[N * <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>]; <span class="comment">// 求lca</span></span><br><span class="line"><span class="keyword">int</span> X[N], Y[N], Z[N], Ans[N]; <span class="comment">// 离线查询</span></span><br><span class="line"><span class="keyword">int</span> root[N], idx;</span><br><span class="line"><span class="keyword">int</span> R; <span class="comment">// R为救济品编号最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- lca --------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* --------- lca --------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 动态开点线段树，维护区间最大值及对应的位置 --------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[t[p].l].Max &gt;= t[t[p].r].Max)</span><br><span class="line">        t[p].Max = t[t[p].l].Max, t[p].Pos = t[t[p].l].Pos;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t[p].Max = t[t[p].r].Max, t[p].Pos = t[t[p].r].Pos;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++ idx; <span class="comment">// 没有点，创建新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].Max += v; t[p].Pos = l; <span class="keyword">return</span> p; }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) t[p].l = <span class="built_in">update</span>(t[p].l, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> t[p].r = <span class="built_in">update</span>(t[p].r, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* --------- 线段树 --------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 树上差分求子树前缀和，线段树合并 --------- */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 把q线段树合并到p线段树上</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> q; <span class="keyword">if</span> (!q) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].Max += t[q].Max; t[p].Pos = l; <span class="keyword">return</span> p; }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    t[p].l = <span class="built_in">merge</span>(t[p].l, t[q].l, l, mid);</span><br><span class="line">    t[p].r = <span class="built_in">merge</span>(t[p].r, t[q].r, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Redfs</span>(v, u);</span><br><span class="line">        root[u] = <span class="built_in">merge</span>(root[u], root[v], <span class="number">1</span>, R);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (t[root[u]].Max) Ans[u] = t[root[u]].Pos;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 树上差分求子树前缀和，线段树合并 --------- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 预处理倍增数组求lca</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; X[i] &gt;&gt; Y[i] &gt;&gt; Z[i];</span><br><span class="line">        R = <span class="built_in">max</span>(Z[i], R);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 每个点都有一棵线段树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> Lca = <span class="built_in">lca</span>(X[i], Y[i]);</span><br><span class="line">        root[X[i]] = <span class="built_in">update</span>(root[X[i]], <span class="number">1</span>, R, Z[i], <span class="number">1</span>);</span><br><span class="line">        root[Y[i]] = <span class="built_in">update</span>(root[Y[i]], <span class="number">1</span>, R, Z[i], <span class="number">1</span>);</span><br><span class="line">        root[Lca] = <span class="built_in">update</span>(root[Lca], <span class="number">1</span>, R, Z[i], <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> gfa = f[Lca][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (gfa) root[gfa] = <span class="built_in">update</span>(root[gfa], <span class="number">1</span>, R, Z[i], <span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Redfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; Ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>扫描线</title>
    <link href="https://horb7.github.io/2022/03/07/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <id>https://horb7.github.io/2022/03/07/%E6%89%AB%E6%8F%8F%E7%BA%BF/</id>
    <published>2022-03-07T15:56:09.000Z</published>
    <updated>2022-03-07T16:27:49.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><p>扫描线是一种ACM中矩阵面积交以及矩阵周长和问题的解法，通常使用线段树解决。</p><h2 id="矩阵面积交"><a href="#矩阵面积交" class="headerlink" title="矩阵面积交"></a>矩阵面积交</h2><p><a href="https://www.luogu.com.cn/problem/P5490">[模板]扫描线</a></p><p>在进行矩阵面积运算时，我们将一条垂直与 $x$ 轴的直线，从 $y$ 轴 $-\infty$ 向 $+\infty$ 扫描，可以将所有矩阵交分割为若干个规则矩阵，如图所示：</p><p><img src="\images\problem\saomiao.png" alt=""></p><p>计算所有矩阵面积交，只需要算出每个规则矩阵的面积和即可。</p><p>对于每个规则矩阵，我们可以知道它的宽为 $x_i - x_{i-1}$ ，只需要知道它的高即可。</p><p>比如，对于 $[x_1, x_2]$ 区间内的规则矩阵，他们的高为两个矩阵的高之和，这个距离我们可以使用线段树维护。</p><p>具体来说，需要维护 $y$ 轴上有多少长度为区间内矩阵的高。</p><p>对于每个规则矩阵，我们设它的左边为入边，右边为出边，那么对于左边，给对应 $y$ 轴上所有点（规则矩阵的高上的所有点）加上权值 $1$ ，当扫描线扫出这个矩阵，也就是经过出边，就同理减去权值 $1$ 。</p><p>由于我们在查询的时候，只需要知道整个 $y$ 轴上有多少长度被覆盖，也就是只查询线段树第一个节点的信息，不需要知道线段树内部节点，那么就可以不使用PushDown操作。整个线段树自下往上传递信息，不需要自上往下传递信息。</p><p>由于 $y$ 轴上的点范围很大，可以对其离散化后，在离散化区间上作线段树，注意对于线段树所维护的区间，它的每个点表示的是与后面的点的边的覆盖次数，也就是把点映射为边。</p><p>剩下的有时间再写。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> {</span> <span class="keyword">int</span> x, y1, y2, k; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid (t[p].l + t[p].r &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> len, cover;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Y;</span><br><span class="line">Line line[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Node t[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p] = { l, r, <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line">    <span class="keyword">if</span> (l != r) { <span class="built_in">build</span>(lc, l, mid); <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r); }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].cover) t[p].len = Y[t[p].r + <span class="number">1</span>] - Y[t[p].l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t[p].l == t[p].r) t[p].len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> t[p].len = t[lc].len + t[rc].len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r)</span><br><span class="line">    {</span><br><span class="line">        t[p].cover += k;</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(lc, l, r, k);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)  <span class="built_in">update</span>(rc, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        line[j ++ ] = { x1, y1, y2, <span class="number">1</span> };</span><br><span class="line">        line[j ++ ] = { x2, y1, y2, <span class="number">-1</span> };</span><br><span class="line">        Y.<span class="built_in">push_back</span>(y1), Y.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(Y.<span class="built_in">begin</span>(), Y.<span class="built_in">end</span>());</span><br><span class="line">    Y.<span class="built_in">erase</span>(<span class="built_in">unique</span>(Y.<span class="built_in">begin</span>(), Y.<span class="built_in">end</span>()), Y.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> <span class="built_in">lower_bound</span>(Y.<span class="built_in">begin</span>(), Y.<span class="built_in">end</span>(), x) - Y.<span class="built_in">begin</span>(); };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(line + <span class="number">1</span>, line + n * <span class="number">2</span> + <span class="number">1</span>, [&amp;](Line a, Line b){ <span class="keyword">return</span> a.x &lt; b.x; });</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, Y.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 在Y轴上建立线段树,点映射为边，最后的点无用</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans = ans + (<span class="keyword">long</span> <span class="keyword">long</span>)t[<span class="number">1</span>].len * (line[i].x - line[i<span class="number">-1</span>].x);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="built_in">find</span>(line[i].y1), <span class="built_in">find</span>(line[i].y2) - <span class="number">1</span>, line[i].k);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;扫描线&quot;&gt;&lt;a href=&quot;#扫描线&quot; class=&quot;headerlink&quot; title=&quot;扫描线&quot;&gt;&lt;/a&gt;扫描线&lt;/h1&gt;&lt;p&gt;扫描线是一种ACM中矩阵面积交以及矩阵周长和问题的解法，通常使用线段树解决。&lt;/p&gt;
&lt;h2 id=&quot;矩阵面积交&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数据结构" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="线段树" scheme="https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 774(Div.2)</title>
    <link href="https://horb7.github.io/2022/03/05/Codeforces-Round-774-Div-2/"/>
    <id>https://horb7.github.io/2022/03/05/Codeforces-Round-774-Div-2/</id>
    <published>2022-03-05T03:42:20.000Z</published>
    <updated>2022-03-23T08:06:10.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Factorials-and-Powers-of-Two"><a href="#C-Factorials-and-Powers-of-Two" class="headerlink" title="C. Factorials and Powers of Two"></a>C. Factorials and Powers of Two</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定数字 $n$ ，它可以由 $k$ 个<strong>不同的</strong>阶乘数和 $2$ 的幂次数组成。求出最小的 $k$ 。</p><p>其中 $1 \le n \le 10^{12}$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于在 $10^{12}$ 内直接只有 $0 \sim 15$ 的阶乘，所以可以二进制枚举需要累加哪些阶乘。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popll(x) (ll)__builtin_popcountll(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">ll fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n, k = <span class="number">2e9</span> + <span class="number">10</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>); s ++ )</span><br><span class="line">    {</span><br><span class="line">        ll now = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) now -= fac[i];</span><br><span class="line">        <span class="keyword">if</span> (now &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        k = <span class="built_in">min</span>(k, <span class="built_in">popll</span>(s) + <span class="built_in">popll</span>(now));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i ++ ) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="D-Weight-the-Tree"><a href="#D-Weight-the-Tree" class="headerlink" title="D.  Weight the Tree"></a>D.  Weight the Tree</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $n$ 个节点的树，为每个节点赋一个正数，使得树上好点最多。如果有多种方案，输出点权和最小的一种方案。</p><p>好点：点权等于邻接点的点权之和的点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>对于 $n = 2$ 的树，明显两个点都可以作为好点，并且每个点点权为 $1$ 。</p><p>对于 $n \gt 2$ 的树，对于任意一条边 $(u, v)$ ，<strong>至多只有一个点为好点</strong>。</p><p>使用树形DP，$dp(i, 0)$ 表示以 $i$ 为根的树，且 $i$ 不作为好点时，最大的好点数量，以及对应的所有好点的边权。同理 $dp(i, 1) $ 表示 $i$ 作为好点。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, val[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp[N][<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dp[u][<span class="number">0</span>] = { <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line">    dp[u][<span class="number">1</span>] = { <span class="number">1</span>, -(<span class="keyword">int</span>)g[u].<span class="built_in">size</span>() };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        dp[u][<span class="number">1</span>].first += dp[v][<span class="number">0</span>].first;</span><br><span class="line">        dp[u][<span class="number">1</span>].second += dp[v][<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">auto</span> M = <span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]); <span class="comment">// 在好点相同的情况下，要选择权值小的</span></span><br><span class="line">        dp[u][<span class="number">0</span>].first += M.first;</span><br><span class="line">        dp[u][<span class="number">0</span>].second += M.second;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_val</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) val[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> val[u] = g[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="built_in">get_val</span>(v, <span class="number">0</span>, u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (dp[v][<span class="number">0</span>] &gt; dp[v][<span class="number">1</span>]) <span class="built_in">get_val</span>(v, <span class="number">0</span>, u);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">get_val</span>(v, <span class="number">1</span>, u);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"2 2\n1 1\n"</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> M = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; M.first &lt;&lt; <span class="string">' '</span> &lt;&lt; -M.second + n - M.first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (M == dp[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">get_val</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">get_val</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; val[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="E-Power-Board"><a href="#E-Power-Board" class="headerlink" title="E. Power Board"></a>E. Power Board</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定 $n \times m$ 的矩阵，其中 $(i, j)$ 位置上的数字为 $i^j$ 。问矩阵中不同的数字的个数。</p><p>其中 $1 \le n, m \le 10^6$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>首先，第一列的元素一定为 $[1, 2, 3, \ldots, n]$ 。</p><p>对于第 $2, 4, 8$ 行，他们是有公共元素的。</p><p>比如第 $2$ 行为 $2, 4, 8, 16, \ldots, 2^m$ 。</p><p>第 $4$ 行为 $4, 16, 64, \ldots, 4^m$ 。</p><p>第 $8$ 行为 $8, 64, 512, \ldots , 8^m$ 。</p><p>我们把他们都按照 $2$ 的幂次方来表示：</p><script type="math/tex; mode=display">\begin{aligned}&2^1, 2^2, 2^3, \ldots, 2^m \\&2^2, 2^4, 2^6, \ldots, 2^{2m} \\&2^3, 2^6, 2^{12}, \ldots, 2^{3m}\end{aligned}</script><p>那么不同的数字仅仅区别于他们的指数，也就是说，我们只需要知道这里有多少个不同的指数即可。</p><p>而上面的指数，在不同的底数情况下都是一样的，他们的答案仅仅区别于行数的多少( $3, 9, 27$ 的指数也是如此)。</p><p>也就是说，我们只需要对于 $n$ 的所有质数行进行分解，然后算出他们在 $n$ 行内有多少倍数(行)。行数最多为 $log_2n$ （即以 $2$ 为底数时所有的倍数行）， 大概在 $20$ 左右，所以只需要预处理最多 $20$ 行不同的指数数量即可。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> del[N], rows[N], cnt[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">bool</span> used[N * <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (ll p = i * i; p &lt;= n; p *= i) del[p] = <span class="literal">true</span>, ++ rows[i];</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!used[i * j]) ++ c, used[i * j] = <span class="literal">true</span>;</span><br><span class="line">        cnt[i] = c;</span><br><span class="line">    }</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!del[i]) ans = ans + cnt[rows[i] + <span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-Factorials-and-Powers-of-Two&quot;&gt;&lt;a href=&quot;#C-Factorials-and-Powers-of-Two&quot; class=&quot;headerlink&quot; title=&quot;C. Factorials and Powers of Two&quot;</summary>
      
    
    
    
    
    <category term="codeforces" scheme="https://horb7.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>小白月赛45F.交换</title>
    <link href="https://horb7.github.io/2022/03/04/%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B45F-%E4%BA%A4%E6%8D%A2/"/>
    <id>https://horb7.github.io/2022/03/04/%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B45F-%E4%BA%A4%E6%8D%A2/</id>
    <published>2022-03-04T14:14:10.000Z</published>
    <updated>2022-03-04T14:54:04.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个操作指令和 $m$ 个查询。</p><p>每个操作指令形如 $x \ \ y$ ，表示交换下标为 $x \ 、 \ y$  的数字。</p><p>对于每个查询，给出一段长度为 $k$ 的序列，你可以选择操作指令中的<strong>一段连续区间</strong>，使得操作完后，这个序列为升序。</p><p>对于每个查询，输出使得序列变为升序所需要的最小连续操作区间的长度，否则输出 $-1$ 。</p><p>其中， $1 \le n \le 2 \times 10^3, 1 \le m \le 10^4, 1 \le x, y, k \le 10$ 。保证每个查询给出的序列为 $[1, k]$ 的排列。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于每个连续的指令区间，一定有且仅有一个排列使得操作完后变为升序。（这里指长度最小的排列，因为任何以它为前缀的排列也一定可以变为升序）。</p><p>假设这个排列为 $P$ ，执行的指令区间为 $[l, r]$ ，那么有：$P -&gt; [l, r] -&gt; [1, 2, \ldots, k]$ 。</p><p>那么，反过来就是：$[1, 2, \ldots , k] -&gt; [r, l] -&gt; P$ 。</p><p>也就是说，对于每个连续指令区间，我们可以预处理出这个 $P$ 。</p><p>所以可以使用 $map \lt vector \lt int \gt , int \gt $ 来存储对于每个 $P$ ，能使它变升序的最小指令区间的长度。</p><p>或者把 $P$ 看作字符串，使用 $map \lt string, int \gt$ 存储。</p><p>这里有一个问题，预处理是 $O(n^3)$ 的。因为需要枚举 $l, r$ ，还要对于 $[l, r]$ 模拟指令来获得 $P$ 。</p><p>一种好的方法是，先正序枚举 $r$ ，再倒序枚举 $l$ ，这样模拟指令就是 $O(1)$ 了，预处理复杂度降为 $O(n^2)$ 。</p><p><del>本来本题到此为止了，但是由于出题人太毒瘤，使用 $map$ 被卡常了，所以还需要换一种策略。</del></p><p>我们可以使用 $Trie$ 树，把所有的查询都存储起来(离线)，记录每个查询所在的节点位置。</p><p>按照上述方法模拟所有区间的指令，预处理出来 $P$ 的最小升序所需区间长度。</p><p>注意如果长度最小的排列被 $[l, r]$ 满足，那么任意以它为前缀的排列也一定满足，所以在 $Trie$ 上要更新到底。</p><p>在查询中可能有本来就是升序的序列，需要特殊处理一下。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">12</span>], ans[N], qid[N], idx; <span class="comment">// ans(i)表示Trie上i节点的答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span> <span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> len, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x = s[i];</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][x]) trie[p][x] = ++ idx;</span><br><span class="line">        p = trie[p][x];</span><br><span class="line">    }</span><br><span class="line">    qid[id] = p; <span class="comment">// 查询次序为id，它所在的Trie树上的位置</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i ++ ) <span class="comment">// 注意更新所有长度</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x = s[i];</span><br><span class="line">        <span class="keyword">if</span> (trie[p][x])</span><br><span class="line">        {</span><br><span class="line">            p = trie[p][x];</span><br><span class="line">            ans[p] = <span class="built_in">min</span>(ans[p], len);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x[N], y[N], q[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(ans, INF, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> k; cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j ++ ) cin &gt;&gt; q[j];</span><br><span class="line">        <span class="built_in">ins</span>(q, k, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; r ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i ++ ) p[i] = i;</span><br><span class="line">        <span class="built_in">update</span>(p, <span class="number">0</span>); <span class="comment">// 特殊处理本来就是升序的查询</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = r; l &gt;= <span class="number">1</span>; l -- )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">swap</span>(p[x[l]], p[y[l]]);</span><br><span class="line">            <span class="built_in">update</span>(p, r - l + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (ans[qid[i]] == INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans[qid[i]] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交换&quot;&gt;&lt;a href=&quot;#交换&quot; class=&quot;headerlink&quot; title=&quot;交换&quot;&gt;&lt;/a&gt;交换&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021浙江省赛题解</title>
    <link href="https://horb7.github.io/2022/03/02/2021%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>https://horb7.github.io/2022/03/02/2021%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</id>
    <published>2022-03-02T05:38:31.000Z</published>
    <updated>2022-03-02T08:50:21.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D-Shortest-Path-Query"><a href="#D-Shortest-Path-Query" class="headerlink" title="D. Shortest Path Query"></a>D. Shortest Path Query</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;ll, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">vector&lt;T&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> n, m, vis[N];</span><br><span class="line">ll f[N][<span class="number">21</span>]; <span class="comment">// f(i, j)表示i点删了j个后面的数字的点走过的最短路</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">// 以root点作为前缀，在它后面加数字，与其他各数字的最短路</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; q;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    q.<span class="built_in">push</span>({<span class="number">0</span>, root});</span><br><span class="line">    <span class="keyword">int</span> j; f[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        T t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ll dist = t.first, u = t.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>; c.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; (u &gt;&gt; j) != root; ++ j);</span><br><span class="line">        f[u][j] = <span class="built_in">min</span>(f[u][j], dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, w]: g[u])</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; v &gt;= root)</span><br><span class="line">                q.<span class="built_in">push</span>({w + dist, v});</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: c) vis[v] = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ll u, v, w, j; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>({v, w});</span><br><span class="line">        g[v].<span class="built_in">push_back</span>({u, w});</span><br><span class="line">        <span class="comment">// v删除j个末尾数字，到达u</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; (v &gt;&gt; j) != u; ++ j);</span><br><span class="line">        f[v][j] = <span class="built_in">min</span>(f[v][j], w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, j = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        ll ans = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 枚举u和v的公共前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">28</span>; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>((v &gt;&gt; i) &lt; (u &gt;&gt; j)) ++ j;</span><br><span class="line">            <span class="keyword">if</span> ((v &gt;&gt; i) == (u &gt;&gt; j)) ans = <span class="built_in">min</span>(ans, <span class="number">1ll</span> * f[u][j] + f[v][i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">60ll</span> * <span class="number">1e9</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-Fair-Distribution"><a href="#F-Fair-Distribution" class="headerlink" title="F. Fair Distribution"></a>F. Fair Distribution</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个数字 $a, b$ ，每次操作可以使 $a - 1$ ，或者 $b + 1$ ，问使 $b \% a == 0$ 的最小操作数量。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假设 $a$ 减小了 $x$ ，那么有 $x \in [0, a-1]$ ，即 $a - x \in [1, a]$ 。</p><p>那么对于 $b$ ，它为了使 $b \% a == 0$ 的最小步数为 $\lceil \dfrac b {a-x} \rceil \times (a - x)$ ，注意 $b$ 只能向上增加，所以要向上取整。</p><p>令 $a - x = i$ ，那么有 $i \in [1, a]$ 。</p><p>总操作数为：</p><script type="math/tex; mode=display">\begin{aligned}&x + \lceil \dfrac b i \rceil \times i - b \\= &a - i + \lceil \dfrac b i \rceil \times i - b \\= &a - i + \lfloor\dfrac {b + i - 1} i \rfloor \times i - b \\= &(a - b) + \lfloor\dfrac {b - 1} i \rfloor \times i\end{aligned}</script><p>可以使用整除分块，枚举 $i$ 的值。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span>(cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a, b, ans = <span class="number">2e9</span>; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b) { cout &lt;&lt; a - b &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= a; l = r + <span class="number">1</span> )</span><br><span class="line">        {</span><br><span class="line">            r = <span class="built_in">min</span>(a, (b - <span class="number">1</span>) / ((b - <span class="number">1</span>) / l));</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (b - <span class="number">1</span>) / l * l + a - b);</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-Wall-Game"><a href="#G-Wall-Game" class="headerlink" title="G. Wall Game"></a>G. Wall Game</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p><img src="\images\problem\Wall_Game.png" alt="image-20220302163515869"></p><p>如图，有 $n$ 个操作，每个操作为：</p><ol><li>在图上添加点（图中单个的的六边形），并和相邻的点联通。</li><li>查询这个点所在的联通块与外界的边的数量。</li></ol><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>使用并查集维护集合内的边的数量。</p><p>由于直接维护边不好维护，可以开两个数组，一个维护集合点的数量，一个维护集合内失效边的数量。</p><p>在合并集合时，遍历点所在的六个相邻点，查询是否已经在同一个联通块，如果在，则失效边增加 $2$ ，否则需要合并两个集合，且失效边加 $2$ 。</p><p>由于点是二维的，可以使用 $map$ 来把点映射为数值。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; Map; <span class="comment">// 把点映射为数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[] = { <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], siz[N], decr[N]; <span class="comment">// decr表示联通块有多少边无效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    Map[{x, y}] = ++ cnt;</span><br><span class="line">    siz[cnt] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++ ) <span class="comment">// 枚举他的6个相邻块</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> dx = x + dr[i], dy = y + dc[i];</span><br><span class="line">        <span class="keyword">if</span> (!Map.<span class="built_in">count</span>({dx, dy})) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> pdx = <span class="built_in">find</span>(Map[{dx, dy}]);</span><br><span class="line">        <span class="keyword">if</span> (pdx != cnt)</span><br><span class="line">        {</span><br><span class="line">            siz[cnt] += siz[pdx];</span><br><span class="line">            decr[cnt] += decr[pdx] + <span class="number">2</span>;</span><br><span class="line">            p[pdx] = cnt;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> decr[cnt] += <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">merge</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> key = <span class="built_in">find</span>(Map[{x, y}]);</span><br><span class="line">            cout &lt;&lt; siz[key] * <span class="number">6</span> - decr[key] &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;D-Shortest-Path-Query&quot;&gt;&lt;a href=&quot;#D-Shortest-Path-Query&quot; class=&quot;headerlink&quot; title=&quot;D. Shortest Path Query&quot;&gt;&lt;/a&gt;D. Shortest Path Query</summary>
      
    
    
    
    
    <category term="区域赛" scheme="https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Namomo Spring Camp 2022每日一题</title>
    <link href="https://horb7.github.io/2022/02/26/Namomo-Spring-Camp-2022%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>https://horb7.github.io/2022/02/26/Namomo-Spring-Camp-2022%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-02-26T11:54:39.000Z</published>
    <updated>2022-03-27T01:44:05.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子串的最大差"><a href="#子串的最大差" class="headerlink" title="子串的最大差"></a>子串的最大差</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义序列的最大差为序列中最大数与最小数的差。比如 $(3,1,4,5,6)$ 的最大差为 $6−1=5 , (2,2)$ 的最大差为 $2−2=0$  。</p><p>定义一个序列的子串为该序列中连续的一段序列。</p><p>给定一个长度为 $n$ 的数组 $a_1,a_2, \ldots ,a_n$，请求出这个序列的所有子串的最大差之和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>所有子串的最大差之和 = 所有子串最大值之和 - 所有子串最小值之和。</p><p>所以可以单独算出最大值之和与最小值之和。</p><p>考虑每个元素作为最大值/最小值的贡献，以最大值为例，假设它前面最近的大于它的元素位置为 $lmax$ ，同理右边为 $rmax$ ，则左边可作为端点的数量为 $i - (lmax-1) + 1$ ，同理右边为 $(rmax-1) - i + 1$ 。那么当前点作为最大值的贡献为 $((rmax-1)-i+1) * (i-(lmax-1)+1) - 1$ 。</p><p>计算每个点的 $lmax$ 和 $rmax$ 可以使用单调栈，具体可参考<a href="https://www.acwing.com/problem/content/832/">这里</a>。</p><p><strong>注意点</strong>：在最大值有多个的区间，如 $[5, 1, 5]$ ，对于所有的 $5$ ，对这个区间一共只能有一个贡献，我们可以让最后面的元素产生贡献，为此，在计算 $lmax$ 时，应该使其取非单调上升序列，而 $rmax$ 取严格下降序列。</p><p>小Trick，在计算完最大值后将所有元素乘上 $-1$ ，这样就又是求最大值，可以复用代码。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], stk[N], top, lmax[N], rmax[N], lmin[N], rmin[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单调栈解决离元素最近且大于它的元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> *left, <span class="keyword">int</span> *right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// left</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; a[stk[top]] &lt; a[i]) -- top;</span><br><span class="line">        left[i] = (top ? stk[top] + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        stk[++ top] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// right</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; a[stk[top]] &lt;= a[i]) -- top;</span><br><span class="line">        right[i] = (top ? stk[top] - <span class="number">1</span>: n);</span><br><span class="line">        stk[++ top] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">calc</span>(lmax, rmax);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) a[i] *= <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">calc</span>(lmin, rmin);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) a[i] *= <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans += <span class="number">1ll</span> * a[i] * (rmax[i] - i + <span class="number">1</span>) * (i - lmax[i] + <span class="number">1</span>);</span><br><span class="line">        ans -= <span class="number">1ll</span> * a[i] * (rmin[i] - i + <span class="number">1</span>) * (i - lmin[i] + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="no-crossing"><a href="#no-crossing" class="headerlink" title="no crossing"></a>no crossing</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个<strong>有向图</strong>，找一条恰好经过 $k$ 个点的最短路径，要求每次选的边<strong>不能越过</strong>之前选择的点，即：对于路径中的边 $x -&gt; y$ ，不存在以前经过的点使得三者关系为：$min(x, y) \le t \le max(x, y)$ 。</p><p>其中 $1 \le n, k \le 100, 0 \le m \le 2000, 1 \le a_i, b_i \le n, 1 \le c_i \le 1000$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>区间DP，记 $f(l, r, dir, step)$ 表示 $[l, r]$ 区间，且方向为 $dir$ ，走过的步数为 $step$ 时最短的路径。</p><p>$dir$ ：$dir$ 为 $0$ 时表示从 $l$ 跳到 $[l+1, r-1]$ 中的某个点，为 $1$ 时表示从 $r$ 跳到 $[l+1, r-1]$ 的某个点。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m, ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N][<span class="number">2</span>][N]; <span class="comment">// dp(l, r, dir, step) 表示[l, r]，方向为dir，步数为step的最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> dir, <span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (step == k - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;ans = dp[l][r][dir][step];</span><br><span class="line">    <span class="keyword">if</span> (~ans) <span class="keyword">return</span> ans; <span class="keyword">else</span> ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 转移</span></span><br><span class="line">    <span class="keyword">int</span> from = dir ? r : l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = l + <span class="number">1</span>; to &lt; r; to ++ )</span><br><span class="line">        <span class="keyword">if</span> (g[from][to])</span><br><span class="line">        {</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(to, r, <span class="number">0</span>, step + <span class="number">1</span>) + g[from][to]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(l, to, <span class="number">1</span>, step + <span class="number">1</span>) + g[from][to]);</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span> (g[u][v]) g[u][v] = <span class="built_in">min</span>(g[u][v], w);</span><br><span class="line">        <span class="keyword">else</span> g[u][v] = w;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(<span class="number">0</span>, i, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">work</span>(i, n+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">2e9</span>) ans = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="Dis"><a href="#Dis" class="headerlink" title="Dis"></a>Dis</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出 $n$ 个点的一棵树，每个点有各自的点权，多次询问两个点简单路径所构成的点集的异或和。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>$Xor(u, v) = Xor(u, root) \bigoplus Xor(v, root) \bigoplus LCA(u, v)$ 。</p><p>$dfs$ 或者 $bfs$ 求出根节点到每个点的路径上点权异或和，同时预处理 $lca$ 的倍增数组即可。</p><p>也可以使用 $Tarjan$ 离线求 $lca$ ，单次处理复杂度降到 $O(1)$ 。</p><p>如果题目要求点权可以修改，则可以使用树链刨分转换为序列，使用线段树或者树状数组维护。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p><strong>倍增LCA求法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>], Xor[N]; <span class="comment">// Xor(i)表示从根节点到i的路径上的异或和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>; Xor[u] = Xor[fa] ^ a[u];</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 以1为树的根</span></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Xor[u] ^ Xor[v] ^ a[<span class="built_in">lca</span>(u, v)]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>离线Tarjan求法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span> <span class="keyword">int</span> id, u, v, _lca; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], Xor[N];</span><br><span class="line"><span class="keyword">int</span> p[N], st[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line">vector&lt;A&gt; ans;</span><br><span class="line">vector&lt;T&gt; query[N]; <span class="comment">// query(i) 表示以i为某一点的所有lca查询</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    st[u] = <span class="number">1</span>; <span class="comment">// 正在搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (!st[v]) { Xor[v] ^= Xor[u]; <span class="built_in">Tarjan</span>(v); p[v] = u; }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, id]: query[u]) <span class="keyword">if</span> (st[v] == <span class="number">2</span>) ans.<span class="built_in">push_back</span>(A{ id, u, v, <span class="built_in">find</span>(v) });</span><br><span class="line">    st[u] = <span class="number">2</span>; <span class="comment">// 完成搜索，回溯</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), Xor[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        query[u].<span class="built_in">push_back</span>({v, i});</span><br><span class="line">        query[v].<span class="built_in">push_back</span>({u, i});</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), [&amp;](A a, A b){ <span class="keyword">return</span> a.id &lt; b.id; });</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[id, u, v, _lca]: ans) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Xor[u] ^ Xor[v] ^ a[_lca]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>树链刨分求法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwick</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] ^= v; }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ans ^= c[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">query</span>(r) ^ <span class="built_in">query</span>(l - <span class="number">1</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line">fenwick F;</span><br><span class="line"><span class="keyword">int</span> son[N], top[N], depth[N], siz[N], father[N], id[N], wt[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    father[u] = fa;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u); siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span> (siz[v] &gt; maxson) son[u] = v, maxson = siz[v];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> topfather)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    top[u] = topfather;</span><br><span class="line">    id[u] = ++ cnt;</span><br><span class="line">    wt[cnt] = a[u]; F.<span class="built_in">add</span>(cnt, wt[cnt]);</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topfather);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (v != son[u] &amp;&amp; v != father[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (depth[top[u]] &lt; depth[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        ans ^= F.<span class="built_in">query</span>(id[top[u]], id[u]);</span><br><span class="line">        u = father[top[u]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (depth[u] &gt; depth[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    ans ^= F.<span class="built_in">query</span>(id[u], id[v]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 第一次dfs求出depth, siz, father, son</span></span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 第二次dfs链接重链, 求出top, id, wt</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">query</span>(u, v));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="选数"><a href="#选数" class="headerlink" title="选数"></a>选数</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定 $N$ 个正整数 $a_1, a_2, \ldots , a_n$ 。要求从其中选出若干个数字，使得这些数字的和 $sum \equiv 0 \pmod N$ ，对于每个下标只能选择一次。若存在则输出选择的数字个数及其下标，否则输出 $-1$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>对于 $n$ 个数字，作前缀和，一共有 $n + 1$  个模数(注意还有全不选的情况)，根据鸽巢原理一定有两个模数相等，假设其在前缀和中的下标为 $i, j$ ，则对于 $[i+1, j]$ 区间的数字，它们的和一定 $sum \equiv 0 \pmod N$ 。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], pre[i] = (pre[i<span class="number">-1</span>] + a[i]) % n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; exist{{<span class="number">0</span>, <span class="number">0</span>}}; <span class="comment">// 记录模数是否出现过，以及出现的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (exist.<span class="built_in">count</span>(pre[i]))</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; i - exist[pre[i]] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = exist[pre[i]] + <span class="number">1</span>; j &lt;= i; j ++ ) cout &lt;&lt; j &lt;&lt; <span class="string">" \n"</span>[j == i];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        exist[pre[i]] = i;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的序列 $a_1, a_2 , \ldots , a_n$ 。</p><p>你需要进行两种操作：</p><ol><li>$1 \ \ x \ \ y$ ，表示将第 $x$ 个数字变为 $y$</li><li>$2 \ \ y$ ，表示将所有小于 $y$ 的数字修改为 $y$ </li></ol><p>一共进行 $q$ 次操作，输出执行完所有操作后的序列。</p><p>其中 $1 \le n , q \le 10^6, 0 \le a \le 10^9, 1 \le x \le n, 0 \le y \le 10^9$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p><strong>离线+ST表</strong></p><p>操作 $1$ 的优先级大于 $2$ ，对于每个数字，当执行操作 $1$ 时，前面所有对这个数字的操作 $2$ 都无效。</p><p>所以对于每个数字，我们只需要知道，所有在它最后一次操作 $1$ 之后的操作 $2$ ，对它的影响即可。</p><p>可以把操作 $2$ 存储起来，然后记录每个数字最后一次操作 $1$ 的位置，二分找到对应的操作 $2$ ，然后查询之后所有操作 $2$ 的最大值，与当前数字取最大值即可。</p><p><strong>(</strong>看了一眼题解emmm….. 我是SB，每次查询区间最大值都是以最后一个操作 $2$ 为右端点，所以只需要做一个后缀最大值计算即可</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> {</span> <span class="keyword">int</span> id, x; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SparseTable</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> n, st[N][<span class="number">21</span>], Lg[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, Q *a)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) Lg[i] = Lg[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) st[i][<span class="number">0</span>] = a[i].x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">                st[i][j] = <span class="built_in">max</span>(st[i][j<span class="number">-1</span>], st[i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> k = Lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], ans[N], last[N]; <span class="comment">// last统计每个下标最后更改的位置</span></span><br><span class="line">Q q[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line">SparseTable ST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y), last[x] = i, a[x] = y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>) q[++ cnt] = { i, x };</span><br><span class="line">    }</span><br><span class="line">    ST.<span class="built_in">init</span>(cnt, q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!last[i]) a[i] = <span class="built_in">max</span>(a[i], ST.<span class="built_in">query</span>(<span class="number">1</span>, cnt));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">lower_bound</span>(q + <span class="number">1</span>, q + cnt + <span class="number">1</span>, last[i], [](Q a, <span class="keyword">int</span> val){ <span class="keyword">return</span> a.id &lt; val; }) - q;</span><br><span class="line">            <span class="keyword">if</span> (pos != cnt + <span class="number">1</span>) a[i] = <span class="built_in">max</span>(a[i], ST.<span class="built_in">query</span>(pos, cnt));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="数数"><a href="#数数" class="headerlink" title="数数"></a>数数</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>在给定 $N$ 长的数组 $\{A\}$ 中进行 $Q$ 次查询 $[L_i, R_i]$ 区间中不大于 $H_i$ 的元素个数。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>离线处理，把所有元素和查询按照权值排序，对于查询 $i$ ，只需要统计之前的数字在 $[L_i, R_i]$ 区间出现多少次即可，可以使用树状数组维护前缀和。</p><p>数据有锅， $L_i$ 可以为 $0$ ，还需要特判一下。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> {</span> <span class="keyword">int</span> id, l, r, h; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwick</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>{ <span class="built_in">fill</span>(c, c + n + <span class="number">1</span>, <span class="number">0</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v; }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ans += c[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[N];</span><br><span class="line">T a[N];</span><br><span class="line">Q query[N];</span><br><span class="line">fenwick F;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    F.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i].first, a[i].second = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; query[i].l &gt;&gt; query[i].r &gt;&gt; query[i].h;</span><br><span class="line">        <span class="keyword">if</span> (!query[i].l) ++ query[i].l;</span><br><span class="line">        query[i].id = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(query + <span class="number">1</span>, query + m + <span class="number">1</span>, [&amp;](Q a, Q b){ <span class="keyword">return</span> a.h &lt; b.h; });</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= n &amp;&amp; a[j].first &lt;= query[i].h) F.<span class="built_in">add</span>(a[j].second, <span class="number">1</span>), ++ j;</span><br><span class="line">        ans[query[i].id] = F.<span class="built_in">query</span>(query[i].l, query[i].r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == m];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="Minimum-Or-Spanning-Tree"><a href="#Minimum-Or-Spanning-Tree" class="headerlink" title="Minimum Or Spanning Tree"></a>Minimum Or Spanning Tree</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个点和 $m$ 条边的无向图，每条边连接 $u,v$ 两个端点，边权为 $w$ ，问图的生成树的最小代价。</p><p>这里，我们定义一棵生成树的代价为它所有边的边权<strong>按位或</strong>得到的值。</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>贪心，由于位运算的每个位都是独立运算的，所以我们一定要让高位尽量小。</p><p>从高到低枚举每个位，如果在当前位为 $0$ 的边可以生成树，那么这一位就可以不用作贡献，否则这一位一定会产生贡献。</p><p><strong>注意</strong>，如果某一位不作贡献，那么我们要把其他作贡献的 $ban$ 掉，在接下来考虑低位时，不能使用不作贡献但在低位为 $0$ 的边。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> {</span> <span class="keyword">int</span> u, v, w; <span class="keyword">bool</span> ban; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line">T e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[i] = { -- u, -- v, w, <span class="number">0</span> };</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!e[j].ban &amp;&amp; !(e[j].w &gt;&gt; i &amp; <span class="number">1</span>)) vis[e[j].u] = vis[e[j].v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis != vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">true</span>)) ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) <span class="keyword">if</span> (e[j].w &gt;&gt; i &amp; <span class="number">1</span>) e[j].ban = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="函数求和"><a href="#函数求和" class="headerlink" title="函数求和"></a>函数求和</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个整数 $a_1, a_2, \ldots, a_n$ 和正整数 $k$ 满足 $(0 \le a_i \le 2^k - 1)$ 。</p><p>定义函数 $f(x)$ 为满足 $a_i \&amp; x != a_i$ 的最小的 $i$ ，当满足条件的 $i$ 不存在时 $f(x) = 0$ 。</p><p>求 $\sum_{i=0}^{2^k-1} f(x)$ 。由于答案可能很大，输出答案取模 $998244353$ 后的值。</p><p>其中 $1 \le n \le 100, 1 \le k \le 60$ 。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>考虑每个数字对答案的贡献。</p><p>对于第一个数字，假设它二进制为 $00101$  ，那么，只要它上面的 $1$ ，在 $x$ 的二进制同样的位上为 $0$ ，就会将 $a_1$ 上的 $0$ 变为 $1$ ，则 $a_1 \&amp; x != a_1$ 。所以贡献为 $(2^{cnt} - 1) \times 2^{leave} \times i$ ，其中 $cnt$ 为二进制下为 $1$ 的数量，$leave$ 表示 $0$ 的数量。</p><p>对于第二个数字，想要让它产生贡献，就必须满足 $a_1 \&amp; x == a_1$ ，即 $a_1$ 二进制上的 $1$ ，在 $x$ 中也同样出现。</p><p>比如 $a_2 = 10101$ ，那么只有第一个位会让 $a_2$ 产生贡献，即 $(2^{new\_cnt} - 1) * 2^{k - new\_cnt - cnt}\times i $ 。其中 $cnt$ 指前面的数字出现的 $1$ 的位数。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    bitset&lt;60&gt; bit;</span><br><span class="line">    <span class="keyword">int</span> n, k, ans = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> &amp;v: a) cin &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;&gt; j &amp; <span class="number">1</span> &amp;&amp; !bit[j]) ++ cnt;</span><br><span class="line">        ans = (ans + (((<span class="number">1ll</span> &lt;&lt; cnt) - <span class="number">1</span>) % P) * ((<span class="number">1ll</span> &lt;&lt; k - bit.<span class="built_in">count</span>() - cnt) % P) * (i + <span class="number">1</span>) % P) % P;</span><br><span class="line">        bit |= a[i];</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Closest-Equals"><a href="#Closest-Equals" class="headerlink" title="Closest Equals"></a>Closest Equals</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>给定一个下标从 $1 \sim n$ 的序列 $a$ ，然后进行 $m$ 次询问。</p><p>每次询问给出一对 $[l, r]$ ，找到区间中数值相等的且距离最近的两个数字 $a_i, a_j$ ，求出他们的距离。</p><p>换言之找到一组数 $(a_i, a_j)$ 满足：</p><ul><li>$a_i = a_j$ </li><li>$l \le i, j \le r \ \  (i != j)$</li></ul><p>求出 $|i - j|$ 的最小值，如果区间不存在两个相等的数字，则输出 $-1$ 。</p><p>其中 $1 \le n, m \le 5 \times 10^5, 1 \le a_i \le 10^9$ 。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>距离最近的两个相同数字，在所有与他们相同的数字中一定是相邻的。</p><p>对于在位置 $i$ 上的数字 $a_i$ ，与它相等的前一个数字为 $pre_i$ ，那么如果询问区间包括这两个位置，则产生 $i - pre_i$ 的贡献，换言之，对于区间 $[l, r]$ ，我们只需要找出所有这样的贡献的最小值即可。</p><p>考虑使用线段树， $i$ 位置的贡献(权值)为 $i - pre_i$ ，那么对于区间 $[1, r]$， <strong>只需要找出区间最小值。</strong></p><p>考虑区间的左端点 $l$ ，位置 $[1, l]$ 上的数字<strong>不会和他们后面的数字产生贡献</strong>，令<strong>他们后面的数字</strong>贡献为 $+ \infty$ 。</p><p>也就是说，我们的线段树需要支持单点修改和区间查询。</p><p>进行 $m$ 次 $[1, l]$ 的单点修改会 $Tle$ ，可以把查询离线下来，这样每次只需要改 $[last_l, now_l-1]$ 的元素即可，每个点只会被修改一次。</p><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (t[p].l + t[p].r &gt;&gt; 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span> <span class="keyword">int</span> l, r, Min; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> {</span> <span class="keyword">int</span> l, r, id; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d[N], ans[N]; <span class="comment">// d(i)表示i位置元素与前面相同元素位置的差值</span></span><br><span class="line"><span class="keyword">int</span> post[N]; <span class="comment">// 和下标为i的数字相等的后面的数字的位置</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; idx;</span><br><span class="line">Q q[N];</span><br><span class="line">Node t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>{ t[p].Min = <span class="built_in">min</span>(t[lc].Min, t[rc].Min); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l != r) <span class="built_in">build</span>(lc, l, mid), <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) { t[p].Min = v; <span class="keyword">return</span> ; }</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(lc, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].Min;</span><br><span class="line">    <span class="keyword">int</span> Min = INF;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) Min = <span class="built_in">min</span>(Min, <span class="built_in">query</span>(lc, l, r));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)  Min = <span class="built_in">min</span>(Min, <span class="built_in">query</span>(rc, l, r));</span><br><span class="line">    <span class="keyword">return</span> Min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">count</span>(x)) d[i] = i - idx[x], post[idx[x]] = i;</span><br><span class="line">        idx[x] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">update</span>(<span class="number">1</span>, i, d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        q[i] = { l, r, i };</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, [&amp;](Q a, Q b){ <span class="keyword">return</span> a.l &lt; b.l; });</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">max</span>(<span class="number">1</span>, q[i<span class="number">-1</span>].l); k &lt;= q[i].l - <span class="number">1</span>; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (post[k]) <span class="built_in">update</span>(<span class="number">1</span>, post[k], INF);</span><br><span class="line">        ans[q[i].id] = <span class="built_in">query</span>(<span class="number">1</span>, q[i].l, q[i].r);</span><br><span class="line">        <span class="keyword">if</span> (ans[q[i].id] == INF) ans[q[i].id] = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="CCPC-Harbin-2021-G-Damaged-Bicycle"><a href="#CCPC-Harbin-2021-G-Damaged-Bicycle" class="headerlink" title="CCPC Harbin 2021 G. Damaged Bicycle"></a>CCPC Harbin 2021 G. Damaged Bicycle</h1><h2 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h2><p>校园可以被看做 $n$ 个点，$m$ 条边的无向图，其中第 $i$ 条边长度为 $w_i$ ，你的宿舍在 $1$ 号点，你想从宿舍去教学楼($n$ 号点)。你的走路速度为每秒 $t$ ，骑车速度为每秒 $s$ 。校园内一共有 $k$ 个停车点，第 $i$ 个停车点在 $a_i$ 点，但是有 $\dfrac {p_i} {100}$  的概率，车可能是坏的。但是你只有到达 $a_i$ 点，才知道第 $i$ 辆车是不是好的。如果车是好的，可以直接骑到终点。</p><p>问你最优策略下，你最小的到达终点的期望时间是多少。如果到达不了 $n$ 号点，输出 $-1$ 。</p><p>其中 $1 \le t \le r \le 10^4, 1 \le n, m \le 10^5, 1 \le w_i \le 10^4, 0 \le k \le 18$ 。</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>注意 $k$ 的范围很小，最多只有 $18$ ，可以考虑对于每一个停车点，他到达其他点的最短路。</p><p>加入从 $1$ 点到达某个停车点，可以有以下策略：</p><ol><li>车没有坏，可以直接骑到终点。</li><li>车坏了，要么直接走到终点，要么去另外一个停车点。</li></ol><p>定义 $dp(id, st)$ 表示在 $id$ 这个停车点，且目前一共走了 $st$ 的停车场($st$ 为每个停车点的状态，即二进制表示)。</p><p>对于车坏了且直接走到终点，有期望时间：</p><p>$res = p[id] \times d[id][n] \div t + (1-p[id]) \times d[id][n] \div r$ 。</p><p>其中前面表示车坏了的情况，后面表示车没坏的情况。</p><p>对于车坏了，走到另外的停车点，有期望时间：</p><p>$res = p[id] \times (d[id][a[i]] + dfs(i, status | (1 &lt;&lt; i-1))) \div t + (1-p[id]) \times d[id][n] \div r$ 。 </p><p>其中 $dfs$ 用来记忆化计算 $dp(id, status)$ 。</p><p>Trick：可以把第 $1$ 个点设为第 $19$ 个停车点，且车坏掉的概率为 $1$ 。这样答案就是 $dp(19, 0)$ 。</p><h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">20</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, r, t, k;</span><br><span class="line">vector&lt;T&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> a[M]; <span class="comment">// 每个停车点所在的位置</span></span><br><span class="line"><span class="keyword">double</span> p[M]; <span class="comment">// 每个停车点的坏车概率</span></span><br><span class="line"><span class="keyword">int</span> d[M][N]; <span class="comment">// 从每个停车点到达其他点的最短路</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">double</span> dp[M][<span class="number">1</span> &lt;&lt; M]; <span class="comment">// dp(id, status)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(d[id], INF, <span class="keyword">sizeof</span> d[id]);</span><br><span class="line">    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>({<span class="number">0</span>, st}); d[id][st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        T ver = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> u = ver.second, dist = ver.first;</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, w]: g[u])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (d[id][v] &gt; dist + w)</span><br><span class="line">            {</span><br><span class="line">                d[id][v] = dist + w;</span><br><span class="line">                q.<span class="built_in">push</span>({d[id][v], v});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从id停车场出发，且当前经过status状态的停车场</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (dp[id][status]) <span class="keyword">return</span> dp[id][status];</span><br><span class="line">    <span class="comment">// 有没有坏都直接走到终点</span></span><br><span class="line">    <span class="keyword">double</span> res = p[id] * (<span class="keyword">double</span>)d[id][n] / t + (<span class="number">1</span> - p[id]) * (<span class="keyword">double</span>)d[id][n] / r;</span><br><span class="line">    <span class="comment">// 如果没坏，直接走到终点，否则走到另一个停车场</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (status &gt;&gt; i<span class="number">-1</span> &amp; <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// i号已经走过</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, (<span class="number">1</span>-p[id]) * (<span class="keyword">double</span>)d[id][n] / r + \</span><br><span class="line">                p[id] * ((<span class="keyword">double</span>)d[id][a[i]] / t + <span class="built_in">dfs</span>(i, status | (<span class="number">1</span> &lt;&lt; i<span class="number">-1</span>))));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[id][status] = res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;t, &amp;r, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>({v, w});</span><br><span class="line">        g[v].<span class="built_in">push_back</span>({u, w});</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;a[i], &amp;p[i]);</span><br><span class="line">        p[i] /= <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从每个停车点计算dij</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ ) <span class="built_in">dijkstra</span>(i, a[i]);</span><br><span class="line">    <span class="built_in">dijkstra</span>(<span class="number">19</span>, <span class="number">1</span>); <span class="comment">// 假设1点位一定坏的停车场</span></span><br><span class="line">    <span class="keyword">if</span> (d[<span class="number">19</span>][n] == INF) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>), <span class="number">0</span>;</span><br><span class="line">    p[<span class="number">19</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, <span class="built_in">dfs</span>(<span class="number">19</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="拆方块"><a href="#拆方块" class="headerlink" title="拆方块"></a>拆方块</h1><h2 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 堆方块，第 $i$ 堆方块由 $h_i$ 个方块堆积而成。</p><p>每次操作，需要把所有上下左右不全为方块或地面（即与空气接触）的方块拆除，问经过多少次操作可以把所有方块拆除。</p><p>其中 $1 \le n \le 10^5, 1 \le h_i \le 10^9$ 。</p><p>样例：</p><p><img src="\images\problem\08D2B51B62DE30780000000000000008.png" alt="img"></p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>大概是找规律？对于每个初始的状态，都等价于 $123 \ldots (k-1)(k)(k-1) \ldots 321$ 。这样的状态，即最左边堆和最右边堆为 $1$ 高度，越往中间高度越高：</p><p><img src="\images\problem\image-20220311171241703.png" alt="image-20220311171241703"></p><p>然后需要拆除的次数就是中间那个最高的堆的高度了。</p><h2 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) a[i] = <span class="built_in">min</span>(a[i<span class="number">-1</span>] + <span class="number">1</span>, a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -- ) a[i] = <span class="built_in">min</span>(a[i + <span class="number">1</span>] + <span class="number">1</span>, a[i]);</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="工作安排"><a href="#工作安排" class="headerlink" title="工作安排"></a>工作安排</h1><h2 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h2><p>约翰有太多的工作要做。</p><p>为了让农场高效运转，他必须靠他的工作赚钱，<strong>每项工作花一个单位时间。</strong></p><p>他的工作日从 $0$ 时刻开始，有 $10^9$ 个单位时间。</p><p>在任一时刻，他都可以选择编号 $1$ 到 $N$ 的 $N$ 项工作中的任意一项工作来完成。</p><p>每项工作又有一个截止时间，对于第 $i$ 个工作，有一个截止时间 $D_i$ ，如果他可以完成这个工作，那么他可以获利 $P_i$ 。</p><p>在给定的工作利润和截止时间下，约翰能够获得的利润最大为多少。</p><p>其中 $1 \le N \le 10^5, 1 \le D_i, P_i \le 10^9$ 。 </p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>原题： <a href="https://www.acwing.com/problem/content/description/147/">超市</a>  。</p><ol><li><p>使用二叉堆贪心，在二叉堆中插入选择的工作的利润，遍历所有的工作：</p><ul><li>当前的截止时间小于堆中选择的工作数量，直接选择这个工作。</li><li>当前截止时间等于堆中选择的工作数量，那么判断堆顶元素是否小于当前工作利润，如果小于，替换为当前工作。</li></ul></li><li><p>使用并查集贪心，优先做利润高的工作，同时尽量在晚的时间来做工作，这样可以对其他工作有“决策包容性”，即：对于截止时间比他大的，不会受到影响；对于截止时间比他小的，它的选择不会变差。</p><p>那么可以把所有工作按照利润从大到小排序，建立一个关于“天数”的并查集，起初每一天都是独立集合。对于每一个工作，假设它在第 $d$ 天过期，那么查询 $d$ 的树根（记为 $r$），如果 $r &gt; 0$ ，那么这项工作在 $r$ 天做，并合并 $r$ 和 $r-1$ 的天数。</p><p>这个并查集本质维护：对于每一天，在他前面第一个空闲时间的位置。</p></li></ol><p>注意这题数据有问题，$D_i$ 可能为 $0$ ，这个工作在开始的时候就截至了，需要特判。</p><h2 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h2><p><strong>二叉堆贪心</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> {</span> <span class="keyword">int</span> d, p; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, pre;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">T a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].d, &amp;a[i].p);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](T a, T b){ <span class="keyword">return</span> a.d &lt; b.d; });</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!a[i].d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i].d &gt; q.<span class="built_in">size</span>()) q.<span class="built_in">push</span>(a[i].p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q.<span class="built_in">top</span>() &lt; a[i].p) { q.<span class="built_in">pop</span>(); q.<span class="built_in">push</span>(a[i].p); }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) { ans = ans + q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>并查集贪心</strong></p><hr><h1 id="三角果计数"><a href="#三角果计数" class="headerlink" title="三角果计数"></a>三角果计数</h1><h2 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个节点的树，三角果定义为一个包含 $3$ 个节点的集合，且他们两两之间的最短路长度 $a, b, c$ 能够构成一个三角形。</p><p>计算这棵树上有多少个不同的三角果。</p><p>其中 $1 \le n \le 10^5$ ，边权 $1 \le w \le10^5, 1 \le u, v \le n$ 。</p><h2 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h2><p>能否组成三角形与边权无关，只要三个点在一条链上就一定不能组成三角果，不在一个链上就一定可以。</p><p>所以对每个节点，取它两棵子树上的一个节点，剩下一个节点取另外一棵子树，或者在另外的其他点取。</p><h2 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll c1 = <span class="number">0</span>, c2 = <span class="number">0</span>; <span class="comment">// c1表示取一个节点，c2表示取两个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        ll cc = <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        ans += c2 * cc;</span><br><span class="line">        c2 += c1 * cc;</span><br><span class="line">        c1 += cc;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c1 + <span class="number">1</span> &lt; n) ans += c2 * (n - c1 - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c1 + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="整齐的数组2"><a href="#整齐的数组2" class="headerlink" title="整齐的数组2"></a>整齐的数组2</h1><h2 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h2><p>Polycarp 有一个长度为 $n$ 的数组 $a_1, a_2, \ldots, a_n$ ( $n$ 是偶数)。Polycarp 还得到了一个正整数 $k$ ，他对数组 $a$ 做如下操作：选择一个下标 $a_i$ ( $1 \le i \le n$ ) 使 $a_i$ 减去 $k$ 。</p><p>在 Polycarp 进行若干次操作后(可能 $0$ 次)，数组 $a$ 中的数字 <strong>至少有一半</strong> 都变成相同的了。请你找到最大的符合条件要求的 $k$ ，若 $k$ 可以为任意大，请输出 $-1$ 。</p><p>其中 $4 \le n \le 40, -10^6 \le a_i \le 10^6$ 。</p><h2 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h2><p>枚举任意两个数 $a_i, a_j$ ，假设他们是最后相同的两个数字，那么 $k$ 一定是 $a_j - a_i$ 的因子，只有这样 $a_j$ 才可以通过若干次 $-k$ 得到 $a_i$ 。</p><p>枚举这个因子，再检查是否通过这个因子可以得到一半的数字，通过减去若干次 $k$ 得到 $a_i$ 即可。</p><h2 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> ((a[i] - a[p]) % d == <span class="number">0</span>) ++ num;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= n / <span class="number">2</span>) k = <span class="built_in">max</span>(k, d);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; n; k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 一开始就有一半数字相同</span></span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            ++ cnt[a[i]];</span><br><span class="line">            <span class="keyword">if</span> (cnt[a[i]] &gt;= n / <span class="number">2</span>) ok = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ok) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则枚举两个数字，枚举因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 把这个数字作为要变成相同数字的最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> dif = a[j] - a[i];</span><br><span class="line">                <span class="comment">// 枚举dif的因子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dif / d; d ++ )</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (dif % d == <span class="number">0</span>)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="built_in">calc</span>(i, d);</span><br><span class="line">                        <span class="keyword">if</span> (d != dif / d) <span class="built_in">calc</span>(i, dif / d);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="三进制循环"><a href="#三进制循环" class="headerlink" title="三进制循环"></a>三进制循环</h1><h2 id="题意-14"><a href="#题意-14" class="headerlink" title="题意"></a>题意</h2><p>在神奇的树の国度，<a href="https://space.bilibili.com/1950658">叽叽</a>发现了一棵包含 $n$ 个节点的三进制树，节点的编号是 $1 \sim n$ 。这棵树的任意一个节点的值可能为 $0, 1, 2$ 其中的一个。她喜欢有规律而不是杂乱无章的序列，她想在这棵树上找到一个路径，要满足从路径的一端到达另一端，从第二个节点开始，每个节点的值都等于上一个节点的值 $+1$ 之后对 $3$ 取模。</p><p>换言之，把路径转化为长度为 $len$ 的序列 $G$ ，对于序列的地 $2 \le i \le len$ 项，要满足 $G_i = (G_{i-1} + 1) \ \ mod \ \ 3$  。例如 $2, 0, 1, 2, 0$ 。</p><p>现在，给出这颗三进制树，你能帮她找到长度最长的满足条件的路径吗，输出最长的路径长度。</p><h2 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h2><p>假设某一个节点作为链上的节点，那么它需要在一端接上一条上升链，另一端接上一条下降链，枚举子树即可。</p><h2 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], dp[N][<span class="number">3</span>][<span class="number">2</span>], ans; <span class="comment">// 0表示上升链，1表示下降链</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dp[u][a[u]][<span class="number">0</span>] = dp[u][a[u]][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>, down = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="keyword">if</span> (up &lt; dp[v][(a[u] + <span class="number">2</span>) % <span class="number">3</span>][<span class="number">0</span>]) up =  dp[v][(a[u] + <span class="number">2</span>) % <span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (down &lt; dp[v][(a[u] + <span class="number">1</span>) % <span class="number">3</span>][<span class="number">1</span>]) down = dp[v][(a[u] + <span class="number">1</span>) % <span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    dp[u][a[u]][<span class="number">0</span>] += up;</span><br><span class="line">    dp[u][a[u]][<span class="number">1</span>] += down;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[u][a[u]][<span class="number">0</span>] + dp[u][a[u]][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="树上逆序对"><a href="#树上逆序对" class="headerlink" title="树上逆序对"></a>树上逆序对</h1><h2 id="题意-15"><a href="#题意-15" class="headerlink" title="题意"></a>题意</h2><p>对于一棵有根树，定义树上的逆序对为满足 $a_i &lt; a_{fa_i}$ 的二元对 $(i, fa_i)$ ，其中 $fa_i$ 表示节点 $i$ 的父节点。</p><p>对于一棵 $k$ 叉树，节点 $i$ 的子节点编号集合为 $[1, n] \ \bigcap \ [k(i-1)+2, ki+1]$  中的所有整数。</p><p>给定 $n$ 个节点的权值 $a_1, a_2, a_3, \ldots , a_n$ ，对于 $k = 1, 2, \ldots , n-1$ 求出当这 $n$ 个节点构成一棵 $k$ 叉树时树上逆序对数。</p><p>其中 $2 \le n \le 2 \times 10^5, 1 \le a_i \le 10^9$ 。</p><h2 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h2><p>对于一棵 $k$ 叉树，它的非叶子节点个数为至多 $\lceil \dfrac n k \rceil$ 个。因为 $k$ 叉树除最后一层是一个满二叉树。</p><p>那么所有可能的 $k$ 叉树，非叶子节点个数总和为 $\lceil \dfrac n 1 \rceil + \lceil \dfrac n 2 \rceil + \lceil \dfrac n 3 \rceil + \ldots + \lceil \dfrac n {n-1} \rceil = nlogn$ 个。</p><p>对于每个非叶子节点，记 $[l, r]$ 为它的儿子区间，这棵树的叉数为 $r-l+1$， 求出小于等于父节点权值的数字即为其 $k$ 叉树的贡献， 那么问题就变成了：</p><p>给定若干个区间，对于每个区间，问满足小于某个数字的数量有多少个。</p><p>对所有这样的区间做离线处理，记录 $[l, r, v]$ ，其中 $v$ 为区间的父节点权值。</p><p>对所有区间按照 $v$ 值排序，然后对所有点的权值排序，对于每个区间，将小于 $v$ 的所有点权值插入树状数组，然后查询该区间有多少点做出贡献即可。</p><h2 id="Code-14"><a href="#Code-14" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> {</span> ll l, r, v; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> {</span> <span class="keyword">int</span> v, id; };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwick</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) res += c[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l<span class="number">-1</span>); }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n, ans[N];</span><br><span class="line">Msg a[N];</span><br><span class="line">vector&lt;T&gt; query;</span><br><span class="line">fenwick F;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].v), a[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n - <span class="number">1</span>; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++ )</span><br><span class="line">        {</span><br><span class="line">            ll l = (ll)k * (u - <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            ll r = (ll)k * u + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) query.<span class="built_in">push_back</span>({l, r, a[u].v});</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(query.<span class="built_in">begin</span>(), query.<span class="built_in">end</span>(), [&amp;](T a, T b){ <span class="keyword">return</span> a.v &lt; b.v; });</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](Msg a, Msg b){ <span class="keyword">return</span> a.v &lt; b.v; });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> Q: query)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> (now &lt;= n &amp;&amp; a[now].v &lt; Q.v) F.<span class="built_in">add</span>(a[now ++ ].id, <span class="number">1</span>);</span><br><span class="line">        ans[Q.r-Q.l+<span class="number">1</span>] += F.<span class="built_in">query</span>(Q.l, Q.r);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="约分"><a href="#约分" class="headerlink" title="约分"></a>约分</h1><h2 id="题意-16"><a href="#题意-16" class="headerlink" title="题意"></a>题意</h2><p>给定一个分数 $\dfrac p q$ 。每次操作可以删除 $p$ 和 $q$ 共有的一个数位，问在这样的约分操作下 $\dfrac p q$ 的最简分数为多少。</p><p>最简分数：与 $\dfrac p q$ 等价的分数中，分子最小的那一个。</p><p>其中 $1 \le p, q \le 2^{63} - 1$ 。</p><h2 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h2><p>数字最多有 $18$ 个数位，二进制枚举 $p$ 应该删除哪些数字，得到分子 $a$，得出等价的 $b$ ，再判断是否能通过操作得到 $b$ 。</p><p>在判断的时候需要知道 $p$ 删除了哪些数位，然后删除的前导 $0$ 一定在 $b$ 的前面，判断这样的 $b$ 是否加上了删除的数位等于 $q$ ，以及 $b$ 是否为 $q$ 的子序列即可。</p><p>具体的可以看代码。</p><h2 id="Code-15"><a href="#Code-15" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll =<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">ll oa, ob;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N], ca, cb, cnta[<span class="number">10</span>], cntb[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">change</span> <span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ca; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!(st &gt;&gt; i &amp; <span class="number">1</span>)) res = res * <span class="number">10</span> + A[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span> <span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll a = <span class="built_in">change</span>(st), b = <span class="number">1.0</span> * ob / oa * a + <span class="number">0.001</span>, oob = b;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// 检查b是否合法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> del[<span class="number">10</span>], CB[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(del, cnta, <span class="keyword">sizeof</span> cnta);</span><br><span class="line">    <span class="built_in">memset</span>(CB, <span class="number">0</span>, <span class="keyword">sizeof</span> CB);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ca; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!(st &gt;&gt; i &amp; <span class="number">1</span>)) -- del[A[i]];</span><br><span class="line">    <span class="comment">// del保留每个数字需要被删除的情况</span></span><br><span class="line">    <span class="keyword">while</span>(b) ++ CB[b % <span class="number">10</span>], b /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ ) <span class="keyword">if</span> (del[i] + CB[i] != cntb[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (CB[<span class="number">0</span>] &gt; cntb[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 加入有自动消退的0，那么一定是在b前面</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f[<span class="number">20</span>]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">int</span> cc = <span class="number">0</span>, cn = cntb[<span class="number">0</span>] - del[<span class="number">0</span>] - CB[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(oob) f[cc ++ ] = oob % <span class="number">10</span>, oob /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cn; i ++ ) f[cc ++ ] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(f, f + cc);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cb; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (f[now] == B[i]) ++ now;</span><br><span class="line">        <span class="keyword">if</span> (now == cc) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\input.txt)"</span>, <span class="string">"r"</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">R"(C:\Users\18340\CLionProjects\horb7\output.txt)"</span>, <span class="string">"w"</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll a, b; cin &gt;&gt; a &gt;&gt; b; oa = a, ob = b;</span><br><span class="line">    <span class="keyword">while</span>(a) A[ca ++ ] = a % <span class="number">10</span>, ++ cnta[a % <span class="number">10</span>], a /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) B[cb ++ ] = b % <span class="number">10</span>, ++ cntb[b % <span class="number">10</span>], b /= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(A, A + ca);</span><br><span class="line">    <span class="built_in">reverse</span>(B, B + cb);</span><br><span class="line"></span><br><span class="line">    ll ans = oa, res = ob;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制枚举删除的数字,0表示保留</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; ca) - <span class="number">1</span>; st ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>(st))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; <span class="built_in">change</span>(st) &amp;&amp; <span class="built_in">change</span>(st))</span><br><span class="line">            {</span><br><span class="line">                ans = <span class="built_in">change</span>(st);</span><br><span class="line">                res = <span class="number">1.0</span> * ob / oa * ans + <span class="number">0.001</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">' '</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="题意-17"><a href="#题意-17" class="headerlink" title="题意"></a>题意</h2><p>你有一个环，环上有 $n$ 个正整数。你能将环切成 $k$ 段，每段包含一个或者多个数字。</p><p>对于一个切分方案，优美程度为每段数字和的最大公约数，你想使切分方案的优美程度最大，对于 $k = 1, 2, \ldots n$ ，输出最大的优美程度。</p><p>其中 $1 \le n \le 2000, 1 \le a_i \le 5 \times 10^7$ 。</p><h2 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h2><p>对于一种 $k$ 段的切分方案：$a_1, a_2, \ldots a_k$ ，其中 $a_i$ 表示第 $i$ 段数字之和。</p><p>那么有 $a_i = k_i \times g$ ，其中 $g$ 表示所有段数字和的最大公约数， $k_i$ 表示第 $i$ 段对于 $g$ 的倍数。</p><p>$\sum_{i=1}^k a_i = g \times \sum_{i=1}^k k_i$ ，也就是，$g$ 一定是 $a_i$ 的总和的因子，也就是所有数字之和的因子。</p><p>数字总和上限为 $10^{11}$ ， 这个数量级下最多有 $4000$ 数量的因子，可以直接枚举因子。</p><p>由于枚举的 $g$ 一定是总和的因子，那么如果有两个位置 $pre[i] \equiv pre[j] \pmod g$ ，剩下的头尾相连也一定是 $g$ 的倍数。对于枚举的 $g$ ，假设可以划分为 $cnt$ 段，此时优美程度为 $g$ ，那么对于任意 $k \le cnt$ ，也可以使用 $g$ 这个优美程度。</p><p>记录 $ans[i]$ 表示 $k = i$ 时的最大优美程度，求后缀最大值。</p><h2 id="Code-16"><a href="#Code-16" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll pre[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span> <span class="params">(ll g)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ++ mp[pre[i] % g];</span><br><span class="line">        cnt = <span class="built_in">max</span>(cnt, mp[pre[i] % g]);</span><br><span class="line">    }</span><br><span class="line">    ans[cnt] = <span class="built_in">max</span>(ans[cnt], g);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], pre[i] = pre[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= pre[n] / i; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (pre[n] % i == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">calc</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i) <span class="built_in">calc</span>(pre[n] / i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -- ) ans[i] = <span class="built_in">max</span>(ans[i], ans[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="平方计数"><a href="#平方计数" class="headerlink" title="平方计数"></a>平方计数</h1><h2 id="题意-18"><a href="#题意-18" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个正整数，第 $i$ 个数用 $a_i$ 表示，求出有多少对 $(i, j)$ 使得 $a_i^2 + a_j$ 为平方数。</p><p>其中 $1 \le n \le 10^6, 1 \le a_i \le 10^6$ 。</p><h2 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h2><p>$a_i^2 + a_j = x^2$ ，转化可得 $a_j = x^2 - a_i^2 = (x - a_i) \times (x + a_i)$ 。</p><p>枚举 $a_j$ 的因子 $fac_1, fac_2$ 那么有 $fac_2 - fac_1 = 2 \times a_i$ 。</p><p>直接枚举 $a_j$ 的因子复杂度为 $O(n \sqrt n)$ ，容易超时，可以使用枚举倍数的形式，复杂度为 $O(n log n)$ 。</p><h2 id="Code-17"><a href="#Code-17" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], cnt[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], ++ cnt[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i ++ ) <span class="comment">// 枚举其中一个因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">1000000</span>; j += i) <span class="comment">// 枚举它的倍数</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> mi = <span class="built_in">min</span>(j / i, i), mx = <span class="built_in">max</span>(j / i, i);</span><br><span class="line">            <span class="keyword">int</span> d = mx - mi; <span class="comment">// d = 2 * a[idx]</span></span><br><span class="line">            <span class="keyword">if</span> (d % <span class="number">2</span> == <span class="number">0</span>) ans = ans + (<span class="keyword">long</span> <span class="keyword">long</span>)cnt[j] * cnt[d / <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; ans / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="字典序最小"><a href="#字典序最小" class="headerlink" title="字典序最小"></a>字典序最小</h1><h2 id="题意-19"><a href="#题意-19" class="headerlink" title="题意"></a>题意</h2><p>从长度为 $n$ 的序列中选择长度为 $m$ 的子序列，满足这个子序列是一个 $1 \sim m$ 的排列，求字典序最小的这样的排列。</p><p>其中 $1 \le n \le 10^6, 1 \le a_i \le m$ 。</p><h2 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h2><p>使用栈来模拟求出答案的过程。</p><p>从前往后枚举每个数字，如果当前数字存在于栈中（被选定为答案），那么直接跳过。</p><p>否则将栈中所有大于它的数字弹出，注意为了使答案满足 $1 \sim m$ 的排列，需要保证弹出的数字在后面还存在。</p><h2 id="Code-18"><a href="#Code-18" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], last[N];</span><br><span class="line"><span class="keyword">bool</span> instk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), last[a[i]] = i;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (instk[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; last[stk.<span class="built_in">top</span>()] &gt; i &amp;&amp; a[i] &lt; stk.<span class="built_in">top</span>())</span><br><span class="line">            instk[stk.<span class="built_in">top</span>()] = <span class="literal">false</span>, stk.<span class="built_in">pop</span>();</span><br><span class="line">        stk.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        instk[a[i]] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span>(stk.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>()), stk.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, ans[i], i + <span class="number">1</span> == m ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="拆拆"><a href="#拆拆" class="headerlink" title="拆拆"></a>拆拆</h1><h2 id="题意-20"><a href="#题意-20" class="headerlink" title="题意"></a>题意</h2><p>多组数据。</p><p>每组给定两个数 $X, Y$ ，问有多少个长度为 $Y$ 的整数序列之乘积为 $X$ ，即</p><script type="math/tex; mode=display">\prod_{i=1}^Y f_i = X</script><p>注意：两序列不同，当且仅当至少有一个下标相同的位置不同。如 $(1, 2), (2, 1)$ 被视为不同的序列。</p><p>答案可能很大，将其模以 $10^9 + 7$ 输出。</p><p>例如：给定 $(X, Y) = (6, 2)$ ，可以将 $6$ 分成 $(\pm 1, \pm 6), (\pm 2, \pm 3), (\pm 3, \pm 2), (\pm 6, \pm 1)$ 八种长度为 $2$ 的序列，答案为 $8$ 。</p><h2 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h2><p>对于乘积，先想到的是对 $X$ 进行质因数分解。</p><p>因为需要 $Y$ 个数字，可以想象成有 $Y$ 个盒子，每个盒子最开始只有数字 $1$ ，对于每种质因数，将他们分在 $Y$ 的盒子里，可以存在空盒子，这是一个隔板法模型，答案为 $C(Y + s - 1, Y - 1)$ ，其中 $s$ 为某个质因数的数量。也就是增加 $Y$ 个球，变为不能为空盒子的隔板法模型。</p><p>由于可以存在负数，所以可以把偶数个数字改为负数，不影响答案，$C(Y, 0) + C(Y, 2) + \ldots = 2^{Y-1}$ 。根据乘法原理乘起来即可。</p><p>由于存在多组测试数组，需要预处理出 $C(n, m)$ 和 每个数字的所有质因子，枚举倍数即可。</p><h2 id="Code-19"><a href="#Code-19" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> {</span> <span class="keyword">int</span> v, s; };</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fac[N], infac[N], P[N];</span><br><span class="line">vector&lt;T&gt; F[N]; <span class="comment">// 所有数字的质因子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="built_in">quick_power</span>(x, mod - <span class="number">2</span>); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++ ) P[i] = (ll)P[i<span class="number">-1</span>] * <span class="number">2</span> % mod;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++ ) fac[i] = (ll)fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">    infac[N<span class="number">-1</span>] = <span class="built_in">inv</span>(fac[N<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- ) infac[i] = (ll)infac[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调和级数求出每个数字的质因子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (F[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> t = j, s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t % i == <span class="number">0</span>) ++ s, t /= i;</span><br><span class="line">            F[j].<span class="built_in">push_back</span>({i, s});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (ll)fac[n] * infac[m] % mod * infac[n-m] % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ps: F[x])</span><br><span class="line">        (ans *= <span class="built_in">C</span>(ps.s + y - <span class="number">1</span>, y - <span class="number">1</span>)) %= mod;</span><br><span class="line">    (ans *= P[y<span class="number">-1</span>]) %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_); _ -- ; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h1><h2 id="题意-21"><a href="#题意-21" class="headerlink" title="题意"></a>题意</h2><p>对于一个长度为 $n$ 的序列，给出 $q$  次提示，每次给出 $[L, R]$ 区间的元素和，问能否知道整个序列的元素和。</p><h2 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h2><p>对于给定的 $[L, R]$ 区间元素和，就是知道了 $sum_R - sum_{L-1}$ 的值，如果我们知道其中任意一个，就知道了另外的值。</p><p>使用并查集维护这样的关系，使得只要知道了集合内任意一个元素的值，都能知道其他元素的值。</p><p>特别的，$sum_0 = 0$ ，能求出整个序列的元素和，只有当 $0$ 和 $n$ 在同一个集合内。</p><h2 id="Code-20"><a href="#Code-20" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m -- ) {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        p[<span class="built_in">find</span>(x - <span class="number">1</span>)] = <span class="built_in">find</span>(y);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">find</span>(<span class="number">0</span>) == <span class="built_in">find</span>(n) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子串的最大差&quot;&gt;&lt;a href=&quot;#子串的最大差&quot; class=&quot;headerlink&quot; title=&quot;子串的最大差&quot;&gt;&lt;/a&gt;子串的最大差&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="每日一题" scheme="https://horb7.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Django入门</title>
    <link href="https://horb7.github.io/2022/02/25/Django%E5%85%A5%E9%97%A8/"/>
    <id>https://horb7.github.io/2022/02/25/Django%E5%85%A5%E9%97%A8/</id>
    <published>2022-02-25T15:31:21.000Z</published>
    <updated>2022-02-26T06:38:35.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.imooc.com/learn/1110">Imooc教程：三小时带你入门Django</a></p><p><a href="https://docs.djangoproject.com/zh-hans/4.0/">Django中文文档</a></p><hr><h1 id="Django-介绍"><a href="#Django-介绍" class="headerlink" title="Django 介绍"></a>Django 介绍</h1><p><strong>基本介绍</strong>：Django 是一个由Python编写的Web应用框架，本身基于MVT模型，即：模型层(Model) ，模板层(Template)，视图层(View)。</p><p>除了上面三层，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template。</p><p>用户操作流程图：<img src="\images\Django\introduction.png" alt=""></p><p>解析：</p><p>用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数：</p><ol><li>如果不涉及函数调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。</li><li>如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。</li></ol><h1 id="Django-基本命令"><a href="#Django-基本命令" class="headerlink" title="Django 基本命令"></a>Django 基本命令</h1><p><code>django-admin</code>是Django用于管理任务的命令行工具，使用<code>django-admin</code>查看其他命令。</p><p><img src="\images\Django\django_admin.png" alt=""></p><p><strong>其中重要的命令有：</strong></p><ol><li><code>startproject</code>  # 用于创建Django的一个项目</li><li><code>startapp</code>  # 用于创建Django的一个应用（软件包）</li><li><code>check</code>  # 校验项目的完整性</li><li><code>runserver</code>  # 进入Django项目环境并启用Django项目</li><li><code>shell</code>  # 进入Django项目的 Python Shell环境</li><li><code>test</code>  # 执行Django用例测试</li><li><code>makemigrations</code>  # 创建模型变更的迁移文件</li><li><code>migrate</code>  # 执行上一个命令创建的迁移文件，即把模型等导入到数据库</li><li><code>dumpdate</code>  # 把数据库数据导出到文件</li><li><code>loaddate</code>  # 把文件数据导入到数据库</li></ol><h1 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h1><p>使用<code>django-admin startproject django_study</code> 创建第一个项目，我们会发现django_study作为文件被创建，且目录下有若干个初始文件：</p><p><img src="\images\Django\startproject.png" alt=""></p><p>其中 <code>manage.py</code> 为项目管理文件，项目中的<code>django_study</code>文件夹包含此<strong>项目</strong>的所有配置。</p><p>其中：<code>settings.py</code>为项目的总设置，<code>urls.py</code> 为Django项目的总路由文件，<code>wsgi.py</code> 为Django作为wsgi应用所需要的内容。</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>使用 <code>python3 manage.py runserver</code> 运行Django项目。</p><ol><li><p>如果你的项目在本地开发</p><p>直接在浏览器输入<code>127.0.0.1:8000</code> 即可，如果成功则显示Django的初始化界面。</p></li><li><p>如果你的项目在服务器上开发</p><p>在命令后面加上<code>0.0.0.0:8000</code>，即<code>python3 manage.py runserver 0.0.0.0:8000</code> (如果是Docker环境需要把端口改为映射的端口，比如我的是8080)，注意服务器的8000端口需要打开，可以去购买服务器的网站上打开，在本地使用<code>ip:8000</code>查看，你会发现没有成功：</p><p><img src="\images\Django\error_start.png" alt=""></p><p>这是因为Django具有保护机制，不会使其他ip地址来访问项目，如果想在本地调试，需要去<code>\django_study\settings.py</code> 文件中，设置ip为可访问ip：</p><p><img src="\images\Django\allowed_host.png" alt=""></p><p>再次使用<code>python3 manage.py runserver 0.0.0.0:8000</code> 重新部署Django项目即可。</p></li></ol><p>以下都用本地开发的ip为例子，服务器开发只需要换自己的服务器的ip即可。</p><h2 id="Django应用介绍"><a href="#Django应用介绍" class="headerlink" title="Django应用介绍"></a>Django应用介绍</h2><p><strong>Django应用 VS Django项目：</strong></p><ul><li><p>一个Django项目就是一个基于Django的Web应用</p></li><li><p>一个Django应用就是一个<strong>可重用</strong>的Python软件包（即可出现在若干个项目中）</p></li><li>每个应用可以自己管理模型、视图、模板、路由和静态文件等</li><li>一个Django项目包含一组配置和若干个Django应用</li></ul><p><img src="\images\Django\appvspro.png" alt=""></p><h3 id="创建一个Django应用"><a href="#创建一个Django应用" class="headerlink" title="创建一个Django应用"></a>创建一个Django应用</h3><p>使用<code>python3 manage.py startapp blog</code> 创建一个应用。</p><p>此时项目文件中新建了一个<code>blog</code>应用(文件夹)，它有以下目录：</p><p><img src="\images\Django\firstapp.png" alt=""></p><p><strong>Django应用目录介绍：</strong></p><ul><li><code>views.py</code>  # 视图处理的地方</li><li><code>models.py</code>  # 定义应用模型的地方</li><li><code>admin.py</code>  # 定义Admin模块管理对象的地方</li><li><code>apps.py</code>  # 声明应用的地方</li><li><code>tests.py</code>  # 编写应用测试用例的地方</li></ul><p>除此之外，还需要创建<code>urls.py</code>文件来管理应用的路由，使用<code>touch urls.py</code>。</p><h2 id="Django-HelloWorld"><a href="#Django-HelloWorld" class="headerlink" title="Django HelloWorld"></a>Django HelloWorld</h2><h3 id="Django视图"><a href="#Django视图" class="headerlink" title="Django视图"></a>Django视图</h3><p>在没有框架的时代，如果要写一个hello,world网页，只需要写出html元素，但对于一个复杂的网页，不可能通过html来表达网页中所有的元素。</p><p>在一个网页中产生内容，就是Django视图的工作。</p><p>具体来说，我们在视图文件中编写一个个的逻辑函数，接受html的请求，并根据请求来生成响应数据并返回。Django视图主要用于处理项目的业务逻辑部分。</p><hr><p>在<code>blog</code>应用中，我们编写其视图函数，在<code>views.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">request</span>):</span>  <span class="comment"># request参数就是http请求的对象</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="Django路由"><a href="#Django路由" class="headerlink" title="Django路由"></a>Django路由</h3><p>在编写完上述代码，重新部署项目，却仍然是Django的欢迎页面。</p><p>这是因为Django视图仅仅是对http的请求做出相应，而我们并没有发出这样的请求，所以没办法到达刚才的视图函数。</p><p>配置路由，可以将http以url的形式发出请求并获得响应，譬如，对于<code>"ip/hello_world"</code>，就是向服务器发出了”hello_world”这个请求。</p><p>我们需要配置应用级别的路由和项目级别的路由。</p><p><strong>对于应用级别的路由</strong>，在<code>blog/urls.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>对于项目级别的路由</strong>，在<code>django_study/urls</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'blog/'</span>, include(<span class="string">'blog.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>它表示，如果我们的请求为<code>blog</code>的子目录，那么通过<code>include</code>转发到<code>blog.urls</code>这个文件中（继续寻找）。</p><p><strong>注意这里的引用模块，都是按照django_study这个项目文件来相对引用的</strong> 。</p><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>我们在<code>django_study</code>项目中创建了一个应用，要想让这个项目使用<code>blog</code>这个应用，需要在项目文件中的<code>settings</code>注册应用。</p><p><img src="\images\Django\add_app.png" alt=""></p><p>这里的<code>BlogConfig</code>是<code>blog/apps</code>文件中的结构体，它代表着这个应用的实体。</p><p><img src="\images\Django\app_name.png" alt=""></p><p>接下来重新部署运行Django项目，在浏览器中输入<code>127.0.0.1:8000/blog/hello_world</code>，发现正确响应了http的请求。</p><p><img src="\images\Django\print_hello_world.png" alt=""></p><p><strong>一张表解释应用路由和项目路由的关系：</strong></p><p><img src="\images\Django\view_url.png" alt=""></p><h1 id="Django模型层"><a href="#Django模型层" class="headerlink" title="Django模型层"></a>Django模型层</h1><h2 id="模型层介绍"><a href="#模型层介绍" class="headerlink" title="模型层介绍"></a>模型层介绍</h2><ul><li>位于Django视图层和数据库之间</li><li>Python对象和数据库表之间的转换</li></ul><p><img src="\images\Django\models.png" alt="image-20220226102117930"></p><p>在项目运行过程，不可避免地需要使用数据来交互，通过视图层，与数据库交互得到数据，然后通过返回到前端渲染。模型层夹在视图层和数据库之间，使用模型层可以屏蔽不同数据库之间的差异，让开发者更加注重业务逻辑。同时模型层提供很多便捷工具来开发。</p><p>简单来说，模型就是抽象数据类型，我们可以把它作为视图与数据库的交互对象。</p><h2 id="模型层配置"><a href="#模型层配置" class="headerlink" title="模型层配置"></a>模型层配置</h2><p>在项目设置<code>django_study/settings.py</code>中，可以看到项目的模型层数据库的相关配置。</p><p><img src="\images\Django\sqlite.png" alt="image-20220226102903267"></p><p>其中<code>ENGINE</code>表示模型层所交互的数据库，默认为Django自带的sqlite3数据库，<code>NAME</code>为数据库名字，作为文件存储在项目文件中。</p><h2 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h2><p>要创建博客文章，需要以下操作：</p><ol><li>设计博客模型</li><li>模型层定义字段</li></ol><h3 id="设计博客模型"><a href="#设计博客模型" class="headerlink" title="设计博客模型"></a>设计博客模型</h3><p>博客模型有以下几个属性：</p><ul><li>文章标题(title)   文本类型</li><li>文章摘要(brief_context)   文本类型</li><li>文章内容(context)   文本类型</li><li>唯一ID标记(article_id)   int，自增，主键</li><li>发布日期(date)  日期类型</li></ul><h3 id="模型层定义字段"><a href="#模型层定义字段" class="headerlink" title="模型层定义字段"></a>模型层定义字段</h3><ul><li>数字类型:  IntegerField</li><li>文本类型:  TextField</li><li><p>日期类型:  DateTimeField</p></li><li><p>自增ID:  AutoField</p></li><li>主键定义:  primary_key属性</li></ul><p>进入应用文件<code>blog/models.py</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span> <span class="comment"># 继承models模型</span></span><br><span class="line">    article_id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.TextField()</span><br><span class="line">    brief_content = models.TextField()</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    publish_date = models.DateTimeField(auto_now=<span class="literal">True</span>) <span class="comment"># auto_now=True 表示文章的发布日期即创建时的日期</span></span><br></pre></td></tr></tbody></table></figure><p>使用<code>python3 manage.py makemigrations</code>，将模型的变更生成迁移文件。</p><p><img src="\images\Django\create_model.png" alt="image-20220226104443577"></p><p>再使用<code>python3 manage.py migrate</code>，运行迁移文件，将迁移内容同步到数据库中。</p><h2 id="Django-Shell"><a href="#Django-Shell" class="headerlink" title="Django Shell"></a>Django Shell</h2><h3 id="Django-Shell-介绍"><a href="#Django-Shell-介绍" class="headerlink" title="Django Shell 介绍"></a>Django Shell 介绍</h3><p>类似于Python Shell，Django Shell可以进入Django项目环境，操作项目中的某些对象或者方法。</p><p>对于某些临时性操作，使用Django Shell可以更加方便，比如对于创建的Article字段，我们并不清楚它是否真的可以使用，Django Shell就是调试的最好工具。</p><p>同时，Django Shell使得小范围Debug更加简单，不需要写测试文件，运行整个项目来测试。</p><h3 id="Django-Shell操作"><a href="#Django-Shell操作" class="headerlink" title="Django Shell操作"></a>Django Shell操作</h3><p>使用<code>python3 manage.py shell</code>来启动Django Shell，引入Article模块来测试。</p><p><img src="\images\Django\django_shell.png" alt="image-20220226105600861"></p><p>其中<code>a.save</code>表示将a对象存入数据库中，使用<code>Article.objects.all()</code>即可获得数据库所有<code>Article</code>对象。</p><p><a href="https://blog.csdn.net/qq_38582906/article/details/106791656">这篇博客</a>详细介绍了Django Shell的使用操作。</p><h1 id="Django-Admin模块"><a href="#Django-Admin模块" class="headerlink" title="Django Admin模块"></a>Django Admin模块</h1><h2 id="Django-Admin模块介绍"><a href="#Django-Admin模块介绍" class="headerlink" title="Django Admin模块介绍"></a>Django Admin模块介绍</h2><p>Django Admin是Django的后台管理工具，它可以读取定义的模型元数据(也就是具体的数据)，提供强大的管理使用页面。</p><p>使用Django Shell创建数据，不仅复杂还容易出错，尤其对于复杂的模型而言。</p><p>使用Django Admin模块，可以在后台管理增加、删除、改变模型元数据，它是基础设施中重要的部分。</p><h2 id="Django-Admin模块的使用"><a href="#Django-Admin模块的使用" class="headerlink" title="Django Admin模块的使用"></a>Django Admin模块的使用</h2><p>使用<code>python3 manage.py createsuperuser</code>来创建超级管理员。</p><p><img src="\images\Django\createsuperuser.png" alt="image-20220226110941610"></p><p>在浏览器中输入<code>127.0.0.1:8000/admin</code>进入后台管理页面。</p><p><img src="\images\Django\admin.png" alt="image-20220226111506880"></p><p>其中Groups和users是默认的模型，但是我们定义的Article模型没有出现，这是因为没有在Admin模块注册Article模型。</p><p>进入<code>blog/admin.py</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article</span><br><span class="line"></span><br><span class="line">admin.site.register(Article)</span><br></pre></td></tr></tbody></table></figure><p>刷新admin页面，就会发现多出了一个模型：</p><p><img src="\images\Django\register_admin.png" alt="image-20220226111841717"></p><p>点击Article，进入Article模型的数据管理页面，发现存在一个数据元，这就是之前在Django Shell中注册的Article对象。</p><p><img src="\images\Django\Article_0.png" alt="image-20220226112028602"></p><p><img src="\images\Django\article_test.png" alt="image-20220226112058253"></p><p>在Admin页面，点击Article模型右边的<code>+</code>号，存储第二个数据：</p><p><img src="\images\Django\article_add.png" alt="image-20220226112257443"></p><p>点击右下方的<code>save</code>，完成在数据库中的存储。</p><p><img src="\images\Django\article_save.png" alt="image-20220226112400431"></p><p>我们发现，这里的数据并没有显示其文章的标题(title)，这不方便之后的管理。</p><p>进入<code>blog/models.py</code>，为Article模型添加方法 <strong>\_\_str\_\_</strong> ：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    article_id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.TextField()</span><br><span class="line">    brief_content = models.TextField()</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    publish_date = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br></pre></td></tr></tbody></table></figure><p>重新部署项目，刷新浏览器：</p><p><img src="\images\Django\add_str.png" alt="image-20220226112802438"></p><p>发现数据可以根据其标题显示了。</p><h1 id="实现博客数据返回页面"><a href="#实现博客数据返回页面" class="headerlink" title="实现博客数据返回页面"></a>实现博客数据返回页面</h1><p>进入<code>blog/views.py</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article_content</span>(<span class="params">request</span>):</span></span><br><span class="line">    article = Article.objects.<span class="built_in">all</span>()[<span class="number">0</span>]</span><br><span class="line">    title = article.title</span><br><span class="line">    brief_content = article.brief_content</span><br><span class="line">    content = article.content</span><br><span class="line">    article_id = article.article_id</span><br><span class="line">    publish_date = article.publish_date</span><br><span class="line">    return_str = <span class="string">'title: %s, brief_content: %s, '</span> \</span><br><span class="line">                 <span class="string">'content: %s, article_id: %s, publish_date: %s'</span> % (title,</span><br><span class="line">                                                                    brief_content,</span><br><span class="line">                                                                    content,</span><br><span class="line">                                                                    article_id,</span><br><span class="line">                                                                    publish_date)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(return_str)</span><br></pre></td></tr></tbody></table></figure><p>配置应用级别路由，进入<code>blog/urls</code>，写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">    path(<span class="string">'content'</span>, blog.views.article_content),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>由于项目级别已经配置，这里不需要再配置。</p><p>打开浏览器，输入<code>127.0.0.1:8000/blog/content</code>，成功返回文章内容。</p><p><img src="\images\Django\article_content.png" alt="image-20220226113801311"></p><h1 id="使用Bootstrap实现静态博客布局"><a href="#使用Bootstrap实现静态博客布局" class="headerlink" title="使用Bootstrap实现静态博客布局"></a>使用Bootstrap实现静态博客布局</h1><p><strong>博客主页设计</strong></p><p><img src="\images\Django\blog_design1.png" alt="image-20220226114157328"></p><p>其中上方为博客标题，左下方为博客文章，右下方为最新的文章。</p><p><strong>文章页面设计</strong></p><p><img src="\images\Django\blog_design2.png" alt="image-20220226114409529"></p><p>其中上方为文章标题，下方为文章内容。</p><h2 id="Bootstrap以及Bootstrap的栅格系统"><a href="#Bootstrap以及Bootstrap的栅格系统" class="headerlink" title="Bootstrap以及Bootstrap的栅格系统"></a>Bootstrap以及Bootstrap的栅格系统</h2><p><strong>Bootstrap</strong>是来自美国Twitter的前端框架，它提供了非常多的控件并附带源码。</p><p>进入<a href="https://v3.bootcss.com/">BootsTrap中文官网</a> 。</p><p>点击上方的<strong>组件</strong> ，即可查看各组件及其源码。</p><p>点击上方<strong>全局CSS样式</strong>，也可以查看其中的各个样式。</p><p><strong>Bootstrap</strong> 中的栅格系统，将页面按照横坐标分割为12等分，对于博客主页，使用9:3来分割：</p><p><img src="\images\Django\blog_bootstrap_1.png" alt="image-20220226115328759"></p><p>在<code>blog</code>下创建<code>templates</code>文件夹，用于存放模板。</p><p>在<code>blog/templates</code>下创建<code>index.html</code>作为博客主页，写入：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Django Study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Django Study Web</span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span> ---- by Horb7<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span> <span class="attr">role</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body-main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span> <span class="attr">rold</span>=<span class="string">"complementary"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>最新文章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章6<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章7<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章8<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章9<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>最新文章10<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其中前面的引入在Bootstrap官网<code>入门</code>中：</p><p><img src="\images\Django\boots_start.png" alt="image-20220226121019232"></p><p>效果：</p><p><img src="\images\Django\boots_1.png" alt="image-20220226121327336"></p><p>对于文章主页，在<code>blog/templates</code>下创建<code>detail.html</code>来写入文章主页的html：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Django Study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题1</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body-main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Django-模板系统"><a href="#Django-模板系统" class="headerlink" title="Django 模板系统"></a>Django 模板系统</h1><h2 id="模板系统简介"><a href="#模板系统简介" class="headerlink" title="模板系统简介"></a>模板系统简介</h2><p>如果对于http的某一个请求，我们需要返回一个html，我们可以在视图函数中(views.py) 直接使用html元素。</p><p>但是视图文件本身不适合编写html，并且，如果html写在视图文件，那么在页面设计改变时就需要修改Python源代码，这样很不方便。</p><p>另外，页面逻辑(view)和页面视图(html)本身应该分开设计，使得视图文库可以从html中解放出来。</p><p>模板系统的表现形式为文本(字符串)，即html文件。它分离了文档了表现形式和表现内容，为此，模板系统定义了独有的标签占位符。</p><h2 id="模板系统基本语法"><a href="#模板系统基本语法" class="headerlink" title="模板系统基本语法"></a>模板系统基本语法</h2><ul><li><p>变量标签：<code>{{ 变量 }}</code> ，如<code>&lt;html&gt;&lt;body&gt;{{ now }}&lt;/body&gt;&lt;/html&gt;</code></p></li><li><p>for循环标签：<code>{% for x in list %},{% endfor %}</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  {% for item in list %}</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>{{ item }}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  {% endfor %}</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>if-else分支标签：<code>{% if %}, {% else %}, {% endif %}</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if true %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> it is a true part. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">{% else %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> it is a false part. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="使用模板系统渲染博客页面"><a href="#使用模板系统渲染博客页面" class="headerlink" title="使用模板系统渲染博客页面"></a>使用模板系统渲染博客页面</h2><p>根据模板系统的语法，我们在<code>blog/templates/index.html</code>中重新写入：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Django Study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Django Study Web</span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span> ---- by Horb7<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container page-body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span> <span class="attr">role</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"body-main"</span>&gt;</span></span><br><span class="line">            {% for article in article_list %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>{{ article.title }}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{ article.content }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            {% endfor %}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span> <span class="attr">rold</span>=<span class="string">"complementary"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>最新文章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            {% for article in article_list %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>{{ article.title }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            {% endfor %}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样就完成了一个模板，那么里面的变量如何获取呢？由于模板是视图函数所返回的html元素，所以我们需要在视图函数中获取变量。</p><p>在<code>blog/views.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index_page</span>(<span class="params">request</span>):</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/index.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'article_list'</span>: all_article</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><p>其中<code>render</code>函数可以返回经过模板渲染后的HttpResponse对象。</p><p>为了方便管理，我们将<code>index.html</code>和<code>detail.html</code>文件放入<code>blog/templates</code> 新创建的文件<code>blog</code>中。</p><p><img src="\images\Django\new_place.png" alt="image-20220226124857810"></p><p>然后进入<code>blog/urls.py</code>中写入路由：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">    path(<span class="string">'content'</span>, blog.views.article_content),</span><br><span class="line">    path(<span class="string">'index'</span>, blog.views.get_index_page),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>最后重新部署项目，打开浏览器，输入<code>127.0.0.1:8000/blog/index</code>，即可到达<code>index.html</code>渲染后的网页。</p><p><img src="\images\Django\index_render.png" alt="image-20220226132216119"></p><p>同理修改文章主页的模板和url即可。</p><p>在<code>blog/views.py</code>加入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_page</span>(<span class="params">request, article_id</span>):</span></span><br><span class="line">    curr_article = Article.objects.<span class="built_in">all</span>()[<span class="number">0</span>]</span><br><span class="line">    section_list = curr_article.content.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/detail.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'curr_article'</span>: curr_article,</span><br><span class="line">                      <span class="string">'section_list'</span>: section_list</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><h2 id="实现文章详情页面的跳转"><a href="#实现文章详情页面的跳转" class="headerlink" title="实现文章详情页面的跳转"></a>实现文章详情页面的跳转</h2><p>在上述实验中，我们的<code>ip/blog/detail</code>只能跳转到第一篇博客，如何根据<code>detail/id</code>来实现根据id跳转到对应的博客？</p><p>我们可以在<code>urls.py</code>中获取id参数，在<code>blog/urls.py</code>重新写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">import</span> blog.views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello_world'</span>, blog.views.hello_world),</span><br><span class="line">    path(<span class="string">'content'</span>, blog.views.article_content),</span><br><span class="line">    path(<span class="string">'index'</span>, blog.views.get_index_page),</span><br><span class="line">    <span class="comment"># path('detail', blog.views.get_detail_page),</span></span><br><span class="line">path(<span class="string">'detail/&lt;int:article_id&gt;'</span>,blog.views.get_detail_page)</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>blog/views.py</code>中写入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_page</span>(<span class="params">request, article_id</span>):</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    curr_article = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> all_article:</span><br><span class="line">        <span class="keyword">if</span> article.article_id == article_id:</span><br><span class="line">            curr_article = article</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    section_list = curr_article.content.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/detail.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'curr_article'</span>: curr_article,</span><br><span class="line">                      <span class="string">'section_list'</span>: section_list</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><p>据此，我们可以在博客首页的文章标题加上跳转链接：</p><p><img src="\images\Django\ahref.png" alt="image-20220226132015689"></p><p><img src="\images\Django\add_href.png" alt="image-20220226131922264"></p><h1 id="实现上下篇文章跳转"><a href="#实现上下篇文章跳转" class="headerlink" title="实现上下篇文章跳转"></a>实现上下篇文章跳转</h1><p>在BootsTrap中文官网，选择<strong>组件</strong>中的分页，选择默认实例作为上下篇反转按钮：</p><p><img src="\images\Django\findbottom.png" alt="image-20220226132720409"></p><p>在文章主页最下方加入上述代码。</p><p><img src="\images\Django\addd_pd.png" alt="image-20220226132833664"></p><p>根据模板占用标签修改：</p><p><img src="\images\Django\modify_bt.png" alt="image-20220226133140145"></p><p>然后进入<code>blog/views.py</code>修改视图函数，返回<code>previous_article</code>和<code>next_article</code>即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_page</span>(<span class="params">request, article_id</span>):</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    curr_article_index = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> index, article <span class="keyword">in</span> <span class="built_in">enumerate</span>(all_article): <span class="comment"># 迭代器</span></span><br><span class="line">        <span class="keyword">if</span> article.article_id == article_id:</span><br><span class="line">            curr_article_index = index</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    curr_article = all_article[curr_article_index]</span><br><span class="line">    previous_article = all_article[curr_article_index - <span class="number">1</span>]</span><br><span class="line">    next_article = all_article[curr_article_index + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> curr_article_index == <span class="number">0</span>:</span><br><span class="line">        previous_article = curr_article</span><br><span class="line">    <span class="keyword">if</span> curr_article_index == <span class="built_in">len</span>(all_article) - <span class="number">1</span>:</span><br><span class="line">        next_article = curr_article</span><br><span class="line">    section_list = curr_article.content.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/detail.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'curr_article'</span>: curr_article,</span><br><span class="line">                      <span class="string">'section_list'</span>: section_list,</span><br><span class="line">                      <span class="string">'previous_article'</span>: previous_article,</span><br><span class="line">                      <span class="string">'next_article'</span>: next_article</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><h1 id="实现文章的分页功能"><a href="#实现文章的分页功能" class="headerlink" title="实现文章的分页功能"></a>实现文章的分页功能</h1><p><strong>Django 分页组件介绍</strong>：</p><p>在Django中有一个分页组件 <strong>Paginator</strong> ，可以在Django Shell中调试入门Paginator。</p><p><img src="\images\Django\test_paginator.png" alt="image-20220226140807054"></p><p>在博客主页<code>index.html</code>的文章块下方，加入一个分页块(使用<code>div</code>，与文章块并列)。</p><p>在Bootstrap中文官网的<strong>组件</strong>中找到分页，拷贝下来放入分页块中。</p><p>刷新浏览器，即可看到分页组件：</p><p><img src="\images\Django\fenye.png" alt="image-20220226135357224"></p><p>在路由中，我们采用<code>/blog/index?page=1</code>来实现文章的分页。</p><p>在<code>blog/views.py</code>中修改：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index_page</span>(<span class="params">request</span>):</span></span><br><span class="line">    page = request.GET.get(<span class="string">'page'</span>)</span><br><span class="line">    <span class="comment"># 如果没有page参数，则page为1</span></span><br><span class="line">    <span class="keyword">if</span> page:</span><br><span class="line">        page = <span class="built_in">int</span>(page)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="number">1</span></span><br><span class="line">    all_article = Article.objects.<span class="built_in">all</span>()</span><br><span class="line">    paginator = Paginator(all_article, <span class="number">3</span>)</span><br><span class="line">    page_num = paginator.num_pages</span><br><span class="line">    page_article_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">if</span> page_article_list.has_next():</span><br><span class="line">        next_page = page + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        next_page = page</span><br><span class="line">    <span class="keyword">if</span> page_article_list.has_previous():</span><br><span class="line">        previous_page = page - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        previous_page = page</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog/index.html'</span>,</span><br><span class="line">                  {</span><br><span class="line">                      <span class="string">'article_list'</span>: page_article_list,</span><br><span class="line">                      <span class="string">'page_num'</span>: <span class="built_in">range</span>(<span class="number">1</span>, page_num + <span class="number">1</span>),</span><br><span class="line">                      <span class="string">'curr_page'</span>: page,</span><br><span class="line">                      <span class="string">'next_page'</span>: next_page,</span><br><span class="line">                      <span class="string">'previous_page'</span>: previous_page</span><br><span class="line">                  }</span><br><span class="line">                  )</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>index.html</code>中修改每个分页按钮的链接：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">aria-label</span>=<span class="string">"Page navigation"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog/index?page={{ previous_page }}"</span> <span class="attr">aria-label</span>=<span class="string">"Previous"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            {% for num in page_num %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog/index?page={{ num }}"</span>&gt;</span>{{ num }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            {% endfor %}</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/blog/index?page={{ next_page }}"</span> <span class="attr">aria-label</span>=<span class="string">"Next"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>刷新浏览器即可查看效果：</p><p><img src="\images\Django\allfianl.png" alt="image-20220226142024599"></p><h1 id="实现最新文章列表"><a href="#实现最新文章列表" class="headerlink" title="实现最新文章列表"></a>实现最新文章列表</h1><p>最新文章在所有文章中取得<code>publish_date</code>最大的5个，由于在分页后，每个页面(即<code>index?page=x</code>)的<code>all_article</code>为当前页面的所有文章，所以不能从这里取。</p><p>在<code>blog/views.py</code>修改，使其返回数据库所有文章最新的五个：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加</span></span><br><span class="line">top5_article = Article.objects.order_by(<span class="string">'-publish_date'</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># return reder()中加</span></span><br><span class="line"><span class="string">'top5_article'</span>: top5_article</span><br></pre></td></tr></tbody></table></figure><p>最后再修改<code>index.html</code>内容，将for范围修改即可。</p><p><img src="\images\Django\modify_new.png" alt="image-20220226143427317"></p><p><strong>最后的成品：</strong></p><p><img src="\images\Django\finalxiaoguo.png" alt="image-20220226143555836"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h</summary>
      
    
    
    
    <category term="项目学习" scheme="https://horb7.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Django" scheme="https://horb7.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>牛客秋季算法班LCA-E-华华和月月种树</title>
    <link href="https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/"/>
    <id>https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/</id>
    <published>2022-02-20T08:48:28.000Z</published>
    <updated>2022-02-24T16:57:27.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="华华和月月种树"><a href="#华华和月月种树" class="headerlink" title="华华和月月种树"></a>华华和月月种树</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>维护一个动态有根树，每个点都有一个权值，开始时只有一个 $0$ 号节点，权值为 $0$ 。有以下操作：</p><ol><li>$1 \ \ i$ ，表示 $i$ 节点长出一个新的子节点，权值为 $0$ ，编号为目前最大编号 $+1$ 。</li><li>$2 \ \ i \ \ a$ ，表示节点 $i$ 的子树的所有节点 (包括 $i$ 节点) 权值 $+a$ 。</li><li>$3 \ \ i$ ，表示查询节点 $i$ 此时的权值。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>离线 + 树状数组</strong></p><p>先根据所有的操作建立一棵树，求得所有节点的dfs序，即可在区间上操作。</p><p>树状数组维护差分的前缀。</p><p>对于操作1，记录它在权值为 $0$ 的时候（刚被开辟出来）它的前缀和，查询该点时减去这个值即可。</p><p>对于操作2，只需要在 $[l[i], r[i]]$ 上所有点权值 $+a$ 即可，使用差分。其中 $l[i]$ 和 $r[i]$ 表示 $i$ 点的进出栈时间(dfs序) 。</p><p>对于操作3，查询前缀和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> op[N], a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> val[N], c[N], l[N], r[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 一开始有一个节点0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    l[u] = ++ cnt; <span class="comment">// 最早的timestamp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (u != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    r[u] = cnt; <span class="comment">// 最晚的timestamp</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) res += c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; op[i] &gt;&gt; a[i];</span><br><span class="line">        ++ a[i]; <span class="comment">// 注意树状数组只能维护[1, n]的区间，不能包括0</span></span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            g[a[i]].<span class="built_in">push_back</span>(++ cnt);</span><br><span class="line">            b[i] = cnt; <span class="comment">// b[i]表示第i个操作后，新的节点编号</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>) cin &gt;&gt; b[i]; <span class="comment">// b[i]表示加多少</span></span><br><span class="line">    }</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 转化为dfs序，进行区间运算</span></span><br><span class="line">    <span class="comment">// 树状数组的区间加+单点查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>) <span class="comment">// 加新的节点</span></span><br><span class="line">        {</span><br><span class="line">            val[l[b[i]]] += <span class="built_in">query</span>(l[a[i]]); <span class="comment">// val(i)表示i点加了多少</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">update</span>(l[a[i]], b[i]);</span><br><span class="line">            <span class="built_in">update</span>(r[a[i]] + <span class="number">1</span>, -b[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(l[a[i]]) - val[l[a[i]]] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;华华和月月种树&quot;&gt;&lt;a href=&quot;#华华和月月种树&quot; class=&quot;headerlink&quot; title=&quot;华华和月月种树&quot;&gt;&lt;/a&gt;华华和月月种树&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="数据结构" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树状数组" scheme="https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客秋季算法班LCA-D.Alliances</title>
    <link href="https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/"/>
    <id>https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/</id>
    <published>2022-02-20T07:40:34.000Z</published>
    <updated>2022-02-20T07:52:22.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alliances"><a href="#Alliances" class="headerlink" title="Alliances"></a>Alliances</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>链接：<a href="https://ac.nowcoder.com/acm/contest/27836/D">https://ac.nowcoder.com/acm/contest/27836/D</a></p><p>  树国是一个有 $n$ 个城市的国家，城市编号为 $1 \sim n$ 。连接这些城市的道路网络形如一棵树， </p><p>  即任意两个城市之间有恰好一条路径。城市中有k个帮派，编号为 $1 \sim k$ 。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。 </p><p>  当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。 </p><p>  shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于选定的首都 $V$ 和选定的帮派，假设他们所有占领的城市的 lca 为 LCA ，那么有下面两个情况：</p><ol><li><p>lca(V, LCA) != LCA</p><p>那么被占据城市距离 $V$ 的最短距离为 $Dist(V, LCA)$ 。</p></li><li><p>lca(V, LCA) == LCA</p><p>即首都在 LCA 的子树中。对这棵子树作 dfs 序，那么距离 $V$ 最短的为 dfn 第一个在 $V$ 前面的或者第一个在 $V$ 后面的，取最小值即可。可以使用二分降低复杂度。</p><p>这里需要注意的是被占据的城市路径上的所有城市也都被占领，他们不会影响每个帮派城市lca的预处理，但会影响第二种情况，所以求的时候还需要加一个lca。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N]; <span class="comment">// 整图</span></span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; q[N]; <span class="comment">// 帮派图</span></span><br><span class="line"><span class="keyword">int</span> dfn[N], timestamp;</span><br><span class="line"><span class="keyword">int</span> top[N]; <span class="comment">// top(i) 表示i帮派占领的城市的lca</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> <span class="comment">// 根据dfs求出dfn和st表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[u] = ++ timestamp; depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> depth[a] + depth[b] - <span class="number">2</span> * depth[<span class="built_in">lca</span>(a, b)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 求出帮派图，邻接表按照dfn排序</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u); q[i].<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">if</span> (!j) top[i] = u;</span><br><span class="line">            <span class="keyword">else</span> top[i] = <span class="built_in">lca</span>(top[i], u);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 按照dfn排序</span></span><br><span class="line">        <span class="built_in">sort</span>(q[i].<span class="built_in">begin</span>(), q[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b){</span><br><span class="line">            <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> V, LCA, u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;u); <span class="comment">// LCA为被选择的帮派的lca</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; x; <span class="comment">// x存储被选择的帮派</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v); x.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (!i) LCA = top[v];</span><br><span class="line">            <span class="keyword">else</span> LCA = <span class="built_in">lca</span>(LCA, top[v]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果V和LCA的lca不是LCA，那么他们的最短距离即为V和LCA的距离</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lca</span>(V, LCA) != LCA)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">dist</span>(V, LCA));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则离V最近的一定是dfn序中靠近V的前面一个或者后面一个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : x)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> siz = q[e].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = siz;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfn[q[e][mid]] &gt;= dfn[V]) r = mid;</span><br><span class="line">                    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="number">0</span>) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r - <span class="number">1</span>])));</span><br><span class="line">                <span class="keyword">if</span> (r != siz) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r])));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Alliances&quot;&gt;&lt;a href=&quot;#Alliances&quot; class=&quot;headerlink&quot; title=&quot;Alliances&quot;&gt;&lt;/a&gt;Alliances&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="图论" scheme="https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="LCA" scheme="https://horb7.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营5</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/</id>
    <published>2022-02-17T10:24:12.000Z</published>
    <updated>2022-02-25T02:30:07.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-疫苗小孩"><a href="#A-疫苗小孩" class="headerlink" title="A. 疫苗小孩"></a>A. 疫苗小孩</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的01字符串，可以选择至多三个 $0$ ，假设它们的位置为 $i, j, k$ ，则 $W_j = w - |k-p|\times q$ ，$W_k = w - |k-p| \times q$ 。求问 $W_j + W_k$ 最大为多少。</p><p>其中 $p$ 表示与前一个选定的 $0$ 的位置差，$w, k, q$ 为给定值。</p><p>其中 $n \le 10^6, 1\le k, w, q \le 10^9$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于 $W_j$ ，要使其最大需要使 $p$ 最小，即 $i$ 与 $j$ 的差值尽量接近 $k$ ，$W_k$ 同理。</p><p>枚举 $j$ 的位置，然后使用二分求得最接近 $j-k$ 的位置（有两个可能的位置），同理求出 $j+k$ 的位置即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; zeros; <span class="comment">// 存储所有0的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) zeros.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> best, w, q; cin &gt;&gt; best &gt;&gt; w &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">0</span> || x &gt;= zeros.<span class="built_in">size</span>(); };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zeros.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] - best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] + best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// 注意pos1为第一个大于等于j-k的位置，pos1-1也可能最接近j-k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// pos2同理</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos1+k) || pos1+k &gt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> now = w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[i]-zeros[pos1+k])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 只选择前两个0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos2+l) || pos2+l &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                now = now + w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[pos2+l]-zeros[i])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 选择三个0</span></span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-战旗小孩"><a href="#C-战旗小孩" class="headerlink" title="C. 战旗小孩"></a>C. 战旗小孩</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 局游戏和原始分数 $start$，每局游戏可以选择两个英雄中的一个，使用礼遇可以选择多两个可选择英雄。</p><p>每局游戏结束后的分数为原始分数加上英雄强度。</p><p>给出每局游戏结束后上榜需要的分数，以及 $m$ 次至多能够使用的礼遇次数，和每局游戏的可选英雄强度。</p><p>游戏的顺序可以任意调整，问进行 $n$ 局游戏后，最多能够上榜几次？</p><p>$1 \le m \le n \le 20$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>二进制枚举哪些局需要使用礼遇，求出每局游戏结束后所选择的英雄强度。</p><p>由于游戏顺序可以任意调整，所以一定是先选择英雄强度高的那一局游戏，在选择低的，这样能尽量满足上榜分数。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">score</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : score) cin &gt;&gt; x;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">all</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ )</span><br><span class="line">            cin &gt;&gt; all[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ ) <span class="comment">// 枚举哪些局需要使用礼遇</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(i) &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) v.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(all[j].<span class="built_in">begin</span>(), all[j].<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="built_in">max</span>(all[j][<span class="number">0</span>], all[j][<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, st = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            st += v[i];</span><br><span class="line">            <span class="keyword">if</span> (st &gt;= score[i]) ++ now;</span><br><span class="line">        }</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-复苏小孩"><a href="#E-复苏小孩" class="headerlink" title="E. 复苏小孩"></a>E. 复苏小孩</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>三只鬼的力量分别为 $1, 1, 1$ ，遍历由 $123$ 构成的字符串时，走到 ‘$i$’ 则第 $i$ 只鬼吸收其他两只鬼一半的力量。</p><p>给定长度为 $n$ 的字符串和 $m$ 次查询，查询有以下两个操作：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个位置的字符改为 $y$ 。</li><li>$2 \ l \ r$ ，询问遍历 $[l, r]$ 子串后三只鬼的力量分别为多少。</li></ol><p>其中 $1 \le n, m \le 10^5$ 。</p><p>答案对 998244353 取模。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>假设走到 ‘1’ 位置，则相当于三只鬼的力量乘上矩阵：</p><script type="math/tex; mode=display">\left[\begin{matrix}    1 & 0 & 0 \\    \dfrac 1 2 & \dfrac 1 2 & 0 \\    \dfrac 1 2 & 0 & \dfrac 1 2 \\\end{matrix}\right]</script><p>‘2’和’3’同理，所以可以使用线段树维护区间上矩阵的乘积。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= P; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, P<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> {</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() { <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) { a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">0</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) { a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span>) { a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">2</span>] = inv; }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildI</span> <span class="params">()</span> </span>{ <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) a[i][i] = <span class="number">1</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>* (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b) {</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                ans.a[i][j] = (ans.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line">    Matrix mt; <span class="comment">// mt为[l, r]区间矩阵相乘的结果</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">};</span><br><span class="line">seg_tree t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">    t[p].mt = t[<span class="built_in">lc</span>(p)].mt * t[<span class="built_in">rc</span>(p)].mt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(s[l] - <span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(v<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Matrix ret; ret.<span class="built_in">buildI</span>();</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].mt;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    Matrix root = t[<span class="number">1</span>].mt;</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Matrix ret = <span class="built_in">query</span>(<span class="number">1</span>, x, y);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++, v = <span class="number">0</span> )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                    v = (v + ret.a[j][i]) % P;</span><br><span class="line">                cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-疫苗小孩&quot;&gt;&lt;a href=&quot;#A-疫苗小孩&quot; class=&quot;headerlink&quot; title=&quot;A. 疫苗小孩&quot;&gt;&lt;/a&gt;A. 疫苗小孩&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法训练营4</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/</id>
    <published>2022-02-17T07:04:12.000Z</published>
    <updated>2022-02-17T04:30:00.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-进制"><a href="#B-进制" class="headerlink" title="B. 进制"></a>B. 进制</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的数字串 $s$ (只有 ‘0’ ~ ‘9’ 这十种字符) ，给定 $q$ 次询问，每次询问有以下两种：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个字符修改为 $y$ ，即令 $s_x = y$ 。</li><li>$2 \ x \ y$ ，查询区间 $[l, r]$ 串能够代表的某个进制的最小值，输出其十进制表示，结果对 $1e9+7$ 取模。</li></ol><p>其中 $1 \le n, q \le 10^5$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于某个固定的区间，其每个位的数码是不变的，那么位权越小，能够表示的数字越小。所以使其最小的进制为其 $max + 1$， $max$ 表示区间最大值。</p><p>所以我们可以使用线段树维护两个信息：区间的最大值、区间数字按照九种进制运算得到的十进制数值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">2</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">11</span>], maxv;</span><br><span class="line">} t[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ )</span><br><span class="line">        t[p].d[i] = ((ll)t[<span class="built_in">lc</span>(p)].d[i] * <span class="built_in">quick_power</span>(i, t[<span class="built_in">rc</span>(p)].r - t[<span class="built_in">rc</span>(p)].l + <span class="number">1</span>) % mod + t[<span class="built_in">rc</span>(p)].d[i]) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = a[l];</span><br><span class="line">        t[p].maxv = a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        a[x] = v;</span><br><span class="line">        t[p].maxv = v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].maxv;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> (ll)t[p].d[v] * <span class="built_in">quick_power</span>(v, r - t[p].r) % mod;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) (ret += <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) (ret += <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r, <span class="built_in">query</span>(<span class="number">1</span>, l, r) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-在这冷漠的世界里光光哭哭"><a href="#L-在这冷漠的世界里光光哭哭" class="headerlink" title="L. 在这冷漠的世界里光光哭哭"></a>L. 在这冷漠的世界里光光哭哭</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的仅由小写字母构成的字符串 $s$ ，给出 $q$ 次查询，每次查询给出一个区间 $[l, r]$ 和一个长度为 $3$ 的字符串 $abc$ ，问：在 $[l, r]$ 中有多少个 $abc$ 的子序列？</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>设 $f3(k, i, j)$ 表示前 $k$ 个字符中，有多少个 $i, s[k], j$ 这样的子序列。</p><p>对于每次查询，二分算出 $b$ 字符在 $[l, r]$ 中出现的第一次位置 $pos1$ 和最后一次位置 $pos2$。</p><p>那么 $f3(pos2, a, c) - f3(pos1-1, a, c)$ 即为，当 $k$ 在 $[l, r]$ 时的所有 $abc$ 的子序列个数。</p><p>根据容斥，再将其减去 $ (a) [bc], (a) [b] (c), [ab] (c) $ 即可。其中$[ \quad ]$ 表示其在 $[l, r]$ 范围内。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80010</span>, M = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> n, q; <span class="keyword">char</span> s[N];</span><br><span class="line">ll f1[N][M]; <span class="comment">// f(i, j)表示前i个字符中有多少个j</span></span><br><span class="line">ll f2[N][M][M]; <span class="comment">// f(i, j, k)表示前i个字符中有多少个 "jk"</span></span><br><span class="line">ll f3[N][M][M]; <span class="comment">// f(k, i, j)表示前k个字符中，有多少个"i s[k] j"，注意k为最后一个字符</span></span><br><span class="line">ll tmp[M][M][M]; <span class="comment">// tmp(k, i, j)表示前k个字符中，有多少个 "i k j"</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[M]; <span class="comment">// g(c)存储字符c的所有位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 计算[l, r]有多少个"ab"</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> f2[r][a][b] - f2[l<span class="number">-1</span>][a][b] - f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        g[id].<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ ) f1[i][j] = f1[i<span class="number">-1</span>][j] + (j == s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                f2[i][j][k] = f2[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (k == s[i] - <span class="string">'a'</span> + <span class="number">1</span>) f2[i][j][k] += f1[i<span class="number">-1</span>][j];</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// "j s[i] k"</span></span><br><span class="line">                <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">                tmp[id][j][k] += f1[i<span class="number">-1</span>][j] * (f1[n][k] - f1[i][k]);</span><br><span class="line">                f3[i][j][k] = tmp[id][j][k];</span><br><span class="line">            }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="keyword">static</span> <span class="keyword">char</span> op[<span class="number">4</span>]; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;l, &amp;r, op + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = op[<span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = op[<span class="number">2</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = op[<span class="number">3</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f1[r][b] - f1[l<span class="number">-1</span>][b] == <span class="number">0</span>) { cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), l) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">upper_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), r) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        ll ans = f3[g[b][pos2<span class="number">-1</span>]][a][c] - f3[g[b][pos1<span class="number">-1</span>]][a][c]; <span class="comment">// b在[l, r]时，所有的"abc"的数量</span></span><br><span class="line">        <span class="comment">// 容斥，减去(a)[bc],(a)[b](c),[ab](c)</span></span><br><span class="line">        ans -= f1[l<span class="number">-1</span>][a] * <span class="built_in">cal</span>(l, r, b, c) + </span><br><span class="line">            f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]) * (f1[n][c] - f1[r][c]) + </span><br><span class="line">            <span class="built_in">cal</span>(l, r, a, b) * (f1[n][c] - f1[r][c]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-进制&quot;&gt;&lt;a href=&quot;#B-进制&quot; class=&quot;headerlink&quot; title=&quot;B. 进制&quot;&gt;&lt;/a&gt;B. 进制&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营3</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/</id>
    <published>2022-02-17T05:34:23.000Z</published>
    <updated>2022-02-17T04:29:51.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-智乃买瓜-another-version"><a href="#C-智乃买瓜-another-version" class="headerlink" title="C. 智乃买瓜(another version)"></a>C. 智乃买瓜(another version)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>智乃来到水果摊前买瓜，水果摊上贩卖着若干个不同的西瓜，第 $i$ 个西瓜的重量为 $w_i$ ，智乃可以买整个瓜 $w_i$ 或者把瓜劈开买半个瓜，半个瓜的重量为 $\dfrac {w_i} 2$ 。</p><p>也就是说对于每个瓜，智乃都有三种不同的决策：</p><ol><li>购买一整个重量为 $w_i$ 的西瓜。</li><li>把瓜劈开，购买半个重量为 $\dfrac {w_i} 2$ 的西瓜。</li><li>不进行购买操作。</li></ol><p>注意，每个瓜的重量都为正偶数。</p><p>现在智乃知道，购买西瓜的重量和分别为 $k = 1, 2, 3 \ldots M$ 时，购买西瓜的方案数（对 $1e9+7$ 取模）。</p><p>请构造出一个水果摊上 $N$ 个西瓜的重量，使得满足所要求的方案数量。保证数据存在 $N \le 10^3$ 的合法解。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于<strong>西瓜的重量为正偶数</strong>，所以对于重量为 $1$ 的方案，它只能由重量为 $2$ 的西瓜劈开得到。</p><p>那么我们就可以根据 $k=1$ 的情况，<strong>去除掉所有方案数中重量为 $2$ 的西瓜对其造成的影响。</strong></p><p>去除后，所有的方案数都不会和重量为 $2$ 的西瓜有关，那么 $k=2$ 时的方案数就只能由重量为 $4$ 的西瓜构成。</p><p>依次去除所有的西瓜即可，把去除的西瓜加到结果数组即可。</p><p><strong>注意点</strong>：</p><ol><li>正向dp的枚举顺序是从后往前，目的是沿用上一层的原始数据。逆向dp也需要减去原始数据，所以要从前往后，否则减去的是这一层的数据。</li><li>正向dp时 $dp[0] = 1$ ，逆向dp也需要加上去。</li></ol><p>本题提示了西瓜的质量为正偶数，如果没有提示，也要往构造所有正偶数质量西瓜去思考。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> (x % p + p) % p; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; dp[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">while</span>(dp[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 把 2*i 的西瓜去除</span></span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">2</span> * i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">            {</span><br><span class="line">                dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j-i]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">2</span> * i) dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j<span class="number">-2</span>*i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-智乃的树旋转-hard-version"><a href="#H-智乃的树旋转-hard-version" class="headerlink" title="H. 智乃的树旋转(hard version)"></a>H. 智乃的树旋转(hard version)</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $N$ 个节点的二叉树，智乃将其做了若干次旋转将其打乱，她想要将其还原，要求旋转操作次数不超过 $N^2$ 次。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote><p>第一行输入正整数 $N$ ($1 \le N \le 10^3$) ，表示二叉树的节点数量。</p><p>接下来 $N$ 行输入二叉树一开始的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为 $0$ 时，则表示该节点无右子树。</p><p>接下来 $N$ 行输入二叉树被打乱后的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为$0$时，则表示该节点无右子树。</p><p>要求你将打乱后的二叉树通过一系列旋转操作还原</p></blockquote><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote><p>首先输出一个整数 $K$ ，表示你还原二叉树进行旋转的次数，要求你给出 $K$ 的范围在 $[0,N2]$ ，接下来 $K$ 行，依次输出旋转操作的旋转轴。</p><p>由于旋转轴只能进行左旋转或者右旋转其中的一种，裁判程序将会自己判断当前需要进行的是左旋转还是右旋转。</p><p>注意：旋转过程中的根节点无法作为旋转轴进行旋转，如果你指定旋转过程中的根节点作为旋转轴，则裁判程序将直接给出WA的结果。</p></blockquote><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>如何将打乱的树还原？可以按照原来的树的先序遍历，依次把每个节点在打乱的树上做splay，单旋情况下，每个节点最多旋转 $n-1$ 次，总次数不超过 $n^2$ 的 数量级。</p><p>所以只需要记录每次旋转时的旋转轴即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span> <span class="keyword">int</span> fa, ch[<span class="number">2</span>]; } a[N], t[N]; <span class="comment">// 原树和打乱后的树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 把u节点向上旋转一次</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> fa = t[u].fa;</span><br><span class="line">    <span class="keyword">int</span> gfa = t[fa].fa;</span><br><span class="line">    <span class="keyword">int</span> t1 = (u != t[fa].ch[<span class="number">0</span>]); <span class="comment">// u是fa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> t2 = (fa != t[gfa].ch[<span class="number">0</span>]); <span class="comment">// fa是gfa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> ch = t[u].ch[t1 ^ <span class="number">1</span>]; <span class="comment">// 需要被用来和fa交换的u的孩子</span></span><br><span class="line">    t[u].fa = gfa;</span><br><span class="line">    t[u].ch[t1 ^ <span class="number">1</span>] = fa;</span><br><span class="line">    t[fa].ch[t1] = ch;</span><br><span class="line">    t[fa].fa = u;</span><br><span class="line">    t[ch].fa = fa;</span><br><span class="line">    t[gfa].ch[t2] = u;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入树，返回这个树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_tree</span> <span class="params">(tree * t, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        t[i].ch[<span class="number">0</span>] = u; t[i].ch[<span class="number">1</span>] = v;</span><br><span class="line">        vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (u) t[u].fa = i;</span><br><span class="line">        <span class="keyword">if</span> (v) t[v].fa = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N] = { <span class="literal">true</span> }; <span class="comment">// 当前点是否被旋转到根过，0设置为true，因为0是树根的fa</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">int</span> n, root_a, <span class="keyword">root_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(!st[t[u].fa]) <span class="comment">// 父节点还没有被旋转，也就是还没有修正</span></span><br><span class="line">    {</span><br><span class="line">        ret.<span class="built_in">push_back</span>(u); <span class="comment">// u需要旋转</span></span><br><span class="line">        <span class="built_in">rot</span>(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 先序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">splay</span>(u); st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">0</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">1</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    root_a = <span class="built_in">input_tree</span>(a, n);</span><br><span class="line">    <span class="keyword">root_t</span> = <span class="built_in">input_tree</span>(t, n);</span><br><span class="line">    <span class="built_in">dfs</span>(root_a); <span class="comment">// 对原树进行先序遍历，依次对打乱的树进行splay</span></span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-智乃的C语言模除方程"><a href="#J-智乃的C语言模除方程" class="headerlink" title="J. 智乃的C语言模除方程"></a>J. 智乃的C语言模除方程</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$x \ \% \ P = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>模除方程 $x \ \% \ P = Q$ ，即 $x = k \times P + Q$ ，$Q &lt; P$ 。</p><p>由于 $Q$ 是 $[l, r]$ 的任意整数，所以显然 $x$ 的定义域为若干个连续子段。</p><p>对于 $[L, R]$ 的查询，设 $f(X)$ 表示 $[0, abs(X)]$ 中满足条件的 $x$ 数量。</p><p>然后需要根据 $L, R$ 的大小分类。</p><ol><li><p>$0 \le L \le R$ </p><p>答案为 $f(R) - f(L - 1)$ 。</p></li><li><p>$L \le 0 \le R$</p><p>答案为 $f(R) + f(L) - f(0)$ 。</p></li><li><p>$L \le R \le 0$ </p><p>答案为 $f(L) - f(R + 1)$ 。</p></li></ol><p>所以接下来需要求出 $f(x)$ 。这里又需要对 $x$ 的大小分类。</p><ol><li><p>$x \ge 0$ </p><p>$f(x)$ 表示 $[0, x]$ 范围，算出所有子段与 $[0, x]$ 的交集。</p><p>整段一共有 $x/P$ 个，注意每一段都要和 $[l, r]$ 取交集 ，然后算出最后一段 $[0, x\%P]$ 和 $[l, r]$ 的交集。</p><p>取交集：$x \% P$ 的余数范围 $[0, P-1]$ ，而 $Q$ 范围 $[l, r]$ ，需要取交集。</p></li><li><p>$x \lt 0$ </p><p>$f(x)$ 表示 $[-x, 0]$ 的范围，也需要算出所有子段与 $[-x, 0]$ 的交集。</p><p>但是由于C语言模除的结果与被除数相同，所以最后的答案也为负数，所以余数范围为负数 $[-P+1, 0]$ 。</p></li></ol><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="comment">// [l, r] 与 [a, b] 的交集</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, <span class="built_in">min</span>(r, b) - <span class="built_in">max</span>(a, l) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(u/p) * <span class="built_in">get</span>(-p+<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">get</span>(u%p,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u/p * <span class="built_in">get</span>(<span class="number">0</span>, p<span class="number">-1</span>) + <span class="built_in">get</span>(<span class="number">0</span>, u%p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    p = <span class="built_in">abs</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= <span class="number">0</span> &amp;&amp; R &gt;= <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(L) + <span class="built_in">f</span>(R) - <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; <span class="number">0</span> &amp;&amp; R &gt; <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(R) - <span class="built_in">f</span>(L<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">f</span>(L) - <span class="built_in">f</span>(R+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-智乃的C语言模除方程-another-version"><a href="#K-智乃的C语言模除方程-another-version" class="headerlink" title="K. 智乃的C语言模除方程(another version)"></a>K. 智乃的C语言模除方程(another version)</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$P \ \% \ x = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>本题和上题唯一的区别在于 $x$ 和 $P$ 在方程的位置交换。</p><p>对于 $P \ \% \ x = Q$ ，有 $P - \lfloor \dfrac P x \rfloor \times x = Q$ 。</p><p>枚举 $x$ 的值，则可以知道 $\lfloor \dfrac P x \rfloor$ 的值，令其为 $c$ ，则变为 $P - c \times x = Q$ 。其中 $P - c \times x$ 为等差数列。</p><p>则问题变为：给定等差数列，问其第 $L$ 项到第 $R$ 项，有多少项在 $[l, r]$ 中。</p><p>根据 $\lfloor \dfrac P x \rfloor$ 的性质，可以使用整除分块来枚举 $x$ 的值。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">ll P, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">intersect</span> <span class="params">(ll l0, ll r0, ll l1, ll r1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(l0, l1);</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(r0, r1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, ansr - ansl + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(ll k, ll cl, ll cr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(cr,(P-l)/k);</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(cl,(P-r+k<span class="number">-1</span>)/k);</span><br><span class="line">  </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ans += <span class="built_in">intersect</span>(ansl,ansr,L,R);</span><br><span class="line">    ans += <span class="built_in">intersect</span>(-ansr,-ansl,L,R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="keyword">if</span> (P &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        P = -P;</span><br><span class="line">        <span class="built_in">swap</span>(l, r);</span><br><span class="line">        l = -l;</span><br><span class="line">        r = -r;</span><br><span class="line">    }</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">0ll</span>, l);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先枚举x的值绝对值在P范围内的情况，即[1, P]</span></span><br><span class="line">    <span class="keyword">for</span> (ll cl = <span class="number">1</span>, cr; cl &lt;= P; cl = cr + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ll k = P / cl;</span><br><span class="line">        cr = P / k;</span><br><span class="line">        ans += <span class="built_in">cal</span>(k, cl, cr); <span class="comment">// 计算x的倍数为k，且x位于[cl, cr]时的情况</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= P &amp;&amp; r &gt;= P)</span><br><span class="line">    {</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, P+<span class="number">1</span>, (ll)(<span class="number">1e10</span>));</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, -(ll)(<span class="number">1e10</span>), -(P+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-智乃买瓜-another-version&quot;&gt;&lt;a href=&quot;#C-智乃买瓜-another-version&quot; class=&quot;headerlink&quot; title=&quot;C. 智乃买瓜(another version)&quot;&gt;&lt;/a&gt;C. 智乃买瓜(another ve</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营2</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/</id>
    <published>2022-02-17T04:09:12.000Z</published>
    <updated>2022-02-17T04:29:38.529Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="A-小沙的炉石"><a href="#A-小沙的炉石" class="headerlink" title="A. 小沙的炉石"></a>A. 小沙的炉石</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 张法术攻击牌和 $m$ 张法术恢复牌，每次攻击消耗一点法力，造成 $1$ 点伤害，恢复牌不消耗法力，可以恢复一点法力。小沙一开始有 $1$ 点法力，法力没有上限。</p><p>每次使用一张法力牌，都会使后面的攻击伤害 $+1$ 。</p><p>给出 $q$ 次询问，每次给出敌人的血量，问能否将其<strong>恰好斩杀</strong>？</p><p>恰好斩杀：正好使得敌方血量变为 $0$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果使用的攻击牌和恢复牌的数量一定，那么可以造成的伤害一定是一个连续的区间。</p><blockquote><p>假设使用 $a$ 张攻击牌和 $b$ 张恢复牌，注意 $a \le b + 1$ 。</p><p>此时最小攻击伤害为：攻击、恢复、攻击、恢复…… ，伤害为 $\sum_{i=1}^a{2 \times i - 1} = a ^ 2$ 。</p><p>每次可以将序列中的一对 [攻击，恢复] 组合调换，造成伤害 $+1$ 。</p><p>最大伤害为：恢复、恢复、恢复、……、攻击、攻击。伤害为 $\sum_{i=1}^{a} b + i = \dfrac {((b + 1) + (b + a)) * a} 2$ 。 </p></blockquote><p>对于每次询问，由于需要恰好斩杀，因此<strong>最多</strong>能够使用的攻击牌是 $min(min(n, m+1), sqrt(hp))$ 。</p><p>由于造成伤害的区间是连续的，因此只需要看最大能造成的伤害是否超过 $hp$ 即可。</p><p>不需要判断最小造成的伤害，因为取到的攻击牌数一定 $\le$ $sqrt(hp)$ 。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    n = <span class="built_in">min</span>(n, m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> hp; cin &gt;&gt; hp;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">min</span>(n, (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(hp));</span><br><span class="line">        <span class="keyword">int</span> maxv = (m + <span class="number">1</span> + m + R) * R / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxv &gt;= hp) cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-小沙的魔法"><a href="#B-小沙的魔法" class="headerlink" title="B. 小沙的魔法"></a>B. 小沙的魔法</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个点和 $m$ 条边，初始时每个点权值为 $x_i = 0$ 。初始时图上无边，每次可以进行以下操作中的一种：</p><ol><li>在 $m$ 条边中选择一条没有被选择过的边加入图中。</li><li>将图中的一个极大连通子图的每个点权值 $+1$ 。</li></ol><p>给定边可能出现重边，自环。</p><p>问最少操作多少次操作2，才能使对于任意点有 $x_i = a_i$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>要使区间增加到目标值，等价于区间每个值初始为 $a_i$ ，每次使得区间值 $-1$ ，最终使区间值全部为 $0$ 。</p><p>优先减去权值最大的，在减去权值最大点的同时，可以顺带减去和它在同一个连通子图的所有点的权值，这整个连通子图全部变为 $0$ ，代价就是权值最大的那个点的权值。</p><p>按权值对每个点的位置排序，从大到小依次遍历当前点的相邻点，把当前点和权值比它大的点合并，先把权值大的点减到和当前点相同的权值，代价为 $a_{gt} - a_{cur}$ 。</p><p>这样最后的图会形成若干个连通子图，再把这些连通子图最小的权值加起来就是最少需要的操作2，加最小权值是因为我们先把比它大的权值点先减到和它权值相同。这也意味这合并时要以权值小的点为根。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[N], id[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">iota</span>(f, f + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">iota</span>(id, id + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) {</span><br><span class="line">        <span class="keyword">return</span> a[x] &gt; a[y]; </span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = id[i]; i &lt;= n; i ++, u = id[i] )</span><br><span class="line">    {</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = h[u]; ~k; k = ne[k])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[k];</span><br><span class="line">            <span class="keyword">int</span> pu = <span class="built_in">find</span>(u), pj = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (vis[j] &amp;&amp; pu != pj)</span><br><span class="line">            {</span><br><span class="line">                res += a[pj] - a[u];</span><br><span class="line">                f[pj] = pu;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i) res += a[i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-小沙的长路"><a href="#E-小沙的长路" class="headerlink" title="E. 小沙的长路"></a>E. 小沙的长路</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>规定有向完全图每条边只能走一次，问：$n$ 个点的有向完全图的最长路径的最大值和最小值分别为多少？</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>$n$ 个点的有向完全图，最长路径一定经过了 $n$ 个点。</p><p>对于最小：如果图上有环，那么经过环一定比不经过环更长，所以我们要使图上无环，这样每个点只走一次，最短为 $n-1$ 。</p><p>对于最长：尽可能走完所有边，等价于给定有向完全图，删除尽可能少的边，使得剩下的图为欧拉图。如果 $n$ 为奇数，那么每个点连接偶数条边，一定存在一个有向无环图为欧拉图。如果 $n$ 为偶数，每个点连接奇数条边，欧拉图至多有 $2$ 个奇数点，也就是要使得 $n-2$ 个点变成偶数，删除一条边改变两个点度的奇偶性，所以需要删除 $\dfrac {n-2} 2$ 条边。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxv;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span> - (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; maxv &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-小沙的算数"><a href="#F-小沙的算数" class="headerlink" title="F. 小沙的算数"></a>F. 小沙的算数</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个算数式（只包含加法和乘法），每次询问把一个数字替换为其他数字，问替换完后的结果为多少？（询问不独立，上一次的修改会影响下一次询问）。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于算数式只包含加法和乘法，而乘法具有连乘性质，所以需要维护乘法区间的乘积。</p><p>对于乘法，只需要修改连乘区间的结果即可。对于加法，直接修改即可。</p><p>维护每个区间的乘法结果，可以使用并查集，开一个 $prod$ 数组表示每个集合的乘积。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, ret;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], prod[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="built_in">quick_power</span>(x, mod<span class="number">-2</span>); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mod</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>{ <span class="keyword">return</span> (x % mod + mod) % mod; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    prod[y] = <span class="built_in">Mod</span>((ll)prod[y] * prod[x]);</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], prod[i] = a[i];</span><br><span class="line">    <span class="comment">// 把乘积合并起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, ans = a[i];</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans = <span class="built_in">Mod</span>((ll)ans * a[j + <span class="number">1</span>]);</span><br><span class="line">            vis[j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">merge</span>(j, j + <span class="number">1</span>);</span><br><span class="line">            ++ j;</span><br><span class="line">        }</span><br><span class="line">        ret = <span class="built_in">Mod</span>((ll)ret + ans);</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) ret = <span class="built_in">Mod</span>((ll)ret + a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id, to; cin &gt;&gt; id &gt;&gt; to;</span><br><span class="line">        <span class="keyword">if</span> (id != n &amp;&amp; s[id] == <span class="string">'*'</span> || id &gt; <span class="number">1</span> &amp;&amp; s[id<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于乘法区间</span></span><br><span class="line">            <span class="keyword">int</span> par = <span class="built_in">find</span>(id);</span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret + <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * <span class="built_in">Mod</span>((ll)to - a[id])));</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            prod[par] = <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * to);</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于加法区间</span></span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret - a[id] + to);</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-小沙的身法"><a href="#G-小沙的身法" class="headerlink" title="G. 小沙的身法"></a>G. 小沙的身法</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个节点的无根无向树，每个节点有权值 $a_i$ ，规定从 $i$ 节点跳到其相邻节点 $j$ 的代价为 $max(0, a_j - a_i)$ 。即从权值低的点跳到权值高的点，代价为其权值差；从权值高的点跳到权值低的点，代价为 $0$ 。</p><p>给定 $m$ 次询问，每次询问：从地面(权值为 $0$)跳到 $u$ 节点，再从 $u$ 节点跳到 $v$ 节点，再从 $v$ 节点跳到地面，最少消耗的代价为多少？</p><p>其中 $1 \le n \le 10^6$ ，$1 \le m \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>对于无向树而言，两个节点之间只有一条简单路径。所以要消耗体力最小，就是走这条简单路径，即路径是唯一的。</p><p>从地面跳到 $u$ 节点，从 $v$ 节点跳到地面的代价为 $a_u$ 。</p><p>从 $u$ 点跳到 $v$ 点的代价，等价于从 $u$ 点跳到根节点的代价，加上从根节点跳到 $v$ 节点的代价，再减去从其 $lca$ 跳到根节点的代价，以及从根节点跳到 $lca$ 的代价。</p><p>由于代价不具有对称性，即从 $u$ 跳到根节点和从根节点跳到 $u$ 节点不是对称的，所以要dfs两次算出从根节点出发到其他点的代价，以及从其他点到达根节点的代价。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, M = N &lt;&lt; <span class="number">2</span>;</span><br><span class="line">ll a[N], d[N], rd[N];</span><br><span class="line"><span class="keyword">namespace</span> LCA {</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> n, h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> fa[N][SIZE + <span class="number">1</span>], depth[N];</span><br><span class="line">    <span class="keyword">int</span> q[N]; <span class="keyword">bool</span> st[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">fill</span>(h, h + n + <span class="number">1</span>, <span class="number">-1</span>); idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="built_in">fill</span>(fa[i], fa[i] + SIZE + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fill</span>(depth, depth + n + <span class="number">1</span>, <span class="number">0</span>); <span class="built_in">fill</span>(st, st + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ; }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = root; depth[root] = <span class="number">1</span>; st[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt) {</span><br><span class="line">            <span class="keyword">int</span> u = q[hh ++ ];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) {</span><br><span class="line">                <span class="keyword">int</span> j = e[i]; <span class="keyword">if</span> (st[j]) <span class="keyword">continue</span>;</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                depth[j] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                fa[j][<span class="number">0</span>] = u;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= SIZE; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">                fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i];</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">        <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    d[u] = d[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &gt; a[fa]) d[u] += a[u] - a[fa];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rd[u] = rd[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &lt; a[fa]) rd[u] += a[fa] - a[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">rdfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n - <span class="number">1</span> &amp;&amp; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v); i ++ ) <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">rdfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y; <span class="keyword">int</span> f = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[x] + rd[x] + d[y] - rd[f] - d[f]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-amp-M-小沙的remake"><a href="#L-amp-M-小沙的remake" class="headerlink" title="L &amp; M. 小沙的remake"></a>L &amp; M. 小沙的remake</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，选择若干个数字组成最长不下降子序列，使得被选中的每个元素，设其位置为 $i$ ，它前面 $b_i$ 个元素至少也有一个被选择。问这样的子序列有多少种？</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>树状数组维护：对于每个位置而言，以它为结尾至少有多少种满足条件的子序列个数。</p><p>按元素权值从小到大排序，从前往后遍历，对于每个元素，设位置为 $i$，查询 $[i-b_i, i)$ 中每个位置的值，相加即为以当前元素为结尾的子序列的方案数。</p><p>这里的Code不按照题目要求的生成数据，方便参照。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b[N];</span><br><span class="line">T a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N]; <span class="comment">// 树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) c[x] = ((ll)c[x] + v) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x ) sum = ((ll)sum + c[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i].x &gt;&gt; b[i], a[i].y = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ll val = <span class="built_in">query</span>(a[i].y - <span class="number">1</span>) - <span class="built_in">query</span>(a[i].y - b[a[i].y] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        val %= mod;</span><br><span class="line">        res = (res + val + mod) % mod;</span><br><span class="line">        <span class="built_in">add</span>(a[i].y, val);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;A-小沙的炉石&quot;&gt;&lt;a href=&quot;#A-小沙的炉石&quot; class=&quot;headerlink&quot; title=&quot;A. 小沙的炉石&quot;&gt;&lt;/a&gt;A. 小沙的炉石&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
</feed>
