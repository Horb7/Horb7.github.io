<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Horb7&#39;s blog</title>
  
  <subtitle>一日事，一日毕</subtitle>
  <link href="https://horb7.github.io/atom.xml" rel="self"/>
  
  <link href="https://horb7.github.io/"/>
  <updated>2022-02-24T16:57:27.471Z</updated>
  <id>https://horb7.github.io/</id>
  
  <author>
    <name>Horb7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客秋季算法班LCA-E-华华和月月种树</title>
    <link href="https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/"/>
    <id>https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/</id>
    <published>2022-02-20T08:48:28.000Z</published>
    <updated>2022-02-24T16:57:27.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="华华和月月种树"><a href="#华华和月月种树" class="headerlink" title="华华和月月种树"></a>华华和月月种树</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>维护一个动态有根树，每个点都有一个权值，开始时只有一个 $0$ 号节点，权值为 $0$ 。有以下操作：</p><ol><li>$1 \ \ i$ ，表示 $i$ 节点长出一个新的子节点，权值为 $0$ ，编号为目前最大编号 $+1$ 。</li><li>$2 \ \ i \ \ a$ ，表示节点 $i$ 的子树的所有节点 (包括 $i$ 节点) 权值 $+a$ 。</li><li>$3 \ \ i$ ，表示查询节点 $i$ 此时的权值。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>离线 + 树状数组</strong></p><p>先根据所有的操作建立一棵树，求得所有节点的dfs序，即可在区间上操作。</p><p>树状数组维护差分的前缀。</p><p>对于操作1，记录它在权值为 $0$ 的时候（刚被开辟出来）它的前缀和，查询该点时减去这个值即可。</p><p>对于操作2，只需要在 $[l[i], r[i]]$ 上所有点权值 $+a$ 即可，使用差分。其中 $l[i]$ 和 $r[i]$ 表示 $i$ 点的进出栈时间(dfs序) 。</p><p>对于操作3，查询前缀和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> op[N], a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> val[N], c[N], l[N], r[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 一开始有一个节点0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    l[u] = ++ cnt; <span class="comment">// 最早的timestamp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (u != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    r[u] = cnt; <span class="comment">// 最晚的timestamp</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) res += c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; op[i] &gt;&gt; a[i];</span><br><span class="line">        ++ a[i]; <span class="comment">// 注意树状数组只能维护[1, n]的区间，不能包括0</span></span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            g[a[i]].<span class="built_in">push_back</span>(++ cnt);</span><br><span class="line">            b[i] = cnt; <span class="comment">// b[i]表示第i个操作后，新的节点编号</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>) cin &gt;&gt; b[i]; <span class="comment">// b[i]表示加多少</span></span><br><span class="line">    }</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 转化为dfs序，进行区间运算</span></span><br><span class="line">    <span class="comment">// 树状数组的区间加+单点查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>) <span class="comment">// 加新的节点</span></span><br><span class="line">        {</span><br><span class="line">            val[l[b[i]]] += <span class="built_in">query</span>(l[a[i]]); <span class="comment">// val(i)表示i点加了多少</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">update</span>(l[a[i]], b[i]);</span><br><span class="line">            <span class="built_in">update</span>(r[a[i]] + <span class="number">1</span>, -b[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(l[a[i]]) - val[l[a[i]]] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;华华和月月种树&quot;&gt;&lt;a href=&quot;#华华和月月种树&quot; class=&quot;headerlink&quot; title=&quot;华华和月月种树&quot;&gt;&lt;/a&gt;华华和月月种树&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="数据结构" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树状数组" scheme="https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客秋季算法班LCA-D.Alliances</title>
    <link href="https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/"/>
    <id>https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/</id>
    <published>2022-02-20T07:40:34.000Z</published>
    <updated>2022-02-20T07:52:22.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alliances"><a href="#Alliances" class="headerlink" title="Alliances"></a>Alliances</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>链接：<a href="https://ac.nowcoder.com/acm/contest/27836/D">https://ac.nowcoder.com/acm/contest/27836/D</a></p><p>  树国是一个有 $n$ 个城市的国家，城市编号为 $1 \sim n$ 。连接这些城市的道路网络形如一棵树， </p><p>  即任意两个城市之间有恰好一条路径。城市中有k个帮派，编号为 $1 \sim k$ 。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。 </p><p>  当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。 </p><p>  shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于选定的首都 $V$ 和选定的帮派，假设他们所有占领的城市的 lca 为 LCA ，那么有下面两个情况：</p><ol><li><p>lca(V, LCA) != LCA</p><p>那么被占据城市距离 $V$ 的最短距离为 $Dist(V, LCA)$ 。</p></li><li><p>lca(V, LCA) == LCA</p><p>即首都在 LCA 的子树中。对这棵子树作 dfs 序，那么距离 $V$ 最短的为 dfn 第一个在 $V$ 前面的或者第一个在 $V$ 后面的，取最小值即可。可以使用二分降低复杂度。</p><p>这里需要注意的是被占据的城市路径上的所有城市也都被占领，他们不会影响每个帮派城市lca的预处理，但会影响第二种情况，所以求的时候还需要加一个lca。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N]; <span class="comment">// 整图</span></span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; q[N]; <span class="comment">// 帮派图</span></span><br><span class="line"><span class="keyword">int</span> dfn[N], timestamp;</span><br><span class="line"><span class="keyword">int</span> top[N]; <span class="comment">// top(i) 表示i帮派占领的城市的lca</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> <span class="comment">// 根据dfs求出dfn和st表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[u] = ++ timestamp; depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> depth[a] + depth[b] - <span class="number">2</span> * depth[<span class="built_in">lca</span>(a, b)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 求出帮派图，邻接表按照dfn排序</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u); q[i].<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">if</span> (!j) top[i] = u;</span><br><span class="line">            <span class="keyword">else</span> top[i] = <span class="built_in">lca</span>(top[i], u);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 按照dfn排序</span></span><br><span class="line">        <span class="built_in">sort</span>(q[i].<span class="built_in">begin</span>(), q[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b){</span><br><span class="line">            <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> V, LCA, u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;u); <span class="comment">// LCA为被选择的帮派的lca</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; x; <span class="comment">// x存储被选择的帮派</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v); x.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (!i) LCA = top[v];</span><br><span class="line">            <span class="keyword">else</span> LCA = <span class="built_in">lca</span>(LCA, top[v]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果V和LCA的lca不是LCA，那么他们的最短距离即为V和LCA的距离</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lca</span>(V, LCA) != LCA)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">dist</span>(V, LCA));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则离V最近的一定是dfn序中靠近V的前面一个或者后面一个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : x)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> siz = q[e].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = siz;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfn[q[e][mid]] &gt;= dfn[V]) r = mid;</span><br><span class="line">                    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="number">0</span>) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r - <span class="number">1</span>])));</span><br><span class="line">                <span class="keyword">if</span> (r != siz) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r])));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Alliances&quot;&gt;&lt;a href=&quot;#Alliances&quot; class=&quot;headerlink&quot; title=&quot;Alliances&quot;&gt;&lt;/a&gt;Alliances&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="图论" scheme="https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="LCA" scheme="https://horb7.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营5</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/</id>
    <published>2022-02-17T10:24:12.000Z</published>
    <updated>2022-02-25T02:30:07.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-疫苗小孩"><a href="#A-疫苗小孩" class="headerlink" title="A. 疫苗小孩"></a>A. 疫苗小孩</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的01字符串，可以选择至多三个 $0$ ，假设它们的位置为 $i, j, k$ ，则 $W_j = w - |k-p|\times q$ ，$W_k = w - |k-p| \times q$ 。求问 $W_j + W_k$ 最大为多少。</p><p>其中 $p$ 表示与前一个选定的 $0$ 的位置差，$w, k, q$ 为给定值。</p><p>其中 $n \le 10^6, 1\le k, w, q \le 10^9$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于 $W_j$ ，要使其最大需要使 $p$ 最小，即 $i$ 与 $j$ 的差值尽量接近 $k$ ，$W_k$ 同理。</p><p>枚举 $j$ 的位置，然后使用二分求得最接近 $j-k$ 的位置（有两个可能的位置），同理求出 $j+k$ 的位置即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; zeros; <span class="comment">// 存储所有0的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) zeros.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> best, w, q; cin &gt;&gt; best &gt;&gt; w &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">0</span> || x &gt;= zeros.<span class="built_in">size</span>(); };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zeros.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] - best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] + best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// 注意pos1为第一个大于等于j-k的位置，pos1-1也可能最接近j-k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// pos2同理</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos1+k) || pos1+k &gt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> now = w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[i]-zeros[pos1+k])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 只选择前两个0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos2+l) || pos2+l &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                now = now + w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[pos2+l]-zeros[i])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 选择三个0</span></span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-战旗小孩"><a href="#C-战旗小孩" class="headerlink" title="C. 战旗小孩"></a>C. 战旗小孩</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 局游戏和原始分数 $start$，每局游戏可以选择两个英雄中的一个，使用礼遇可以选择多两个可选择英雄。</p><p>每局游戏结束后的分数为原始分数加上英雄强度。</p><p>给出每局游戏结束后上榜需要的分数，以及 $m$ 次至多能够使用的礼遇次数，和每局游戏的可选英雄强度。</p><p>游戏的顺序可以任意调整，问进行 $n$ 局游戏后，最多能够上榜几次？</p><p>$1 \le m \le n \le 20$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>二进制枚举哪些局需要使用礼遇，求出每局游戏结束后所选择的英雄强度。</p><p>由于游戏顺序可以任意调整，所以一定是先选择英雄强度高的那一局游戏，在选择低的，这样能尽量满足上榜分数。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">score</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : score) cin &gt;&gt; x;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">all</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ )</span><br><span class="line">            cin &gt;&gt; all[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ ) <span class="comment">// 枚举哪些局需要使用礼遇</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(i) &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) v.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(all[j].<span class="built_in">begin</span>(), all[j].<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="built_in">max</span>(all[j][<span class="number">0</span>], all[j][<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, st = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            st += v[i];</span><br><span class="line">            <span class="keyword">if</span> (st &gt;= score[i]) ++ now;</span><br><span class="line">        }</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-复苏小孩"><a href="#E-复苏小孩" class="headerlink" title="E. 复苏小孩"></a>E. 复苏小孩</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>三只鬼的力量分别为 $1, 1, 1$ ，遍历由 $123$ 构成的字符串时，走到 ‘$i$’ 则第 $i$ 只鬼吸收其他两只鬼一半的力量。</p><p>给定长度为 $n$ 的字符串和 $m$ 次查询，查询有以下两个操作：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个位置的字符改为 $y$ 。</li><li>$2 \ l \ r$ ，询问遍历 $[l, r]$ 子串后三只鬼的力量分别为多少。</li></ol><p>其中 $1 \le n, m \le 10^5$ 。</p><p>答案对 998244353 取模。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>假设走到 ‘1’ 位置，则相当于三只鬼的力量乘上矩阵：</p><script type="math/tex; mode=display">\left[\begin{matrix}    1 & 0 & 0 \\    \dfrac 1 2 & \dfrac 1 2 & 0 \\    \dfrac 1 2 & 0 & \dfrac 1 2 \\\end{matrix}\right]</script><p>‘2’和’3’同理，所以可以使用线段树维护区间上矩阵的乘积。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= P; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, P<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> {</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() { <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) { a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">0</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) { a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span>) { a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">2</span>] = inv; }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildI</span> <span class="params">()</span> </span>{ <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) a[i][i] = <span class="number">1</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>* (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b) {</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                ans.a[i][j] = (ans.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line">    Matrix mt; <span class="comment">// mt为[l, r]区间矩阵相乘的结果</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">};</span><br><span class="line">seg_tree t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">    t[p].mt = t[<span class="built_in">lc</span>(p)].mt * t[<span class="built_in">rc</span>(p)].mt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(s[l] - <span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(v<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Matrix ret; ret.<span class="built_in">buildI</span>();</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].mt;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    Matrix root = t[<span class="number">1</span>].mt;</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Matrix ret = <span class="built_in">query</span>(<span class="number">1</span>, x, y);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++, v = <span class="number">0</span> )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                    v = (v + ret.a[j][i]) % P;</span><br><span class="line">                cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-疫苗小孩&quot;&gt;&lt;a href=&quot;#A-疫苗小孩&quot; class=&quot;headerlink&quot; title=&quot;A. 疫苗小孩&quot;&gt;&lt;/a&gt;A. 疫苗小孩&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法训练营4</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/</id>
    <published>2022-02-17T07:04:12.000Z</published>
    <updated>2022-02-17T04:30:00.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-进制"><a href="#B-进制" class="headerlink" title="B. 进制"></a>B. 进制</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的数字串 $s$ (只有 ‘0’ ~ ‘9’ 这十种字符) ，给定 $q$ 次询问，每次询问有以下两种：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个字符修改为 $y$ ，即令 $s_x = y$ 。</li><li>$2 \ x \ y$ ，查询区间 $[l, r]$ 串能够代表的某个进制的最小值，输出其十进制表示，结果对 $1e9+7$ 取模。</li></ol><p>其中 $1 \le n, q \le 10^5$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于某个固定的区间，其每个位的数码是不变的，那么位权越小，能够表示的数字越小。所以使其最小的进制为其 $max + 1$， $max$ 表示区间最大值。</p><p>所以我们可以使用线段树维护两个信息：区间的最大值、区间数字按照九种进制运算得到的十进制数值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">2</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">11</span>], maxv;</span><br><span class="line">} t[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ )</span><br><span class="line">        t[p].d[i] = ((ll)t[<span class="built_in">lc</span>(p)].d[i] * <span class="built_in">quick_power</span>(i, t[<span class="built_in">rc</span>(p)].r - t[<span class="built_in">rc</span>(p)].l + <span class="number">1</span>) % mod + t[<span class="built_in">rc</span>(p)].d[i]) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = a[l];</span><br><span class="line">        t[p].maxv = a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        a[x] = v;</span><br><span class="line">        t[p].maxv = v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].maxv;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> (ll)t[p].d[v] * <span class="built_in">quick_power</span>(v, r - t[p].r) % mod;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) (ret += <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) (ret += <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r, <span class="built_in">query</span>(<span class="number">1</span>, l, r) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-在这冷漠的世界里光光哭哭"><a href="#L-在这冷漠的世界里光光哭哭" class="headerlink" title="L. 在这冷漠的世界里光光哭哭"></a>L. 在这冷漠的世界里光光哭哭</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的仅由小写字母构成的字符串 $s$ ，给出 $q$ 次查询，每次查询给出一个区间 $[l, r]$ 和一个长度为 $3$ 的字符串 $abc$ ，问：在 $[l, r]$ 中有多少个 $abc$ 的子序列？</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>设 $f3(k, i, j)$ 表示前 $k$ 个字符中，有多少个 $i, s[k], j$ 这样的子序列。</p><p>对于每次查询，二分算出 $b$ 字符在 $[l, r]$ 中出现的第一次位置 $pos1$ 和最后一次位置 $pos2$。</p><p>那么 $f3(pos2, a, c) - f3(pos1-1, a, c)$ 即为，当 $k$ 在 $[l, r]$ 时的所有 $abc$ 的子序列个数。</p><p>根据容斥，再将其减去 $ (a) [bc], (a) [b] (c), [ab] (c) $ 即可。其中$[ \quad ]$ 表示其在 $[l, r]$ 范围内。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80010</span>, M = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> n, q; <span class="keyword">char</span> s[N];</span><br><span class="line">ll f1[N][M]; <span class="comment">// f(i, j)表示前i个字符中有多少个j</span></span><br><span class="line">ll f2[N][M][M]; <span class="comment">// f(i, j, k)表示前i个字符中有多少个 "jk"</span></span><br><span class="line">ll f3[N][M][M]; <span class="comment">// f(k, i, j)表示前k个字符中，有多少个"i s[k] j"，注意k为最后一个字符</span></span><br><span class="line">ll tmp[M][M][M]; <span class="comment">// tmp(k, i, j)表示前k个字符中，有多少个 "i k j"</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[M]; <span class="comment">// g(c)存储字符c的所有位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 计算[l, r]有多少个"ab"</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> f2[r][a][b] - f2[l<span class="number">-1</span>][a][b] - f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        g[id].<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ ) f1[i][j] = f1[i<span class="number">-1</span>][j] + (j == s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                f2[i][j][k] = f2[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (k == s[i] - <span class="string">'a'</span> + <span class="number">1</span>) f2[i][j][k] += f1[i<span class="number">-1</span>][j];</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// "j s[i] k"</span></span><br><span class="line">                <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">                tmp[id][j][k] += f1[i<span class="number">-1</span>][j] * (f1[n][k] - f1[i][k]);</span><br><span class="line">                f3[i][j][k] = tmp[id][j][k];</span><br><span class="line">            }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="keyword">static</span> <span class="keyword">char</span> op[<span class="number">4</span>]; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;l, &amp;r, op + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = op[<span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = op[<span class="number">2</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = op[<span class="number">3</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f1[r][b] - f1[l<span class="number">-1</span>][b] == <span class="number">0</span>) { cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), l) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">upper_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), r) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        ll ans = f3[g[b][pos2<span class="number">-1</span>]][a][c] - f3[g[b][pos1<span class="number">-1</span>]][a][c]; <span class="comment">// b在[l, r]时，所有的"abc"的数量</span></span><br><span class="line">        <span class="comment">// 容斥，减去(a)[bc],(a)[b](c),[ab](c)</span></span><br><span class="line">        ans -= f1[l<span class="number">-1</span>][a] * <span class="built_in">cal</span>(l, r, b, c) + </span><br><span class="line">            f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]) * (f1[n][c] - f1[r][c]) + </span><br><span class="line">            <span class="built_in">cal</span>(l, r, a, b) * (f1[n][c] - f1[r][c]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-进制&quot;&gt;&lt;a href=&quot;#B-进制&quot; class=&quot;headerlink&quot; title=&quot;B. 进制&quot;&gt;&lt;/a&gt;B. 进制&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营3</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/</id>
    <published>2022-02-17T05:34:23.000Z</published>
    <updated>2022-02-17T04:29:51.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-智乃买瓜-another-version"><a href="#C-智乃买瓜-another-version" class="headerlink" title="C. 智乃买瓜(another version)"></a>C. 智乃买瓜(another version)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>智乃来到水果摊前买瓜，水果摊上贩卖着若干个不同的西瓜，第 $i$ 个西瓜的重量为 $w_i$ ，智乃可以买整个瓜 $w_i$ 或者把瓜劈开买半个瓜，半个瓜的重量为 $\dfrac {w_i} 2$ 。</p><p>也就是说对于每个瓜，智乃都有三种不同的决策：</p><ol><li>购买一整个重量为 $w_i$ 的西瓜。</li><li>把瓜劈开，购买半个重量为 $\dfrac {w_i} 2$ 的西瓜。</li><li>不进行购买操作。</li></ol><p>注意，每个瓜的重量都为正偶数。</p><p>现在智乃知道，购买西瓜的重量和分别为 $k = 1, 2, 3 \ldots M$ 时，购买西瓜的方案数（对 $1e9+7$ 取模）。</p><p>请构造出一个水果摊上 $N$ 个西瓜的重量，使得满足所要求的方案数量。保证数据存在 $N \le 10^3$ 的合法解。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于<strong>西瓜的重量为正偶数</strong>，所以对于重量为 $1$ 的方案，它只能由重量为 $2$ 的西瓜劈开得到。</p><p>那么我们就可以根据 $k=1$ 的情况，<strong>去除掉所有方案数中重量为 $2$ 的西瓜对其造成的影响。</strong></p><p>去除后，所有的方案数都不会和重量为 $2$ 的西瓜有关，那么 $k=2$ 时的方案数就只能由重量为 $4$ 的西瓜构成。</p><p>依次去除所有的西瓜即可，把去除的西瓜加到结果数组即可。</p><p><strong>注意点</strong>：</p><ol><li>正向dp的枚举顺序是从后往前，目的是沿用上一层的原始数据。逆向dp也需要减去原始数据，所以要从前往后，否则减去的是这一层的数据。</li><li>正向dp时 $dp[0] = 1$ ，逆向dp也需要加上去。</li></ol><p>本题提示了西瓜的质量为正偶数，如果没有提示，也要往构造所有正偶数质量西瓜去思考。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> (x % p + p) % p; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; dp[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">while</span>(dp[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 把 2*i 的西瓜去除</span></span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">2</span> * i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">            {</span><br><span class="line">                dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j-i]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">2</span> * i) dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j<span class="number">-2</span>*i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-智乃的树旋转-hard-version"><a href="#H-智乃的树旋转-hard-version" class="headerlink" title="H. 智乃的树旋转(hard version)"></a>H. 智乃的树旋转(hard version)</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $N$ 个节点的二叉树，智乃将其做了若干次旋转将其打乱，她想要将其还原，要求旋转操作次数不超过 $N^2$ 次。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote><p>第一行输入正整数 $N$ ($1 \le N \le 10^3$) ，表示二叉树的节点数量。</p><p>接下来 $N$ 行输入二叉树一开始的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为 $0$ 时，则表示该节点无右子树。</p><p>接下来 $N$ 行输入二叉树被打乱后的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为$0$时，则表示该节点无右子树。</p><p>要求你将打乱后的二叉树通过一系列旋转操作还原</p></blockquote><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote><p>首先输出一个整数 $K$ ，表示你还原二叉树进行旋转的次数，要求你给出 $K$ 的范围在 $[0,N2]$ ，接下来 $K$ 行，依次输出旋转操作的旋转轴。</p><p>由于旋转轴只能进行左旋转或者右旋转其中的一种，裁判程序将会自己判断当前需要进行的是左旋转还是右旋转。</p><p>注意：旋转过程中的根节点无法作为旋转轴进行旋转，如果你指定旋转过程中的根节点作为旋转轴，则裁判程序将直接给出WA的结果。</p></blockquote><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>如何将打乱的树还原？可以按照原来的树的先序遍历，依次把每个节点在打乱的树上做splay，单旋情况下，每个节点最多旋转 $n-1$ 次，总次数不超过 $n^2$ 的 数量级。</p><p>所以只需要记录每次旋转时的旋转轴即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span> <span class="keyword">int</span> fa, ch[<span class="number">2</span>]; } a[N], t[N]; <span class="comment">// 原树和打乱后的树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 把u节点向上旋转一次</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> fa = t[u].fa;</span><br><span class="line">    <span class="keyword">int</span> gfa = t[fa].fa;</span><br><span class="line">    <span class="keyword">int</span> t1 = (u != t[fa].ch[<span class="number">0</span>]); <span class="comment">// u是fa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> t2 = (fa != t[gfa].ch[<span class="number">0</span>]); <span class="comment">// fa是gfa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> ch = t[u].ch[t1 ^ <span class="number">1</span>]; <span class="comment">// 需要被用来和fa交换的u的孩子</span></span><br><span class="line">    t[u].fa = gfa;</span><br><span class="line">    t[u].ch[t1 ^ <span class="number">1</span>] = fa;</span><br><span class="line">    t[fa].ch[t1] = ch;</span><br><span class="line">    t[fa].fa = u;</span><br><span class="line">    t[ch].fa = fa;</span><br><span class="line">    t[gfa].ch[t2] = u;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入树，返回这个树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_tree</span> <span class="params">(tree * t, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        t[i].ch[<span class="number">0</span>] = u; t[i].ch[<span class="number">1</span>] = v;</span><br><span class="line">        vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (u) t[u].fa = i;</span><br><span class="line">        <span class="keyword">if</span> (v) t[v].fa = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N] = { <span class="literal">true</span> }; <span class="comment">// 当前点是否被旋转到根过，0设置为true，因为0是树根的fa</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">int</span> n, root_a, <span class="keyword">root_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(!st[t[u].fa]) <span class="comment">// 父节点还没有被旋转，也就是还没有修正</span></span><br><span class="line">    {</span><br><span class="line">        ret.<span class="built_in">push_back</span>(u); <span class="comment">// u需要旋转</span></span><br><span class="line">        <span class="built_in">rot</span>(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 先序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">splay</span>(u); st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">0</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">1</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    root_a = <span class="built_in">input_tree</span>(a, n);</span><br><span class="line">    <span class="keyword">root_t</span> = <span class="built_in">input_tree</span>(t, n);</span><br><span class="line">    <span class="built_in">dfs</span>(root_a); <span class="comment">// 对原树进行先序遍历，依次对打乱的树进行splay</span></span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-智乃的C语言模除方程"><a href="#J-智乃的C语言模除方程" class="headerlink" title="J. 智乃的C语言模除方程"></a>J. 智乃的C语言模除方程</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$x \ \% \ P = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>模除方程 $x \ \% \ P = Q$ ，即 $x = k \times P + Q$ ，$Q &lt; P$ 。</p><p>由于 $Q$ 是 $[l, r]$ 的任意整数，所以显然 $x$ 的定义域为若干个连续子段。</p><p>对于 $[L, R]$ 的查询，设 $f(X)$ 表示 $[0, abs(X)]$ 中满足条件的 $x$ 数量。</p><p>然后需要根据 $L, R$ 的大小分类。</p><ol><li><p>$0 \le L \le R$ </p><p>答案为 $f(R) - f(L - 1)$ 。</p></li><li><p>$L \le 0 \le R$</p><p>答案为 $f(R) + f(L) - f(0)$ 。</p></li><li><p>$L \le R \le 0$ </p><p>答案为 $f(L) - f(R + 1)$ 。</p></li></ol><p>所以接下来需要求出 $f(x)$ 。这里又需要对 $x$ 的大小分类。</p><ol><li><p>$x \ge 0$ </p><p>$f(x)$ 表示 $[0, x]$ 范围，算出所有子段与 $[0, x]$ 的交集。</p><p>整段一共有 $x/P$ 个，注意每一段都要和 $[l, r]$ 取交集 ，然后算出最后一段 $[0, x\%P]$ 和 $[l, r]$ 的交集。</p><p>取交集：$x \% P$ 的余数范围 $[0, P-1]$ ，而 $Q$ 范围 $[l, r]$ ，需要取交集。</p></li><li><p>$x \lt 0$ </p><p>$f(x)$ 表示 $[-x, 0]$ 的范围，也需要算出所有子段与 $[-x, 0]$ 的交集。</p><p>但是由于C语言模除的结果与被除数相同，所以最后的答案也为负数，所以余数范围为负数 $[-P+1, 0]$ 。</p></li></ol><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="comment">// [l, r] 与 [a, b] 的交集</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, <span class="built_in">min</span>(r, b) - <span class="built_in">max</span>(a, l) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(u/p) * <span class="built_in">get</span>(-p+<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">get</span>(u%p,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u/p * <span class="built_in">get</span>(<span class="number">0</span>, p<span class="number">-1</span>) + <span class="built_in">get</span>(<span class="number">0</span>, u%p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    p = <span class="built_in">abs</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= <span class="number">0</span> &amp;&amp; R &gt;= <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(L) + <span class="built_in">f</span>(R) - <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; <span class="number">0</span> &amp;&amp; R &gt; <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(R) - <span class="built_in">f</span>(L<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">f</span>(L) - <span class="built_in">f</span>(R+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-智乃的C语言模除方程-another-version"><a href="#K-智乃的C语言模除方程-another-version" class="headerlink" title="K. 智乃的C语言模除方程(another version)"></a>K. 智乃的C语言模除方程(another version)</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$P \ \% \ x = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>本题和上题唯一的区别在于 $x$ 和 $P$ 在方程的位置交换。</p><p>对于 $P \ \% \ x = Q$ ，有 $P - \lfloor \dfrac P x \rfloor \times x = Q$ 。</p><p>枚举 $x$ 的值，则可以知道 $\lfloor \dfrac P x \rfloor$ 的值，令其为 $c$ ，则变为 $P - c \times x = Q$ 。其中 $P - c \times x$ 为等差数列。</p><p>则问题变为：给定等差数列，问其第 $L$ 项到第 $R$ 项，有多少项在 $[l, r]$ 中。</p><p>根据 $\lfloor \dfrac P x \rfloor$ 的性质，可以使用整除分块来枚举 $x$ 的值。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">ll P, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">intersect</span> <span class="params">(ll l0, ll r0, ll l1, ll r1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(l0, l1);</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(r0, r1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, ansr - ansl + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(ll k, ll cl, ll cr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(cr,(P-l)/k);</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(cl,(P-r+k<span class="number">-1</span>)/k);</span><br><span class="line">  </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ans += <span class="built_in">intersect</span>(ansl,ansr,L,R);</span><br><span class="line">    ans += <span class="built_in">intersect</span>(-ansr,-ansl,L,R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="keyword">if</span> (P &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        P = -P;</span><br><span class="line">        <span class="built_in">swap</span>(l, r);</span><br><span class="line">        l = -l;</span><br><span class="line">        r = -r;</span><br><span class="line">    }</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">0ll</span>, l);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先枚举x的值绝对值在P范围内的情况，即[1, P]</span></span><br><span class="line">    <span class="keyword">for</span> (ll cl = <span class="number">1</span>, cr; cl &lt;= P; cl = cr + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ll k = P / cl;</span><br><span class="line">        cr = P / k;</span><br><span class="line">        ans += <span class="built_in">cal</span>(k, cl, cr); <span class="comment">// 计算x的倍数为k，且x位于[cl, cr]时的情况</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= P &amp;&amp; r &gt;= P)</span><br><span class="line">    {</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, P+<span class="number">1</span>, (ll)(<span class="number">1e10</span>));</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, -(ll)(<span class="number">1e10</span>), -(P+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-智乃买瓜-another-version&quot;&gt;&lt;a href=&quot;#C-智乃买瓜-another-version&quot; class=&quot;headerlink&quot; title=&quot;C. 智乃买瓜(another version)&quot;&gt;&lt;/a&gt;C. 智乃买瓜(another ve</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营2</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/</id>
    <published>2022-02-17T04:09:12.000Z</published>
    <updated>2022-02-17T04:29:38.529Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="A-小沙的炉石"><a href="#A-小沙的炉石" class="headerlink" title="A. 小沙的炉石"></a>A. 小沙的炉石</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 张法术攻击牌和 $m$ 张法术恢复牌，每次攻击消耗一点法力，造成 $1$ 点伤害，恢复牌不消耗法力，可以恢复一点法力。小沙一开始有 $1$ 点法力，法力没有上限。</p><p>每次使用一张法力牌，都会使后面的攻击伤害 $+1$ 。</p><p>给出 $q$ 次询问，每次给出敌人的血量，问能否将其<strong>恰好斩杀</strong>？</p><p>恰好斩杀：正好使得敌方血量变为 $0$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果使用的攻击牌和恢复牌的数量一定，那么可以造成的伤害一定是一个连续的区间。</p><blockquote><p>假设使用 $a$ 张攻击牌和 $b$ 张恢复牌，注意 $a \le b + 1$ 。</p><p>此时最小攻击伤害为：攻击、恢复、攻击、恢复…… ，伤害为 $\sum_{i=1}^a{2 \times i - 1} = a ^ 2$ 。</p><p>每次可以将序列中的一对 [攻击，恢复] 组合调换，造成伤害 $+1$ 。</p><p>最大伤害为：恢复、恢复、恢复、……、攻击、攻击。伤害为 $\sum_{i=1}^{a} b + i = \dfrac {((b + 1) + (b + a)) * a} 2$ 。 </p></blockquote><p>对于每次询问，由于需要恰好斩杀，因此<strong>最多</strong>能够使用的攻击牌是 $min(min(n, m+1), sqrt(hp))$ 。</p><p>由于造成伤害的区间是连续的，因此只需要看最大能造成的伤害是否超过 $hp$ 即可。</p><p>不需要判断最小造成的伤害，因为取到的攻击牌数一定 $\le$ $sqrt(hp)$ 。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    n = <span class="built_in">min</span>(n, m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> hp; cin &gt;&gt; hp;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">min</span>(n, (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(hp));</span><br><span class="line">        <span class="keyword">int</span> maxv = (m + <span class="number">1</span> + m + R) * R / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxv &gt;= hp) cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-小沙的魔法"><a href="#B-小沙的魔法" class="headerlink" title="B. 小沙的魔法"></a>B. 小沙的魔法</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个点和 $m$ 条边，初始时每个点权值为 $x_i = 0$ 。初始时图上无边，每次可以进行以下操作中的一种：</p><ol><li>在 $m$ 条边中选择一条没有被选择过的边加入图中。</li><li>将图中的一个极大连通子图的每个点权值 $+1$ 。</li></ol><p>给定边可能出现重边，自环。</p><p>问最少操作多少次操作2，才能使对于任意点有 $x_i = a_i$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>要使区间增加到目标值，等价于区间每个值初始为 $a_i$ ，每次使得区间值 $-1$ ，最终使区间值全部为 $0$ 。</p><p>优先减去权值最大的，在减去权值最大点的同时，可以顺带减去和它在同一个连通子图的所有点的权值，这整个连通子图全部变为 $0$ ，代价就是权值最大的那个点的权值。</p><p>按权值对每个点的位置排序，从大到小依次遍历当前点的相邻点，把当前点和权值比它大的点合并，先把权值大的点减到和当前点相同的权值，代价为 $a_{gt} - a_{cur}$ 。</p><p>这样最后的图会形成若干个连通子图，再把这些连通子图最小的权值加起来就是最少需要的操作2，加最小权值是因为我们先把比它大的权值点先减到和它权值相同。这也意味这合并时要以权值小的点为根。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[N], id[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">iota</span>(f, f + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">iota</span>(id, id + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) {</span><br><span class="line">        <span class="keyword">return</span> a[x] &gt; a[y]; </span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = id[i]; i &lt;= n; i ++, u = id[i] )</span><br><span class="line">    {</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = h[u]; ~k; k = ne[k])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[k];</span><br><span class="line">            <span class="keyword">int</span> pu = <span class="built_in">find</span>(u), pj = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (vis[j] &amp;&amp; pu != pj)</span><br><span class="line">            {</span><br><span class="line">                res += a[pj] - a[u];</span><br><span class="line">                f[pj] = pu;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i) res += a[i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-小沙的长路"><a href="#E-小沙的长路" class="headerlink" title="E. 小沙的长路"></a>E. 小沙的长路</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>规定有向完全图每条边只能走一次，问：$n$ 个点的有向完全图的最长路径的最大值和最小值分别为多少？</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>$n$ 个点的有向完全图，最长路径一定经过了 $n$ 个点。</p><p>对于最小：如果图上有环，那么经过环一定比不经过环更长，所以我们要使图上无环，这样每个点只走一次，最短为 $n-1$ 。</p><p>对于最长：尽可能走完所有边，等价于给定有向完全图，删除尽可能少的边，使得剩下的图为欧拉图。如果 $n$ 为奇数，那么每个点连接偶数条边，一定存在一个有向无环图为欧拉图。如果 $n$ 为偶数，每个点连接奇数条边，欧拉图至多有 $2$ 个奇数点，也就是要使得 $n-2$ 个点变成偶数，删除一条边改变两个点度的奇偶性，所以需要删除 $\dfrac {n-2} 2$ 条边。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxv;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span> - (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; maxv &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-小沙的算数"><a href="#F-小沙的算数" class="headerlink" title="F. 小沙的算数"></a>F. 小沙的算数</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个算数式（只包含加法和乘法），每次询问把一个数字替换为其他数字，问替换完后的结果为多少？（询问不独立，上一次的修改会影响下一次询问）。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于算数式只包含加法和乘法，而乘法具有连乘性质，所以需要维护乘法区间的乘积。</p><p>对于乘法，只需要修改连乘区间的结果即可。对于加法，直接修改即可。</p><p>维护每个区间的乘法结果，可以使用并查集，开一个 $prod$ 数组表示每个集合的乘积。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, ret;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], prod[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="built_in">quick_power</span>(x, mod<span class="number">-2</span>); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mod</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>{ <span class="keyword">return</span> (x % mod + mod) % mod; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    prod[y] = <span class="built_in">Mod</span>((ll)prod[y] * prod[x]);</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], prod[i] = a[i];</span><br><span class="line">    <span class="comment">// 把乘积合并起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, ans = a[i];</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans = <span class="built_in">Mod</span>((ll)ans * a[j + <span class="number">1</span>]);</span><br><span class="line">            vis[j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">merge</span>(j, j + <span class="number">1</span>);</span><br><span class="line">            ++ j;</span><br><span class="line">        }</span><br><span class="line">        ret = <span class="built_in">Mod</span>((ll)ret + ans);</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) ret = <span class="built_in">Mod</span>((ll)ret + a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id, to; cin &gt;&gt; id &gt;&gt; to;</span><br><span class="line">        <span class="keyword">if</span> (id != n &amp;&amp; s[id] == <span class="string">'*'</span> || id &gt; <span class="number">1</span> &amp;&amp; s[id<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于乘法区间</span></span><br><span class="line">            <span class="keyword">int</span> par = <span class="built_in">find</span>(id);</span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret + <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * <span class="built_in">Mod</span>((ll)to - a[id])));</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            prod[par] = <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * to);</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于加法区间</span></span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret - a[id] + to);</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-小沙的身法"><a href="#G-小沙的身法" class="headerlink" title="G. 小沙的身法"></a>G. 小沙的身法</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个节点的无根无向树，每个节点有权值 $a_i$ ，规定从 $i$ 节点跳到其相邻节点 $j$ 的代价为 $max(0, a_j - a_i)$ 。即从权值低的点跳到权值高的点，代价为其权值差；从权值高的点跳到权值低的点，代价为 $0$ 。</p><p>给定 $m$ 次询问，每次询问：从地面(权值为 $0$)跳到 $u$ 节点，再从 $u$ 节点跳到 $v$ 节点，再从 $v$ 节点跳到地面，最少消耗的代价为多少？</p><p>其中 $1 \le n \le 10^6$ ，$1 \le m \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>对于无向树而言，两个节点之间只有一条简单路径。所以要消耗体力最小，就是走这条简单路径，即路径是唯一的。</p><p>从地面跳到 $u$ 节点，从 $v$ 节点跳到地面的代价为 $a_u$ 。</p><p>从 $u$ 点跳到 $v$ 点的代价，等价于从 $u$ 点跳到根节点的代价，加上从根节点跳到 $v$ 节点的代价，再减去从其 $lca$ 跳到根节点的代价，以及从根节点跳到 $lca$ 的代价。</p><p>由于代价不具有对称性，即从 $u$ 跳到根节点和从根节点跳到 $u$ 节点不是对称的，所以要dfs两次算出从根节点出发到其他点的代价，以及从其他点到达根节点的代价。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, M = N &lt;&lt; <span class="number">2</span>;</span><br><span class="line">ll a[N], d[N], rd[N];</span><br><span class="line"><span class="keyword">namespace</span> LCA {</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> n, h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> fa[N][SIZE + <span class="number">1</span>], depth[N];</span><br><span class="line">    <span class="keyword">int</span> q[N]; <span class="keyword">bool</span> st[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">fill</span>(h, h + n + <span class="number">1</span>, <span class="number">-1</span>); idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="built_in">fill</span>(fa[i], fa[i] + SIZE + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fill</span>(depth, depth + n + <span class="number">1</span>, <span class="number">0</span>); <span class="built_in">fill</span>(st, st + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ; }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = root; depth[root] = <span class="number">1</span>; st[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt) {</span><br><span class="line">            <span class="keyword">int</span> u = q[hh ++ ];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) {</span><br><span class="line">                <span class="keyword">int</span> j = e[i]; <span class="keyword">if</span> (st[j]) <span class="keyword">continue</span>;</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                depth[j] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                fa[j][<span class="number">0</span>] = u;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= SIZE; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">                fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i];</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">        <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    d[u] = d[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &gt; a[fa]) d[u] += a[u] - a[fa];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rd[u] = rd[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &lt; a[fa]) rd[u] += a[fa] - a[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">rdfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n - <span class="number">1</span> &amp;&amp; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v); i ++ ) <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">rdfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y; <span class="keyword">int</span> f = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[x] + rd[x] + d[y] - rd[f] - d[f]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-amp-M-小沙的remake"><a href="#L-amp-M-小沙的remake" class="headerlink" title="L &amp; M. 小沙的remake"></a>L &amp; M. 小沙的remake</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，选择若干个数字组成最长不下降子序列，使得被选中的每个元素，设其位置为 $i$ ，它前面 $b_i$ 个元素至少也有一个被选择。问这样的子序列有多少种？</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>树状数组维护：对于每个位置而言，以它为结尾至少有多少种满足条件的子序列个数。</p><p>按元素权值从小到大排序，从前往后遍历，对于每个元素，设位置为 $i$，查询 $[i-b_i, i)$ 中每个位置的值，相加即为以当前元素为结尾的子序列的方案数。</p><p>这里的Code不按照题目要求的生成数据，方便参照。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b[N];</span><br><span class="line">T a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N]; <span class="comment">// 树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) c[x] = ((ll)c[x] + v) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x ) sum = ((ll)sum + c[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i].x &gt;&gt; b[i], a[i].y = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ll val = <span class="built_in">query</span>(a[i].y - <span class="number">1</span>) - <span class="built_in">query</span>(a[i].y - b[a[i].y] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        val %= mod;</span><br><span class="line">        res = (res + val + mod) % mod;</span><br><span class="line">        <span class="built_in">add</span>(a[i].y, val);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;A-小沙的炉石&quot;&gt;&lt;a href=&quot;#A-小沙的炉石&quot; class=&quot;headerlink&quot; title=&quot;A. 小沙的炉石&quot;&gt;&lt;/a&gt;A. 小沙的炉石&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022寒假算法集训营1</title>
    <link href="https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/"/>
    <id>https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/</id>
    <published>2022-02-17T03:00:00.000Z</published>
    <updated>2022-02-17T04:29:29.455Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="A-九小时九个人九扇门"><a href="#A-九小时九个人九扇门" class="headerlink" title="A. 九小时九个人九扇门"></a>A. 九小时九个人九扇门</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个数字和编号为 $1 \sim 9$ 的九扇门，规定：$k$ 个数字的组合能够打开编号为 $f$ 的门，当且仅当这 $k$ 个数字之和的数字根等于 $f$ 。问对于每一扇门，有几种组合可以打开？</p><p>其中 $1 \le n \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><p>数字根：不断将数字 $m$ 各个位上的数字相加，直到 $m$ 为一位数。一位数的数字根就是本身。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%A0%B9">数字根的性质</a></p><p>求数字根：根据<strong>任何数字加 $9$ 的数字的数字根不变</strong>的性质，只需要模 $9$ 即可算出数字根。</p><p>设 $dp(i)$ 表示打开模 $9$ 为 $i$ 号门的组合数量。由于状态转移时，依赖关系不好找，而被依赖的关系容易找到，所以对于每个状态，更新被这个状态依赖的关系。注意DP的初始条件，为了启动DP要使 $dp(0)$ 为 $1$ ，最后要减去。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">9</span>)</span></span>; dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> nxt = dp;</span><br><span class="line">        <span class="keyword">int</span> a; cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++ )</span><br><span class="line">            (nxt[(k + a) % <span class="number">9</span>] += dp[k]) %= mod;</span><br><span class="line">        dp.<span class="built_in">swap</span>(nxt);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i ++ ) cout &lt;&lt; dp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    cout &lt;&lt; (dp[<span class="number">0</span>] + mod - <span class="number">1</span>) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-炸鸡块君与FIFA22"><a href="#B-炸鸡块君与FIFA22" class="headerlink" title="B. 炸鸡块君与FIFA22"></a>B. 炸鸡块君与FIFA22</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的由 ‘W’, ‘L’, ‘D’ 构成的字符串表示若干场次的结果。</p><p>‘W’表示胜利，分数加一；’L’表示失败，分数减一；’D’表示平局，分数不变。</p><p>特别的，当分数为 $3$ 的整数倍时，失败不会减少分数。</p><p>给定 $q$ 次查询，每次查询给出 $l, r, s$ ，问，在初始分数为 $s$ 时，经过 $[l, r]$ 场次后，最终的分数为多少？</p><p>其中 $1 \le n, q \le 2 \times 10^5$ ，$1 \le l, r \le n$ ，$0 \le s \le 10^9$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到如果起始分数在模 $3$ 意义下相等，那么经历区间 $[l, r]$ 后，<strong>分数的变化量</strong>是不变的。</p><p>可以使用 ST 表，倍增实现查询，复杂度为 $O(max(q, n)\times log n))$ 。其中查询复杂度为 $q log n$ ，初始化复杂度为 $n log n$ 。</p><p>设 $st[k][i][j]$ 表示初始分数模 $3$ 意义下为 $k$ ，经历区间 $[l, r]$ 后<strong>分数的变化量</strong>。</p><p>预处理：$st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j]) \% 3][i + (1 &lt;&lt; j)][j-1]$ ，注意经过 $2^{j-1}$ 区间后初始分数在后面的区间要变化。</p><p>对于每次查询，我们可以每次走最大的二次幂，直到走完区间。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][<span class="number">21</span>], Lg[N];</span><br><span class="line"><span class="comment">/* 预处理,st[k][i][j] 表示初始分数模3为k时，经过[i, i + 2^j - 1]区间后分数的变化量 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) Lg[i] = Lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'W'</span>) st[j][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'L'</span> &amp;&amp; j) st[j][i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n ; j ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                st[k][i][j] = st[k][i][j<span class="number">-1</span>] + st[(k + st[k][i][j<span class="number">-1</span>]) % <span class="number">3</span>][i + (<span class="number">1</span> &lt;&lt; j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;] (<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> g = Lg[r - l + <span class="number">1</span>];</span><br><span class="line">            ret += st[k][l][g];</span><br><span class="line">            (k += st[k][l][g]) %= <span class="number">3</span>;</span><br><span class="line">            l = l + (<span class="number">1</span> &lt;&lt; g);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; k + <span class="built_in">query</span>(k % <span class="number">3</span>, l, r) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-Baby’s-first-attempt-on-CPU"><a href="#C-Baby’s-first-attempt-on-CPU" class="headerlink" title="C. Baby’s first attempt on CPU"></a>C. Baby’s first attempt on CPU</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出 $n$ 个程序语句 $(3 \le n \le 100)$ ，其中某些程序语句有先写后读的制约关系，如果两条程序语句存在先读后写，那么这两条语句中间至少需要三条语句来使程序不出错。我们可以加入空语句来占位。</p><p>问，要使程序不出错，至少需要加入多少条空语句？</p><p>给出的数据保证第 $i$ 行输入 $i, j, f$ ，如果 $f = 1$ ，表示第 $i$ 条语句和第 $i - j$ 条语句有先写后读的关系。并且 $i - j &lt;= 0$ 的情况始终有 $f = 0$ 。即不存在后面的语句先写，前面的语句再读。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>贪心，设 $has(i)$ 表示第 $i$ 条语句后加入多少条空语句。</p><p>对于第 $i$ 条语句，假设它与第 $i-j$ 条语句有先读后写的关系，判断间隔有没有三条语句，如果没有，那么只需要在第 $i-1$ 条语句后加入空语句即可。</p><p>证明也很简单，对于后面的语句 $k$ ，如果有制约关系的语句 $k - k_j \le i - j \quad or \quad k - k_j \ge i$ ，那么加在哪条语句后都不会影响，反之，我们加在第 $i-1$ 条语句后一定更好，它能最大限度地包含于 $[k - k_j, k]$ 的位置。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> has[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> f; cin &gt;&gt; f; <span class="keyword">if</span> (!f) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="built_in">accumulate</span>(has + i - j, has + i, j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) has[i<span class="number">-1</span>] += <span class="number">3</span> - cnt;</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(has + <span class="number">1</span>, has + n, <span class="number">0ll</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="D-牛牛做数论"><a href="#D-牛牛做数论" class="headerlink" title="D. 牛牛做数论"></a>D. 牛牛做数论</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定数字 $n$ 和函数 $H(x) = \dfrac {\phi(x)} x$ ，问：</p><ol><li>回答一个 $x_0 \in [2, n]$ ，使得 $H(x_0)$ 最小。如果存在多个，输出 $x_0$ 最小的那个。</li><li>回答一个 $x_0 \in [2, n]$ ，使得 $H(x_0)$ 最大。如果存在多个，输出 $x_0$ 最大的那个。</li></ol><p>其中 $1 \le n \le 10^9$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>根据欧拉函数定义 ：$\phi(x) = x \times \prod_{i=1}^n (1 - \dfrac 1 p_i)$ 。其中 $n$ 为 $x$ 质因子个数，$p_i$ 为$x$ 的各个质因子。</p><p>于是，函数 $H(x) = \prod_{i=1}^n (1 - \dfrac 1 p_i)$ 。</p><p>所以，求最小值，只需要把所有可能的质因子都加进去累乘即可，因为每个因子都小于 $1$ 。</p><p>求最大值，一定是只有一项因子，且这项因子的 $p_i$ 尽可能大，所以取不大于 $n$ 的最大质数，暴力求出即可，因为质数在 $[1, 10^9]$ 内浓度很大。(相邻质数最多相差 $282$) 。</p><p>注意 $n \le 10^9$ ，在这个范围内最多有 $10$ 个不同的质因子。所以只需要枚举这几个就可以。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> p[] = { <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span> };</span><br><span class="line">    <span class="keyword">auto</span> is_prime = [&amp;] (<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">2</span>) <span class="keyword">return</span> x == <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ --; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = p[<span class="number">0</span>], pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">long</span> <span class="keyword">long</span>)ans * p[pos] &lt;= n) ans *= p[pos ++ ];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        </span><br><span class="line">        ans = n;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">is_prime</span>(ans)) -- ans;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-炸鸡块君的高中回忆"><a href="#E-炸鸡块君的高中回忆" class="headerlink" title="E. 炸鸡块君的高中回忆"></a>E. 炸鸡块君的高中回忆</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个人想要进入学校，但是只有 $m$ 个校园卡，于是他们有如下方案：先让 $m$ 个人进入学校，再由一个人带着 $m$ 个校园卡出来。反复直到全部人进入学校。</p><p>每次进入或出去学校需要 $1$ 个单位时间，问所有人进入学校至少需要多少单位时间？</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先有两个特判：</p><ol><li>$n \le m$ ，可以一次进去完，只需要 $1$ 个单位时间。</li><li>$m == 1$ ，一定无法让所有人进去学校，因为每轮实际上只有 $m-1$ 个人进入学校。</li></ol><p>否则，我们可以先让这 $n$ 个人进入第一轮循环，之后，他们需要循环的次数为 $\lceil \dfrac {n - m} {m-1} \rceil$ ，注意最后一次不需要再有人出来送校园卡，因此总时间为 $2 + 2 \times \lceil \dfrac {n - m} {m-1} \rceil - 1$ 。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= m) { cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> d = (n - m + m - <span class="number">1</span> - <span class="number">1</span>) / (m - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> + d * <span class="number">2</span> - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-中位数切分"><a href="#F-中位数切分" class="headerlink" title="F. 中位数切分"></a>F. 中位数切分</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列 $a$ ，将其划分为若干个子段，使得其中每个段的<strong>数值的中位数</strong>不小于 $m$ ，问最多能划分多少段？</p><p>（偶数长度字段的中位数为两个中较小的那一个。）</p><p>不存在任意划分策略则输出 $-1$ 。</p><p>其中 $1 \le n \le 10^5$ ，$1 \le m \le 10^9$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>首先，我们按照题意将序列划分若干个子段，使得每个字段数值的中位数不小于 $m$ 。</p><p><img src="/images/problem/cutArray.png" alt=""></p><p>根据题目，我们发现<strong>对于每一个子段，不小于 $m$ 的数字个数一定大于 小于 $m$ 的数字个数。</strong></p><p>贪心考虑，如果当前枚举的区间，已经满足大于关系，即 <strong>不小于 $m$ 的数字个数比小于 $m$ 的数字个数多 $1$</strong> 。那么我们就可以把这块区间划分出来。</p><p>可以证明这样贪心一定是最优的，因为如果在这个区间之后加入 不小于 $m$ 的数字数量小于 小于 $m$ 的数字个数，那么不满足题意；如果大于，那么不必要合并，因为两个都是满足条件的子段。当然如果等于，那么还是要加上的，但是这不影响结果，因为这个区间还是满足如上条件。</p><p>我们发现，对于划分好的最优解子段，每个子段都满足 $\ge m$ 的数字数量比 $&lt; m$ 的数字数量多 $1$ ，所以只需要统计一下区间的两个数量差即可。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ --; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m, cnt = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m) ++ cnt; <span class="keyword">else</span> -- cnt;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; (cnt &lt;= <span class="number">0</span> ? <span class="number">-1</span> : cnt) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-ACM-is-all-you-need"><a href="#G-ACM-is-all-you-need" class="headerlink" title="G. ACM is all you need"></a>G. ACM is all you need</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列 $a$ ，可以选择任意整数值 $b$ ，使得序列 $a$ 中每个元素 $a_i$ 变为 $|a_i - b| + b$ 。问经过一次变换后，序列中的极小值点的数量最少为多少？</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>变换中 $+b$ 的操作是对整个序列都加上 $b$ ，不会改变相对大小，因此无用，可以看作变换为 $a_i = |a_i - b|$ 。</p><p>同时， $b$ 的值小于等于 $0$ 的情况是完全一样的，同样不改变相对大小，我们可以用 $b = 0$ 代替所有 $b \le 0$ 的情况。</p><p>所以确定 $b$ 的值为 $[0, inf]$ 。</p><p>对于序列中每个元素而言，如果让它变成极小值点，取得 $b$ 值的范围是连续的，可以算出所有 $n-2$ 个 $b$ 范围的区间，那么问题就变成了：给定 $n-2$ 个区间，求被区间覆盖最小次数的点的覆盖次数。</p><p>对于区间 $[l, r]$ ，可以在每个位置上 $+1$ ，那么就是求 $[0, inf]$ 上每个位置的最小值。</p><p>可以使用差分来快速实现区间加，范围比较大，使用map离散化处理即可。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp; x : a) cin &gt;&gt; x;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; m[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 注意0位置是需要考虑的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : { a[i<span class="number">-1</span>], a[i+<span class="number">1</span>] })</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (x &gt; a[i]) r = <span class="built_in">min</span>(r, a[i] + (x - a[i] - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (x &lt; a[i]) l = <span class="built_in">max</span>(l, x + (a[i] - x) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == a[i]) r = l - <span class="number">1</span>; <span class="comment">// 这个点不可能成为极小值点</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">            ++ m[l]; <span class="keyword">if</span> (r != INF) -- m[r + <span class="number">1</span>]; <span class="comment">// 注意正无穷没有右端点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ret = INF, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : m) ret = <span class="built_in">min</span>(ret, sum += v);</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-牛牛看云"><a href="#H-牛牛看云" class="headerlink" title="H. 牛牛看云"></a>H. 牛牛看云</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列 $a$ ，求出 $\sum_{i=1}^n\sum_{j=i}^n|a_i + a_j - 1000|$ 。</p><p>其中 $3 \le n \le 10^6$ ，$0 \le a_i \le 1000$ 。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>题目简化一下就是求 $|a_i + a_j - 1000|$ ，其中 $1 \le i \le j \le n$ 。</p><p>容易发现，对于 $i \lt j$ 的情况， 把 $i$ 、$j$ 调换一下式子依然不变，所以式子对 $i$ 、$j$ 有对称性。</p><p>那么我们只需要对称地求出所有情况，再除以二即可。</p><p>注意点：</p><ol><li>式子对 $i = j$ 不具有对称性，所以在求式子结果的时候，需要给这种情况加上。</li><li>$n$ 很大， $a_i$ 很小，可以在值域上做暴力。</li></ol><blockquote><p>为什么 $i = j$ 不具有对称性？</p><p>对于 $1, 1, 2, 2$ 这个样例，我们枚举 $1$ 和 $2$ 的时候，把前和后的状态都算了，所以有对称性。</p><p>对于 $1, 1$ ，我们枚举 $1$ 和 $1$ 的时候，对于每一个 $1$ ，在计算加自己的时候，只计算了一次，根据对称性我们要加两次，这样最后除以二的时候才算出来一次。所以我们对每个 $1$ 都要再加一遍自己的情况。</p><p>其实本质上就是，$i=j$ 代表同一个式子，而 $i != j$ 代表了两种式子，一个定义域为 $i &lt; j$ ，一个定义域为 $i &gt; j$ 。</p></blockquote><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="keyword">int</span> x; cin &gt;&gt; x; ++ c[x]; }</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1000</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i == j) ret = ret + c[i] * (c[j] + <span class="number">1</span>) * <span class="built_in">abs</span>(i + j - <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">else</span> ret = ret + c[i] * c[j] * <span class="built_in">abs</span>(i + j - <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="I-B站与各唱各的"><a href="#I-B站与各唱各的" class="headerlink" title="I. B站与各唱各的"></a>I. B站与各唱各的</h1><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>有 $n$ 个UP主和 $m$ 句歌词，现在他们每个人要独立完成这 $m$ 句歌词，对于每一句歌词，他们可以选择唱或者不唱。完成后，将它们拼接起来。</p><p>如果一句歌词没有人唱或者被所有人唱过，那么这句歌词算失败的，否则是成功的。</p><p>问唱成功的歌词数量的期望为多少？</p><p>若答案为分数，需要在模数为 $10^9 + 7$ 下取逆。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>由于每个UP都是独立完成 $m$ 句歌词，所以对于每句歌词唱与不唱的概率都为 $\dfrac 1 2$ 。</p><p>对于任意一句歌词，没有人唱或者全部人都唱的概率为 $(\dfrac 1 2)^n$ 。</p><p>所以每一句歌词唱成功的概率为 $1 - (\dfrac 1 2)^n \times 2 = 1 - (\dfrac 1 2)^{n - 1}$ 。</p><p>每一句成功的概率乘以总歌词数量即为唱成功的歌词数量的期望，即 $(1 - (\dfrac 1 2)^{n - 1}) \times m$ 。</p><h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">auto</span> quick_power = [&amp;] (<span class="keyword">int</span> a, <span class="keyword">int</span> k) -&gt; <span class="keyword">int</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (a %= p; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % p)</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll) res * a % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, p<span class="number">-2</span>);</span><br><span class="line">        cout &lt;&lt; (ll)(<span class="number">1</span> - <span class="built_in">quick_power</span>(inv, n<span class="number">-1</span>) + p) % p * m % p &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-小朋友做游戏"><a href="#J-小朋友做游戏" class="headerlink" title="J. 小朋友做游戏"></a>J. 小朋友做游戏</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>班级里有 $A$ 个安静的小朋友和 $B$ 个吵闹的小朋友，现在要选出 $n$ 个小朋友围成一圈，满足不存在两个吵闹的小朋友相邻。每个小朋友有一个幸福度，选中即可为班级增加幸福度，问最大幸福度为多少？</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>为了满足条件，安静的小朋友至少要选出 $(n + 1) / 2$ 个，否则一定存在吵闹的小朋友相邻。</p><p>可以先选出这 $(n + 1) / 2$ 个小朋友，再双指针贪心选最大的幸福度。</p><p>双指针判断比较麻烦，要先判断是否有选完的，再贪心选。可以把剩下的小朋友放在一个容器中，选出最大的幸福度即可。</p><h2 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> A, B, n; cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(A)</span>, <span class="title">b</span><span class="params">(B)</span>, all</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : a) cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : b) cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span> (A &lt; n - A) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n + <span class="number">1</span>) / <span class="number">2</span>; i &lt; A; i ++ ) all.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B; i ++ ) all.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">        <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; i ++ ) ret += a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - (n + <span class="number">1</span>) / <span class="number">2</span>; i ++ ) ret += all[i];</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-冒险公社"><a href="#K-冒险公社" class="headerlink" title="K. 冒险公社"></a>K. 冒险公社</h1><h2 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h2><p>数轴上有 $n$ 座连续的岛屿，玩家从第一座岛屿出发，依次经过所有岛屿直到到达第 $n$ 座岛屿。</p><p>岛屿有三种类型：绿岛、红岛和黑岛。</p><p>在玩家到达第 $i$ 座岛屿时，如果第 $i, i-1, i-2$ 中绿岛数量大于红岛，则罗盘发出绿色；如果红岛数量大于绿岛，则发出红光；否则发出黑光。</p><p>给出在 $n$ 座岛屿上，罗盘发出的光，问这 $n$ 座岛屿最多有几座绿岛？(第 $1, 2$ 座岛屿不发光，规定为 ‘X’) 。</p><p>其中 $1 \le n \le 10^5$ ，发出的光的颜色为长度 $n$ 的字符串，由 ‘R’、’G’、’B’ 构成。</p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>为了方便，我们设绿岛为 $0$ ，红岛为 $1$ ，黑岛为 $2$ 。</p><p>设 $dp(i, j, k, l)$ 表示对于前 $i$ 座岛屿，且最后三座岛屿为 $(j, k, l)$ 时，绿岛的最大数量。</p><p>转移方程为 $dp(i, j, k, l) = max(dp(i, j, k, l), dp(i-1, t, j, k))$ ，其中 $0 \le t \le 2$ 。</p><p>注意在转移前判断 $(j, k, l)$ 是否合法，以及 $dp(i-1, t, j, k)$ 是否合法。$dp = -1$ 表示这种状态是不合法的。</p><p>坑点：注意一定用 $dp(i-1, t, j, k)$ 判断，不要用 $(t, j, k)$ 判断是否为 $s[i-1]$ ，因为即使等于，也不一定合法，还和前面的岛屿有联系。</p><h2 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">/* dp(i, j, k, l) 表示考虑前i个字符，此时最后三个岛屿为(j, k, l)时的最大绿岛数量</span></span><br><span class="line"><span class="comment"> * 其中0表示绿岛，1表示红岛，2表示黑岛</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">get_color</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x1 = (a == <span class="number">0</span>) + (b == <span class="number">0</span>) + (c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x2 = (a == <span class="number">1</span>) + (b == <span class="number">1</span>) + (c == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) <span class="keyword">return</span> <span class="string">'G'</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) <span class="keyword">return</span> <span class="string">'R'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_color</span>(i, j, k) == s[<span class="number">3</span>]) dp[<span class="number">3</span>][i][j][k] = !i + !j + !k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; t ++ )</span><br><span class="line">                        <span class="keyword">if</span> (~dp[i<span class="number">-1</span>][t][j][k] &amp;&amp; <span class="built_in">get_color</span>(j, k, l) == s[i])</span><br><span class="line">                            dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i<span class="number">-1</span>][t][j][k] + !l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp[n][i][j][k]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-牛牛学走路"><a href="#L-牛牛学走路" class="headerlink" title="L. 牛牛学走路"></a>L. 牛牛学走路</h1><h2 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h2><p>给出字符串 $s$ ，牛牛会按照字符串给的方向走一遍，问走的位置里原点最远为多少？</p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>签到题，维护一下当前的位置即可，设原点为 $(0, 0)$ 。</p><h2 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> }, dc[] = { <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line">    d[<span class="string">'U'</span>] = <span class="number">0</span>; d[<span class="string">'D'</span>] = <span class="number">1</span>; d[<span class="string">'R'</span>] = <span class="number">2</span>; d[<span class="string">'L'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        x += dr[d[s[i]]]; y += dc[d[s[i]]];</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, dis);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ret);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;A-九小时九个人九扇门&quot;&gt;&lt;a href=&quot;#A-九小时九个人九扇门&quot; class=&quot;headerlink&quot; title=&quot;A. 九小时九个人九扇门&quot;&gt;&lt;/a&gt;A. 九小时九个人九扇门&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; clas</summary>
      
    
    
    
    
    <category term="牛客集训营" scheme="https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>康托展开</title>
    <link href="https://horb7.github.io/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <id>https://horb7.github.io/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2022-01-01T11:51:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><blockquote><p>康托展开是一个全排列与自然数的双射，常用于构建hash表时的空间压缩。假设有 $n$ 个数(1, 2, 3, 4 …) ，  可以有 $n!$ 的排列组合，康托展开表示在某一个全排列在这些组合的名次（以0开始）。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个全排列 $A$ 的名次为 $a_1 \times (n-1)! + a_2 \times (n-2)! \ldots + a_n \times 0!$ 。</p><p>其中 $a_i$ 表示第 $i$ 个数字，$A_i &gt; A_j \ and \ i &lt; j$ 。即比当前数字小但是在它后面的数字的个数。</p><p>因为对这个位置而言，我们选择 $a_i$ 中任意一个数字填充这个位置，后面的数字任意排列都可以比原来的小，所以比它小的名次的排列数量为 $a_i \times (n - i)!$ 。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++ ) x += A[j] &lt; A[i];</span><br><span class="line">    id += x * fac[n - i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><p>由于康托展开是一个全排列和自然数的双射，因此我们也可以根据名次得出全排列。</p><p>从前往后，对于第 $i$ 个数字，我们可以得到 $a_i = id / (n-i)!$ 。</p><p>由于 $a_i$ 表示在其后面且小于它的数值的数量，所以我们要遍历得到这个位置的值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id; cin &gt;&gt; id;</span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// st(i) 表示i数字有没有出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> a = id / fac[n - i];</span><br><span class="line">    id %= fac[n - i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 没有出现过</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (!a) <span class="comment">// 已经找到a个数字比它小</span></span><br><span class="line">            { A[i] = j; st[i] = <span class="literal">true</span>; <span class="keyword">break</span>; }</span><br><span class="line">            <span class="keyword">else</span> -- a;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.luogu.com.cn/problem/P3014">洛谷 P3014 Cow Line S</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="康托展开-1"><a href="#康托展开-1" class="headerlink" title="康托展开"></a>康托展开</h3><p>注意到内层循环的目的是为了找出后面有几个数字小于当前位置的数字，我们可以采用树状数组维护，从后往前遍历即可。这样查询只需要 $O(logn)$ 的时间，总复杂度降至 $O(nlogn)$ 。</p><p><a href="https://www.luogu.com.cn/problem/P5367">洛谷P5367 模板 康托展开</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll c[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) ++ c[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">    ll id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="built_in">add</span>(a[i]), id = (id + fac[n-i] * <span class="built_in">query</span>(a[i] - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (id + <span class="number">1</span>) % mod);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="逆康托展开-1"><a href="#逆康托展开-1" class="headerlink" title="逆康托展开"></a>逆康托展开</h3><p>注意到内层循环的目的是为了找出剩下没有被选上的数字中的第 $a_i+1$ 个数字，我们可以采用线段树维护，复杂度 $O(logn)$ ，总复杂度为 $O(nlogn)$ 。</p><p>具体来说，我们维护 $[l, r]$ 中有多少数字是有效的（未被删除），每次查询找出全局第 $a_i + 1$ 小的数字即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll st; <span class="comment">// st 表示当前这个区间有多少数字未被删除</span></span><br><span class="line">};</span><br><span class="line">node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].st = t[<span class="built_in">ls</span>(p)].st + t[<span class="built_in">rs</span>(p)].st;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r; t[p].st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    -- t[p].st; <span class="comment">// 在这个区间查询后需要删除那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) <span class="keyword">return</span> t[p].l;</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].st &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), k - t[<span class="built_in">ls</span>(p)].st);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.luogu.com.cn/problem/P3014">洛谷 P3014 Cow Line S优化版</a> </p><p>记得每次初始化~</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll c[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) ++ c[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll st; <span class="comment">// st 表示当前这个区间有多少数字未被删除</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].st = t[<span class="built_in">ls</span>(p)].st + t[<span class="built_in">rs</span>(p)].st;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r; t[p].st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    -- t[p].st; <span class="comment">// 在这个区间查询后需要删除那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) <span class="keyword">return</span> t[p].l;</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].st &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), k - t[<span class="built_in">ls</span>(p)].st);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, n) c[i] = <span class="number">0</span>;</span><br><span class="line">            ll id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="built_in">add</span>(a[i]), id += fac[n-i] * <span class="built_in">query</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, id + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            ll id; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;id); id -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> x = id / fac[n - i];</span><br><span class="line">                id %= fac[n - i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, <span class="built_in">query</span>(<span class="number">1</span>, x+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2021.12.31</strong> 更新，使用树状数组模板和<a href="https://horb7.github.io/2021/12/30/zkw%E6%A0%91/">zkw树</a>实现康托展开和逆康托展开。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll fac[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> {</span></span><br><span class="line">  <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">  <span class="keyword">int</span> n; ll a[N];</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x &amp; -x; }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{ <span class="keyword">this</span>-&gt;n = n; <span class="built_in">fill</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>, <span class="number">0</span>); }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">1</span>)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) a[x] += v; }</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ ll res = <span class="number">0</span>; <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x)) res += a[x]; <span class="keyword">return</span> res; }</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">ask</span>(r) - <span class="built_in">ask</span>(l<span class="number">-1</span>); }</span><br><span class="line">};</span><br><span class="line">BIT&lt;N&gt; bit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* zkw树 */</span></span><br><span class="line"></span><br><span class="line">ll M, t[N &lt;&lt; <span class="number">1</span>]; <span class="comment">// t(i) 表示i节点表示的区间内有多少剩余的1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (ll i = M; i &lt; M + n; i ++ ) t[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = M - <span class="number">1</span>; i; i -- ) t[i] = t[i&lt;&lt;<span class="number">1</span>] + t[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span> <span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll r;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; M; )</span><br><span class="line">    {</span><br><span class="line">        -- t[r];</span><br><span class="line">        <span class="keyword">if</span> (t[r&lt;&lt;<span class="number">1</span>] &gt;= x) r &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x -= t[r&lt;&lt;<span class="number">1</span>], (r &lt;&lt;= <span class="number">1</span>) |= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -- t[r], r - M + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q); <span class="keyword">for</span> (M = <span class="number">1</span>; M &lt; n; M &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            bit.<span class="built_in">init</span>(n);</span><br><span class="line">            ll id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            <span class="built_in">per</span>(i, n, <span class="number">1</span>) bit.<span class="built_in">add</span>(a[i]), id += fac[n-i] * bit.<span class="built_in">ask</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, id + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            ll id; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;id); id -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> x = id / fac[n - i];</span><br><span class="line">                id %= fac[n - i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, <span class="built_in">ask</span>(x+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;康托展开&quot;&gt;&lt;a href=&quot;#康托展开&quot; class=&quot;headerlink&quot; title=&quot;康托展开&quot;&gt;&lt;/a&gt;康托展开&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;康托展开是一个全排列与自然数的双射，常用于构建hash表时的空间压缩。假设有 $n$ 个数(1, </summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>扩展中国剩余定理</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-21T15:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>对于同余方程组：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\x \equiv a_3 \pmod {m_3} \\..... \\x \equiv a_n \pmod {m_n} \\\end{cases}</script><p>求出满足上述同余方程组的 $x$ 的一组解，<strong>公式满足 $m_1,m_2, m_3 … m_n$ 互质。</strong></p><p>令 $M = \prod_{i=1}^{n}m_i , M_i = M / m_i, M_i \times M_i^{-1} \equiv 1 \pmod {m_i}$ 。</p><p>中国剩余定理构造出了这样一组解:</p><script type="math/tex; mode=display">x = \sum_{i=1}^{n} M_i * M_i^{-1} * a_i</script><p>对于每一组解 $x \equiv a_i \pmod {m_i}$ ，$x$ 除了 $M_i \times M_i ^ {-1} \times a_i$ 项之外，其余都能被 $m_i$ 整除，所以只剩下这一项。</p><p>又因为 $M_i \times M_i^{-1} \equiv 1 \pmod {m_i}$ 。所以 $x \equiv a_i \pmod {m_i}$ 。</p><h2 id="扩展中国剩余定理-1"><a href="#扩展中国剩余定理-1" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h2><p>传统的中国剩余定理限制性太强，必须要满足 $m_1, m_2, m_3 … m_n$ 互质。如何求出不满足模数不互质的同余方程组的解？</p><p>先从两个柿子看起：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\\end{cases}</script><p>首先可以得到 $x = k_1 \times m_1 + a_1 = k_2 \times m_2 + a_2$ 。</p><p>对这个柿子化简： $k_1 \times m_1 + k_2 \times (-m_2) = a_2 - a_1$ 。</p><p>对于这个柿子，我们可以用扩展欧几里得求出一组满足 $k_1 \times m_1 + k_2 \times (-m_2) = gcd(m_1, -m_2)$ 的 $k_1, k_2$ 解。</p><p>记 $gcd(m1, -m2) = d$ 。</p><p>根据贝祖定理，如果不满足 $d | a_2 - a_1$ ，那么不存在解。否则，我们只需要扩大 $(a_2 - a_1) / d$ 倍即可得到 $k_1$ 的一组解。</p><p>由于这是个不定方程，在求出 $k_1$ 后，我们可以得到其他满足的解一定为 $k_1 = k_1 + k \times (m_2 / d)$ 。</p><p>我们把这个通解 $k_1$ 带入原来的柿子：$x = (k_1 + k \times (m_2 / d)) \times m_1 + a_1$ 。</p><p>得到：</p><p>$x = k_1 \times m_1 + a_1 + k \times (m_1 \times m_2) / d$ 。</p><p>$x = k_1 \times m_1 + a_1 + k \times lcm(m_1, m_2)$ 。</p><p>令 $m_0 = lcm(m1, m2), a_0 = k_1 \times m_1 + a_1$ 。</p><p>那么，我们得到 $x = k \times m_0 + a_0$ ，这个柿子满足这两个同余方程组解。</p><p>通过这样的方式，我们就可以把两个同余方程组化简成一个，最终达到化简 $n$ 个同余方程组的效果。</p><p>那么最终可以算出 $x = k \times m + a$ ，其中 $m = lcm(m_1, m_2 … m_n)$ ，所以在 $\pmod m$ 的意义下， $x = a$ 。</p><p>例题:<a href="https://www.acwing.com/problem/content/description/206/">Acwing 204 表达整数的奇怪方式</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, x - (a / b) \times y);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = ((a % b) + b) % b;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a1, m1; cin &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a2, m2, k1, k2; cin &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(a1, -a2, k1, k2);</span><br><span class="line">        <span class="keyword">if</span> ((m1 - m2) % r) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl, <span class="number">0</span>;</span><br><span class="line">        k1 = <span class="built_in">mod</span>(k1 \<span class="built_in">times</span> (m2 - m1) / r, <span class="built_in">abs</span>(a2 / r));</span><br><span class="line">        m1 = k1 \times a1 + m1;</span><br><span class="line">        a1 = <span class="built_in">abs</span>(a1 \times a2 / r);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于为什么取 $abs$ 的原因:</p><ol><li>由于 $a \% b$ 和 $a \% -b$ 是相同的，所以我们在计算 $k_1$ 时 需要加上 $abs(a_2 / r)$ ，防止在 $mod$ 过程中加上负数，结果仍然是负数。</li><li>下一个阶段的 $a_1$ 实际上一个的 $lcm(a_1,a_2)$ ，但是在计算 $gcd(a_1, a_2)$ 时可能出现负数，导致计算 $lcm$ 时会出现负数，这里要取 $abs$ 。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;扩展中国剩余定理&quot;&gt;&lt;a href=&quot;#扩展中国剩余定理&quot; class=&quot;headerlink&quot; title=&quot;扩展中国剩余定理&quot;&gt;&lt;/a&gt;扩展中国剩余定理&lt;/h1&gt;&lt;h2 id=&quot;中国剩余定理&quot;&gt;&lt;a href=&quot;#中国剩余定理&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>整除分块</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-23T13:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><h2 id="一维分块引入"><a href="#一维分块引入" class="headerlink" title="一维分块引入"></a>一维分块引入</h2><p>给定一个整数，求出</p><script type="math/tex; mode=display">\sum_{i=1}^n \lfloor \dfrac n i \rfloor</script><p>其中: $1 \le n \le 10^9$ 。</p><p>对于上述题目，$O(n)$ 的解法是很显然的，但是对于 $n$ 很大或者有多组测试样例时，这样的复杂度是不能接受的。我们需要找出更优秀的复杂度来解决上述题目。</p><p>容易发现，由于 $\dfrac n i$ 是向下取整的，因此在某一个连续的区间， $\dfrac n i$ 取值是相同的，比如 $n = 10$ 时：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">n/i</td><td style="text-align:center">10</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>每一个取值都是一个连续的块，那么只要我们直到某一个块的左右端点，就可以 $O(1)$ 地算出这个块的总和。</p><p><strong>定理1</strong>： $\dfrac n i$ 中最多有 $2 \times \sqrt{n}$ 个块。</p><blockquote><p>我们把 $\dfrac n 1, \dfrac n 2, \ldots \dfrac n n$ 分成 $2$ 个部分，前一部分为 $\dfrac n 1, \dfrac n 2, \ldots \dfrac {n} {\lfloor \sqrt n \rfloor }$ ，后一部分为 $\dfrac n {\lfloor \sqrt n \rfloor + 1}, \dfrac n {\lfloor \sqrt n \rfloor + 2}, \ldots \dfrac n n$ 。</p><p>对于前一部分，有 $\sqrt n$ 项，对于后一部分，它所有的取值为 $1, 2, \ldots \sqrt n$ ，因此不同的取值有 $\sqrt n$ 项，所以最多有 $2 \times \sqrt n$ 项不同的取值。</p></blockquote><p> 根据定理1，我们根据最好的情况，即把每一个块都 $O(1)$ 地算出结果，那么复杂度就是 $O(\sqrt n)$ 的。</p><p><strong>定理2</strong>： 如果第 $k$ 块，如果它的左端点为 $l$ ，那么它的右端点为 $\dfrac n {\lfloor \dfrac n l \rfloor}$ 。</p><blockquote><p>假设第 $k$ 段的取值为 $t$ ，取 $i$ 为 $l \le i \le r$ ，那么显然有 $\dfrac n i = \dfrac n l = t$ ，即 $i \times t \le n$ ，$i \le \dfrac n t$，由于 $r = max(i)$ ，那么 $r = \dfrac n t = \dfrac n {\lfloor \dfrac n l \rfloor}$ 。</p></blockquote><p>如此，我们便可以求出所有块的左右端点进行运算，复杂度为 $O(\sqrt n)$ 。</p><hr><p>给出整除分块模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ret += (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="约数研究"><a href="#约数研究" class="headerlink" title="约数研究"></a><a href="https://www.luogu.com.cn/problem/P1403">约数研究</a></h3><p>由于直接求 $i$ 的约数个数不好求，我们可以枚举所有的因子。</p><p>假设因子为 $i$ ，那么在 $[1, n]$ 中，因数含有 $i$ ，即 $i$ 的倍数有 $\lfloor \dfrac n i \rfloor$ 个。</p><p>因此问题转化为求 $\sum_{i=1}^n \lfloor \dfrac n i \rfloor$ ，这就是基本整除分块。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ret += (<span class="keyword">long</span> <span class="keyword">long</span>) (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="余数求和"><a href="#余数求和" class="headerlink" title="余数求和"></a><a href="https://www.luogu.com.cn/problem/P2261">余数求和</a></h3><p>首先由于 $k \ \ mod \ \ i = k - \lfloor \dfrac k i \rfloor \times i$ 。</p><p>于是我们可以把原式转化成 $\sum_{i=1}^n k - \lfloor \dfrac k i \rfloor \times i = n \times k - \sum_{i=1}^n \lfloor \dfrac k i \rfloor \times i$ 。</p><p>其中 $\lfloor \dfrac k i \rfloor$ 我们可以使用整除分块处理，这样对于每一个块而言， $\lfloor \dfrac k i \rfloor$ 都是一个常数，那么我们要求它乘以一个等差数列的值，只需要求 $i$ 在这个块的累加和即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = n * k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = <span class="built_in">min</span>(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        ret -= (<span class="keyword">long</span> <span class="keyword">long</span>)(l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span> * (k / l);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二维分块"><a href="#二维分块" class="headerlink" title="二维分块"></a>二维分块</h2><p>给定两个整数 $n, m$ ，求：</p><script type="math/tex; mode=display">\sum_{i=1}^{min(n, m)} \lfloor \dfrac n i \rfloor \times \lfloor \dfrac m i \rfloor</script><p>由一维分块，我们可以得到块数最多为 $2 \times \sqrt n + 2 \times \sqrt m$ 。</p><p>我们记 $k = min(n, m)$ 。</p><p>对于其中一个块，假设左端点为 $l$ ，那么其右端点为 $r = min(k, min(n / (n / l), m / (m / l)))$ 。因为我们要保证块里的元素相同，必须要保证 $\lfloor \dfrac n i \rfloor$ 元素相同且 $\lfloor \dfrac m i \rfloor$ 元素相同。</p><p>二维分块模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    r = <span class="built_in">min</span>(k, <span class="built_in">min</span>(n / (n / l), m / (m / l)));</span><br><span class="line">    ret += (n / l) * (m / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整除分块&quot;&gt;&lt;a href=&quot;#整除分块&quot; class=&quot;headerlink&quot; title=&quot;整除分块&quot;&gt;&lt;/a&gt;整除分块&lt;/h1&gt;&lt;h2 id=&quot;一维分块引入&quot;&gt;&lt;a href=&quot;#一维分块引入&quot; class=&quot;headerlink&quot; title=&quot;一维分块引</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-20T01:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h1><p>在拓展欧几里得定理之前，先介绍以下<strong>贝祖定理</strong>：</p><blockquote><p>如果方程式 $ax + by = m$ 成立，那么 $gcd(a, b) | m$</p></blockquote><p>显然，我们可以把原方程式写作：$m = k1 \times g \times x + k2 \times g \times y = g(k1 \times x + k2 \times y)$</p><p>根据贝祖定理，如果有 $ax + by = 1$ ，那么 $gcd(a, b) = 1$， 即 $a$ 与 $b$ 互质。</p><p>我们可以使用著名的辗转相除法算出来 $gcd(a, v=b)$ :</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拓展欧几里得-1"><a href="#拓展欧几里得-1" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><p>给出 $ax + by = m$ ，如何求出他的一组解？</p><p>根据贝祖定理，只要我们求出 $ax + by = gcd(a, b)$ 即可，由于 $gcd(a, b) | m$ ，所以可以求出原式的一组因子，只需要乘上 $m / gcd(a, b)$ 即为原式的一组解。</p><p>那么问题就转化为了，求 $ax + by = gcd(a, b)$ 的一组 $(a, b)$ 。</p><p>$gcd(a, b)$ 可以用欧几里得辗转相除求出，而 $a, b$ 可以在求的过程中得出。</p><p>假设我们到达了终点，此时 $a = gcd(a, b), b = 0$ ，那么有 $x = 1, y = 0$ 。</p><p>由于$gcd(a, b)$ 是递归的，当我们想要求得 $ax + by = m$ 时，我们已经求出了 $bx + (a \% b)y = m$ 的一组解。</p><p>$a \% b = a - \lfloor \dfrac a b \rfloor \times b$</p><p>把已有的式子化作：$bx + (a - \lfloor \dfrac a b \rfloor \times b)y = m$</p><p>那么，可以得到：$ay + b(x - \lfloor \dfrac a b \rfloor \times y) = m$</p><p>所以我们发现，如果从上一层状态推下来，那么：$x = y, y = x - \lfloor \dfrac a b \rfloor \times y$</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, x - (a / b) * y);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 $ax + by \equiv m \pmod p$ 有无穷多组，而我们只计算出了一种，那么如何得到其他解？</p><p>假设我们得到解为 $x_0, y_0$ ，还有另外一组解为 $x_1, y_1$ ，那么可以得到：</p><p>$ax_0 + by_0 \equiv m \pmod p$</p><p>$ax_1 + by_1 \equiv m \pmod p$ </p><p>两个柿子相减，得到 $a(x_0 - x_1) \equiv -b(y_0 - y_1) \pmod p$ </p><p>两边同时除以 $gcd(a, b)$ ，有 $a / gcd(a, b) (x_0 - x_1) \equiv -b / gcd(a, b)(y_0 - y_1) \pmod p$</p><p>此时 $a / gcd$ 与 $b / gcd$ 互质，所以一定有 $a / gcd(a, b) | (y_0 - y_1), b / gcd(a, b) | (x_0 - x_1)$</p><p>我们记 $x_1 = x_0 + k \times \dfrac{b}{gcd(a, b)}$ ，同理 $y_1 = y_0 + k \times \dfrac{a}{gcd(a, b)}$ 。</p><h3 id="欧几里得用途"><a href="#欧几里得用途" class="headerlink" title="欧几里得用途"></a>欧几里得用途</h3><h5 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h5><p> $a \times a^{-1} \equiv 1 \pmod p$ ，可以写成 $a \times a^{-1} \equiv kp + 1 \pmod p$ ，</p><p>这样，我们就可以得到柿子 : $a \times a^{-1} + kp \equiv 1 \pmod p$ 。</p><p>这就是拓展欧几里得公式，由于 $a, p$ 都已知，只需要用拓展欧几里得算出 $(a^{-1}, k)$ 即可。</p><p><strong>注意拓展欧几里得可以计算 $p$ 与 $a$ 非互质情况下的逆元，而欧拉定理不能算出。</strong></p><h5 id="计算同余方程组"><a href="#计算同余方程组" class="headerlink" title="计算同余方程组"></a>计算同余方程组</h5><p><a href="http://localhost:4000/2021/12/19/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">扩展中国剩余定理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拓展欧几里得&quot;&gt;&lt;a href=&quot;#拓展欧几里得&quot; class=&quot;headerlink&quot; title=&quot;拓展欧几里得&quot;&gt;&lt;/a&gt;拓展欧几里得&lt;/h1&gt;&lt;p&gt;在拓展欧几里得定理之前，先介绍以下&lt;strong&gt;贝祖定理&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2022-02-17T14:24:19.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树介绍"><a href="#最小生成树介绍" class="headerlink" title="最小生成树介绍"></a>最小生成树介绍</h1><p><img src="/images/ds/mst.png" alt=""></p><p>在介绍最小生成树前，先介绍一下生成树：在一张联通无向图中，我们取图上的所有点，并取最少的边将其相连使其连通生成一棵树，这个树就被称作这张图的生成树。因为树的边数一定是点数-1，所以就是取 $n-1$ 条边来连通 $n$ 个点。</p><p>那么最小生成树(Minimum Spanning Tree)，是最小权重生成树的简称。规定树的权值为树上所有边的权值和，那么它就是一张连通加权无向图中一颗权值最小的生成树，如上图。由定义可以看出，<strong>最小生成树不一定唯一</strong>。</p><hr><p>对于如何生成最小生成树的问题，我们有两种常见的解决方法，分别是Prim算法和Kruskal算法，两者都基于贪心。</p><h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>给定图 $G(V, E)$ ，我们逐步进行Prim算法，假设在过程中，$V_{new}$ 表示已经选中作为生成树上的结点，$E_{new}$ 表示已经选中作为最小生成树上的边。</p><p>规定Prim算法如下：</p><ol><li>初始化一个结点 $x$ 加入 $V_{new}$ ，则 $V_{new} = {x}$ 。由于最小生成树包含所有节点，我们可以用任意一个结点初始化。</li><li>从集合 $E$ 中选择权值最小的边 $(u, v)$ ，满足 $u \in V_{new}$ 且 $v \notin V_{new}$ ，将 $v$ 加入集合 $V_{new}$ 中，把 $(u, v)$ 加入 $E_{new}$ 中。</li><li>重复操作，直到所有点都已经被选中加入最小生成树中，即 $V_{new} = V$ 。</li><li>根据 $V_{new}$ 和 $E_{new}$ 所得到的新图 $G_{new}(V_{new}, E_{new})$ 即为原图 $G(V, E)$ 的最小生成树。</li></ol><p>只需要证明根据第二步所得到边一定为最优解即可。</p><ol><li><p>按照Prim算法得到的第一条边一定是最小生成树上的边。</p><p>如果不是，我们把这一条边加入到最小生成树中，形成回路，我们让最小的边取代回路中比它大的边，得到权值更小的生成树。所以第一条边一定是最小生成树上的边。</p></li><li><p>假设在某一个步骤中，Prim得到的点集为 $V_{new} = \{v1, v2, v3 \ldots vs-1\}$ 。 根据Prim算法，我们应该选择与这些点有交集的边中，权值最小的边。</p><p>假设这个权值最小的边连接 $V_{new}$ 中的 $vk$ ，如果不选择这条边，那么我们把这条边加入最小生成树中，形成一个回路，且这个回路包含 $vk$ ，我们假设连接 $vk$ 的那条边另一端为 $vi$ ，我们用权值最小的边替换掉 $(vk, vi)$ ，得到的生成树权值一定不大于最小生成树，因此选择这条边为最优边。</p></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx; <span class="comment">// 邻接表存图</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// st(x) 表示x点已经加入生成树中</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">// dist(x) 表示x点距离已经生成的树的最小距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span> <span class="params">()</span> <span class="comment">// 返回最小生成树的权值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d); d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始化从1开始，最开始生成树上的V和E都为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 要加入n个点，迭代n次，每次放进一个点</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 找出距离当前生成树最近的点</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[k] &amp;&amp; (t == <span class="number">-1</span> || dist[k] &lt; dist[t])) t = k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把选择的点加入生成树中</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        ret += dist[t];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于加入了一个点，那么其他点也可以通过连接这个点到达生成树，更新dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], w[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有没有觉得Prim算法和Dijkstra算法雷同？没错，它们都是根据同样的贪心思想，唯一的区别仅仅在于更新的时候。</p><p><strong>Prim算法复杂度</strong>：根据上述代码，复杂度为 $O(n^2 + 2E)$ ，由于图上每个点至多被更新 $1$ 次，所以图的所有边至多被更新 $2$ 次。</p><p>与Dijsktra算法一样，Prim算法可以使用二叉堆优化，复杂度降到 $O((n + 2E)logn)$ 。</p><hr><h1 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h1><p>如果说Prim算法是小树长成大树的过程，那么Kruskal算法就是拼图的过程。</p><p>Prim算法基于点来扩大树，而Kruskal基于边来扩大，具体来说，该算法的过程如下：</p><ol><li>将图 $G(V, E)$ 的所有边按权值进行非递减排序。</li><li>初始化每个点都为单独的连通分量。（因为此时我们还没有选择边作为最小生成树的一部分）</li><li>从后往前检查所有边$(u, v)$ 。<ul><li>$u$ 和 $v$ 在同一个连通分量里，那么加入 $(u, v)$ 会产生环，因此不能选择。</li><li>$u$ 和 $v$ 不在一个连通分量里，那么加入 $(u, v)$ 一定是最优的。如果不加入，形成生成树 $T$ ，把 $(u, v)$ 加入 $T$ 中，会形成环，环中包含 $(u, v)$ 和另外一条权值不小于 $(u, v)$ 的边，我们把这条边用 $(u, v)$ 替换，不会使结果变差，因此 $(u, v)$ 是最优的选择。</li></ul></li></ol><p>因为会考虑所有边，因此一定能构成一颗完整的最小生成树（除非原图不连通）。</p><p>在Kruskal算法中，最关键的地方在于“连通”分量的查询和合并，需要知道两个点是否在一个连通分量中，以及如果不是在一个连通分量，需要将其合并，我们可以使用<a href="https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/"><strong>并查集</strong></a>来支持此操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span></span><br><span class="line">    <span class="keyword">int</span> u, v, d; <span class="comment">// 表示边两端的点以及边权</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp; rhs) <span class="keyword">const</span> { <span class="comment">// 重载小于号，支持比较</span></span><br><span class="line">        <span class="keyword">return</span> d &lt; rhs.d;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">Edge edges[M];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edges + <span class="number">1</span>, edges + m + <span class="number">1</span>); <span class="comment">// 假设边集从1开始存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, cnt = <span class="number">0</span>; <span class="comment">// cnt表示目前已经选择了多少条边（生成树只需要n-1条边）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; cnt &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u = edges[i].u, v = edges[i].v, d = edges[i].d;</span><br><span class="line">        u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        ++ cnt, res += d, p[u] = v;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 原图不连通，没有生成树，何谈最小</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小生成树介绍&quot;&gt;&lt;a href=&quot;#最小生成树介绍&quot; class=&quot;headerlink&quot; title=&quot;最小生成树介绍&quot;&gt;&lt;/a&gt;最小生成树介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/ds/mst.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在介绍最小</summary>
      
    
    
    
    <category term="图论" scheme="https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="生成树" scheme="https://horb7.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最近公共祖先</title>
    <link href="https://horb7.github.io/2022/02/16/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://horb7.github.io/2022/02/16/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-19T14:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先 (LCA)"></a>最近公共祖先 (LCA)</h1><p>在一个有根树中，两个结点 $a、b$ 都有若干个祖先(本身也是自己的祖先)，他们也会有公共的祖先，距离他们最近，也就是在有根树中深度最大的祖先，被称做 $a、b$ 的最近公共祖先。</p><h2 id="求最近公共祖先"><a href="#求最近公共祖先" class="headerlink" title="求最近公共祖先"></a>求最近公共祖先</h2><h3 id="向上标记法"><a href="#向上标记法" class="headerlink" title="向上标记法"></a>向上标记法</h3><p>先从一个点开始向上走到根节点，再由另一个结点开始向上走，走到一个已经被标记过的结点，那么这个结点就是这两个点的最近公共祖先。</p><p>最坏情况下树为一条链，时间复杂度为 $O(n)$ 。</p><p>由于复杂度比较大，因此这个算法不常用。</p><h3 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h3><p>倍增法基于<strong>二进制拆分</strong>，每次都尽可能向上多跳几步。</p><p>$\displaystyle {fa(i, j})$ 表示结点 $i$ 向上走 $2^j$ 次后到达的结点。</p><p>$depth(i)$ 表示结点 $i$ 在有根树中的深度。</p><p>对于结点 $a 、 b$ ，假设 $depth(a) &lt; depth(b)$ ，我们先把 $a$ 跳到与 $b$ 相同的深度；如果此时 $a == b$ ，那么LCA就是 $y$ ；否则，我们同时让 $a、b$ 向上跳到不是 LCA 的结点，最后跳到的结点的父节点就是 LCA 。</p><p>由于每次跳的步数都是 $2$ 的整数次幂，所以时间复杂度为 $O (log n)$ 。</p><p>预处理出所有 $fa(i, j)$ 的时间复杂度为 $O (n log n)$ ，所以倍增法适用于多次查询LCA。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P3379">洛谷 P3379</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qus, root;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>]; <span class="comment">// fa(i, j) 表示i结点向上走 2^j 步到达的结点</span></span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="keyword">int</span> q[N]; <span class="keyword">bool</span> st[N]; <span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    st[root] = <span class="literal">true</span>; depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i] )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j])</span><br><span class="line">            {</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 初始化 fa(i, 0) 为父节点</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 预处理 fa 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; ++ j )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i )</span><br><span class="line">            fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 (a, b) 的lca</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 保证 a 的深度大于 b</span></span><br><span class="line">    <span class="comment">// a 跳到与 b 相同深度的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b; <span class="comment">// a == b ，那么 b 就是 lca</span></span><br><span class="line">    <span class="comment">// 同时跳上面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">        {</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">            b = fa[b][i];</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>]; <span class="comment">// 此时 a 父节点就算 lca</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span> (x, y); <span class="built_in">add</span> (y, x);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">bfs</span> (); <span class="comment">// 求出每个结点的深度及fa数组</span></span><br><span class="line">    <span class="keyword">while</span> (qus -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span> (x, y) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Tarjan离线算法"><a href="#Tarjan离线算法" class="headerlink" title="Tarjan离线算法"></a>Tarjan离线算法</h3><p>Tarjan算法基于深度优先遍历，本质上是对向上标记法的优化。</p><p>遍历有根树，给每个结点分为三类。</p><ul><li>已经遍历过并且已经回溯的点</li><li>正在被遍历的点</li><li>还没有被搜索过的点</li></ul><p><strong>当一个结点回溯，我们将它合并到它的父节点上</strong>，我们可以发现，<strong>如果一次查询包括当前正在被遍历的结点和已经回溯的结点，那么他们的 LCA 就是已经回溯的点所在的集合的祖先结点</strong>。而合并及查询集合祖先的操作可以使用并查集。</p><p><img src="/images/ds/lca-tarjan.png" alt=""></p><p>如图，粉色是未被搜索到的点，蓝色是正在被遍历的点，其他都是已经遍历的点(有些未回溯，所以他们处于不同的集合)。</p><p>绿色和黄色任意点的LCA都是黄色点集合的祖先结点，其他也是如此。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P3379">洛谷 P3379</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qus, root;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> st[N]; <span class="comment">// 记录每个点的状态：1表示正在搜索，2表示已经回溯，0表示还没有搜索到</span></span><br><span class="line">vector&lt;PII&gt; query[N]; <span class="comment">// query[i] -&gt; (j, id) 表示在第id个查询中，查询的结点是(i, j)</span></span><br><span class="line"><span class="keyword">int</span> ans[N]; <span class="comment">// 存储每个查询的结果</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    st[u] = <span class="number">1</span>; <span class="comment">// 正在搜索 u 结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">// 如果还没有遍历，则遍历子结点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) { <span class="built_in">tarjan</span>(j); p[j] = u; } <span class="comment">// 回溯后记得及时合并到父节点上</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : query[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> y = t.first, id = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>) ans[id] = <span class="built_in">find</span>(y); <span class="comment">// 如果j已经回溯</span></span><br><span class="line">    }</span><br><span class="line">    st[u] = <span class="number">2</span>; <span class="comment">// u 结点回溯</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span> (x, y); <span class="built_in">add</span> (y, x);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qus; ++ i )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        {</span><br><span class="line">            query[x].<span class="built_in">push_back</span>({y, i});</span><br><span class="line">            query[y].<span class="built_in">push_back</span>({x, i});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i ) p[i] = i;</span><br><span class="line">    <span class="built_in">tarjan</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i ) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最近公共祖先-LCA&quot;&gt;&lt;a href=&quot;#最近公共祖先-LCA&quot; class=&quot;headerlink&quot; title=&quot;最近公共祖先 (LCA)&quot;&gt;&lt;/a&gt;最近公共祖先 (LCA)&lt;/h1&gt;&lt;p&gt;在一个有根树中，两个结点 $a、b$ 都有若干个祖先(本身也是自己的</summary>
      
    
    
    
    
    <category term="tree" scheme="https://horb7.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>环形纸牌均分问题</title>
    <link href="https://horb7.github.io/2022/02/16/%E7%8E%AF%E5%BD%A2%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/"/>
    <id>https://horb7.github.io/2022/02/16/%E7%8E%AF%E5%BD%A2%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2022-01-03T13:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环形纸牌均分问题"><a href="#环形纸牌均分问题" class="headerlink" title="环形纸牌均分问题"></a>环形纸牌均分问题</h1><blockquote><p>环形纸牌均分是一道很经典的贪心问题，但是每次遇到类似的都想不出来，于是就有了这篇博客记录QAQ。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有 $n$ 堆纸牌围成环形，每堆纸牌拥有 $a_i$ 个纸牌，第 $i$ 堆纸牌可以顺时针或者逆时针传播一张牌，代价为 $1$ 。问使得每堆牌的牌数数量都相等，需要的最少代价为多少？</p><p>$1 \le n \le 10^6, 1 \le a_i \le 10^9$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假设第 $i$ 堆纸牌顺时针传播了 $s_i$ 张纸牌，那么第 $i$ 堆纸牌最终有 $a_i - s_i + s_{i-1}$ 张纸牌。</p><p>由于最终纸牌数量都相等，因此有 $\overline a = \dfrac {a_1 + a_2 + \ldots + a_n} n$ 。</p><p>那么有 ：</p><script type="math/tex; mode=display">\begin{aligned}&\overline a = a_1 - s_1 + s_n \\&\overline a = a_2 - s_2 + s_1 \\&\overline a = a_3 - s_3 + s_2 \\& \ldots \\&\overline a = a_n - s_n + s_{n - 1} \\\end{aligned}</script><p>我们把 $s_i$ 提取出来：</p><script type="math/tex; mode=display">\begin{aligned}&s_1 = s_n - (\overline a - a_1) \\&s_2 = s_1 - (\overline a - a_2) = s_n - (\overline a - a_1) - (\overline a - a_2) = s_n - (2 \times \overline a - (a_1 + a_2)) \\&s_2 = s_2 - (\overline a - a_3) = s_n - (2 \times \overline a - (a_1 + a_2)) - (\overline a - a_3) = s_n - (3 \times \overline a - (a_1 + a_2 + a_3)) \\& \ldots \\&s_n = s_{n} - (n \times \overline a - (a_1 + a_2 + \ldots + a_n)) \\\end{aligned}</script><p>题目要我们求得是 $res = \sum_{i=1}^n |s_i|$ 。</p><p>所以 $res = |s_n - (\overline a - a_1)| + |s_n - (2 \times \overline a - (a_1 + a_2))| + \ldots + |s_n - (\overline n \times a - (a_1 + \ldots a_n))|$ 。</p><p>我们令 $x = s_n, \ i \times \overline a - \sum_{j = 1}^i a_j = c_i$ 。</p><p>那么 $res = |x - c_1| + |x - c_2| + |x - c_3| + \ldots + |x - c_n|$ 。</p><p>问题变成了仓库选址问题，选出一个点在数轴上与各点距离和最小，选择中位数即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll s[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>]; <span class="comment">// 求前缀和，方便计算c(i)</span></span><br><span class="line">    ll A = s[n] / n; <span class="comment">// 均值，最后到达的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[i] = i * A - s[i];</span><br><span class="line">    <span class="built_in">nth_element</span>(c + <span class="number">1</span>, c + (n + <span class="number">1</span>) / <span class="number">2</span>, c + n + <span class="number">1</span>); <span class="comment">// 求出中位数</span></span><br><span class="line">    ll x = c[(n + <span class="number">1</span>) / <span class="number">2</span>], res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res += <span class="built_in">abs</span>(x - c[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/124/">AcWing122.糖果传递</a>    模板题</p><p><a href="https://www.acwing.com/problem/content/107/">AcWing105.七夕祭</a>       排序+环形均分纸牌</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">int</span> c[N], r[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对n个人均分纸牌</span></span><br><span class="line"><span class="function">ll <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> aver = t / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) pre[i] = pre[i - <span class="number">1</span>] + a[i] - aver;</span><br><span class="line">    <span class="built_in">sort</span>(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>);</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) ret = ret + <span class="built_in">abs</span>(pre[i] - pre[n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= t &amp;&amp; cin &gt;&gt; x &gt;&gt; y; i ++ ) ++ c[x], ++ r[y];</span><br><span class="line">    <span class="keyword">if</span> (t % n == <span class="number">0</span> &amp;&amp; t % m == <span class="number">0</span>) cout &lt;&lt; <span class="string">"both "</span> &lt;&lt; <span class="built_in">calc</span>(c, n) + <span class="built_in">calc</span>(r, m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t % n == <span class="number">0</span>) cout &lt;&lt; <span class="string">"row "</span> &lt;&lt; <span class="built_in">calc</span>(c, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t % m == <span class="number">0</span>) cout &lt;&lt; <span class="string">"column "</span> &lt;&lt; <span class="built_in">calc</span>(r, m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">"impossible"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环形纸牌均分问题&quot;&gt;&lt;a href=&quot;#环形纸牌均分问题&quot; class=&quot;headerlink&quot; title=&quot;环形纸牌均分问题&quot;&gt;&lt;/a&gt;环形纸牌均分问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;环形纸牌均分是一道很经典的贪心问题，但是每次遇到类似的都想不出来，</summary>
      
    
    
    
    
    <category term="贪心" scheme="https://horb7.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>素数筛</title>
    <link href="https://horb7.github.io/2022/02/16/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <id>https://horb7.github.io/2022/02/16/%E7%B4%A0%E6%95%B0%E7%AD%9B/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2021-12-19T14:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="质数筛选"><a href="#质数筛选" class="headerlink" title="质数筛选"></a>质数筛选</h1><blockquote><p>  质数筛选指在一个范围内筛去非质数，留下质数，通常用单独的质数数组保存留下的质数。</p></blockquote><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>对于每个数字(从2开始)，筛去它所有的倍数，那么留下来的一定都是质数。</p><p>证：对于任意和数 $x$ ，一定存在一个质因数 $pj$ ，那么我们一定可以用 $pj$ 筛去 $x$ 。</p><p>时间复杂度 $O (n log n)$。</p><p>证：对于每个数字 $i$ ，内层循环会执行 $n / i$ 次。那么一共执行</p><script type="math/tex; mode=display">n / 2 + n / 3 + ... n / n = n(1 / 2 + 1 / 3 + ... + 1 / n) = n log n</script><pre><code>次。</code></pre><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!st[i]) prime[++ cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i ) st[j] = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们发现，对于每个和数 $x$ ，假设存在质因数 $pj$ ，那么如果我们用和数 $x$ 来筛去的数字也一定存在质因数 $pj$ ，也就是在 $x$ 之前这些数字就已经被 $pj$ 筛去，不需要再用 $x$ 筛去。</p><p>优化版：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!st[i])</span><br><span class="line">    {</span><br><span class="line">        prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i ) st[j] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>质数定理: $1 \sim n$ 中大约有 $n \ / \ ln \ n$ 个质数，那么总执行次数大约为 $n log n / log n = n$ ，实际复杂度大约为 $O(n log log n)$。 </p><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p>又称线性筛，每次我们都只用最小质因数来筛去和数 $x$ ，这样就不会重复筛数。因此时间复杂度为 $O(n)$ 。</p><p>原理写在代码块中，例题：</p><p>[洛谷3383]:</p><p><a href="https://www.luogu.com.cn/problem/P3383">https://www.luogu.com.cn/problem/P3383</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> prime[N], idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// O(n) 线性筛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 没有标记，是质数</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[++ idx] = i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            由于被筛选的值 k 可能含有多个质因数，会被筛去多次。</span></span><br><span class="line"><span class="comment">            我们只用k的最小质因数筛去k，这样每个数字都只会被筛去一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            k = prime[j] * i      i是当前数</span></span><br><span class="line"><span class="comment">            从小到大枚举所有质数</span></span><br><span class="line"><span class="comment">            1. i % prime[j] == 0  prime[j]是i的最小质因数，那么prime[j]一定是k的最小质因数</span></span><br><span class="line"><span class="comment">            2. i % prime[j] != 0  prime[j]小于i的任意质因数，那么prime[j]一定也是k的最小质因数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            对于每个和数x，一定存在最小质因数pj，那么当我们枚举到x / pj时，就可以把x筛去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; prime[j] &lt;= n / i; j ++ )</span><br><span class="line">        {</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                为什么这里需要break?</span></span><br><span class="line"><span class="comment">                假设当前被筛去的数字是 i * pj，由于i是pj的倍数，那么如果继续递增pj，i的最小质因数</span></span><br><span class="line"><span class="comment">                一定还是原来的pj，被筛去的数字最小质因数也一定是pj，那么我们再筛的话就会产生重复</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, prime[k]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); <span class="keyword">while</span> (T -- )</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;质数筛选&quot;&gt;&lt;a href=&quot;#质数筛选&quot; class=&quot;headerlink&quot; title=&quot;质数筛选&quot;&gt;&lt;/a&gt;质数筛选&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  质数筛选指在一个范围内筛去非质数，留下质数，通常用单独的质数数组保存留下的质数。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="math" scheme="https://horb7.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>线段树入门</title>
    <link href="https://horb7.github.io/2022/02/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/"/>
    <id>https://horb7.github.io/2022/02/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</id>
    <published>2022-02-16T14:54:28.239Z</published>
    <updated>2022-02-18T02:04:59.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线段树介绍"><a href="#线段树介绍" class="headerlink" title="线段树介绍"></a>线段树介绍</h2><p>线段树是一种基于分治思想的二叉树结构，用于在区间上进行高效的信息统计。</p><p><img src="/images/ds/segment_tree_intro.png" alt=""></p><p>如图是一般的线段树结构，我们可以发现：</p><ol><li>线段树的每个节点都代表一个区间，且按照深度递增，代表的区间逐渐缩小。</li><li>线段树是单独的一棵树，具有唯一的根节点，它代表需要统计信息的整个区间。</li><li>线段树的每个叶子节点都代表一个长度为 $1$ 的区间 $[x, x]$ 。</li><li>对于每个非叶子结点 $[l, r]$ ，它的左节点为 $[l, mid]$ ，右节点为 $[mid+1, r]$ ，其中 $mid = (l + r) / 2$ 。</li></ol><p>如果去除最后一层，那么线段树是一棵完全二叉树，因此我们可以采用与二叉堆类似的存储形式：</p><ol><li>根节点编号为 $1$ 。</li><li>对于非叶子节点 $p$ ，左节点为 $p \times 2$ ，右节点为 $p \times 2 + 1$ 。</li></ol><p>需要注意的是，最后一层是不满的，我们需要空出数组的位置来表示空节点。</p><p>除去最后一层，由于最后第二层最多有 $n$ 个节点，因此满二叉树需要 $n + \dfrac n 2 + \dfrac n 4 + \ldots + 1 = 2 \times n - 1$ 个节点。</p><p>最后一层需要开 $n \times 2$ 个节点，因此我们需要至少 $n \times 4$ 的空间存储，才能保证数组不会越界。</p><hr><h2 id="线段树的建树"><a href="#线段树的建树" class="headerlink" title="线段树的建树"></a>线段树的建树</h2><p>线段树的基本用途是维护序列的某些属性，最基本的线段树具有查询和修改两个功能。给定长度为 $[1, n]$ 的序列，我们可以按 $[1, n]$ 的区间建一棵线段树。线段树基于分治思想，需要从上往下构建。递归完成后也可以方便地从下往上传递信息。</p><p>下面以维护区间最大值为例。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(p) (p&lt;&lt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(p) (p&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">// 节点的信息，维护 [l, r] 区间内的信息</span></span><br><span class="line">    <span class="keyword">int</span> maxv; <span class="comment">// 需要在区间上维护的信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>; <span class="comment">// 假设序列最长长度为 N</span></span><br><span class="line">seg_tree t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="comment">// 原序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 当前构建的节点及其需要维护的区间</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].maxv = a[l]; <span class="keyword">return</span>; } <span class="comment">// 到达叶子节点，不需要再往下创建节点</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 否则创建左节点 [l, mid] 和右节点 [mid+1, r]</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 构建完后需要维护这个区间的信息，由于已经创建好左节点(左边一半区间)和右节点(右边一半区间)，根据这两个节点来维护</span></span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">// 从根节点1开始，它维护的是整个区间[1, n]</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="线段树的单点修改"><a href="#线段树的单点修改" class="headerlink" title="线段树的单点修改"></a>线段树的单点修改</h2><p>利用线段树递归从下往上传递信息的结构，我们也可以很方便地修改某一个元素。</p><p>叶子节点代表单个长度的区间，也就是具体的某一个元素。我们可以递归地找到需要修改的叶子节点，在回溯的过程维护它的父节点(代表的区间包括自己的区间，所以也要修改)。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> <span class="comment">// 需要把x位置的元素改为v，目前为p节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) { t[p].maxv = v; <span class="keyword">return</span>; } <span class="comment">// 已经找到</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 否则判断去左区间找还是去右区间找</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), x, v); <span class="comment">// 左区间为[l, mid]，在这个区间内</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), x, v); <span class="comment">// 右区间为[mid+1, r]</span></span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv); <span class="comment">// 注意修改完子区间后，当前区间需要维护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, x, v); <span class="comment">// 从根节点开始找</span></span><br></pre></td></tr></tbody></table></figure><p>在线段树的单点修改过程中，每一层只会被调用一次，而线段树的高度为 $log n$ ，因此复杂度为 $log n$ 。</p><hr><h2 id="线段树区间查询"><a href="#线段树区间查询" class="headerlink" title="线段树区间查询"></a>线段树区间查询</h2><p>以维护区间最大值的线段树为例，我们查找区间 $[l ,r]$ 的最大值，需要从根节点开始，递归完成：</p><ol><li>如果 $[l, r]$ 区间完全覆盖了当前节点的范围，直接返回当前节点维护的信息。</li><li>如果左节点和 $[l, r]$ 有交叉，那么递归查询左节点。</li><li>如果右节点和 $[l, r]$ 有交叉，那么递归查询右节点。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 需要查询[l, r]的最大值，当前节点为p</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="keyword">return</span> t[p].maxv; <span class="comment">// 完全覆盖，节点区间内所有元素都是查询区间内的元素</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 否则查询左节点和右节点</span></span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">-2e9</span>; <span class="comment">// 设为负无穷</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) maxv = <span class="built_in">max</span>(maxv, <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r)); <span class="comment">// [l, r]与左节点有交叉</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) maxv = <span class="built_in">max</span>(<span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r)); <span class="comment">// [l, r]与右节点有交叉</span></span><br><span class="line">    <span class="keyword">return</span> maxv;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl; <span class="comment">// 从根节点开始查询</span></span><br></pre></td></tr></tbody></table></figure><p>关于复杂度：</p><ol><li><p>在任意一个节点，只查询它的左节点/右节点。</p><p>显然复杂度是 $O(log n)$ 的。</p></li><li><p>在某些节点，查询左右节点。</p><p>在左节点，显然又有两种可能，如果只查询一遍，那么可以保证 $O(log n)$ 的复杂度，如果查询左右两边，那么左边一定是被完全覆盖的，因此可以直接回溯。右节点同理。</p><p>所以查询左右节点，本质只是比查询单边多了一次查询，因此复杂度为 $O(2 log n) = O(log n)$ 。</p></li></ol><hr><h2 id="线段树的区间修改"><a href="#线段树的区间修改" class="headerlink" title="线段树的区间修改"></a>线段树的区间修改</h2><p>假设现在要把 $[l, r]$ 中所有元素加上 $v$ ，一种显然的做法是对 $[l, r]$ 中所有元素执行一次单点修改，但这样的复杂度为 $O(len \times log n)$ 的，最坏情况下修改所有元素，则需要修改整棵树，复杂度 $O(n)$ 。</p><p>可以发现，如果我们对区间 $[l, r]$ 中所有元素进行修改，但后面的查询中没有用到 $[l, r]$ 的子区间 ，那么这个修改是无意义的。也就是说，最<strong>好的办法就是在查询时才更新当前的区间</strong> 。</p><p>类似于区间查找，当我们发现某一个节点维护的区间被需要修改的区间覆盖，那么我们修改完当前节点后，直接回溯，不用对其递归修改，比如修改区间 $[1, 10]$ ，当我们递归到节点 $[1, 5]$ 时，就可以修改并回溯。同时我们要给这个节点打上标记，表示当前节点已经修改，但其子区间未修改。</p><p>在之后的查询过程中，如果需要使用其子结点，则使用标记的信息更新两个子结点，同时为子结点打上标记，再清除当前节点的标记。</p><p>类似于区间查询，区间修改会将区间划分为 $O(log n)$ 个小区间，将复杂度降为 $O(log n)$ 。</p><p>下面以例题 <a href="https://www.luogu.com.cn/problem/P3372">[模板]线段树1</a> 为例。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以维护区间和为例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll sum, add; <span class="comment">// sum为[l, r]区间元素的和，add为懒标记，记录当前这个区间，每个元素加了多少</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">seg_tree t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// pushup操作：自下而上维护每个节点的sum值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].sum = t[<span class="built_in">lc</span>(p)].sum + t[<span class="built_in">rc</span>(p)].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// pushdown操作：将懒标记下传，将子节点变为真实值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!t[p].add) <span class="keyword">return</span> ; <span class="comment">// 如果当前位置没有懒标记，直接返回</span></span><br><span class="line">    t[<span class="built_in">lc</span>(p)].sum += t[p].add * (t[<span class="built_in">lc</span>(p)].r - t[<span class="built_in">lc</span>(p)].l + <span class="number">1</span>); <span class="comment">// 左节点</span></span><br><span class="line">    t[<span class="built_in">rc</span>(p)].sum += t[p].add * (t[<span class="built_in">rc</span>(p)].r - t[<span class="built_in">rc</span>(p)].l + <span class="number">1</span>); <span class="comment">// 右节点</span></span><br><span class="line">    t[<span class="built_in">lc</span>(p)].add += t[p].add; <span class="comment">// 给左节点加懒标记，注意左节点可能已经加过懒标记</span></span><br><span class="line">    t[<span class="built_in">rc</span>(p)].add += t[p].add; <span class="comment">// 给右节点加懒标记，注意右节点可能已经加过懒标记</span></span><br><span class="line">    t[p].add = <span class="number">0</span>; <span class="comment">// 清除p的懒标记</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].sum = a[l]; <span class="keyword">return</span>; } <span class="comment">// 到达叶子节点，此时区间长度为1，sum即为此位置的值</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="comment">// 使用pushup自下往上维护信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> <span class="comment">// 为[l, r]区间所有数字增加v</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="comment">// 当前节点被[l, r]区间覆盖</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 修改当前区间，打上标记并回溯</span></span><br><span class="line">        t[p].sum += (ll)v * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="comment">// 此时这个点的子节点需要使用，将懒标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), l, r, v); <span class="comment">// 左节点[t[p].l, mid]有部分被覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), l, r, v); <span class="comment">// 右节点[mid+1, t[p].r]有部分被覆盖</span></span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="comment">// 子结点被修改，记得维护当前节点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="comment">// 子节点需要使用，记得下传懒标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>; <span class="comment">// 当前节点被[l, r]覆盖的元素的和</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret += <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r); <span class="comment">// 左节点[t[p].l, mid]有部分被覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret += <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r); <span class="comment">// 右节点[mid+1, t[p].r]有部分被覆盖</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">// 在区间[1, n]上建立线段树</span></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, l, r, v;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) cin &gt;&gt; v, <span class="built_in">modify</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><a href="https://www.acwing.com/problem/content/248/">一个简单的整数问题</a> 可以使用树状数组</li><li><p><a href="https://www.acwing.com/problem/content/244/">一个简单的整数问题2</a> 区间加，区间和</p></li><li><p><a href="https://ac.nowcoder.com/acm/contest/23479/B">进制</a> 维护所有进制</p></li><li><p><a href="https://www.acwing.com/problem/content/246/">你能回答这些问题吗</a> 比较难的题目，需要维护较多信息</p></li><li><p><a href="https://www.acwing.com/problem/content/247/">区间最大公约数</a> 更损相减法</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线段树介绍&quot;&gt;&lt;a href=&quot;#线段树介绍&quot; class=&quot;headerlink&quot; title=&quot;线段树介绍&quot;&gt;&lt;/a&gt;线段树介绍&lt;/h2&gt;&lt;p&gt;线段树是一种基于分治思想的二叉树结构，用于在区间上进行高效的信息统计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imag</summary>
      
    
    
    
    <category term="数据结构" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="线段树" scheme="https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux下使用C++连接MySql</title>
    <link href="https://horb7.github.io/2022/02/16/Linux%E4%B8%8BMySql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://horb7.github.io/2022/02/16/Linux%E4%B8%8BMySql%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-16T14:54:28.238Z</published>
    <updated>2022-01-07T04:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h1><p>在Ubuntu 20.04环境下，我们已经安装好MySql，如果想要用C++连接MySql，我们还需要mysql-client，完整的需要以下几项：</p><p><code>sudo apt-get install mysql-server</code></p><p><code>sudo apt-get install apache2</code></p><p><code>sudo apt-get install libmysqlclient-dev</code></p><p>安装后，检查<code>/usr/include/mysql</code>中是否存在<code>mysql.h</code>文件：</p><p><img src="/images/db/mysql_h.png" alt=""></p><p>如果存在，说明安装成功，可以用C++连接MySql数据库了。</p><hr><h1 id="使用C-连接MySql"><a href="#使用C-连接MySql" class="headerlink" title="使用C++连接MySql"></a>使用C++连接MySql</h1><h2 id="相关API介绍"><a href="#相关API介绍" class="headerlink" title="相关API介绍"></a>相关API介绍</h2><p>在cpp文件中，我们需要引入<code>mysql.h</code>头文件来使用MySql相关API。</p><p>这里列出常用的函数。（注：MYSQL为结构体，存储mysql操作的处理）</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">MYSQL * mysql_init(MYSQL * mysql)</td><td>初始化MYSQL结构体，参数为NULL指针则分配+初始化</td></tr><tr><td style="text-align:left">MYSQL * mysql_real_connect(MYSQL * mysql, const char * host, const char * user, const char * passwd, const char * db, unsigned int port, const char * unix_socket, unsigned long client_flag)</td><td>把mysql结构体连接到具体的服务器的某个用户上，返回非0表示连接成功</td></tr><tr><td style="text-align:left">int mysql_query(MYSQL * mysql, const char * stmt_str)</td><td>执行SQL查询，若成功查询返回0，否则返回1</td></tr><tr><td style="text-align:left">MYSQL_RES * mysql_store_result(MYSQL * mysql)</td><td>存储上次查询的所有结果</td></tr><tr><td style="text-align:left">int mysql_next_result(MYSQL * mysql)</td><td>查看是否存在下一个结果集（一次查询可能返回多个表）并把指针放到下一个表便于查询。返回0表示存在，非0表示不存在。</td></tr><tr><td style="text-align:left">unsigned int mysql_num_fields(MYSQL_RES * result)</td><td>返回结果集的列数</td></tr><tr><td style="text-align:left">unsigned int mysql_num_rows(MYSQL_RES * result)</td><td>返回结果集的行数</td></tr><tr><td style="text-align:left">MYSQL_ROW mysql_fetch_row(MYSQL_RES * result)</td><td>从结果集中返回下一行数据，NULL表示结束</td></tr><tr><td style="text-align:left">MYSQL_FIELD mysql_fetch_field(MYSQL_RES * result)</td><td>从结果集中返回下一列数据，NULL表示结束</td></tr><tr><td style="text-align:left">char * mysql_error(MYSQL * mysql)</td><td>返回上一次的报错信息</td></tr><tr><td style="text-align:left">void mysql_free_result(MYSQL_RES * result)</td><td>释放结果集所占的内存</td></tr><tr><td style="text-align:left">void mysql_close(MYSQL * mysql)</td><td>关闭结构体对数据库的连接</td></tr></tbody></table></div><hr><h2 id="C-连接MqSql基本流程"><a href="#C-连接MqSql基本流程" class="headerlink" title="C++连接MqSql基本流程"></a>C++连接MqSql基本流程</h2><ol><li>使用mysql_init()初始化结构体</li><li>使用mysql_real_connect()建立结构体与对应数据库的连接</li><li>使用mysql_query()进行相关的数据操作</li><li>输出查询：<ol><li>使用res = mysql_store_result(mysql)来获取查询的结果集</li><li>使用mysql_num_rows(res)获取行数，mysql_num_fields(res)获取列数</li><li>不断通过mysql_fetch_row(res)来获取每一行的查询数据，直到结束</li></ol></li><li>释放结果集所占的内存mysql_free_result(res)</li><li>mysql_close(mysql)关闭结构体与数据库的连接</li></ol><p><strong>注意点</strong>：由于我们使用的不是C++原有的库，所以在编译的时候要指明额外使用的库</p><p>编译命令：<code>g++ test.cpp -o main -I/usr/include/mysql -lmysqlclient</code></p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"*******"</span> <span class="comment">// 此处为你的服务器ip地址，如果为本地则输入localhost</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"*****"</span> <span class="comment">// 服务器用户名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"******"</span> <span class="comment">// 用户名对应的密码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATABASE <span class="meta-string">"*******"</span> <span class="comment">// 需要使用的数据库名字</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * sql_operator = <span class="string">"insert into student(class, sid, sname) values('cs2001', 111111111, 'i_dont_know')"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * sql_query = <span class="string">"call attend_exam(1)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sql_operator: %s\n"</span>, sql_operator);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sql_query: %s\n"</span>, sql_query);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator_sql(sql_operator);</span></span><br><span class="line">    <span class="built_in">query_sql</span>(sql_query);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MYSQL conn;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="built_in">mysql_init</span>(&amp;conn);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_real_connect</span>(&amp;conn, HOST, USERNAME, PASSWORD, DATABASE, <span class="number">0</span>, <span class="literal">NULL</span>, CLIENT_FOUND_ROWS))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connect success!\n"</span>);</span><br><span class="line">        res = <span class="built_in">mysql_query</span>(&amp;conn, sql);</span><br><span class="line">        <span class="keyword">if</span> (res) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">mysql_error</span>(&amp;conn)); <span class="comment">// 如果执行不成功，输出报错信息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"operator success!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">mysql_close</span>(&amp;conn);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MYSQL my_connection; <span class="comment">// 数据库连接</span></span><br><span class="line">    <span class="keyword">int</span> res; <span class="comment">// 执行sql语句后的返回标志</span></span><br><span class="line">    MYSQL_RES * res_ptr; <span class="comment">// 指向查询结果的指针</span></span><br><span class="line">    MYSQL_FIELD * field; <span class="comment">// 字段结构指针</span></span><br><span class="line">    MYSQL_ROW result_row; <span class="comment">// 按行返回的查询信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row, column; <span class="comment">// 查询返回的行数和列数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">mysql_init</span>(&amp;my_connection); <span class="comment">// 初始化mysql连接my_connection</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_real_connect</span>(&amp;my_connection, HOST, USERNAME, PASSWORD, DATABASE, <span class="number">0</span>, <span class="literal">NULL</span>, CLIENT_FOUND_ROWS))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connectio success!\n"</span>);</span><br><span class="line">        <span class="comment">// 设置查询编码为utf8</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(&amp;my_connection, <span class="string">"set names utf8"</span>);</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">mysql_query</span>(&amp;my_connection, sql); <span class="comment">// 查询，返回0代表成功</span></span><br><span class="line">        <span class="keyword">if</span> (res) <span class="built_in">printf</span>(<span class="string">"Error: mysql_query!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 执行成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"query some row\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> tables = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 把返回信息的所有表都输出</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                res_ptr = <span class="built_in">mysql_store_result</span>(&amp;my_connection);</span><br><span class="line">                <span class="keyword">if</span> (res_ptr) <span class="comment">// 结果不为空，说明有结果</span></span><br><span class="line">                {</span><br><span class="line">                    column = <span class="built_in">mysql_num_fields</span>(res_ptr); <span class="comment">// 此表的列数</span></span><br><span class="line">                    row = <span class="built_in">mysql_num_rows</span>(res_ptr); <span class="comment">// 此表的行数</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"查询到第 %d 行, 此为第 %d 张表\n"</span>, row + <span class="number">1</span>, ++ tables);</span><br><span class="line">                    <span class="comment">// 输出每一列的属性</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; field = <span class="built_in">mysql_fetch_field</span>(res_ptr); i ++ )</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s\t"</span>, field-&gt;name);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(result_row = <span class="built_in">mysql_fetch_row</span>(res_ptr))</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j ++ )</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">"%s\t"</span>, result_row[j]);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">               <span class="keyword">else</span> <span class="built_in">mysql_free_result</span>(res_ptr); <span class="comment">// 如果以及查询完毕，则释放查询结果占用的内存</span></span><br><span class="line">            } <span class="keyword">while</span>(!<span class="built_in">mysql_next_result</span>(&amp;my_connection)); <span class="comment">// 返回0则代表还有剩余的结果</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">mysql_close</span>(&amp;my_connection); <span class="comment">// 查询结束，关闭结构体与数据库的连接</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装MySql&quot;&gt;&lt;a href=&quot;#安装MySql&quot; class=&quot;headerlink&quot; title=&quot;安装MySql&quot;&gt;&lt;/a&gt;安装MySql&lt;/h1&gt;&lt;p&gt;在Ubuntu 20.04环境下，我们已经安装好MySql，如果想要用C++连接MySql，我们还需</summary>
      
    
    
    
    <category term="数据库" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Linux" scheme="https://horb7.github.io/tags/Linux/"/>
    
    <category term="MySql" scheme="https://horb7.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Edu Codeforces Round 121</title>
    <link href="https://horb7.github.io/2022/02/16/Edu-Codeforces-Round-121/"/>
    <id>https://horb7.github.io/2022/02/16/Edu-Codeforces-Round-121/</id>
    <published>2022-02-16T14:54:28.238Z</published>
    <updated>2022-01-17T03:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Edu-Codeforces-Round-121"><a href="#Edu-Codeforces-Round-121" class="headerlink" title="Edu Codeforces Round 121"></a>Edu Codeforces Round 121</h1><h2 id="C-Monsters-And-Spells"><a href="#C-Monsters-And-Spells" class="headerlink" title="C. Monsters And Spells"></a>C. Monsters And Spells</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 只怪物需要被消灭，第 $i$ 只怪物在 $k_i$ 秒出现，有 $h_i$ 点生命值 ，<strong>必须在怪物出现的那一秒消灭他</strong>。</p><p>Monocarp 每秒可以使用一次法咒，可以选择法咒伤害为 $x + 1$ 或 $1$ ，$x$ 为上一秒使用法咒造成的伤害。</p><p>使用伤害为 $x$ 的法咒，会消耗 $x$ 点法力值。</p><p>问Monocarp至少需要消耗多少法力值才能消灭 $n$ 只怪物。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于第 $i$ 只怪物，需要使用法咒的区间为 $[k_i - h_i + 1, k_i]$ 。也就是至少要从 $k_i - h_i + 1$ 位置开始使用法咒。</p><p>这个区间可能会有重复，比如两只怪物的区间为 $[l_1, r_1]$ 和 $[l_2, r_2]$ 。其中 $l_1 \le l_2 \le r_1$ 。</p><p>那么对于区间 $[l_2, r_2]$ 的怪物，我们需要从 $l_1$ 开始使用法咒，否则不能消灭第一只怪物。</p><p>也就是说消灭这两只怪物的区间为两个区间的合并，即 $[l_1, r_2]$ 。</p><p>推广到所有怪物，只需要把他们的<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/">区间合并</a>即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, s) for (auto x : s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb emplace_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">k</span><span class="params">(n)</span>, <span class="title">h</span><span class="params">(n)</span></span>;</span><br><span class="line">    forr(&amp;x, k) cin &gt;&gt; x;</span><br><span class="line">    forr(&amp;x, h) cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    vector&lt;T&gt; v, f; <span class="comment">// v存储所有怪物的区间，f存储合并后的区间</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n<span class="number">-1</span>) v.<span class="built_in">pb</span>(k[i] - h[i] + <span class="number">1</span>, k[i]);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 合并区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [x, y] : v)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (f.<span class="built_in">empty</span>() || f.<span class="built_in">back</span>().second &lt; x) f.<span class="built_in">pb</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> f.<span class="built_in">back</span>().second = <span class="built_in">max</span>(f.<span class="built_in">back</span>().second, y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [x, y] : f)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> cost = y - x + <span class="number">1</span>;</span><br><span class="line">        ret += (<span class="number">1</span> + cost) * cost / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="D-Martial-Arts-Tournament"><a href="#D-Martial-Arts-Tournament" class="headerlink" title="D. Martial Arts Tournament"></a>D. Martial Arts Tournament</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个参赛选手，第 $i$ 个选手体重为 $a_i$ ，现在要根据选手的体重分为三个赛区，轻量、中量、重量区。</p><p>选择两个标准 $x, y$ ，所有严格小于 $x$ 重量的选手在轻量赛区，所有不小于 $y$ 重量的选手在重量赛区。</p><p>现在要使三个赛区的选手数量为 $2$ 的幂，请问至少需要加多少选手？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>前缀和思想，令 $f(x)$ 表示轻量赛区需要 $x$ 个人，实际上有多少人(因为间断点左右不能重量相同) 。同理 $g(x)$ 表示重量赛区需要 $x$ 个人，实际上有多少人。</p><p>枚举 $f(x)$ 和 $g(y)$ 中的 $x$ 和 $y$ 都为 $2$ 的幂次的情况，求出中量赛区需要多少人，加起来就是总共需要的人数，取最小值即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="keyword">int</span> x; cin &gt;&gt; x; ++ a[x]; }</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// rep(i, 1, n) 枚举重量，s维护前缀和(人数)</span></span><br><span class="line">    <span class="comment">// 第二个循环rep(j, s, s + a[i] - 1) 其实是枚举中间的间断点，此时应该还是s，不能累加上自己，因为间断点左右不能重量相同。</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="built_in">rep</span>(j, s, s + a[i] - <span class="number">1</span>) f[j] = s; s += a[i]; }</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) { <span class="built_in">rep</span>(j, s, s + a[i] - <span class="number">1</span>) g[j] = s; s += a[i]; }</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n; a &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n; b &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x = f[a], y = g[b];</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">1</span>; <span class="keyword">while</span>(ans &lt; n - x - y) ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, ans + a + b);</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; ret - n &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Edu-Codeforces-Round-121&quot;&gt;&lt;a href=&quot;#Edu-Codeforces-Round-121&quot; class=&quot;headerlink&quot; title=&quot;Edu Codeforces Round 121&quot;&gt;&lt;/a&gt;Edu Codeforces</summary>
      
    
    
    
    
    <category term="codeforces" scheme="https://horb7.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Manacher算法</title>
    <link href="https://horb7.github.io/2022/02/16/Manacher%E7%AE%97%E6%B3%95/"/>
    <id>https://horb7.github.io/2022/02/16/Manacher%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-16T14:54:28.238Z</published>
    <updated>2021-12-23T09:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher是一种<strong>处理字符串最长回文子串</strong>的算法，由Manacher于1975年发明。</p><p>Manacher算法与KMP思想类似，都是反复对以往已经处理过的信息的再次运用，以达到减少重复计算的目的。</p><p>在朴素算法中，我们枚举了每个中心点 $i$​​ 的位置，并从中心点由0不断增长，求出以 $i$​ 为中心点时的最长回文串，而Manacher正是对此的优化。</p><p>首先，回文串有奇偶之分，在朴素算法中需要分别处理，我们可以直接在每个字符前后加一个字符串中不出现的字符(‘#’)，这样所有的回文串都变成了奇回文串，同时为了处理越界问题，需要在整个字符串前后加两个不同的字符(可以是’@’和’^’等)。</p><p>==”abac” —&gt;”@#a#b#a#c#^”==</p><p>我们用 $p[i]$​​ ​表示以 $i$​​​​ 为中心点时的<strong>最大回文半径</strong>，即，对于上述例子，$p[4] = 4(b作为中心点)$​ 。​</p><p>假设我们正在处理以第 $i+1$ 为中心点的字符串，如果前 $i$ 个字符串中，第 $j$ 个字符串向右延伸地最长，为maxRange，存在下列两种情况：</p><ol><li><p>$i+1&lt;maxRange$​​ ，那么，根据回文串的对称性，在 $i+1$​​ 关于$j$​​对称的地方$(记作k)$​，$s[i] == s[k]$，我们可以用之前计算的 $k$ 来​​给 $i$ 赋一个初值。​ </p></li><li><p>$i+1&gt;=maxRange$​，直接记第 $i+1$​ 位初始值为1即可。</p></li></ol><p><em>Code</em></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ss[<span class="number">0</span>] = <span class="string">'@'</span>; ss[++len] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">{</span><br><span class="line">    ss[++len] = s[i];</span><br><span class="line">    ss[++len] = <span class="string">'#'</span>;</span><br><span class="line">}</span><br><span class="line">ss[++len] = <span class="string">'^'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (maxRange &gt; i) p[i] = <span class="built_in">min</span>(maxRange - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">    <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i + p[i]] == s[i - p[i]]) p[i] ++ ;</span><br><span class="line">    <span class="keyword">if</span> (i + p[i] &gt; maxRange) maxRange = i + p[i], id = i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Manacher算法的时间复杂度时间复杂度为 $O(n)$，朴素算法时间复杂度为 $O(n^2)$。</p><p>时间复杂度证明：首先外层循环复杂度是 $O(n)$​ 的，只需要证明内层while循环总次数为 $O(n)$​ 级别即可。<br>对于每个中心点，如果它向右拓展了 $k$​ 次，那么对于后面的 $k$​ 个数字，每个都可以少拓展一次(赋初值)，while总循环次数为 $O(n)$​。所以总复杂度为 $O(n)$​。</p><p>例题链接: <a href="https://www.acwing.com/problem/content/description/1526/">https://www.acwing.com/problem/content/description/1526/</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">char</span> ss[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>], len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    ss[<span class="number">0</span>] = <span class="string">'@'</span>;</span><br><span class="line">    ss[++len] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        ss[++len] = s[i];</span><br><span class="line">        ss[++len] = <span class="string">'#'</span>;</span><br><span class="line">    }</span><br><span class="line">    ss[++len] = <span class="string">'^'</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRange = <span class="number">-1</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (maxRange &gt; i) p[i] = <span class="built_in">min</span>(maxRange - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss[i + p[i]] == ss[i - p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; maxRange) maxRange = i + p[i], id = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) res = <span class="built_in">max</span>(res, p[i] - <span class="number">1</span>); <span class="comment">// id仅仅是拓展到最右边的位置，这个maxRange受到 i和p[i]共同影响，不能直接用p[id]-1作为结果</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Manacher算法&quot;&gt;&lt;a href=&quot;#Manacher算法&quot; class=&quot;headerlink&quot; title=&quot;Manacher算法&quot;&gt;&lt;/a&gt;Manacher算法&lt;/h2&gt;&lt;p&gt;Manacher是一种&lt;strong&gt;处理字符串最长回文子串&lt;/strong</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://horb7.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>MySql安装与简单配置</title>
    <link href="https://horb7.github.io/2022/02/16/MySql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>https://horb7.github.io/2022/02/16/MySql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</id>
    <published>2022-02-16T14:54:28.238Z</published>
    <updated>2022-01-07T11:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-安装和配置"><a href="#Mysql-安装和配置" class="headerlink" title="Mysql 安装和配置"></a>Mysql 安装和配置</h1><p>纯小白开始用 mysql ，记录一下安装与配置的环节，便于以后查看。下文的 mysql 版本均为 $8.0$。 Linux版本为Ubuntu 20.04。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Ubuntu 20.04上，默认情况只有最新版本的mysql包含在apt存储库里，所以要先更新服务器的软件包索引：</p><p><code>sudo apt update</code></p><p>接下来安装mysql默认包。</p><p><code>sudo apt install mysql-server</code></p><p>安装完mysql后，它默认是启动的。</p><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><h3 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h3><p>mysql安装完毕后，数据目录必须初始化，使用 <code>sudo mysql_secure_installation</code> 来自动初始化数据目录。</p><p>之后需要对mysql安装的安全选项做一些修改。</p><ol><li>是否安装验证密码插件，用来测试mysql密码的强度。</li><li>为mysql root用户设置密码，然后确认。</li><li>之后的提示可以按 $enter$ 使用默认值。</li></ol><h3 id="修改用户身份验证和使用权限"><a href="#修改用户身份验证和使用权限" class="headerlink" title="修改用户身份验证和使用权限"></a>修改用户身份验证和使用权限</h3><p>在 mysql8.0 中，mysql root 用户设置为使用默认的 auth_socket 插件进行身份验证，而不是密码。如果要使用外部程序来访问用户，操作会变得繁琐。</p><p>我们可以把身份验证修改为使用密码验证。即把 $auth\_socket$ 变成 $mysql \_ native \_ password$ 模式。</p><p>首先进入到mysql里，<code>sudo mysql</code></p><p>接下来我们可以查看mysql用户的账号使用的身份验证方式。</p><p><code>SELECT user, plugin, host FROM mysql.user;</code></p><p><img src="/images/db/modify_passwd.png" alt="image-20211209232523927"></p><p>由于我这里已经设置了，所以是 $mysql \_ native \_ password$ 模式。</p><p>我们可以使用 $ALTER \ \ USER$ 命令修改root用户。注意要把 $password$ 设置为选择的密码规范（满足一定强度）。</p><p><code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password by 'password';</code> ，这里$password$ 填入你需要更改的密码。</p><p>然后需要使用 <code>FLUSH PRIVILEGES;</code> 来使服务器重新加载授权表并使新更改生效。</p><p>之后我们可以再次使用 <code>SELECT user, plugin, host FROM mysql.user;</code> 来验证是否修改了root 用户的登陆模式。</p><p>注意，如果使用了密码登录，我们可以使用 <code>mysql -u root -p</code> 这样的方式来访问mysql root用户。</p><h4 id="如何更改密码规范？"><a href="#如何更改密码规范？" class="headerlink" title="如何更改密码规范？"></a>如何更改密码规范？</h4><p>在我们设置密码的时候可能会出现 “mysql: Your password does not satisfy the current policy requirements” 这样的错误，这是因为密码规范比较高，而你设置的密码太简单。</p><p>如果要设置简单一点的密码，我们需要更改密码规范：</p><p>使用 <code>show variables like 'validate_password%'</code> 来查看当前的密码规范。</p><p><img src="/images/db/modify_passwd2.png" alt=""></p><p>$policy$ 表示当前密码规范强度（有 $LOW$, $MEDIUM$, $HIGH$ 三种强度）。</p><p>$length$ 表示密码至少需要多少长度。</p><p>我们可以对这两个属性进行设置：</p><p><code>set global validate_password.policy=0;</code></p><p><code>set global validate_password.length=1;</code></p><p>接下来我们再次使用 $ALTER \ \ USER$ 命令即可更改用户密码。</p><h3 id="修改用户或添加权限"><a href="#修改用户或添加权限" class="headerlink" title="修改用户或添加权限"></a>修改用户或添加权限</h3><h4 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h4><p>如果要查看用户比较少的属性，可以直接使用</p><p><code>use mysql;</code></p><p><code>SELECT user, host FROM mysql.user</code></p><p>来查询。</p><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><p><code>CREATE USER 'user_name'@'host' IDENTIFIED BY 'password'</code> </p><p>其中：</p><p>user_name 是你创建出来的用户的用户名。</p><p>host 表示这个新创建的用户登录模式，$localhost$ 表示只能从本服务器登录，$\%$ 表示可以从远程登录。</p><p>password 为新用户的密码，可以不填。</p><h4 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h4><p><code>GRANT privileges ON databasename.tablename TO 'username'@'host'</code></p><p>查看用户权限：<code>SHOW GRANTS FOR USER%host</code></p><p>其中：</p><p>privileges 表示赋予的权利，如 select，update，insert，delete等，如果要赋予全部权力，可以使用ALL。</p><p>databasename.tablename 表示某个数据库的某个表，如果可以对任意数据库的任意表做操作，可以使用 *.* 。</p><p>username@host 表示某一个用户。</p><h4 id="撤销用户权限"><a href="#撤销用户权限" class="headerlink" title="撤销用户权限"></a>撤销用户权限</h4><p><code>REVOKE privileges ON dataname.tablename FROM 'username'@'host'</code></p><h5 id="撤销操作的注意点"><a href="#撤销操作的注意点" class="headerlink" title="撤销操作的注意点"></a>撤销操作的注意点</h5><p><strong>撤销语句必须和之前的授权语句一模一样，否则无法撤销权限。</strong></p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p><code>DROP USER 'username'@'host'</code> </p><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><p><code>RENAME USER 'name1'@'host1' TO 'name2'@'host2'</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql-安装和配置&quot;&gt;&lt;a href=&quot;#Mysql-安装和配置&quot; class=&quot;headerlink&quot; title=&quot;Mysql 安装和配置&quot;&gt;&lt;/a&gt;Mysql 安装和配置&lt;/h1&gt;&lt;p&gt;纯小白开始用 mysql ，记录一下安装与配置的环节，便于以后查看。</summary>
      
    
    
    
    <category term="数据库" scheme="https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Linux" scheme="https://horb7.github.io/tags/Linux/"/>
    
    <category term="MySql" scheme="https://horb7.github.io/tags/MySql/"/>
    
  </entry>
  
</feed>
