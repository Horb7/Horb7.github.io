{"meta":{"title":"Horb7's blog","subtitle":"一日事，一日毕","description":"","author":"Horb7","url":"https://horb7.github.io","root":"/"},"pages":[{"title":"404","date":"2019-10-13T07:49:05.000Z","updated":"2022-02-24T16:08:40.191Z","comments":true,"path":"/404.html","permalink":"https://horb7.github.io/404.html","excerpt":"","text":""},{"title":"About","date":"2022-02-16T14:54:28.240Z","updated":"2021-12-25T01:10:44.000Z","comments":true,"path":"about/index.html","permalink":"https://horb7.github.io/about/index.html","excerpt":"","text":"关于我菜到无法自拔却想学各种东西那件事。 Profile 计算机本科在读（就读于全球某工商大学） 六级可能没过 想要入门全栈 codeforces想要上16001900 $Nothing \\ \\ to \\ \\ write.$"},{"title":"Gallery","date":"2022-02-24T16:07:11.471Z","updated":"2021-12-21T15:03:44.000Z","comments":true,"path":"gallery/index.html","permalink":"https://horb7.github.io/gallery/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2022-02-24T16:02:30.695Z","comments":true,"path":"link/index.html","permalink":"https://horb7.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-19T02:33:11.000Z","updated":"2022-02-25T02:10:53.481Z","comments":true,"path":"tags/index.html","permalink":"https://horb7.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-19T02:31:54.000Z","updated":"2022-02-25T02:11:16.425Z","comments":true,"path":"categories/index.html","permalink":"https://horb7.github.io/categories/index.html","excerpt":"","text":""},{"title":"记录一些遇到的编程语法问题","date":"2022-02-16T14:54:28.251Z","updated":"2022-01-26T14:10:18.000Z","comments":true,"path":"trick/index.html","permalink":"https://horb7.github.io/trick/index.html","excerpt":"","text":"关于sort中cmp的写法在比较函数中，一定要按照比较函数规定写，即只能写 $a &gt; b$ 或 $a &lt; b$ 。 坚决不能写 $a \\le b$ 或 $a &gt;= b$ 或 $a = b$ 等形式。一来加上等于不会改变结果（本身就是不稳定排序），二来加了等于可能会引起段错误。"}],"posts":[{"title":"2021浙江省赛题解","slug":"2021浙江省赛题解","date":"2022-03-02T05:38:31.000Z","updated":"2022-03-02T08:50:21.516Z","comments":true,"path":"2022/03/02/2021浙江省赛题解/","link":"","permalink":"https://horb7.github.io/2022/03/02/2021%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"","text":"D. Shortest Path QueryCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using T = pair&lt;ll, int&gt;;const int N = 100010;vector&lt;T&gt; g[N];int n, m, vis[N];ll f[N][21]; // f(i, j)表示i点删了j个后面的数字的点走过的最短路void dijkstra (int root) // 以root点作为前缀，在它后面加数字，与其他各数字的最短路{ priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; q; vector&lt;int&gt; c; q.push({0, root}); int j; f[root][0] = 0; while(!q.empty()) { T t = q.top(); q.pop(); ll dist = t.first, u = t.second; if (vis[u]) continue; vis[u] = true; c.push_back(u); for (j = 0; (u &gt;&gt; j) != root; ++ j); f[u][j] = min(f[u][j], dist); for (auto &amp;[v, w]: g[u]) if (!vis[v] &amp;&amp; v &gt;= root) q.push({w + dist, v}); } for (int v: c) vis[v] = false;}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); memset(f, 0x3f, sizeof f); for (int i = 1; i &lt;= m; i ++ ) { ll u, v, w, j; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); if (u &gt; v) swap(u, v); g[u].push_back({v, w}); g[v].push_back({u, w}); // v删除j个末尾数字，到达u for (j = 0; (v &gt;&gt; j) != u; ++ j); f[v][j] = min(f[v][j], w); } for (int i = 1; i &lt;= n; i ++ ) dijkstra(i); int q; scanf(\"%d\", &amp;q); while(q -- ) { int u, v, j = 0; scanf(\"%d%d\", &amp;u, &amp;v); ll ans = (1ll &lt;&lt; 60); // 枚举u和v的公共前缀 for (int i = 0; i &lt; 28; i ++ ) { while((v &gt;&gt; i) &lt; (u &gt;&gt; j)) ++ j; if ((v &gt;&gt; i) == (u &gt;&gt; j)) ans = min(ans, 1ll * f[u][j] + f[v][i]); } if (ans &gt; 60ll * 1e9) printf(\"-1\\n\"); else printf(\"%lld\\n\", ans); } return 0;} F. Fair Distribution题意给定两个数字 $a, b$ ，每次操作可以使 $a - 1$ ，或者 $b + 1$ ，问使 $b \\% a == 0$ 的最小操作数量。 分析假设 $a$ 减小了 $x$ ，那么有 $x \\in [0, a-1]$ ，即 $a - x \\in [1, a]$ 。 那么对于 $b$ ，它为了使 $b \\% a == 0$ 的最小步数为 $\\lceil \\dfrac b {a-x} \\rceil \\times (a - x)$ ，注意 $b$ 只能向上增加，所以要向上取整。 令 $a - x = i$ ，那么有 $i \\in [1, a]$ 。 总操作数为： \\begin{aligned} &x + \\lceil \\dfrac b i \\rceil \\times i - b \\\\ = &a - i + \\lceil \\dfrac b i \\rceil \\times i - b \\\\ = &a - i + \\lfloor\\dfrac {b + i - 1} i \\rfloor \\times i - b \\\\ = &(a - b) + \\lfloor\\dfrac {b - 1} i \\rfloor \\times i \\end{aligned}可以使用整除分块，枚举 $i$ 的值。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for(cin &gt;&gt; _; _ -- ; ) { int a, b, ans = 2e9; cin &gt;&gt; a &gt;&gt; b; if (a &gt;= b) { cout &lt;&lt; a - b &lt;&lt; endl; continue; } for (int l = 1, r; l &lt;= a; l = r + 1 ) { r = min(a, (b - 1) / ((b - 1) / l)); ans = min(ans, (b - 1) / l * l + a - b); } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} G. Wall Game题意 如图，有 $n$ 个操作，每个操作为： 在图上添加点（图中单个的的六边形），并和相邻的点联通。 查询这个点所在的联通块与外界的边的数量。 分析使用并查集维护集合内的边的数量。 由于直接维护边不好维护，可以开两个数组，一个维护集合点的数量，一个维护集合内失效边的数量。 在合并集合时，遍历点所在的六个相邻点，查询是否已经在同一个联通块，如果在，则失效边增加 $2$ ，否则需要合并两个集合，且失效边加 $2$ 。 由于点是二维的，可以使用 $map$ 来把点映射为数值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;pair&lt;int, int&gt;, int&gt; Map; // 把点映射为数值const int dr[] = { 0, 1, 1, 0, -1, -1 };const int dc[] = { 1, 0, -1, -1, 0, 1 };const int N = 500010;int p[N], siz[N], decr[N]; // decr表示联通块有多少边无效int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void merge (int x, int y){ static int cnt = 0; Map[{x, y}] = ++ cnt; siz[cnt] = 1; for (int i = 0; i &lt; 6; i ++ ) // 枚举他的6个相邻块 { int dx = x + dr[i], dy = y + dc[i]; if (!Map.count({dx, dy})) continue; int pdx = find(Map[{dx, dy}]); if (pdx != cnt) { siz[cnt] += siz[pdx]; decr[cnt] += decr[pdx] + 2; p[pdx] = cnt; } else decr[cnt] += 2; }}int main (){ cin.tie(0)-&gt;sync_with_stdio(0); int n; cin &gt;&gt; n; iota(p + 1, p + N, 1); while(n -- ) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) merge(x, y); else { int key = find(Map[{x, y}]); cout &lt;&lt; siz[key] * 6 - decr[key] &lt;&lt; endl; } } return 0;}","categories":[],"tags":[{"name":"区域赛","slug":"区域赛","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"}]},{"title":"Namomo Spring Camp 2022每日一题","slug":"Namomo-Spring-Camp-2022每日一题","date":"2022-02-26T11:54:39.000Z","updated":"2022-03-02T03:40:34.849Z","comments":true,"path":"2022/02/26/Namomo-Spring-Camp-2022每日一题/","link":"","permalink":"https://horb7.github.io/2022/02/26/Namomo-Spring-Camp-2022%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"子串的最大差题意定义序列的最大差为序列中最大数与最小数的差。比如 $(3,1,4,5,6)$ 的最大差为 $6−1=5 , (2,2)$ 的最大差为 $2−2=0$ 。 定义一个序列的子串为该序列中连续的一段序列。 给定一个长度为 $n$ 的数组 $a_1,a_2, \\ldots ,a_n$，请求出这个序列的所有子串的最大差之和。 分析所有子串的最大差之和 = 所有子串最大值之和 - 所有子串最小值之和。 所以可以单独算出最大值之和与最小值之和。 考虑每个元素作为最大值/最小值的贡献，以最大值为例，假设它前面最近的大于它的元素位置为 $lmax$ ，同理右边为 $rmax$ ，则左边可作为端点的数量为 $i - (lmax-1) + 1$ ，同理右边为 $(rmax-1) - i + 1$ 。那么当前点作为最大值的贡献为 $((rmax-1)-i+1) * (i-(lmax-1)+1) - 1$ 。 计算每个点的 $lmax$ 和 $rmax$ 可以使用单调栈，具体可参考这里。 注意点：在最大值有多个的区间，如 $[5, 1, 5]$ ，对于所有的 $5$ ，对这个区间一共只能有一个贡献，我们可以让最后面的元素产生贡献，为此，在计算 $lmax$ 时，应该使其取非单调上升序列，而 $rmax$ 取严格下降序列。 小Trick，在计算完最大值后将所有元素乘上 $-1$ ，这样就又是求最大值，可以复用代码。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int N = 500010;int n, a[N], stk[N], top, lmax[N], rmax[N], lmin[N], rmin[N];// 使用单调栈解决离元素最近且大于它的元素位置void calc (int *left, int *right){ // left top = 0; for (int i = 1; i &lt;= n; i ++ ) { while(top &amp;&amp; a[stk[top]] &lt; a[i]) -- top; left[i] = (top ? stk[top] + 1 : 1); stk[++ top] = i; } // right top = 0; for (int i = n; i &gt;= 1; i -- ) { while(top &amp;&amp; a[stk[top]] &lt;= a[i]) -- top; right[i] = (top ? stk[top] - 1: n); stk[++ top] = i; }}int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; calc(lmax, rmax); for (int i = 1; i &lt;= n; i ++ ) a[i] *= -1; calc(lmin, rmin); for (int i = 1; i &lt;= n; i ++ ) a[i] *= -1; long long ans = 0; for (int i = 1; i &lt;= n; i ++ ) { ans += 1ll * a[i] * (rmax[i] - i + 1) * (i - lmax[i] + 1); ans -= 1ll * a[i] * (rmin[i] - i + 1) * (i - lmin[i] + 1); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} no crossing题意给出一个有向图，找一条恰好经过 $k$ 个点的最短路径，要求每次选的边不能越过之前选择的点，即：对于路径中的边 $x -&gt; y$ ，不存在以前经过的点使得三者关系为：$min(x, y) \\le t \\le max(x, y)$ 。 其中 $1 \\le n, k \\le 100, 0 \\le m \\le 2000, 1 \\le a_i, b_i \\le n, 1 \\le c_i \\le 1000$ 。 分析区间DP，记 $f(l, r, dir, step)$ 表示 $[l, r]$ 区间，且方向为 $dir$ ，走过的步数为 $step$ 时最短的路径。 $dir$ ：$dir$ 为 $0$ 时表示从 $l$ 跳到 $[l+1, r-1]$ 中的某个点，为 $1$ 时表示从 $r$ 跳到 $[l+1, r-1]$ 的某个点。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int n, k, m, ans = 2e9 + 10;int g[N][N];int dp[N][N][2][N]; // dp(l, r, dir, step) 表示[l, r]，方向为dir，步数为step的最短路径int work (int l, int r, int dir, int step){ if (step == k - 1) return 0; int &amp;ans = dp[l][r][dir][step]; if (~ans) return ans; else ans = 2e9 + 10; // 转移 int from = dir ? r : l; for (int to = l + 1; to &lt; r; to ++ ) if (g[from][to]) { ans = min(ans, work(to, r, 0, step + 1) + g[from][to]); ans = min(ans, work(l, to, 1, step + 1) + g[from][to]); } return ans;}int main (){ memset(dp, -1, sizeof dp); cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= m; i ++ ) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (g[u][v]) g[u][v] = min(g[u][v], w); else g[u][v] = w; } for (int i = 1; i &lt;= n; i ++ ) { ans = min(ans, work(0, i, 1, 0)); ans = min(ans, work(i, n+1, 0, 0)); } if (ans &gt; 2e9) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; return 0;} Dis题意给出 $n$ 个点的一棵树，每个点有各自的点权，多次询问两个点简单路径所构成的点集的异或和。 分析$Xor(u, v) = Xor(u, root) \\bigoplus Xor(v, root) \\bigoplus LCA(u, v)$ 。 $dfs$ 或者 $bfs$ 求出根节点到每个点的路径上点权异或和，同时预处理 $lca$ 的倍增数组即可。 也可以使用 $Tarjan$ 离线求 $lca$ ，单次处理复杂度降到 $O(1)$ 。 如果题目要求点权可以修改，则可以使用树链刨分转换为序列，使用线段树或者树状数组维护。 Code倍增LCA求法 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int n, m, a[N];vector&lt;int&gt; g[N];int depth[N], f[N][21], Xor[N]; // Xor(i)表示从根节点到i的路径上的异或和void dfs (int u, int fa){ depth[u] = depth[fa] + 1; Xor[u] = Xor[fa] ^ a[u]; f[u][0] = fa; for (int i = 1; i &lt; 21; i ++ ) f[u][i] = f[f[u][i-1]][i-1]; for (int v: g[u]) if (v != fa) dfs(v, u);}int lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); for (int i = 20; i &gt;= 0; i -- ) if (depth[f[a][i]] &gt;= depth[b]) a = f[a][i]; if (a == b) return b; for (int i = 20; i &gt;= 0; i -- ) if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i]; return f[a][0];}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); // 以1为树的根 while(m -- ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); printf(\"%d\\n\", Xor[u] ^ Xor[v] ^ a[lca(u, v)]); } return 0;} 离线Tarjan求法 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using T = pair&lt;int, int&gt;;struct A { int id, u, v, _lca; };const int N = 1000010;int n, m, a[N], Xor[N];int p[N], st[N];vector&lt;int&gt; g[N];vector&lt;A&gt; ans;vector&lt;T&gt; query[N]; // query(i) 表示以i为某一点的所有lca查询int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void Tarjan (int u){ st[u] = 1; // 正在搜索 for (int v: g[u]) if (!st[v]) { Xor[v] ^= Xor[u]; Tarjan(v); p[v] = u; } for (auto &amp;[v, id]: query[u]) if (st[v] == 2) ans.push_back(A{ id, u, v, find(v) }); st[u] = 2; // 完成搜索，回溯}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]), Xor[i] = a[i]; for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } iota(p + 1, p + n + 1, 1); for (int i = 1; i &lt;= m; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); query[u].push_back({v, i}); query[v].push_back({u, i}); } Tarjan(1); sort(ans.begin(), ans.end(), [&amp;](A a, A b){ return a.id &lt; b.id; }); for (auto &amp;[id, u, v, _lca]: ans) printf(\"%d\\n\", Xor[u] ^ Xor[v] ^ a[_lca]); return 0;} 树链刨分求法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;struct fenwick{ int c[N]; void add (int x, int v) { if (x) for (; x &lt; N; x += x &amp; -x) c[x] ^= v; } int query (int x) { int ans = 0; if (x) for (; x; x -= x &amp; -x) ans ^= c[x]; return ans; } int query (int l, int r) { return query(r) ^ query(l - 1); }};int n, m, a[N];vector&lt;int&gt; g[N];fenwick F;int son[N], top[N], depth[N], siz[N], father[N], id[N], wt[N], cnt;void dfs1 (int u, int fa){ depth[u] = depth[fa] + 1; father[u] = fa; siz[u] = 1; int maxson = -1; for (int v : g[u]) { if (v == fa) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; maxson) son[u] = v, maxson = siz[v]; }}void dfs2 (int u, int topfather){ top[u] = topfather; id[u] = ++ cnt; wt[cnt] = a[u]; F.add(cnt, wt[cnt]); if (!son[u]) return ; dfs2(son[u], topfather); for (int v : g[u]) if (v != son[u] &amp;&amp; v != father[u]) dfs2(v, v);}int query (int u, int v){ int ans = 0; while(top[u] != top[v]) { if (depth[top[u]] &lt; depth[top[v]]) swap(u, v); ans ^= F.query(id[top[u]], id[u]); u = father[top[u]]; } if (depth[u] &gt; depth[v]) swap(u, v); ans ^= F.query(id[u], id[v]); return ans;}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs1(1, 0); // 第一次dfs求出depth, siz, father, son dfs2(1, 1); // 第二次dfs链接重链, 求出top, id, wt for (int i = 1; i &lt;= m; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); printf(\"%d\\n\", query(u, v)); } return 0;} 选数题意给定 $N$ 个正整数 $a_1, a_2, \\ldots , a_n$ 。要求从其中选出若干个数字，使得这些数字的和 $sum \\equiv 0 \\pmod N$ ，对于每个下标只能选择一次。若存在则输出选择的数字个数及其下标，否则输出 $-1$ 。 分析对于 $n$ 个数字，作前缀和，一共有 $n + 1$ 个模数(注意还有全不选的情况)，根据鸽巢原理一定有两个模数相等，假设其在前缀和中的下标为 $i, j$ ，则对于 $[i+1, j]$ 区间的数字，它们的和一定 $sum \\equiv 0 \\pmod N$ 。 Code123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int n, a[N], pre[N];int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], pre[i] = (pre[i-1] + a[i]) % n; map&lt;int, int&gt; exist{{0, 0}}; // 记录模数是否出现过，以及出现的下标 for (int i = 1; i &lt;= n; i ++ ) { if (exist.count(pre[i])) { cout &lt;&lt; i - exist[pre[i]] &lt;&lt; endl; for (int j = exist[pre[i]] + 1; j &lt;= i; j ++ ) cout &lt;&lt; j &lt;&lt; \" \\n\"[j == i]; return 0; } exist[pre[i]] = i; } cout &lt;&lt; -1 &lt;&lt; endl; return 0;} 序列操作题意给定一个长度为 $n$ 的序列 $a_1, a_2 , \\ldots , a_n$ 。 你需要进行两种操作： $1 \\ \\ x \\ \\ y$ ，表示将第 $x$ 个数字变为 $y$ $2 \\ \\ y$ ，表示将所有小于 $y$ 的数字修改为 $y$ 一共进行 $q$ 次操作，输出执行完所有操作后的序列。 其中 $1 \\le n , q \\le 10^6, 0 \\le a \\le 10^9, 1 \\le x \\le n, 0 \\le y \\le 10^9$ 。 分析离线+ST表 操作 $1$ 的优先级大于 $2$ ，对于每个数字，当执行操作 $1$ 时，前面所有对这个数字的操作 $2$ 都无效。 所以对于每个数字，我们只需要知道，所有在它最后一次操作 $1$ 之后的操作 $2$ ，对它的影响即可。 可以把操作 $2$ 存储起来，然后记录每个数字最后一次操作 $1$ 的位置，二分找到对应的操作 $2$ ，然后查询之后所有操作 $2$ 的最大值，与当前数字取最大值即可。 (看了一眼题解emmm….. 我是SB，每次查询区间最大值都是以最后一个操作 $2$ 为右端点，所以只需要做一个后缀最大值计算即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;struct Q { int id, x; };struct SparseTable{ int n, st[N][21], Lg[N]; void init(int n, Q *a) { this-&gt;n = n; for (int i = 2; i &lt;= n; i ++ ) Lg[i] = Lg[i&gt;&gt;1] + 1; for (int i = 1; i &lt;= n; i ++ ) st[i][0] = a[i].x; for (int j = 1; j &lt; 21; j ++ ) for (int i = 1; i &lt;= n; i ++ ) st[i][j] = max(st[i][j-1], st[i + (1&lt;&lt;j-1)][j-1]); } int query (int l, int r) { int k = Lg[r - l + 1]; return max(st[l][k], st[r - (1&lt;&lt;k) + 1][k]); }};int n, m, a[N], ans[N], last[N]; // last统计每个下标最后更改的位置Q q[N];int cnt;SparseTable ST;int main (){ int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; i ++ ) { int op, x, y; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) scanf(\"%d\", &amp;y), last[x] = i, a[x] = y; if (op == 2) q[++ cnt] = { i, x }; } ST.init(cnt, q); for (int i = 1; i &lt;= n; i ++ ) { if (!last[i]) a[i] = max(a[i], ST.query(1, cnt)); else { int pos = lower_bound(q + 1, q + cnt + 1, last[i], [](Q a, int val){ return a.id &lt; val; }) - q; if (pos != cnt + 1) a[i] = max(a[i], ST.query(pos, cnt)); } } for (int i = 1; i &lt;= n; i ++ ) printf(\"%d \", a[i]); return 0;}","categories":[],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://horb7.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"Django入门","slug":"Django入门","date":"2022-02-25T15:31:21.000Z","updated":"2022-02-26T06:38:35.387Z","comments":true,"path":"2022/02/25/Django入门/","link":"","permalink":"https://horb7.github.io/2022/02/25/Django%E5%85%A5%E9%97%A8/","excerpt":"","text":"前言学习资料Imooc教程：三小时带你入门Django Django中文文档 Django 介绍基本介绍：Django 是一个由Python编写的Web应用框架，本身基于MVT模型，即：模型层(Model) ，模板层(Template)，视图层(View)。 除了上面三层，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template。 用户操作流程图： 解析： 用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数： 如果不涉及函数调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。 如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。 Django 基本命令django-admin是Django用于管理任务的命令行工具，使用django-admin查看其他命令。 其中重要的命令有： startproject # 用于创建Django的一个项目 startapp # 用于创建Django的一个应用（软件包） check # 校验项目的完整性 runserver # 进入Django项目环境并启用Django项目 shell # 进入Django项目的 Python Shell环境 test # 执行Django用例测试 makemigrations # 创建模型变更的迁移文件 migrate # 执行上一个命令创建的迁移文件，即把模型等导入到数据库 dumpdate # 把数据库数据导出到文件 loaddate # 把文件数据导入到数据库 创建一个项目使用django-admin startproject django_study 创建第一个项目，我们会发现django_study作为文件被创建，且目录下有若干个初始文件： 其中 manage.py 为项目管理文件，项目中的django_study文件夹包含此项目的所有配置。 其中：settings.py为项目的总设置，urls.py 为Django项目的总路由文件，wsgi.py 为Django作为wsgi应用所需要的内容。 运行项目使用 python3 manage.py runserver 运行Django项目。 如果你的项目在本地开发 直接在浏览器输入127.0.0.1:8000 即可，如果成功则显示Django的初始化界面。 如果你的项目在服务器上开发 在命令后面加上0.0.0.0:8000，即python3 manage.py runserver 0.0.0.0:8000 (如果是Docker环境需要把端口改为映射的端口，比如我的是8080)，注意服务器的8000端口需要打开，可以去购买服务器的网站上打开，在本地使用ip:8000查看，你会发现没有成功： 这是因为Django具有保护机制，不会使其他ip地址来访问项目，如果想在本地调试，需要去\\django_study\\settings.py 文件中，设置ip为可访问ip： 再次使用python3 manage.py runserver 0.0.0.0:8000 重新部署Django项目即可。 以下都用本地开发的ip为例子，服务器开发只需要换自己的服务器的ip即可。 Django应用介绍Django应用 VS Django项目： 一个Django项目就是一个基于Django的Web应用 一个Django应用就是一个可重用的Python软件包（即可出现在若干个项目中） 每个应用可以自己管理模型、视图、模板、路由和静态文件等 一个Django项目包含一组配置和若干个Django应用 创建一个Django应用使用python3 manage.py startapp blog 创建一个应用。 此时项目文件中新建了一个blog应用(文件夹)，它有以下目录： Django应用目录介绍： views.py # 视图处理的地方 models.py # 定义应用模型的地方 admin.py # 定义Admin模块管理对象的地方 apps.py # 声明应用的地方 tests.py # 编写应用测试用例的地方 除此之外，还需要创建urls.py文件来管理应用的路由，使用touch urls.py。 Django HelloWorldDjango视图在没有框架的时代，如果要写一个hello,world网页，只需要写出html元素，但对于一个复杂的网页，不可能通过html来表达网页中所有的元素。 在一个网页中产生内容，就是Django视图的工作。 具体来说，我们在视图文件中编写一个个的逻辑函数，接受html的请求，并根据请求来生成响应数据并返回。Django视图主要用于处理项目的业务逻辑部分。 在blog应用中，我们编写其视图函数，在views.py中写入： 123456789from django.shortcuts import render# Create your views here.from django.http import HttpResponsedef hello_world(request): # request参数就是http请求的对象 return HttpResponse(\"Hello World!\") Django路由在编写完上述代码，重新部署项目，却仍然是Django的欢迎页面。 这是因为Django视图仅仅是对http的请求做出相应，而我们并没有发出这样的请求，所以没办法到达刚才的视图函数。 配置路由，可以将http以url的形式发出请求并获得响应，譬如，对于\"ip/hello_world\"，就是向服务器发出了”hello_world”这个请求。 我们需要配置应用级别的路由和项目级别的路由。 对于应用级别的路由，在blog/urls.py中写入： 123456from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world),] 对于项目级别的路由，在django_study/urls中写入： 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('blog/', include('blog.urls')),] 它表示，如果我们的请求为blog的子目录，那么通过include转发到blog.urls这个文件中（继续寻找）。 注意这里的引用模块，都是按照django_study这个项目文件来相对引用的 。 部署项目我们在django_study项目中创建了一个应用，要想让这个项目使用blog这个应用，需要在项目文件中的settings注册应用。 这里的BlogConfig是blog/apps文件中的结构体，它代表着这个应用的实体。 接下来重新部署运行Django项目，在浏览器中输入127.0.0.1:8000/blog/hello_world，发现正确响应了http的请求。 一张表解释应用路由和项目路由的关系： Django模型层模型层介绍 位于Django视图层和数据库之间 Python对象和数据库表之间的转换 在项目运行过程，不可避免地需要使用数据来交互，通过视图层，与数据库交互得到数据，然后通过返回到前端渲染。模型层夹在视图层和数据库之间，使用模型层可以屏蔽不同数据库之间的差异，让开发者更加注重业务逻辑。同时模型层提供很多便捷工具来开发。 简单来说，模型就是抽象数据类型，我们可以把它作为视图与数据库的交互对象。 模型层配置在项目设置django_study/settings.py中，可以看到项目的模型层数据库的相关配置。 其中ENGINE表示模型层所交互的数据库，默认为Django自带的sqlite3数据库，NAME为数据库名字，作为文件存储在项目文件中。 创建博客文章要创建博客文章，需要以下操作： 设计博客模型 模型层定义字段 设计博客模型博客模型有以下几个属性： 文章标题(title) 文本类型 文章摘要(brief_context) 文本类型 文章内容(context) 文本类型 唯一ID标记(article_id) int，自增，主键 发布日期(date) 日期类型 模型层定义字段 数字类型: IntegerField 文本类型: TextField 日期类型: DateTimeField 自增ID: AutoField 主键定义: primary_key属性 进入应用文件blog/models.py，写入： 12345678910from django.db import models# Create your models here.class Article(models.Model): # 继承models模型 article_id = models.AutoField(primary_key=True) title = models.TextField() brief_content = models.TextField() content = models.TextField() publish_date = models.DateTimeField(auto_now=True) # auto_now=True 表示文章的发布日期即创建时的日期 使用python3 manage.py makemigrations，将模型的变更生成迁移文件。 再使用python3 manage.py migrate，运行迁移文件，将迁移内容同步到数据库中。 Django ShellDjango Shell 介绍类似于Python Shell，Django Shell可以进入Django项目环境，操作项目中的某些对象或者方法。 对于某些临时性操作，使用Django Shell可以更加方便，比如对于创建的Article字段，我们并不清楚它是否真的可以使用，Django Shell就是调试的最好工具。 同时，Django Shell使得小范围Debug更加简单，不需要写测试文件，运行整个项目来测试。 Django Shell操作使用python3 manage.py shell来启动Django Shell，引入Article模块来测试。 其中a.save表示将a对象存入数据库中，使用Article.objects.all()即可获得数据库所有Article对象。 这篇博客详细介绍了Django Shell的使用操作。 Django Admin模块Django Admin模块介绍Django Admin是Django的后台管理工具，它可以读取定义的模型元数据(也就是具体的数据)，提供强大的管理使用页面。 使用Django Shell创建数据，不仅复杂还容易出错，尤其对于复杂的模型而言。 使用Django Admin模块，可以在后台管理增加、删除、改变模型元数据，它是基础设施中重要的部分。 Django Admin模块的使用使用python3 manage.py createsuperuser来创建超级管理员。 在浏览器中输入127.0.0.1:8000/admin进入后台管理页面。 其中Groups和users是默认的模型，但是我们定义的Article模型没有出现，这是因为没有在Admin模块注册Article模型。 进入blog/admin.py，写入： 1234567from django.contrib import admin# Register your models here.from .models import Articleadmin.site.register(Article) 刷新admin页面，就会发现多出了一个模型： 点击Article，进入Article模型的数据管理页面，发现存在一个数据元，这就是之前在Django Shell中注册的Article对象。 在Admin页面，点击Article模型右边的+号，存储第二个数据： 点击右下方的save，完成在数据库中的存储。 我们发现，这里的数据并没有显示其文章的标题(title)，这不方便之后的管理。 进入blog/models.py，为Article模型添加方法 \\_\\_str\\_\\_ ： 12345678910111213from django.db import models# Create your models here.class Article(models.Model): article_id = models.AutoField(primary_key=True) title = models.TextField() brief_content = models.TextField() content = models.TextField() publish_date = models.DateTimeField(auto_now=True) def __str__(self): return self.title 重新部署项目，刷新浏览器： 发现数据可以根据其标题显示了。 实现博客数据返回页面进入blog/views.py，写入： 1234567891011121314def article_content(request): article = Article.objects.all()[0] title = article.title brief_content = article.brief_content content = article.content article_id = article.article_id publish_date = article.publish_date return_str = 'title: %s, brief_content: %s, ' \\ 'content: %s, article_id: %s, publish_date: %s' % (title, brief_content, content, article_id, publish_date) return HttpResponse(return_str) 配置应用级别路由，进入blog/urls，写入： 1234567from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world), path('content', blog.views.article_content),] 由于项目级别已经配置，这里不需要再配置。 打开浏览器，输入127.0.0.1:8000/blog/content，成功返回文章内容。 使用Bootstrap实现静态博客布局博客主页设计 其中上方为博客标题，左下方为博客文章，右下方为最新的文章。 文章页面设计 其中上方为文章标题，下方为文章内容。 Bootstrap以及Bootstrap的栅格系统Bootstrap是来自美国Twitter的前端框架，它提供了非常多的控件并附带源码。 进入BootsTrap中文官网 。 点击上方的组件 ，即可查看各组件及其源码。 点击上方全局CSS样式，也可以查看其中的各个样式。 Bootstrap 中的栅格系统，将页面按照横坐标分割为12等分，对于博客主页，使用9:3来分割： 在blog下创建templates文件夹，用于存放模板。 在blog/templates下创建index.html作为博客主页，写入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Django Study&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\" integrity=\"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu\" crossorigin=\"anonymous\"&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\" integrity=\"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container page-header\"&gt;&lt;h1&gt;My Django Study Web &lt;small&gt; ---- by Horb7&lt;/small&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"container page-body\"&gt; &lt;div class=\"col-md-9\" role=\"main\"&gt; &lt;div class=\"body-main\"&gt; &lt;div&gt; &lt;h2&gt;文章标题1&lt;/h2&gt; &lt;p&gt;第一个文章&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;文章标题2&lt;/h2&gt; &lt;p&gt;第二个文章&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\" rold=\"complementary\"&gt; &lt;div&gt; &lt;h2&gt;最新文章&lt;/h2&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章1&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章2&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章3&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章4&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章5&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章6&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章7&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章8&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章9&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章10&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中前面的引入在Bootstrap官网入门中： 效果： 对于文章主页，在blog/templates下创建detail.html来写入文章主页的html： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Django Study&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\" integrity=\"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu\" crossorigin=\"anonymous\"&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\" integrity=\"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container page-header\"&gt;&lt;h1&gt;文章标题1&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"body-main\"&gt; &lt;div&gt; &lt;p&gt;第一个文章&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Django 模板系统模板系统简介如果对于http的某一个请求，我们需要返回一个html，我们可以在视图函数中(views.py) 直接使用html元素。 但是视图文件本身不适合编写html，并且，如果html写在视图文件，那么在页面设计改变时就需要修改Python源代码，这样很不方便。 另外，页面逻辑(view)和页面视图(html)本身应该分开设计，使得视图文库可以从html中解放出来。 模板系统的表现形式为文本(字符串)，即html文件。它分离了文档了表现形式和表现内容，为此，模板系统定义了独有的标签占位符。 模板系统基本语法 变量标签：{{ 变量 }} ，如&lt;html&gt;&lt;body&gt;{{ now }}&lt;/body&gt;&lt;/html&gt; for循环标签：{% for x in list %},{% endfor %} 12345&lt;ul&gt; {% for item in list %} &lt;li&gt;{{ item }}&lt;/li&gt; {% endfor %}&lt;/ul&gt; if-else分支标签：{% if %}, {% else %}, {% endif %} 12345{% if true %} &lt;p&gt; it is a true part. &lt;/p&gt;{% else %} &lt;p&gt; it is a false part. &lt;/p&gt;{% endif %} 使用模板系统渲染博客页面根据模板系统的语法，我们在blog/templates/index.html中重新写入： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Django Study&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\" integrity=\"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu\" crossorigin=\"anonymous\"&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\" integrity=\"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container page-header\"&gt;&lt;h1&gt;My Django Study Web &lt;small&gt; ---- by Horb7&lt;/small&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"container page-body\"&gt; &lt;div class=\"col-md-9\" role=\"main\"&gt; &lt;div class=\"body-main\"&gt; {% for article in article_list %} &lt;div&gt; &lt;h2&gt;{{ article.title }}&lt;/h2&gt; &lt;p&gt;{{ article.content }}&lt;/p&gt; &lt;/div&gt; {% endfor %} &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\" rold=\"complementary\"&gt; &lt;div&gt; &lt;h2&gt;最新文章&lt;/h2&gt; {% for article in article_list %} &lt;h4&gt;&lt;a href=\"#\"&gt;{{ article.title }}&lt;/a&gt;&lt;/h4&gt; {% endfor %} &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样就完成了一个模板，那么里面的变量如何获取呢？由于模板是视图函数所返回的html元素，所以我们需要在视图函数中获取变量。 在blog/views.py中写入： 1234567def get_index_page(request): all_article = Article.objects.all() return render(request, 'blog/index.html', { 'article_list': all_article } ) 其中render函数可以返回经过模板渲染后的HttpResponse对象。 为了方便管理，我们将index.html和detail.html文件放入blog/templates 新创建的文件blog中。 然后进入blog/urls.py中写入路由： 12345678from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world), path('content', blog.views.article_content), path('index', blog.views.get_index_page),] 最后重新部署项目，打开浏览器，输入127.0.0.1:8000/blog/index，即可到达index.html渲染后的网页。 同理修改文章主页的模板和url即可。 在blog/views.py加入： 123456789def get_detail_page(request, article_id): curr_article = Article.objects.all()[0] section_list = curr_article.content.split('\\n') return render(request, 'blog/detail.html', { 'curr_article': curr_article, 'section_list': section_list } ) 实现文章详情页面的跳转在上述实验中，我们的ip/blog/detail只能跳转到第一篇博客，如何根据detail/id来实现根据id跳转到对应的博客？ 我们可以在urls.py中获取id参数，在blog/urls.py重新写入： 12345678910from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world), path('content', blog.views.article_content), path('index', blog.views.get_index_page), # path('detail', blog.views.get_detail_page), path('detail/&lt;int:article_id&gt;',blog.views.get_detail_page)] 然后在blog/views.py中写入： 123456789101112131415def get_detail_page(request, article_id): all_article = Article.objects.all() curr_article = None for article in all_article: if article.article_id == article_id: curr_article = article break section_list = curr_article.content.split('\\n') return render(request, 'blog/detail.html', { 'curr_article': curr_article, 'section_list': section_list } ) 据此，我们可以在博客首页的文章标题加上跳转链接： 实现上下篇文章跳转在BootsTrap中文官网，选择组件中的分页，选择默认实例作为上下篇反转按钮： 在文章主页最下方加入上述代码。 根据模板占用标签修改： 然后进入blog/views.py修改视图函数，返回previous_article和next_article即可。 1234567891011121314151617181920212223def get_detail_page(request, article_id): all_article = Article.objects.all() curr_article_index = None for index, article in enumerate(all_article): # 迭代器 if article.article_id == article_id: curr_article_index = index break curr_article = all_article[curr_article_index] previous_article = all_article[curr_article_index - 1] next_article = all_article[curr_article_index + 1] if curr_article_index == 0: previous_article = curr_article if curr_article_index == len(all_article) - 1: next_article = curr_article section_list = curr_article.content.split('\\n') return render(request, 'blog/detail.html', { 'curr_article': curr_article, 'section_list': section_list, 'previous_article': previous_article, 'next_article': next_article } ) 实现文章的分页功能Django 分页组件介绍： 在Django中有一个分页组件 Paginator ，可以在Django Shell中调试入门Paginator。 在博客主页index.html的文章块下方，加入一个分页块(使用div，与文章块并列)。 在Bootstrap中文官网的组件中找到分页，拷贝下来放入分页块中。 刷新浏览器，即可看到分页组件： 在路由中，我们采用/blog/index?page=1来实现文章的分页。 在blog/views.py中修改： 12345678910111213141516171819202122232425262728def get_index_page(request): page = request.GET.get('page') # 如果没有page参数，则page为1 if page: page = int(page) else: page = 1 all_article = Article.objects.all() paginator = Paginator(all_article, 3) page_num = paginator.num_pages page_article_list = paginator.page(page) if page_article_list.has_next(): next_page = page + 1 else: next_page = page if page_article_list.has_previous(): previous_page = page - 1 else: previous_page = page return render(request, 'blog/index.html', { 'article_list': page_article_list, 'page_num': range(1, page_num + 1), 'curr_page': page, 'next_page': next_page, 'previous_page': previous_page } ) 然后在index.html中修改每个分页按钮的链接： 12345678910111213141516171819&lt;div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"/blog/index?page={{ previous_page }}\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; {% for num in page_num %} &lt;li&gt;&lt;a href=\"/blog/index?page={{ num }}\"&gt;{{ num }}&lt;/a&gt;&lt;/li&gt; {% endfor %} &lt;li&gt; &lt;a href=\"/blog/index?page={{ next_page }}\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 刷新浏览器即可查看效果： 实现最新文章列表最新文章在所有文章中取得publish_date最大的5个，由于在分页后，每个页面(即index?page=x)的all_article为当前页面的所有文章，所以不能从这里取。 在blog/views.py修改，使其返回数据库所有文章最新的五个： 1234# 增加top5_article = Article.objects.order_by('-publish_date')[:5]# return reder()中加'top5_article': top5_article 最后再修改index.html内容，将for范围修改即可。 最后的成品：","categories":[{"name":"项目学习","slug":"项目学习","permalink":"https://horb7.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://horb7.github.io/tags/Django/"}]},{"title":"牛客秋季算法班LCA-E-华华和月月种树","slug":"牛客秋季算法班LCA-E-华华和月月种树","date":"2022-02-20T08:48:28.000Z","updated":"2022-02-24T16:57:27.471Z","comments":true,"path":"2022/02/20/牛客秋季算法班LCA-E-华华和月月种树/","link":"","permalink":"https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/","excerpt":"","text":"华华和月月种树题意维护一个动态有根树，每个点都有一个权值，开始时只有一个 $0$ 号节点，权值为 $0$ 。有以下操作： $1 \\ \\ i$ ，表示 $i$ 节点长出一个新的子节点，权值为 $0$ ，编号为目前最大编号 $+1$ 。 $2 \\ \\ i \\ \\ a$ ，表示节点 $i$ 的子树的所有节点 (包括 $i$ 节点) 权值 $+a$ 。 $3 \\ \\ i$ ，表示查询节点 $i$ 此时的权值。 分析离线 + 树状数组 先根据所有的操作建立一棵树，求得所有节点的dfs序，即可在区间上操作。 树状数组维护差分的前缀。 对于操作1，记录它在权值为 $0$ 的时候（刚被开辟出来）它的前缀和，查询该点时减去这个值即可。 对于操作2，只需要在 $[l[i], r[i]]$ 上所有点权值 $+a$ 即可，使用差分。其中 $l[i]$ 和 $r[i]$ 表示 $i$ 点的进出栈时间(dfs序) 。 对于操作3，查询前缀和即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int op[N], a[N], b[N];int val[N], c[N], l[N], r[N];vector&lt;int&gt; g[N];int cnt = 1; // 一开始有一个节点0void dfs (int u, int fa){ l[u] = ++ cnt; // 最早的timestamp for (int v : g[u]) if (u != fa) dfs(v, u); r[u] = cnt; // 最晚的timestamp}void update (int x, int v){ if (x) for (; x &lt; N; x += x &amp; -x) c[x] += v;}int query (int x){ int res = 0; if (x) for (; x; x -= x &amp; -x) res += c[x]; return res;}int main (){ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; op[i] &gt;&gt; a[i]; ++ a[i]; // 注意树状数组只能维护[1, n]的区间，不能包括0 if (op[i] == 1) { g[a[i]].push_back(++ cnt); b[i] = cnt; // b[i]表示第i个操作后，新的节点编号 } else if (op[i] == 2) cin &gt;&gt; b[i]; // b[i]表示加多少 } cnt = 0; dfs(1, 0); // 转化为dfs序，进行区间运算 // 树状数组的区间加+单点查询 for (int i = 1; i &lt;= n; i ++ ) { if (op[i] == 1) // 加新的节点 { val[l[b[i]]] += query(l[a[i]]); // val(i)表示i点加了多少 } else if (op[i] == 2) { update(l[a[i]], b[i]); update(r[a[i]] + 1, -b[i]); } else cout &lt;&lt; query(l[a[i]]) - val[l[a[i]]] &lt;&lt; endl; } return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"牛客秋季算法班LCA-D.Alliances","slug":"牛客秋季算法班LCA-D-Alliances","date":"2022-02-20T07:40:34.000Z","updated":"2022-02-20T07:52:22.424Z","comments":true,"path":"2022/02/20/牛客秋季算法班LCA-D-Alliances/","link":"","permalink":"https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/","excerpt":"","text":"Alliances题意链接：https://ac.nowcoder.com/acm/contest/27836/D 树国是一个有 $n$ 个城市的国家，城市编号为 $1 \\sim n$ 。连接这些城市的道路网络形如一棵树， 即任意两个城市之间有恰好一条路径。城市中有k个帮派，编号为 $1 \\sim k$ 。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。 当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。 shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。 分析对于选定的首都 $V$ 和选定的帮派，假设他们所有占领的城市的 lca 为 LCA ，那么有下面两个情况： lca(V, LCA) != LCA 那么被占据城市距离 $V$ 的最短距离为 $Dist(V, LCA)$ 。 lca(V, LCA) == LCA 即首都在 LCA 的子树中。对这棵子树作 dfs 序，那么距离 $V$ 最短的为 dfn 第一个在 $V$ 前面的或者第一个在 $V$ 后面的，取最小值即可。可以使用二分降低复杂度。 这里需要注意的是被占据的城市路径上的所有城市也都被占领，他们不会影响每个帮派城市lca的预处理，但会影响第二种情况，所以求的时候还需要加一个lca。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010;int n, k;vector&lt;int&gt; g[N]; // 整图int depth[N], f[N][21];vector&lt;int&gt; q[N]; // 帮派图int dfn[N], timestamp;int top[N]; // top(i) 表示i帮派占领的城市的lcavoid dfs (int u, int fa) // 根据dfs求出dfn和st表{ dfn[u] = ++ timestamp; depth[u] = depth[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt; 21; i ++ ) f[u][i] = f[f[u][i-1]][i-1]; for (int v : g[u]) if (v != fa) dfs(v, u);}int lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); for (int i = 20; i &gt;= 0; i -- ) if (depth[f[a][i]] &gt;= depth[b]) a = f[a][i]; if (a == b) return b; for (int i = 20; i &gt;= 0; i -- ) if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i]; return f[a][0];}int dist (int a, int b){ return depth[a] + depth[b] - 2 * depth[lca(a, b)];}int main (){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); // 求出帮派图，邻接表按照dfn排序 scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; i ++ ) { int u, v; scanf(\"%d\", &amp;v); for (int j = 0; j &lt; v; j ++ ) { scanf(\"%d\", &amp;u); q[i].push_back(u); if (!j) top[i] = u; else top[i] = lca(top[i], u); } // 按照dfn排序 sort(q[i].begin(), q[i].end(), [&amp;](int a, int b){ return dfn[a] &lt; dfn[b]; }); } int Q; scanf(\"%d\", &amp;Q); while(Q -- ) { int V, LCA, u, v; scanf(\"%d%d\", &amp;V, &amp;u); // LCA为被选择的帮派的lca vector&lt;int&gt; x; // x存储被选择的帮派 for (int i = 0; i &lt; u; i ++ ) { scanf(\"%d\", &amp;v); x.push_back(v); if (!i) LCA = top[v]; else LCA = lca(LCA, top[v]); } // 如果V和LCA的lca不是LCA，那么他们的最短距离即为V和LCA的距离 if (lca(V, LCA) != LCA) { printf(\"%d\\n\", dist(V, LCA)); } // 否则离V最近的一定是dfn序中靠近V的前面一个或者后面一个 else { int ans = 2e9 + 10; for (int e : x) { int siz = q[e].size(); int l = 0, r = siz; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if (dfn[q[e][mid]] &gt;= dfn[V]) r = mid; else l = mid + 1; } if (r != 0) ans = min(ans, dist(V, lca(V, q[e][r - 1]))); if (r != siz) ans = min(ans, dist(V, lca(V, q[e][r]))); } printf(\"%d\\n\", ans); } } return 0;}","categories":[{"name":"图论","slug":"图论","permalink":"https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://horb7.github.io/tags/LCA/"}]},{"title":"2022寒假算法集训营5","slug":"2022寒假算法集训营5","date":"2022-02-17T10:24:12.000Z","updated":"2022-02-25T02:30:07.265Z","comments":true,"path":"2022/02/17/2022寒假算法集训营5/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/","excerpt":"","text":"A. 疫苗小孩题意给出长度为 $n$ 的01字符串，可以选择至多三个 $0$ ，假设它们的位置为 $i, j, k$ ，则 $W_j = w - |k-p|\\times q$ ，$W_k = w - |k-p| \\times q$ 。求问 $W_j + W_k$ 最大为多少。 其中 $p$ 表示与前一个选定的 $0$ 的位置差，$w, k, q$ 为给定值。 其中 $n \\le 10^6, 1\\le k, w, q \\le 10^9$ 。 分析对于 $W_j$ ，要使其最大需要使 $p$ 最小，即 $i$ 与 $j$ 的差值尽量接近 $k$ ，$W_k$ 同理。 枚举 $j$ 的位置，然后使用二分求得最接近 $j-k$ 的位置（有两个可能的位置），同理求出 $j+k$ 的位置即可。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = ' ' + s; vector&lt;int&gt; zeros; // 存储所有0的位置 for (int i = 1; i &lt;= n; i ++ ) if (s[i] == '0') zeros.push_back(i); long long best, w, q; cin &gt;&gt; best &gt;&gt; w &gt;&gt; q; long long ans = 0; auto check = [&amp;](int x) { return x &lt; 0 || x &gt;= zeros.size(); }; for (int i = 0; i &lt; zeros.size(); i ++ ) { int pos1 = lower_bound(zeros.begin(), zeros.end(), zeros[i] - best) - zeros.begin(); int pos2 = lower_bound(zeros.begin(), zeros.end(), zeros[i] + best) - zeros.begin(); for (int k : {-1, 0}) // 注意pos1为第一个大于等于j-k的位置，pos1-1也可能最接近j-k for (int l : {-1, 0}) // pos2同理 { if (check(pos1+k) || pos1+k &gt;= i) continue; long long now = w - abs(best - abs(zeros[i]-zeros[pos1+k])) * q; ans = max(ans, now); // 只选择前两个0 if (check(pos2+l) || pos2+l &lt;= i) continue; now = now + w - abs(best - abs(zeros[pos2+l]-zeros[i])) * q; ans = max(ans, now); // 选择三个0 } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} C. 战旗小孩题意给定 $n$ 局游戏和原始分数 $start$，每局游戏可以选择两个英雄中的一个，使用礼遇可以选择多两个可选择英雄。 每局游戏结束后的分数为原始分数加上英雄强度。 给出每局游戏结束后上榜需要的分数，以及 $m$ 次至多能够使用的礼遇次数，和每局游戏的可选英雄强度。 游戏的顺序可以任意调整，问进行 $n$ 局游戏后，最多能够上榜几次？ $1 \\le m \\le n \\le 20$ 。 分析二进制枚举哪些局需要使用礼遇，求出每局游戏结束后所选择的英雄强度。 由于游戏顺序可以任意调整，所以一定是先选择英雄强度高的那一局游戏，在选择低的，这样能尽量满足上榜分数。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start; vector&lt;int&gt; score(n); for (int &amp;x : score) cin &gt;&gt; x; vector&lt;vector&lt;int&gt;&gt; all(n, vector&lt;int&gt;(4)); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; 4; j ++ ) cin &gt;&gt; all[i][j]; int ans = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) // 枚举哪些局需要使用礼遇 { if (__builtin_popcount(i) &gt; m) continue; vector&lt;int&gt; v; for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1) v.push_back(*max_element(all[j].begin(), all[j].end())); else v.push_back(max(all[j][0], all[j][1])); sort(v.begin(), v.end(), greater&lt;int&gt;()); int now = 0, st = start; for (int i = 0; i &lt; n; i ++ ) { st += v[i]; if (st &gt;= score[i]) ++ now; } ans = max(ans, now); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} E. 复苏小孩题意三只鬼的力量分别为 $1, 1, 1$ ，遍历由 $123$ 构成的字符串时，走到 ‘$i$’ 则第 $i$ 只鬼吸收其他两只鬼一半的力量。 给定长度为 $n$ 的字符串和 $m$ 次查询，查询有以下两个操作： $1 \\ x \\ y$ ，表示将第 $x$ 个位置的字符改为 $y$ 。 $2 \\ l \\ r$ ，询问遍历 $[l, r]$ 子串后三只鬼的力量分别为多少。 其中 $1 \\le n, m \\le 10^5$ 。 答案对 998244353 取模。 分析假设走到 ‘1’ 位置，则相当于三只鬼的力量乘上矩阵： \\left[ \\begin{matrix} 1 & 0 & 0 \\\\ \\dfrac 1 2 & \\dfrac 1 2 & 0 \\\\ \\dfrac 1 2 & 0 & \\dfrac 1 2 \\\\ \\end{matrix} \\right]‘2’和’3’同理，所以可以使用线段树维护区间上矩阵的乘积。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 100010, P = 998244353;int quick_power (int a, int k) { int ret = 1; for (a %= P; k; k &gt;&gt;= 1, a = (ll)a * a % P) if (k &amp; 1) ret = (ll)ret * a % P; return ret;}const int inv = quick_power(2, P-2);struct Matrix { int a[3][3]; Matrix() { memset(a, 0, sizeof a); } void build (int x) { memset(a, 0, sizeof a); if (x == 0) { a[0][0] = 1; a[1][1] = a[2][2] = a[1][0] = a[2][0] = inv; } if (x == 1) { a[1][1] = 1; a[0][0] = a[2][2] = a[0][1] = a[2][1] = inv; } if (x == 2) { a[2][2] = 1; a[0][0] = a[1][1] = a[0][2] = a[1][2] = inv; } } void buildI () { for (int i = 0; i &lt; 3; i ++ ) a[i][i] = 1; }};Matrix operator* (const Matrix &amp;a, const Matrix &amp;b) { Matrix ans; for (int k = 0; k &lt; 3; k ++ ) for (int i = 0; i &lt; 3; i ++ ) for (int j = 0; j &lt; 3; j ++ ) ans.a[i][j] = (ans.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % P; return ans;}struct seg_tree { #define lc(x) x&lt;&lt;1 #define rc(x) x&lt;&lt;1|1 Matrix mt; // mt为[l, r]区间矩阵相乘的结果 int l, r;};seg_tree t[N&lt;&lt;2];char s[N];void pushup (int p) { t[p].mt = t[lc(p)].mt * t[rc(p)].mt;}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; if (l == r) { t[p].mt.build(s[l] - '1'); return ; } int mid = l + r &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid+1, r); pushup(p);}void update (int p, int x, int v){ if (t[p].l == t[p].r &amp;&amp; t[p].l == x) { t[p].mt.build(v-1); return ; } int mid = t[p].l + t[p].r &gt;&gt; 1; if (x &lt;= mid) update(lc(p), x, v); else update(rc(p), x, v); pushup(p);}Matrix query (int p, int l, int r){ Matrix ret; ret.buildI(); if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].mt; int mid = t[p].l + t[p].r &gt;&gt; 1; if (l &lt;= mid) ret = ret * query(lc(p), l, r); if (r &gt; mid) ret = ret * query(rc(p), l, r); return ret;}int main (){ int n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + 1); build(1, 1, n); Matrix root = t[1].mt; while(m -- ) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) update(1, x, y); else { Matrix ret = query(1, x, y); for (int i = 0, v = 0; i &lt; 3; i ++, v = 0 ) { for (int j = 0; j &lt; 3; j ++ ) v = (v + ret.a[j][i]) % P; cout &lt;&lt; v &lt;&lt; ' '; } cout &lt;&lt; endl; } } return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法训练营4","slug":"2022寒假算法集训营4","date":"2022-02-17T07:04:12.000Z","updated":"2022-02-17T04:30:00.486Z","comments":true,"path":"2022/02/17/2022寒假算法集训营4/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/","excerpt":"","text":"B. 进制题意给定长度为 $n$ 的数字串 $s$ (只有 ‘0’ ~ ‘9’ 这十种字符) ，给定 $q$ 次询问，每次询问有以下两种： $1 \\ x \\ y$ ，表示将第 $x$ 个字符修改为 $y$ ，即令 $s_x = y$ 。 $2 \\ x \\ y$ ，查询区间 $[l, r]$ 串能够代表的某个进制的最小值，输出其十进制表示，结果对 $1e9+7$ 取模。 其中 $1 \\le n, q \\le 10^5$ 。 分析对于某个固定的区间，其每个位的数码是不变的，那么位权越小，能够表示的数字越小。所以使其最小的进制为其 $max + 1$， $max$ 表示区间最大值。 所以我们可以使用线段树维护两个信息：区间的最大值、区间数字按照九种进制运算得到的十进制数值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 100010, M = N &lt;&lt; 2, mod = 1e9 + 7;int quick_power(int a, int k){ int ret = 1; for (a %= mod; k; k &gt;&gt;= 1, a = (ll)a * a % mod) if (k &amp; 1) ret = (ll)ret * a % mod; return ret;}struct tree { #define lc(x) x &lt;&lt; 1 #define rc(x) x &lt;&lt; 1 | 1 int l, r; int d[11], maxv;} t[M];int n, q, a[N];void pushup (int p){ t[p].maxv = max(t[lc(p)].maxv, t[rc(p)].maxv); for (int i = 2; i &lt;= 10; i ++ ) t[p].d[i] = ((ll)t[lc(p)].d[i] * quick_power(i, t[rc(p)].r - t[rc(p)].l + 1) % mod + t[rc(p)].d[i]) % mod;}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; if (l == r) { for (int i = 2; i &lt;= 10; i ++ ) t[p].d[i] = a[l]; t[p].maxv = a[l]; return ; } int mid = l + r &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushup(p);}void modify (int p, int x, int v){ if (t[p].l == t[p].r &amp;&amp; t[p].l == x) { a[x] = v; t[p].maxv = v; for (int i = 2; i &lt;= 10; i ++ ) t[p].d[i] = v; return ; } int mid = t[p].l + t[p].r &gt;&gt; 1; if (x &lt;= mid) modify(lc(p), x, v); else modify(rc(p), x, v); pushup(p);}int query (int p, int l, int r){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].maxv; int mid = t[p].l + t[p].r &gt;&gt; 1; int ret = -1; if (l &lt;= mid) ret = max(ret, query(lc(p), l, r)); if (r &gt; mid) ret = max(ret, query(rc(p), l, r)); return ret;}ll query (int p, int l, int r, int v){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return (ll)t[p].d[v] * quick_power(v, r - t[p].r) % mod; int mid = t[p].l + t[p].r &gt;&gt; 1; ll ret = 0; if (l &lt;= mid) (ret += query(lc(p), l, r, v)) %= mod; if (r &gt; mid) (ret += query(rc(p), l, r, v)) %= mod; return ret;}int main (){ cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i ++ ) scanf(\"%1d\", &amp;a[i]); build(1, 1, n); for (int i = 1; i &lt;= q; i ++ ) { int op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 1) modify(1, l, r); else cout &lt;&lt; query(1, l, r, query(1, l, r) + 1) &lt;&lt; endl; } return 0;} L. 在这冷漠的世界里光光哭哭题意给定一个长度为 $n$ 的仅由小写字母构成的字符串 $s$ ，给出 $q$ 次查询，每次查询给出一个区间 $[l, r]$ 和一个长度为 $3$ 的字符串 $abc$ ，问：在 $[l, r]$ 中有多少个 $abc$ 的子序列？ 分析设 $f3(k, i, j)$ 表示前 $k$ 个字符中，有多少个 $i, s[k], j$ 这样的子序列。 对于每次查询，二分算出 $b$ 字符在 $[l, r]$ 中出现的第一次位置 $pos1$ 和最后一次位置 $pos2$。 那么 $f3(pos2, a, c) - f3(pos1-1, a, c)$ 即为，当 $k$ 在 $[l, r]$ 时的所有 $abc$ 的子序列个数。 根据容斥，再将其减去 $ (a) [bc], (a) [b] (c), [ab] (c) $ 即可。其中$[ \\quad ]$ 表示其在 $[l, r]$ 范围内。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 80010, M = 27;int n, q; char s[N];ll f1[N][M]; // f(i, j)表示前i个字符中有多少个jll f2[N][M][M]; // f(i, j, k)表示前i个字符中有多少个 \"jk\"ll f3[N][M][M]; // f(k, i, j)表示前k个字符中，有多少个\"i s[k] j\"，注意k为最后一个字符ll tmp[M][M][M]; // tmp(k, i, j)表示前k个字符中，有多少个 \"i k j\"vector&lt;int&gt; g[M]; // g(c)存储字符c的所有位置ll cal (int l, int r, int a, int b) // 计算[l, r]有多少个\"ab\"{ return f2[r][a][b] - f2[l-1][a][b] - f1[l-1][a] * (f1[r][b] - f1[l-1][b]);}int main (){ scanf(\"%d%d%s\", &amp;n, &amp;q, s + 1); for (int i = 1; i &lt;= 26; i ++ ) g[i].push_back(0); for (int i = 1; i &lt;= n; i ++ ) { int id = s[i] - 'a' + 1; g[id].push_back(i); } for (int i = 1; i &lt;= 26; i ++ ) g[i].push_back(1e9); for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= 26; j ++ ) f1[i][j] = f1[i-1][j] + (j == s[i] - 'a' + 1); for (int j = 1; j &lt;= 26; j ++ ) for (int k = 1; k &lt;= 26; k ++ ) { f2[i][j][k] = f2[i-1][j][k]; if (k == s[i] - 'a' + 1) f2[i][j][k] += f1[i-1][j]; } } for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= 26; j ++ ) for (int k = 1; k &lt;= 26; k ++ ) { // \"j s[i] k\" int id = s[i] - 'a' + 1; tmp[id][j][k] += f1[i-1][j] * (f1[n][k] - f1[i][k]); f3[i][j][k] = tmp[id][j][k]; } for (int i = 1; i &lt;= q; i ++ ) { int l, r; static char op[4]; scanf(\"%d%d%s\", &amp;l, &amp;r, op + 1); int a = op[1] - 'a' + 1; int b = op[2] - 'a' + 1; int c = op[3] - 'a' + 1; if (f1[r][b] - f1[l-1][b] == 0) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } int pos1 = lower_bound(g[b].begin(), g[b].end(), l) - g[b].begin(); int pos2 = upper_bound(g[b].begin(), g[b].end(), r) - g[b].begin(); ll ans = f3[g[b][pos2-1]][a][c] - f3[g[b][pos1-1]][a][c]; // b在[l, r]时，所有的\"abc\"的数量 // 容斥，减去(a)[bc],(a)[b](c),[ab](c) ans -= f1[l-1][a] * cal(l, r, b, c) + f1[l-1][a] * (f1[r][b] - f1[l-1][b]) * (f1[n][c] - f1[r][c]) + cal(l, r, a, b) * (f1[n][c] - f1[r][c]); printf(\"%lld\\n\", ans); } return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法集训营3","slug":"2022寒假算法集训营3","date":"2022-02-17T05:34:23.000Z","updated":"2022-02-17T04:29:51.950Z","comments":true,"path":"2022/02/17/2022寒假算法集训营3/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/","excerpt":"","text":"C. 智乃买瓜(another version)题意智乃来到水果摊前买瓜，水果摊上贩卖着若干个不同的西瓜，第 $i$ 个西瓜的重量为 $w_i$ ，智乃可以买整个瓜 $w_i$ 或者把瓜劈开买半个瓜，半个瓜的重量为 $\\dfrac {w_i} 2$ 。 也就是说对于每个瓜，智乃都有三种不同的决策： 购买一整个重量为 $w_i$ 的西瓜。 把瓜劈开，购买半个重量为 $\\dfrac {w_i} 2$ 的西瓜。 不进行购买操作。 注意，每个瓜的重量都为正偶数。 现在智乃知道，购买西瓜的重量和分别为 $k = 1, 2, 3 \\ldots M$ 时，购买西瓜的方案数（对 $1e9+7$ 取模）。 请构造出一个水果摊上 $N$ 个西瓜的重量，使得满足所要求的方案数量。保证数据存在 $N \\le 10^3$ 的合法解。 分析由于西瓜的重量为正偶数，所以对于重量为 $1$ 的方案，它只能由重量为 $2$ 的西瓜劈开得到。 那么我们就可以根据 $k=1$ 的情况，去除掉所有方案数中重量为 $2$ 的西瓜对其造成的影响。 去除后，所有的方案数都不会和重量为 $2$ 的西瓜有关，那么 $k=2$ 时的方案数就只能由重量为 $4$ 的西瓜构成。 依次去除所有的西瓜即可，把去除的西瓜加到结果数组即可。 注意点： 正向dp的枚举顺序是从后往前，目的是沿用上一层的原始数据。逆向dp也需要减去原始数据，所以要从前往后，否则减去的是这一层的数据。 正向dp时 $dp[0] = 1$ ，逆向dp也需要加上去。 本题提示了西瓜的质量为正偶数，如果没有提示，也要往构造所有正偶数质量西瓜去思考。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010, p = 1e9 + 7;int n, dp[N];int mod (int x) { return (x % p + p) % p; }int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; dp[i]; dp[0] = 1; vector&lt;int&gt; ret; for (int i = 1; i &lt;= n; i ++ ) while(dp[i]) { // 把 2*i 的西瓜去除 ret.push_back(2 * i); for (int j = i; j &lt;= n; j ++ ) { dp[j] = mod(dp[j] - dp[j-i]); if (j &gt;= 2 * i) dp[j] = mod(dp[j] - dp[j-2*i]); } } cout &lt;&lt; ret.size() &lt;&lt; endl; for (int v : ret) cout &lt;&lt; v &lt;&lt; ' '; return 0;} H. 智乃的树旋转(hard version)题意给定一棵 $N$ 个节点的二叉树，智乃将其做了若干次旋转将其打乱，她想要将其还原，要求旋转操作次数不超过 $N^2$ 次。 输入描述 第一行输入正整数 $N$ ($1 \\le N \\le 10^3$) ，表示二叉树的节点数量。 接下来 $N$ 行输入二叉树一开始的样子。 每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。 当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为 $0$ 时，则表示该节点无右子树。 接下来 $N$ 行输入二叉树被打乱后的样子。 每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。 当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为$0$时，则表示该节点无右子树。 要求你将打乱后的二叉树通过一系列旋转操作还原 输出描述 首先输出一个整数 $K$ ，表示你还原二叉树进行旋转的次数，要求你给出 $K$ 的范围在 $[0,N2]$ ，接下来 $K$ 行，依次输出旋转操作的旋转轴。 由于旋转轴只能进行左旋转或者右旋转其中的一种，裁判程序将会自己判断当前需要进行的是左旋转还是右旋转。 注意：旋转过程中的根节点无法作为旋转轴进行旋转，如果你指定旋转过程中的根节点作为旋转轴，则裁判程序将直接给出WA的结果。 分析如何将打乱的树还原？可以按照原来的树的先序遍历，依次把每个节点在打乱的树上做splay，单旋情况下，每个节点最多旋转 $n-1$ 次，总次数不超过 $n^2$ 的 数量级。 所以只需要记录每次旋转时的旋转轴即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;struct tree { int fa, ch[2]; } a[N], t[N]; // 原树和打乱后的树void rot (int u) // 把u节点向上旋转一次{ int fa = t[u].fa; int gfa = t[fa].fa; int t1 = (u != t[fa].ch[0]); // u是fa的左/右孩子 int t2 = (fa != t[gfa].ch[0]); // fa是gfa的左/右孩子 int ch = t[u].ch[t1 ^ 1]; // 需要被用来和fa交换的u的孩子 t[u].fa = gfa; t[u].ch[t1 ^ 1] = fa; t[fa].ch[t1] = ch; t[fa].fa = u; t[ch].fa = fa; t[gfa].ch[t2] = u;}// 输入树，返回这个树的根int input_tree (tree * t, int n){ vector&lt;bool&gt; vis(n + 1); for (int i = 1; i &lt;= n; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; t[i].ch[0] = u; t[i].ch[1] = v; vis[u] = vis[v] = true; if (u) t[u].fa = i; if (v) t[v].fa = i; } for (int i = 1; i &lt;= n; i ++ ) if (!vis[i]) return i; return -1;}bool st[N] = { true }; // 当前点是否被旋转到根过，0设置为true，因为0是树根的favector&lt;int&gt; ret;int n, root_a, root_t;void splay (int u){ while(!st[t[u].fa]) // 父节点还没有被旋转，也就是还没有修正 { ret.push_back(u); // u需要旋转 rot(u); }}void dfs (int u) // 先序遍历{ splay(u); st[u] = true; if (a[u].ch[0]) dfs(a[u].ch[0]); if (a[u].ch[1]) dfs(a[u].ch[1]);}int main (){ cin &gt;&gt; n; root_a = input_tree(a, n); root_t = input_tree(t, n); dfs(root_a); // 对原树进行先序遍历，依次对打乱的树进行splay cout &lt;&lt; ret.size() &lt;&lt; endl; for (int v : ret) cout &lt;&lt; v &lt;&lt; endl; return 0;} J. 智乃的C语言模除方程题意给定模除方程：$x \\ \\% \\ P = Q(Q \\in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\\%$ 遵循C语言的规则。 给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。 其中 $-10^9 \\le P, l, r, L, R \\le 10^9$ 且 $P != 0, l \\le r, L \\le R$ 。 分析模除方程 $x \\ \\% \\ P = Q$ ，即 $x = k \\times P + Q$ ，$Q &lt; P$ 。 由于 $Q$ 是 $[l, r]$ 的任意整数，所以显然 $x$ 的定义域为若干个连续子段。 对于 $[L, R]$ 的查询，设 $f(X)$ 表示 $[0, abs(X)]$ 中满足条件的 $x$ 数量。 然后需要根据 $L, R$ 的大小分类。 $0 \\le L \\le R$ 答案为 $f(R) - f(L - 1)$ 。 $L \\le 0 \\le R$ 答案为 $f(R) + f(L) - f(0)$ 。 $L \\le R \\le 0$ 答案为 $f(L) - f(R + 1)$ 。 所以接下来需要求出 $f(x)$ 。这里又需要对 $x$ 的大小分类。 $x \\ge 0$ $f(x)$ 表示 $[0, x]$ 范围，算出所有子段与 $[0, x]$ 的交集。 整段一共有 $x/P$ 个，注意每一段都要和 $[l, r]$ 取交集 ，然后算出最后一段 $[0, x\\%P]$ 和 $[l, r]$ 的交集。 取交集：$x \\% P$ 的余数范围 $[0, P-1]$ ，而 $Q$ 范围 $[l, r]$ ，需要取交集。 $x \\lt 0$ $f(x)$ 表示 $[-x, 0]$ 的范围，也需要算出所有子段与 $[-x, 0]$ 的交集。 但是由于C语言模除的结果与被除数相同，所以最后的答案也为负数，所以余数范围为负数 $[-P+1, 0]$ 。 Code12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint p, l, r, L, R;int get(int a,int b) // [l, r] 与 [a, b] 的交集{ return max(0ll, min(r, b) - max(a, l) + 1);}int f(int u){ if (u &lt; 0) return abs(u/p) * get(-p+1,0) + get(u%p,0); else return u/p * get(0, p-1) + get(0, u%p);}signed main(){ cin &gt;&gt; p &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R; p = abs(p); if(L &lt;= 0 &amp;&amp; R &gt;= 0) cout &lt;&lt; f(L) + f(R) - f(0); else if(L &gt; 0 &amp;&amp; R &gt; 0) cout &lt;&lt; f(R) - f(L-1); else cout &lt;&lt; f(L) - f(R+1);} K. 智乃的C语言模除方程(another version)题意给定模除方程：$P \\ \\% \\ x = Q(Q \\in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\\%$ 遵循C语言的规则。 给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。 其中 $-10^9 \\le P, l, r, L, R \\le 10^9$ 且 $P != 0, l \\le r, L \\le R$ 。 分析本题和上题唯一的区别在于 $x$ 和 $P$ 在方程的位置交换。 对于 $P \\ \\% \\ x = Q$ ，有 $P - \\lfloor \\dfrac P x \\rfloor \\times x = Q$ 。 枚举 $x$ 的值，则可以知道 $\\lfloor \\dfrac P x \\rfloor$ 的值，令其为 $c$ ，则变为 $P - c \\times x = Q$ 。其中 $P - c \\times x$ 为等差数列。 则问题变为：给定等差数列，问其第 $L$ 项到第 $R$ 项，有多少项在 $[l, r]$ 中。 根据 $\\lfloor \\dfrac P x \\rfloor$ 的性质，可以使用整除分块来枚举 $x$ 的值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll P, l, r, L, R;ll intersect (ll l0, ll r0, ll l1, ll r1){ ll ansl = max(l0, l1); ll ansr = min(r0, r1); return max(0ll, ansr - ansl + 1);}ll cal (ll k, ll cl, ll cr){ ll ansr = min(cr,(P-l)/k); ll ansl = max(cl,(P-r+k-1)/k); ll ans = 0; ans += intersect(ansl,ansr,L,R); ans += intersect(-ansr,-ansl,L,R); return ans;}int main (){ cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R; if (P &lt; 0) { P = -P; swap(l, r); l = -l; r = -r; } l = max(0ll, l); ll ans = 0; // 先枚举x的值绝对值在P范围内的情况，即[1, P] for (ll cl = 1, cr; cl &lt;= P; cl = cr + 1) { ll k = P / cl; cr = P / k; ans += cal(k, cl, cr); // 计算x的倍数为k，且x位于[cl, cr]时的情况 } if(l &lt;= P &amp;&amp; r &gt;= P) { ans += intersect(L, R, P+1, (ll)(1e10)); ans += intersect(L, R, -(ll)(1e10), -(P+1)); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法集训营2","slug":"2022寒假算法集训营2","date":"2022-02-17T04:09:12.000Z","updated":"2022-02-17T04:29:38.529Z","comments":true,"path":"2022/02/17/2022寒假算法集训营2/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/","excerpt":"","text":"A. 小沙的炉石题意给定 $n$ 张法术攻击牌和 $m$ 张法术恢复牌，每次攻击消耗一点法力，造成 $1$ 点伤害，恢复牌不消耗法力，可以恢复一点法力。小沙一开始有 $1$ 点法力，法力没有上限。 每次使用一张法力牌，都会使后面的攻击伤害 $+1$ 。 给出 $q$ 次询问，每次给出敌人的血量，问能否将其恰好斩杀？ 恰好斩杀：正好使得敌方血量变为 $0$ 。 分析如果使用的攻击牌和恢复牌的数量一定，那么可以造成的伤害一定是一个连续的区间。 假设使用 $a$ 张攻击牌和 $b$ 张恢复牌，注意 $a \\le b + 1$ 。 此时最小攻击伤害为：攻击、恢复、攻击、恢复…… ，伤害为 $\\sum_{i=1}^a{2 \\times i - 1} = a ^ 2$ 。 每次可以将序列中的一对 [攻击，恢复] 组合调换，造成伤害 $+1$ 。 最大伤害为：恢复、恢复、恢复、……、攻击、攻击。伤害为 $\\sum_{i=1}^{a} b + i = \\dfrac {((b + 1) + (b + a)) * a} 2$ 。 对于每次询问，由于需要恰好斩杀，因此最多能够使用的攻击牌是 $min(min(n, m+1), sqrt(hp))$ 。 由于造成伤害的区间是连续的，因此只需要看最大能造成的伤害是否超过 $hp$ 即可。 不需要判断最小造成的伤害，因为取到的攻击牌数一定 $\\le$ $sqrt(hp)$ 。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longsigned main (){ int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; n = min(n, m + 1); while(q -- ) { int hp; cin &gt;&gt; hp; int R = min(n, (int)sqrt(hp)); int maxv = (m + 1 + m + R) * R / 2; if (maxv &gt;= hp) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; } return 0;} B. 小沙的魔法题意给定 $n$ 个点和 $m$ 条边，初始时每个点权值为 $x_i = 0$ 。初始时图上无边，每次可以进行以下操作中的一种： 在 $m$ 条边中选择一条没有被选择过的边加入图中。 将图中的一个极大连通子图的每个点权值 $+1$ 。 给定边可能出现重边，自环。 问最少操作多少次操作2，才能使对于任意点有 $x_i = a_i$ 。 分析要使区间增加到目标值，等价于区间每个值初始为 $a_i$ ，每次使得区间值 $-1$ ，最终使区间值全部为 $0$ 。 优先减去权值最大的，在减去权值最大点的同时，可以顺带减去和它在同一个连通子图的所有点的权值，这整个连通子图全部变为 $0$ ，代价就是权值最大的那个点的权值。 按权值对每个点的位置排序，从大到小依次遍历当前点的相邻点，把当前点和权值比它大的点合并，先把权值大的点减到和当前点相同的权值，代价为 $a_{gt} - a_{cur}$ 。 这样最后的图会形成若干个连通子图，再把这些连通子图最小的权值加起来就是最少需要的操作2，加最小权值是因为我们先把比它大的权值点先减到和它权值相同。这也意味这合并时要以权值小的点为根。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010, M = 10000010;int n, m;int h[N], e[M], ne[M], idx;int a[N];int f[N], id[N], vis[N];int find (int x) { return x == f[x] ? x : f[x] = find(f[x]); }void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}int main (){ memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; iota(f, f + n + 1, 0); iota(id, id + n + 1, 0); for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; sort(id + 1, id + n + 1, [&amp;](int x, int y) { return a[x] &gt; a[y]; }); for (int i = 1; i &lt;= m; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); } long long res = 0; for (int i = 1, u = id[i]; i &lt;= n; i ++, u = id[i] ) { vis[u] = true; for (int k = h[u]; ~k; k = ne[k]) { int j = e[k]; int pu = find(u), pj = find(j); if (vis[j] &amp;&amp; pu != pj) { res += a[pj] - a[u]; f[pj] = pu; } } } for (int i = 1; i &lt;= n; i ++ ) if (find(i) == i) res += a[i]; cout &lt;&lt; res &lt;&lt; endl; return 0;} E. 小沙的长路题意规定有向完全图每条边只能走一次，问：$n$ 个点的有向完全图的最长路径的最大值和最小值分别为多少？ 分析$n$ 个点的有向完全图，最长路径一定经过了 $n$ 个点。 对于最小：如果图上有环，那么经过环一定比不经过环更长，所以我们要使图上无环，这样每个点只走一次，最短为 $n-1$ 。 对于最长：尽可能走完所有边，等价于给定有向完全图，删除尽可能少的边，使得剩下的图为欧拉图。如果 $n$ 为奇数，那么每个点连接偶数条边，一定存在一个有向无环图为欧拉图。如果 $n$ 为偶数，每个点连接奇数条边，欧拉图至多有 $2$ 个奇数点，也就是要使得 $n-2$ 个点变成偶数，删除一条边改变两个点度的奇偶性，所以需要删除 $\\dfrac {n-2} 2$ 条边。 Code123456789101112#include &lt;iostream&gt;using namespace std;int main (){ long long n; cin &gt;&gt; n; long long maxv; if (n &amp; 1) maxv = n * (n - 1) / 2; else maxv = n * (n - 1) / 2 - (n - 2) / 2; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; maxv &lt;&lt; endl; return 0;} F. 小沙的算数题意给定一个算数式（只包含加法和乘法），每次询问把一个数字替换为其他数字，问替换完后的结果为多少？（询问不独立，上一次的修改会影响下一次询问）。 分析由于算数式只包含加法和乘法，而乘法具有连乘性质，所以需要维护乘法区间的乘积。 对于乘法，只需要修改连乘区间的结果即可。对于加法，直接修改即可。 维护每个区间的乘法结果，可以使用并查集，开一个 $prod$ 数组表示每个集合的乘积。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 2000010, mod = 1000000007;int n, q, ret;string s;int a[N]; bool vis[N];int p[N], prod[N];int quick_power (int a, int k){ int res = 1; for (a %= mod; k; k &gt;&gt;= 1, a = (ll)a * a % mod) if (k &amp; 1) res = (ll)res * a % mod; return res;}int inv (int x) { return quick_power(x, mod-2); }int Mod (long long x) { return (x % mod + mod) % mod; }int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void merge (int x, int y){ x = find(x), y = find(y); prod[y] = Mod((ll)prod[y] * prod[x]); p[x] = y;}int main (){ cin &gt;&gt; n &gt;&gt; q; iota(p + 1, p + n + 1, 1); cin &gt;&gt; s; s = ' ' + s; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], prod[i] = a[i]; // 把乘积合并起来 for (int i = 1; i &lt; n; i ++ ) { if (s[i] != '*') continue; int j = i, ans = a[i]; vis[i] = true; while(j &lt; n &amp;&amp; s[j] == '*') { ans = Mod((ll)ans * a[j + 1]); vis[j + 1] = true; merge(j, j + 1); ++ j; } ret = Mod((ll)ret + ans); i = j; } for (int i = 1; i &lt;= n; i ++ ) if (!vis[i]) ret = Mod((ll)ret + a[i]); while(q -- ) { int id, to; cin &gt;&gt; id &gt;&gt; to; if (id != n &amp;&amp; s[id] == '*' || id &gt; 1 &amp;&amp; s[id-1] == '*') { // 位于乘法区间 int par = find(id); ret = Mod((ll)ret + Mod((ll)Mod((ll)prod[par] * inv(a[id])) * Mod((ll)to - a[id]))); cout &lt;&lt; ret &lt;&lt; endl; prod[par] = Mod((ll)Mod((ll)prod[par] * inv(a[id])) * to); a[id] = to; } else { // 位于加法区间 ret = Mod((ll)ret - a[id] + to); cout &lt;&lt; ret &lt;&lt; endl; a[id] = to; } } return 0;} G. 小沙的身法题意给定 $n$ 个节点的无根无向树，每个节点有权值 $a_i$ ，规定从 $i$ 节点跳到其相邻节点 $j$ 的代价为 $max(0, a_j - a_i)$ 。即从权值低的点跳到权值高的点，代价为其权值差；从权值高的点跳到权值低的点，代价为 $0$ 。 给定 $m$ 次询问，每次询问：从地面(权值为 $0$)跳到 $u$ 节点，再从 $u$ 节点跳到 $v$ 节点，再从 $v$ 节点跳到地面，最少消耗的代价为多少？ 其中 $1 \\le n \\le 10^6$ ，$1 \\le m \\le 10^5$ ，$1 \\le a_i \\le 10^9$ 。 分析对于无向树而言，两个节点之间只有一条简单路径。所以要消耗体力最小，就是走这条简单路径，即路径是唯一的。 从地面跳到 $u$ 节点，从 $v$ 节点跳到地面的代价为 $a_u$ 。 从 $u$ 点跳到 $v$ 点的代价，等价于从 $u$ 点跳到根节点的代价，加上从根节点跳到 $v$ 节点的代价，再减去从其 $lca$ 跳到根节点的代价，以及从根节点跳到 $lca$ 的代价。 由于代价不具有对称性，即从 $u$ 跳到根节点和从根节点跳到 $u$ 节点不是对称的，所以要dfs两次算出从根节点出发到其他点的代价，以及从其他点到达根节点的代价。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1000010, M = N &lt;&lt; 2;ll a[N], d[N], rd[N];namespace LCA { constexpr int SIZE = 20; int n, h[N], e[M], ne[M], idx; int fa[N][SIZE + 1], depth[N]; int q[N]; bool st[N]; void init () { fill(h, h + n + 1, -1); idx = 0; for (int i = 0; i &lt;= n; i ++ ) fill(fa[i], fa[i] + SIZE + 1, 0); fill(depth, depth + n + 1, 0); fill(st, st + n + 1, 0); } void add (int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ; } void bfs (int root = 1) { int hh = 0, tt = 0; q[0] = root; depth[root] = 1; st[root] = 1; while(hh &lt;= tt) { int u = q[hh ++ ]; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (st[j]) continue; st[j] = true; depth[j] = depth[u] + 1; fa[j][0] = u; q[++ tt] = j; } } for (int j = 1; j &lt;= SIZE; j ++ ) for (int i = 1; i &lt;= n; i ++ ) fa[i][j] = fa[fa[i][j-1]][j-1]; } int lca (int a, int b) { if (depth[a] &lt; depth[b]) swap(a, b); for (int i = SIZE; i &gt;= 0; i -- ) if (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i]; if (a == b) return b; for (int i = SIZE; i &gt;= 0; i -- ) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0]; }};using namespace LCA;void dfs (int u, int fa){ d[u] = d[fa]; if (a[u] &gt; a[fa]) d[u] += a[u] - a[fa]; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j != fa) dfs(j, u); }}void rdfs (int u, int fa){ rd[u] = rd[fa]; if (a[u] &lt; a[fa]) rd[u] += a[fa] - a[u]; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j != fa) rdfs(j, u); }}int main (){ int m; cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%lld\", &amp;a[i]); for (int i = 1, u, v; i &lt;= n - 1 &amp;&amp; scanf(\"%d%d\", &amp;u, &amp;v); i ++ ) add(u, v), add(v, u); dfs(1, 0); rdfs(1, 0); bfs(); for (int i = 1; i &lt;= m; i ++ ) { int x, y; cin &gt;&gt; x &gt;&gt; y; int f = lca(x, y); printf(\"%lld\\n\", a[x] + rd[x] + d[y] - rd[f] - d[f]); } return 0;} L &amp; M. 小沙的remake题意给定长度为 $n$ 的序列，选择若干个数字组成最长不下降子序列，使得被选中的每个元素，设其位置为 $i$ ，它前面 $b_i$ 个元素至少也有一个被选择。问这样的子序列有多少种？ 分析树状数组维护：对于每个位置而言，以它为结尾至少有多少种满足条件的子序列个数。 按元素权值从小到大排序，从前往后遍历，对于每个元素，设位置为 $i$，查询 $[i-b_i, i)$ 中每个位置的值，相加即为以当前元素为结尾的子序列的方案数。 这里的Code不按照题目要求的生成数据，方便参照。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;using T = pair&lt;int, int&gt;;using ll = long long;#define x first#define y secondconst int N = 2e6 + 10, mod = 1e9+7;int n, b[N];T a[N];int c[N]; // 树状数组void add (int x, int v){ for (; x &lt;= n; x += x &amp; -x) c[x] = ((ll)c[x] + v) % mod;}ll query (int x){ ll sum = 0; for (; x; x -= x &amp; -x ) sum = ((ll)sum + c[x]) % mod; return sum;}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i].x &gt;&gt; b[i], a[i].y = i; sort(a + 1, a + n + 1); ll res = 0; for (int i = 1; i &lt;= n; i ++ ) { ll val = query(a[i].y - 1) - query(a[i].y - b[a[i].y] - 1) + 1; val %= mod; res = (res + val + mod) % mod; add(a[i].y, val); } cout &lt;&lt; res &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法集训营1","slug":"2022寒假算法集训营1","date":"2022-02-17T03:00:00.000Z","updated":"2022-02-17T04:29:29.455Z","comments":true,"path":"2022/02/17/2022寒假算法集训营1/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/","excerpt":"","text":"A. 九小时九个人九扇门题意给定 $n$ 个数字和编号为 $1 \\sim 9$ 的九扇门，规定：$k$ 个数字的组合能够打开编号为 $f$ 的门，当且仅当这 $k$ 个数字之和的数字根等于 $f$ 。问对于每一扇门，有几种组合可以打开？ 其中 $1 \\le n \\le 10^5$ ，$1 \\le a_i \\le 10^9$ 。 数字根：不断将数字 $m$ 各个位上的数字相加，直到 $m$ 为一位数。一位数的数字根就是本身。 分析数字根的性质 求数字根：根据任何数字加 $9$ 的数字的数字根不变的性质，只需要模 $9$ 即可算出数字根。 设 $dp(i)$ 表示打开模 $9$ 为 $i$ 号门的组合数量。由于状态转移时，依赖关系不好找，而被依赖的关系容易找到，所以对于每个状态，更新被这个状态依赖的关系。注意DP的初始条件，为了启动DP要使 $dp(0)$ 为 $1$ ，最后要减去。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;int main (){ int n; cin &gt;&gt; n; vector&lt;int&gt; dp(9); dp[0] = 1; for (int i = 0; i &lt; n; i ++ ) { auto nxt = dp; int a; cin &gt;&gt; a; for (int k = 0; k &lt; 9; k ++ ) (nxt[(k + a) % 9] += dp[k]) %= mod; dp.swap(nxt); } for (int i = 1; i &lt; 9; i ++ ) cout &lt;&lt; dp[i] &lt;&lt; ' '; cout &lt;&lt; (dp[0] + mod - 1) % mod &lt;&lt; endl; return 0;} B. 炸鸡块君与FIFA22题意给定长度为 $n$ 的由 ‘W’, ‘L’, ‘D’ 构成的字符串表示若干场次的结果。 ‘W’表示胜利，分数加一；’L’表示失败，分数减一；’D’表示平局，分数不变。 特别的，当分数为 $3$ 的整数倍时，失败不会减少分数。 给定 $q$ 次查询，每次查询给出 $l, r, s$ ，问，在初始分数为 $s$ 时，经过 $[l, r]$ 场次后，最终的分数为多少？ 其中 $1 \\le n, q \\le 2 \\times 10^5$ ，$1 \\le l, r \\le n$ ，$0 \\le s \\le 10^9$ 。 分析注意到如果起始分数在模 $3$ 意义下相等，那么经历区间 $[l, r]$ 后，分数的变化量是不变的。 可以使用 ST 表，倍增实现查询，复杂度为 $O(max(q, n)\\times log n))$ 。其中查询复杂度为 $q log n$ ，初始化复杂度为 $n log n$ 。 设 $st[k][i][j]$ 表示初始分数模 $3$ 意义下为 $k$ ，经历区间 $[l, r]$ 后分数的变化量。 预处理：$st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j]) \\% 3][i + (1 &lt;&lt; j)][j-1]$ ，注意经过 $2^{j-1}$ 区间后初始分数在后面的区间要变化。 对于每次查询，我们可以每次走最大的二次幂，直到走完区间。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int st[3][N][21], Lg[N];/* 预处理,st[k][i][j] 表示初始分数模3为k时，经过[i, i + 2^j - 1]区间后分数的变化量 */int main (){ int n, q; cin &gt;&gt; n &gt;&gt; q; string s; cin &gt;&gt; s; s = ' ' + s; for (int i = 2; i &lt;= n; i ++ ) Lg[i] = Lg[i &gt;&gt; 1] + 1; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt; 3; j ++ ) { if (s[i] == 'W') st[j][i][0] = 1; else if (s[i] == 'L' &amp;&amp; j) st[j][i][0] = -1; } for (int j = 1; (1 &lt;&lt; j) &lt;= n ; j ++ ) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++ ) for (int k = 0; k &lt; 3; k ++ ) st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j-1]) % 3][i + (1 &lt;&lt; j-1)][j-1]; auto query = [&amp;] (int k, int l, int r) -&gt; int { int ret = 0; while(l &lt;= r) { int g = Lg[r - l + 1]; ret += st[k][l][g]; (k += st[k][l][g]) %= 3; l = l + (1 &lt;&lt; g); } return ret; }; while (q -- ) { int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; k + query(k % 3, l, r) &lt;&lt; endl; } return 0;} C. Baby’s first attempt on CPU题意给出 $n$ 个程序语句 $(3 \\le n \\le 100)$ ，其中某些程序语句有先写后读的制约关系，如果两条程序语句存在先读后写，那么这两条语句中间至少需要三条语句来使程序不出错。我们可以加入空语句来占位。 问，要使程序不出错，至少需要加入多少条空语句？ 给出的数据保证第 $i$ 行输入 $i, j, f$ ，如果 $f = 1$ ，表示第 $i$ 条语句和第 $i - j$ 条语句有先写后读的关系。并且 $i - j &lt;= 0$ 的情况始终有 $f = 0$ 。即不存在后面的语句先写，前面的语句再读。 分析贪心，设 $has(i)$ 表示第 $i$ 条语句后加入多少条空语句。 对于第 $i$ 条语句，假设它与第 $i-j$ 条语句有先读后写的关系，判断间隔有没有三条语句，如果没有，那么只需要在第 $i-1$ 条语句后加入空语句即可。 证明也很简单，对于后面的语句 $k$ ，如果有制约关系的语句 $k - k_j \\le i - j \\quad or \\quad k - k_j \\ge i$ ，那么加在哪条语句后都不会影响，反之，我们加在第 $i-1$ 条语句后一定更好，它能最大限度地包含于 $[k - k_j, k]$ 的位置。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int has[N];int main (){ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= 3; j ++ ) { int f; cin &gt;&gt; f; if (!f) continue; int cnt = accumulate(has + i - j, has + i, j - 1); if (cnt &lt; 3) has[i-1] += 3 - cnt; } cout &lt;&lt; accumulate(has + 1, has + n, 0ll) &lt;&lt; endl; return 0;} D. 牛牛做数论题意给定数字 $n$ 和函数 $H(x) = \\dfrac {\\phi(x)} x$ ，问： 回答一个 $x_0 \\in [2, n]$ ，使得 $H(x_0)$ 最小。如果存在多个，输出 $x_0$ 最小的那个。 回答一个 $x_0 \\in [2, n]$ ，使得 $H(x_0)$ 最大。如果存在多个，输出 $x_0$ 最大的那个。 其中 $1 \\le n \\le 10^9$ 。 分析根据欧拉函数定义 ：$\\phi(x) = x \\times \\prod_{i=1}^n (1 - \\dfrac 1 p_i)$ 。其中 $n$ 为 $x$ 质因子个数，$p_i$ 为$x$ 的各个质因子。 于是，函数 $H(x) = \\prod_{i=1}^n (1 - \\dfrac 1 p_i)$ 。 所以，求最小值，只需要把所有可能的质因子都加进去累乘即可，因为每个因子都小于 $1$ 。 求最大值，一定是只有一项因子，且这项因子的 $p_i$ 尽可能大，所以取不大于 $n$ 的最大质数，暴力求出即可，因为质数在 $[1, 10^9]$ 内浓度很大。(相邻质数最多相差 $282$) 。 注意 $n \\le 10^9$ ，在这个范围内最多有 $10$ 个不同的质因子。所以只需要枚举这几个就可以。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ const int p[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; auto is_prime = [&amp;] (int x) -&gt; bool { if (x &lt;= 2) return x == 2; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) return false; return true; }; int _; for (cin &gt;&gt; _; _ --; ) { int n; cin &gt;&gt; n; if (n == 1) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } int ans = p[0], pos = 1; while((long long)ans * p[pos] &lt;= n) ans *= p[pos ++ ]; cout &lt;&lt; ans &lt;&lt; ' '; ans = n; while(!is_prime(ans)) -- ans; cout &lt;&lt; ans &lt;&lt; endl; } return 0;} E. 炸鸡块君的高中回忆题意有 $n$ 个人想要进入学校，但是只有 $m$ 个校园卡，于是他们有如下方案：先让 $m$ 个人进入学校，再由一个人带着 $m$ 个校园卡出来。反复直到全部人进入学校。 每次进入或出去学校需要 $1$ 个单位时间，问所有人进入学校至少需要多少单位时间？ 分析首先有两个特判： $n \\le m$ ，可以一次进去完，只需要 $1$ 个单位时间。 $m == 1$ ，一定无法让所有人进去学校，因为每轮实际上只有 $m-1$ 个人进入学校。 否则，我们可以先让这 $n$ 个人进入第一轮循环，之后，他们需要循环的次数为 $\\lceil \\dfrac {n - m} {m-1} \\rceil$ ，注意最后一次不需要再有人出来送校园卡，因此总时间为 $2 + 2 \\times \\lceil \\dfrac {n - m} {m-1} \\rceil - 1$ 。 Code123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for (cin &gt;&gt; _; _--; ) { int n, m; cin &gt;&gt; n &gt;&gt; m; if (n &lt;= m) { cout &lt;&lt; 1 &lt;&lt; endl; continue; } if (m == 1) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } int d = (n - m + m - 1 - 1) / (m - 1); cout &lt;&lt; 2 + d * 2 - 1 &lt;&lt; endl; } return 0;} F. 中位数切分题意给出长度为 $n$ 的序列 $a$ ，将其划分为若干个子段，使得其中每个段的数值的中位数不小于 $m$ ，问最多能划分多少段？ （偶数长度字段的中位数为两个中较小的那一个。） 不存在任意划分策略则输出 $-1$ 。 其中 $1 \\le n \\le 10^5$ ，$1 \\le m \\le 10^9$ ，$1 \\le a_i \\le 10^9$ 。 分析首先，我们按照题意将序列划分若干个子段，使得每个字段数值的中位数不小于 $m$ 。 根据题目，我们发现对于每一个子段，不小于 $m$ 的数字个数一定大于 小于 $m$ 的数字个数。 贪心考虑，如果当前枚举的区间，已经满足大于关系，即 不小于 $m$ 的数字个数比小于 $m$ 的数字个数多 $1$ 。那么我们就可以把这块区间划分出来。 可以证明这样贪心一定是最优的，因为如果在这个区间之后加入 不小于 $m$ 的数字数量小于 小于 $m$ 的数字个数，那么不满足题意；如果大于，那么不必要合并，因为两个都是满足条件的子段。当然如果等于，那么还是要加上的，但是这不影响结果，因为这个区间还是满足如上条件。 我们发现，对于划分好的最优解子段，每个子段都满足 $\\ge m$ 的数字数量比 $&lt; m$ 的数字数量多 $1$ ，所以只需要统计一下区间的两个数量差即可。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for (cin &gt;&gt; _; _ --; ) { int n, m, cnt = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { int x; cin &gt;&gt; x; if (x &gt;= m) ++ cnt; else -- cnt; } cout &lt;&lt; (cnt &lt;= 0 ? -1 : cnt) &lt;&lt; endl; } return 0;} G. ACM is all you need题意给定长度为 $n$ 的序列 $a$ ，可以选择任意整数值 $b$ ，使得序列 $a$ 中每个元素 $a_i$ 变为 $|a_i - b| + b$ 。问经过一次变换后，序列中的极小值点的数量最少为多少？ 分析变换中 $+b$ 的操作是对整个序列都加上 $b$ ，不会改变相对大小，因此无用，可以看作变换为 $a_i = |a_i - b|$ 。 同时， $b$ 的值小于等于 $0$ 的情况是完全一样的，同样不改变相对大小，我们可以用 $b = 0$ 代替所有 $b \\le 0$ 的情况。 所以确定 $b$ 的值为 $[0, inf]$ 。 对于序列中每个元素而言，如果让它变成极小值点，取得 $b$ 值的范围是连续的，可以算出所有 $n-2$ 个 $b$ 范围的区间，那么问题就变成了：给定 $n-2$ 个区间，求被区间覆盖最小次数的点的覆盖次数。 对于区间 $[l, r]$ ，可以在每个位置上 $+1$ ，那么就是求 $[0, inf]$ 上每个位置的最小值。 可以使用差分来快速实现区间加，范围比较大，使用map离散化处理即可。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ const int INF = 0x3f3f3f3f; int _; for (cin &gt;&gt; _; _ -- ; ) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int &amp; x : a) cin &gt;&gt; x; map&lt;int, int&gt; m; m[0] = 0; // 注意0位置是需要考虑的 for (int i = 1; i &lt; n - 1; i ++ ) { int l = 0, r = INF; for (int x : { a[i-1], a[i+1] }) { if (x &gt; a[i]) r = min(r, a[i] + (x - a[i] - 1) / 2); if (x &lt; a[i]) l = max(l, x + (a[i] - x) / 2 + 1); if (x == a[i]) r = l - 1; // 这个点不可能成为极小值点 } if (r &lt; l) continue; ++ m[l]; if (r != INF) -- m[r + 1]; // 注意正无穷没有右端点 } int ret = INF, sum = 0; for (auto [k, v] : m) ret = min(ret, sum += v); cout &lt;&lt; ret &lt;&lt; endl; } return 0;} H. 牛牛看云题意给出长度为 $n$ 的序列 $a$ ，求出 $\\sum_{i=1}^n\\sum_{j=i}^n|a_i + a_j - 1000|$ 。 其中 $3 \\le n \\le 10^6$ ，$0 \\le a_i \\le 1000$ 。 分析题目简化一下就是求 $|a_i + a_j - 1000|$ ，其中 $1 \\le i \\le j \\le n$ 。 容易发现，对于 $i \\lt j$ 的情况， 把 $i$ 、$j$ 调换一下式子依然不变，所以式子对 $i$ 、$j$ 有对称性。 那么我们只需要对称地求出所有情况，再除以二即可。 注意点： 式子对 $i = j$ 不具有对称性，所以在求式子结果的时候，需要给这种情况加上。 $n$ 很大， $a_i$ 很小，可以在值域上做暴力。 为什么 $i = j$ 不具有对称性？ 对于 $1, 1, 2, 2$ 这个样例，我们枚举 $1$ 和 $2$ 的时候，把前和后的状态都算了，所以有对称性。 对于 $1, 1$ ，我们枚举 $1$ 和 $1$ 的时候，对于每一个 $1$ ，在计算加自己的时候，只计算了一次，根据对称性我们要加两次，这样最后除以二的时候才算出来一次。所以我们对每个 $1$ 都要再加一遍自己的情况。 其实本质上就是，$i=j$ 代表同一个式子，而 $i != j$ 代表了两种式子，一个定义域为 $i &lt; j$ ，一个定义域为 $i &gt; j$ 。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i++)#define int long longusing namespace std;const int N = 1010;int c[N];signed main (){ int n; cin &gt;&gt; n; long long ret = 0; rep(i, 1, n) { int x; cin &gt;&gt; x; ++ c[x]; } rep(i, 0, 1000) rep(j, 0, 1000) { if (i == j) ret = ret + c[i] * (c[j] + 1) * abs(i + j - 1000); else ret = ret + c[i] * c[j] * abs(i + j - 1000); } cout &lt;&lt; ret / 2 &lt;&lt; endl; return 0;} I. B站与各唱各的歌词有 $n$ 个UP主和 $m$ 句歌词，现在他们每个人要独立完成这 $m$ 句歌词，对于每一句歌词，他们可以选择唱或者不唱。完成后，将它们拼接起来。 如果一句歌词没有人唱或者被所有人唱过，那么这句歌词算失败的，否则是成功的。 问唱成功的歌词数量的期望为多少？ 若答案为分数，需要在模数为 $10^9 + 7$ 下取逆。 分析由于每个UP都是独立完成 $m$ 句歌词，所以对于每句歌词唱与不唱的概率都为 $\\dfrac 1 2$ 。 对于任意一句歌词，没有人唱或者全部人都唱的概率为 $(\\dfrac 1 2)^n$ 。 所以每一句歌词唱成功的概率为 $1 - (\\dfrac 1 2)^n \\times 2 = 1 - (\\dfrac 1 2)^{n - 1}$ 。 每一句成功的概率乘以总歌词数量即为唱成功的歌词数量的期望，即 $(1 - (\\dfrac 1 2)^{n - 1}) \\times m$ 。 Code1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main (){ const int p = 1e9 + 7; auto quick_power = [&amp;] (int a, int k) -&gt; int { int res = 1; for (a %= p; k; k &gt;&gt;= 1, a = (ll)a * a % p) if (k &amp; 1) res = (ll) res * a % p; return res; }; int _; for (cin &gt;&gt; _; _ -- ; ) { int n, m; cin &gt;&gt; n &gt;&gt; m; int inv = quick_power(2, p-2); cout &lt;&lt; (ll)(1 - quick_power(inv, n-1) + p) % p * m % p &lt;&lt; endl; } return 0;} J. 小朋友做游戏题意班级里有 $A$ 个安静的小朋友和 $B$ 个吵闹的小朋友，现在要选出 $n$ 个小朋友围成一圈，满足不存在两个吵闹的小朋友相邻。每个小朋友有一个幸福度，选中即可为班级增加幸福度，问最大幸福度为多少？ 分析为了满足条件，安静的小朋友至少要选出 $(n + 1) / 2$ 个，否则一定存在吵闹的小朋友相邻。 可以先选出这 $(n + 1) / 2$ 个小朋友，再双指针贪心选最大的幸福度。 双指针判断比较麻烦，要先判断是否有选完的，再贪心选。可以把剩下的小朋友放在一个容器中，选出最大的幸福度即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for (cin &gt;&gt; _; _ -- ; ) { int A, B, n; cin &gt;&gt; A &gt;&gt; B &gt;&gt; n; vector&lt;int&gt; a(A), b(B), all; for (auto &amp; x : a) cin &gt;&gt; x; for (auto &amp; x : b) cin &gt;&gt; x; sort(a.begin(), a.end(), greater&lt;int&gt;()); sort(b.begin(), b.end(), greater&lt;int&gt;()); if (A &lt; n - A) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } for (int i = (n + 1) / 2; i &lt; A; i ++ ) all.push_back(a[i]); for (int i = 0; i &lt; B; i ++ ) all.push_back(b[i]); sort(all.begin(), all.end(), greater&lt;int&gt;()); int ret = 0; for (int i = 0; i &lt; (n + 1) / 2; i ++ ) ret += a[i]; for (int i = 0; i &lt; n - (n + 1) / 2; i ++ ) ret += all[i]; cout &lt;&lt; ret &lt;&lt; endl; } return 0;} K. 冒险公社题意数轴上有 $n$ 座连续的岛屿，玩家从第一座岛屿出发，依次经过所有岛屿直到到达第 $n$ 座岛屿。 岛屿有三种类型：绿岛、红岛和黑岛。 在玩家到达第 $i$ 座岛屿时，如果第 $i, i-1, i-2$ 中绿岛数量大于红岛，则罗盘发出绿色；如果红岛数量大于绿岛，则发出红光；否则发出黑光。 给出在 $n$ 座岛屿上，罗盘发出的光，问这 $n$ 座岛屿最多有几座绿岛？(第 $1, 2$ 座岛屿不发光，规定为 ‘X’) 。 其中 $1 \\le n \\le 10^5$ ，发出的光的颜色为长度 $n$ 的字符串，由 ‘R’、’G’、’B’ 构成。 分析为了方便，我们设绿岛为 $0$ ，红岛为 $1$ ，黑岛为 $2$ 。 设 $dp(i, j, k, l)$ 表示对于前 $i$ 座岛屿，且最后三座岛屿为 $(j, k, l)$ 时，绿岛的最大数量。 转移方程为 $dp(i, j, k, l) = max(dp(i, j, k, l), dp(i-1, t, j, k))$ ，其中 $0 \\le t \\le 2$ 。 注意在转移前判断 $(j, k, l)$ 是否合法，以及 $dp(i-1, t, j, k)$ 是否合法。$dp = -1$ 表示这种状态是不合法的。 坑点：注意一定用 $dp(i-1, t, j, k)$ 判断，不要用 $(t, j, k)$ 判断是否为 $s[i-1]$ ，因为即使等于，也不一定合法，还和前面的岛屿有联系。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int dp[N][3][3][3];/* dp(i, j, k, l) 表示考虑前i个字符，此时最后三个岛屿为(j, k, l)时的最大绿岛数量 * 其中0表示绿岛，1表示红岛，2表示黑岛 */char get_color (int a, int b, int c){ int x1 = (a == 0) + (b == 0) + (c == 0); int x2 = (a == 1) + (b == 1) + (c == 1); if (x1 &gt; x2) return 'G'; if (x1 &lt; x2) return 'R'; return 'B';}int main (){ int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = ' ' + s; memset(dp, -1, sizeof dp); // 初始化 for (int i = 0; i &lt; 3; i ++ ) for (int j = 0; j &lt; 3; j ++ ) for (int k = 0; k &lt; 3; k ++ ) if (get_color(i, j, k) == s[3]) dp[3][i][j][k] = !i + !j + !k; for (int i = 4; i &lt;= n; i ++ ) for (int j = 0; j &lt; 3; j ++ ) for (int k = 0; k &lt; 3; k ++ ) for (int l = 0; l &lt; 3; l ++ ) for (int t = 0; t &lt; 3; t ++ ) if (~dp[i-1][t][j][k] &amp;&amp; get_color(j, k, l) == s[i]) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i-1][t][j][k] + !l); int ret = -1; for (int i = 0; i &lt; 3; i ++ ) for (int j = 0; j &lt; 3; j ++ ) for (int k = 0; k &lt; 3; k ++ ) ret = max(ret, dp[n][i][j][k]); cout &lt;&lt; ret &lt;&lt; endl; return 0;} L. 牛牛学走路题意给出字符串 $s$ ，牛牛会按照字符串给的方向走一遍，问走的位置里原点最远为多少？ 分析签到题，维护一下当前的位置即可，设原点为 $(0, 0)$ 。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int dr[] = { 0, 0, 1, -1 }, dc[] = { 1, -1, 0, 0 };void solve (){ map&lt;char, int&gt; d; d['U'] = 0; d['D'] = 1; d['R'] = 2; d['L'] = 3; int x = 0, y = 0, n; cin &gt;&gt; n; string s; cin &gt;&gt; s; double ret = -1; for (int i = 0; i &lt; n; i ++ ) { x += dr[d[s[i]]]; y += dc[d[s[i]]]; double dis = sqrt(x * x + y * y); ret = max(ret, dis); } printf(\"%.12lf\\n\", ret);}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"扩展中国剩余定理","slug":"扩展中国剩余定理","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-21T15:39:40.000Z","comments":true,"path":"2022/02/16/扩展中国剩余定理/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"","text":"扩展中国剩余定理中国剩余定理对于同余方程组： \\begin{cases} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ x \\equiv a_3 \\pmod {m_3} \\\\ ..... \\\\ x \\equiv a_n \\pmod {m_n} \\\\ \\end{cases}求出满足上述同余方程组的 $x$ 的一组解，公式满足 $m_1,m_2, m_3 … m_n$ 互质。 令 $M = \\prod_{i=1}^{n}m_i , M_i = M / m_i, M_i \\times M_i^{-1} \\equiv 1 \\pmod {m_i}$ 。 中国剩余定理构造出了这样一组解: x = \\sum_{i=1}^{n} M_i * M_i^{-1} * a_i对于每一组解 $x \\equiv a_i \\pmod {m_i}$ ，$x$ 除了 $M_i \\times M_i ^ {-1} \\times a_i$ 项之外，其余都能被 $m_i$ 整除，所以只剩下这一项。 又因为 $M_i \\times M_i^{-1} \\equiv 1 \\pmod {m_i}$ 。所以 $x \\equiv a_i \\pmod {m_i}$ 。 扩展中国剩余定理传统的中国剩余定理限制性太强，必须要满足 $m_1, m_2, m_3 … m_n$ 互质。如何求出不满足模数不互质的同余方程组的解？ 先从两个柿子看起： \\begin{cases} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ \\end{cases}首先可以得到 $x = k_1 \\times m_1 + a_1 = k_2 \\times m_2 + a_2$ 。 对这个柿子化简： $k_1 \\times m_1 + k_2 \\times (-m_2) = a_2 - a_1$ 。 对于这个柿子，我们可以用扩展欧几里得求出一组满足 $k_1 \\times m_1 + k_2 \\times (-m_2) = gcd(m_1, -m_2)$ 的 $k_1, k_2$ 解。 记 $gcd(m1, -m2) = d$ 。 根据贝祖定理，如果不满足 $d | a_2 - a_1$ ，那么不存在解。否则，我们只需要扩大 $(a_2 - a_1) / d$ 倍即可得到 $k_1$ 的一组解。 由于这是个不定方程，在求出 $k_1$ 后，我们可以得到其他满足的解一定为 $k_1 = k_1 + k \\times (m_2 / d)$ 。 我们把这个通解 $k_1$ 带入原来的柿子：$x = (k_1 + k \\times (m_2 / d)) \\times m_1 + a_1$ 。 得到： $x = k_1 \\times m_1 + a_1 + k \\times (m_1 \\times m_2) / d$ 。 $x = k_1 \\times m_1 + a_1 + k \\times lcm(m_1, m_2)$ 。 令 $m_0 = lcm(m1, m2), a_0 = k_1 \\times m_1 + a_1$ 。 那么，我们得到 $x = k \\times m_0 + a_0$ ，这个柿子满足这两个同余方程组解。 通过这样的方式，我们就可以把两个同余方程组化简成一个，最终达到化简 $n$ 个同余方程组的效果。 那么最终可以算出 $x = k \\times m + a$ ，其中 $m = lcm(m_1, m_2 … m_n)$ ，所以在 $\\pmod m$ 的意义下， $x = a$ 。 例题:Acwing 204 表达整数的奇怪方式 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;int exgcd (int a, int b, int &amp; x, int &amp; y){ if (!b) return x = 1, y = 0, a; int r = exgcd(b, a % b, x, y); tie(x, y) = make_tuple(y, x - (a / b) \\times y); return r;}int mod (int a, int b){ int res = ((a % b) + b) % b; return res;}signed main (){ int n; cin &gt;&gt; n; int a1, m1; cin &gt;&gt; a1 &gt;&gt; m1; for (int i = 1; i &lt; n; i ++ ) { int a2, m2, k1, k2; cin &gt;&gt; a2 &gt;&gt; m2; int r = exgcd(a1, -a2, k1, k2); if ((m1 - m2) % r) return cout &lt;&lt; \"-1\" &lt;&lt; endl, 0; k1 = mod(k1 \\times (m2 - m1) / r, abs(a2 / r)); m1 = k1 \\times a1 + m1; a1 = abs(a1 \\times a2 / r); } cout &lt;&lt; m1 &lt;&lt; endl; return 0;} 关于为什么取 $abs$ 的原因: 由于 $a \\% b$ 和 $a \\% -b$ 是相同的，所以我们在计算 $k_1$ 时 需要加上 $abs(a_2 / r)$ ，防止在 $mod$ 过程中加上负数，结果仍然是负数。 下一个阶段的 $a_1$ 实际上一个的 $lcm(a_1,a_2)$ ，但是在计算 $gcd(a_1, a_2)$ 时可能出现负数，导致计算 $lcm$ 时会出现负数，这里要取 $abs$ 。","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"康托展开","slug":"康托展开","date":"2022-02-16T14:54:28.239Z","updated":"2022-01-01T11:51:58.000Z","comments":true,"path":"2022/02/16/康托展开/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","excerpt":"","text":"康托展开 康托展开是一个全排列与自然数的双射，常用于构建hash表时的空间压缩。假设有 $n$ 个数(1, 2, 3, 4 …) ， 可以有 $n!$ 的排列组合，康托展开表示在某一个全排列在这些组合的名次（以0开始）。 原理一个全排列 $A$ 的名次为 $a_1 \\times (n-1)! + a_2 \\times (n-2)! \\ldots + a_n \\times 0!$ 。 其中 $a_i$ 表示第 $i$ 个数字，$A_i &gt; A_j \\ and \\ i &lt; j$ 。即比当前数字小但是在它后面的数字的个数。 因为对这个位置而言，我们选择 $a_i$ 中任意一个数字填充这个位置，后面的数字任意排列都可以比原来的小，所以比它小的名次的排列数量为 $a_i \\times (n - i)!$ 。 1234567int id = 0;for (int i = 1; i &lt;= n; i ++ ){ int x = 0; for (int j = i + 1; j &lt;= n; j ++ ) x += A[j] &lt; A[i]; id += x * fac[n - i];} 逆康托展开由于康托展开是一个全排列和自然数的双射，因此我们也可以根据名次得出全排列。 从前往后，对于第 $i$ 个数字，我们可以得到 $a_i = id / (n-i)!$ 。 由于 $a_i$ 表示在其后面且小于它的数值的数量，所以我们要遍历得到这个位置的值。 1234567891011121314int id; cin &gt;&gt; id;bool st[N]; // st(i) 表示i数字有没有出现for (int i = 1; i &lt;= n; i ++ ){ int a = id / fac[n - i]; id %= fac[n - i]; for (int j = 1; j &lt;= n; j ++ ) if (!st[j]) // 没有出现过 { if (!a) // 已经找到a个数字比它小 { A[i] = j; st[i] = true; break; } else -- a; }} 洛谷 P3014 Cow Line S 优化康托展开注意到内层循环的目的是为了找出后面有几个数字小于当前位置的数字，我们可以采用树状数组维护，从后往前遍历即可。这样查询只需要 $O(logn)$ 的时间，总复杂度降至 $O(nlogn)$ 。 洛谷P5367 模板 康托展开 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )typedef long long ll;const int N = 1000010, mod = 998244353;int n, a[N];ll c[N], fac[N];void add (int x){ for (; x &lt;= n; x += x &amp; -x) ++ c[x];}ll query (int x){ ll ret = 0; if (x) for (; x; x -= x &amp; -x) ret += c[x]; return ret;}void solve (){ scanf(\"%d\", &amp;n); fac[0] = 1; rep(i, 1, n) fac[i] = fac[i-1] * i % mod; ll id = 0; rep(i, 1, n) scanf(\"%d\", &amp;a[i]); per(i, n, 1) add(a[i]), id = (id + fac[n-i] * query(a[i] - 1) % mod) % mod; printf(\"%lld\", (id + 1) % mod);}signed main (){ solve(); return 0;} 逆康托展开注意到内层循环的目的是为了找出剩下没有被选上的数字中的第 $a_i+1$ 个数字，我们可以采用线段树维护，复杂度 $O(logn)$ ，总复杂度为 $O(nlogn)$ 。 具体来说，我们维护 $[l, r]$ 中有多少数字是有效的（未被删除），每次查询找出全局第 $a_i + 1$ 小的数字即可。 123456789101112131415161718192021222324252627struct node{ #define ls(x) x&lt;&lt;1 #define rs(x) x&lt;&lt;1|1 int l, r; ll st; // st 表示当前这个区间有多少数字未被删除};node t[N&lt;&lt;2];inline void pushup (int p){ t[p].st = t[ls(p)].st + t[rs(p)].st;}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; t[p].st = 1; if (l == r) return ; int mid = l + r &gt;&gt; 1; build(ls(p), l, mid); build(rs(p), mid+1, r); pushup(p);}int query (int p, int k){ -- t[p].st; // 在这个区间查询后需要删除那个数字 if (t[p].l == t[p].r) return t[p].l; if (t[ls(p)].st &gt;= k) return query(ls(p), k); else return query(rs(p), k - t[ls(p)].st);} 洛谷 P3014 Cow Line S优化版 记得每次初始化~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )typedef long long ll;const int N = 10000;int n, a[N];ll c[N], fac[N];void add (int x){ for (; x &lt;= n; x += x &amp; -x) ++ c[x];}ll query (int x){ ll ret = 0; if (x) for (; x; x -= x &amp; -x) ret += c[x]; return ret;}struct node{ #define ls(x) x&lt;&lt;1 #define rs(x) x&lt;&lt;1|1 int l, r; ll st; // st 表示当前这个区间有多少数字未被删除};node t[N&lt;&lt;2];inline void pushup (int p){ t[p].st = t[ls(p)].st + t[rs(p)].st;}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; t[p].st = 1; if (l == r) return ; int mid = l + r &gt;&gt; 1; build(ls(p), l, mid); build(rs(p), mid+1, r); pushup(p);}int query (int p, int k){ -- t[p].st; // 在这个区间查询后需要删除那个数字 if (t[p].l == t[p].r) return t[p].l; if (t[ls(p)].st &gt;= k) return query(ls(p), k); else return query(rs(p), k - t[ls(p)].st);}void solve (){ int q; scanf(\"%d%d\", &amp;n, &amp;q); fac[0] = 1; rep(i, 1, n) fac[i] = fac[i-1] * i; while(q -- ) { char op; cin &gt;&gt; op; if (op == 'Q') { rep(i, 0, n) c[i] = 0; ll id = 0; rep(i, 1, n) scanf(\"%d\", &amp;a[i]); per(i, n, 1) add(a[i]), id += fac[n-i] * query(a[i] - 1); printf(\"%lld\\n\", id + 1); } else { build(1, 1, n); ll id; scanf(\"%lld\", &amp;id); id -- ; for (int i = 1; i &lt;= n; i ++ ) { int x = id / fac[n - i]; id %= fac[n - i]; printf(\"%lld \", query(1, x+1)); } printf(\"\\n\"); } }}signed main (){ solve(); return 0;} 2021.12.31 更新，使用树状数组模板和zkw树实现康托展开和逆康托展开。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )typedef long long ll;const int N = 10000;int n, a[N];ll fac[N];template&lt;int N&gt; struct BIT { using ll = long long; int n; ll a[N]; static constexpr int lowbit(int x) { return x &amp; -x; } void init(int n) { this-&gt;n = n; fill(a+1, a+n+1, 0); } void add(int x, int v = 1) { if (x) for (; x &lt;= n; x += lowbit(x)) a[x] += v; } ll ask(int x) { ll res = 0; if (x) for (; x; x -= lowbit(x)) res += a[x]; return res; } ll ask(int l, int r) { return ask(r) - ask(l-1); }};BIT&lt;N&gt; bit;/* zkw树 */ll M, t[N &lt;&lt; 1]; // t(i) 表示i节点表示的区间内有多少剩余的1void build (){ for (ll i = M; i &lt; M + n; i ++ ) t[i] = 1; for (ll i = M - 1; i; i -- ) t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1];}ll ask (ll x){ ll r; for (r = 1; r &lt; M; ) { -- t[r]; if (t[r&lt;&lt;1] &gt;= x) r &lt;&lt;= 1; else x -= t[r&lt;&lt;1], (r &lt;&lt;= 1) |= 1; } return -- t[r], r - M + 1;}void solve (){ int q; scanf(\"%d%d\", &amp;n, &amp;q); for (M = 1; M &lt; n; M &lt;&lt;= 1); fac[0] = 1; rep(i, 1, n) fac[i] = fac[i-1] * i; while(q -- ) { char op; cin &gt;&gt; op; if (op == 'Q') { bit.init(n); ll id = 0; rep(i, 1, n) scanf(\"%d\", &amp;a[i]); per(i, n, 1) bit.add(a[i]), id += fac[n-i] * bit.ask(a[i] - 1); printf(\"%lld\\n\", id + 1); } else { build(); ll id; scanf(\"%lld\", &amp;id); id -- ; for (int i = 1; i &lt;= n; i ++ ) { int x = id / fac[n - i]; id %= fac[n - i]; printf(\"%lld \", ask(x+1)); } printf(\"\\n\"); } }}signed main (){ solve(); return 0;}","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"整除分块","slug":"整除分块","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-23T13:45:34.000Z","comments":true,"path":"2022/02/16/整除分块/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/","excerpt":"","text":"整除分块一维分块引入给定一个整数，求出 \\sum_{i=1}^n \\lfloor \\dfrac n i \\rfloor其中: $1 \\le n \\le 10^9$ 。 对于上述题目，$O(n)$ 的解法是很显然的，但是对于 $n$ 很大或者有多组测试样例时，这样的复杂度是不能接受的。我们需要找出更优秀的复杂度来解决上述题目。 容易发现，由于 $\\dfrac n i$ 是向下取整的，因此在某一个连续的区间， $\\dfrac n i$ 取值是相同的，比如 $n = 10$ 时： i 1 2 3 4 5 6 7 8 9 10 n/i 10 5 3 2 2 1 1 1 1 1 每一个取值都是一个连续的块，那么只要我们直到某一个块的左右端点，就可以 $O(1)$ 地算出这个块的总和。 定理1： $\\dfrac n i$ 中最多有 $2 \\times \\sqrt{n}$ 个块。 我们把 $\\dfrac n 1, \\dfrac n 2, \\ldots \\dfrac n n$ 分成 $2$ 个部分，前一部分为 $\\dfrac n 1, \\dfrac n 2, \\ldots \\dfrac {n} {\\lfloor \\sqrt n \\rfloor }$ ，后一部分为 $\\dfrac n {\\lfloor \\sqrt n \\rfloor + 1}, \\dfrac n {\\lfloor \\sqrt n \\rfloor + 2}, \\ldots \\dfrac n n$ 。 对于前一部分，有 $\\sqrt n$ 项，对于后一部分，它所有的取值为 $1, 2, \\ldots \\sqrt n$ ，因此不同的取值有 $\\sqrt n$ 项，所以最多有 $2 \\times \\sqrt n$ 项不同的取值。 根据定理1，我们根据最好的情况，即把每一个块都 $O(1)$ 地算出结果，那么复杂度就是 $O(\\sqrt n)$ 的。 定理2： 如果第 $k$ 块，如果它的左端点为 $l$ ，那么它的右端点为 $\\dfrac n {\\lfloor \\dfrac n l \\rfloor}$ 。 假设第 $k$ 段的取值为 $t$ ，取 $i$ 为 $l \\le i \\le r$ ，那么显然有 $\\dfrac n i = \\dfrac n l = t$ ，即 $i \\times t \\le n$ ，$i \\le \\dfrac n t$，由于 $r = max(i)$ ，那么 $r = \\dfrac n t = \\dfrac n {\\lfloor \\dfrac n l \\rfloor}$ 。 如此，我们便可以求出所有块的左右端点进行运算，复杂度为 $O(\\sqrt n)$ 。 给出整除分块模板： 12345for (int l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); ret += (r - l + 1) * (n / l);} 例题约数研究由于直接求 $i$ 的约数个数不好求，我们可以枚举所有的因子。 假设因子为 $i$ ，那么在 $[1, n]$ 中，因数含有 $i$ ，即 $i$ 的倍数有 $\\lfloor \\dfrac n i \\rfloor$ 个。 因此问题转化为求 $\\sum_{i=1}^n \\lfloor \\dfrac n i \\rfloor$ ，这就是基本整除分块。 1234567891011void solve (){ int n; cin &gt;&gt; n; long long ret = 0; for (int l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); ret += (long long) (r - l + 1) * (n / l); } cout &lt;&lt; ret &lt;&lt; endl;} 余数求和首先由于 $k \\ \\ mod \\ \\ i = k - \\lfloor \\dfrac k i \\rfloor \\times i$ 。 于是我们可以把原式转化成 $\\sum_{i=1}^n k - \\lfloor \\dfrac k i \\rfloor \\times i = n \\times k - \\sum_{i=1}^n \\lfloor \\dfrac k i \\rfloor \\times i$ 。 其中 $\\lfloor \\dfrac k i \\rfloor$ 我们可以使用整除分块处理，这样对于每一个块而言， $\\lfloor \\dfrac k i \\rfloor$ 都是一个常数，那么我们要求它乘以一个等差数列的值，只需要求 $i$ 在这个块的累加和即可。 123456789101112void solve (){ int n, k; cin &gt;&gt; n &gt;&gt; k; long long ret = n * k; for (int l = 1, r; l &lt;= n; l = r + 1) { if (k / l) r = min(k / (k / l), n); else r = n; ret -= (long long)(l + r) * (r - l + 1) / 2 * (k / l); } cout &lt;&lt; ret &lt;&lt; endl;} 二维分块给定两个整数 $n, m$ ，求： \\sum_{i=1}^{min(n, m)} \\lfloor \\dfrac n i \\rfloor \\times \\lfloor \\dfrac m i \\rfloor由一维分块，我们可以得到块数最多为 $2 \\times \\sqrt n + 2 \\times \\sqrt m$ 。 我们记 $k = min(n, m)$ 。 对于其中一个块，假设左端点为 $l$ ，那么其右端点为 $r = min(k, min(n / (n / l), m / (m / l)))$ 。因为我们要保证块里的元素相同，必须要保证 $\\lfloor \\dfrac n i \\rfloor$ 元素相同且 $\\lfloor \\dfrac m i \\rfloor$ 元素相同。 二维分块模板： 12345for (int l = 1, r; l &lt;= k; l = r + 1){ r = min(k, min(n / (n / l), m / (m / l))); ret += (n / l) * (m / l) * (r - l + 1);}","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2022-02-16T14:54:28.239Z","updated":"2022-02-17T14:24:19.704Z","comments":true,"path":"2022/02/16/最小生成树/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"最小生成树介绍 在介绍最小生成树前，先介绍一下生成树：在一张联通无向图中，我们取图上的所有点，并取最少的边将其相连使其连通生成一棵树，这个树就被称作这张图的生成树。因为树的边数一定是点数-1，所以就是取 $n-1$ 条边来连通 $n$ 个点。 那么最小生成树(Minimum Spanning Tree)，是最小权重生成树的简称。规定树的权值为树上所有边的权值和，那么它就是一张连通加权无向图中一颗权值最小的生成树，如上图。由定义可以看出，最小生成树不一定唯一。 对于如何生成最小生成树的问题，我们有两种常见的解决方法，分别是Prim算法和Kruskal算法，两者都基于贪心。 Prim算法给定图 $G(V, E)$ ，我们逐步进行Prim算法，假设在过程中，$V_{new}$ 表示已经选中作为生成树上的结点，$E_{new}$ 表示已经选中作为最小生成树上的边。 规定Prim算法如下： 初始化一个结点 $x$ 加入 $V_{new}$ ，则 $V_{new} = {x}$ 。由于最小生成树包含所有节点，我们可以用任意一个结点初始化。 从集合 $E$ 中选择权值最小的边 $(u, v)$ ，满足 $u \\in V_{new}$ 且 $v \\notin V_{new}$ ，将 $v$ 加入集合 $V_{new}$ 中，把 $(u, v)$ 加入 $E_{new}$ 中。 重复操作，直到所有点都已经被选中加入最小生成树中，即 $V_{new} = V$ 。 根据 $V_{new}$ 和 $E_{new}$ 所得到的新图 $G_{new}(V_{new}, E_{new})$ 即为原图 $G(V, E)$ 的最小生成树。 只需要证明根据第二步所得到边一定为最优解即可。 按照Prim算法得到的第一条边一定是最小生成树上的边。 如果不是，我们把这一条边加入到最小生成树中，形成回路，我们让最小的边取代回路中比它大的边，得到权值更小的生成树。所以第一条边一定是最小生成树上的边。 假设在某一个步骤中，Prim得到的点集为 $V_{new} = \\{v1, v2, v3 \\ldots vs-1\\}$ 。 根据Prim算法，我们应该选择与这些点有交集的边中，权值最小的边。 假设这个权值最小的边连接 $V_{new}$ 中的 $vk$ ，如果不选择这条边，那么我们把这条边加入最小生成树中，形成一个回路，且这个回路包含 $vk$ ，我们假设连接 $vk$ 的那条边另一端为 $vi$ ，我们用权值最小的边替换掉 $(vk, vi)$ ，得到的生成树权值一定不大于最小生成树，因此选择这条边为最优边。 12345678910111213141516171819202122232425262728int h[N], e[M], w[M], ne[M], idx; // 邻接表存图bool st[N]; // st(x) 表示x点已经加入生成树中int dist[N]; // dist(x) 表示x点距离已经生成的树的最小距离int prim () // 返回最小生成树的权值{ int ret = 0; memset(d, 0x3f, sizeof d); d[1] = 0; // 初始化从1开始，最开始生成树上的V和E都为空 for (int i = 0; i &lt; n; i ++ ) // 要加入n个点，迭代n次，每次放进一个点 { // 找出距离当前生成树最近的点 int t = -1; for (int k = 1; k &lt;= n; k ++ ) if (!st[k] &amp;&amp; (t == -1 || dist[k] &lt; dist[t])) t = k; // 把选择的点加入生成树中 st[t] = true; ret += dist[t]; // 由于加入了一个点，那么其他点也可以通过连接这个点到达生成树，更新dist for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; dist[j] = min(dist[j], w[i]); } } return ret; // 返回最小生成树的权值} 有没有觉得Prim算法和Dijkstra算法雷同？没错，它们都是根据同样的贪心思想，唯一的区别仅仅在于更新的时候。 Prim算法复杂度：根据上述代码，复杂度为 $O(n^2 + 2E)$ ，由于图上每个点至多被更新 $1$ 次，所以图的所有边至多被更新 $2$ 次。 与Dijsktra算法一样，Prim算法可以使用二叉堆优化，复杂度降到 $O((n + 2E)logn)$ 。 Kruskal 算法如果说Prim算法是小树长成大树的过程，那么Kruskal算法就是拼图的过程。 Prim算法基于点来扩大树，而Kruskal基于边来扩大，具体来说，该算法的过程如下： 将图 $G(V, E)$ 的所有边按权值进行非递减排序。 初始化每个点都为单独的连通分量。（因为此时我们还没有选择边作为最小生成树的一部分） 从后往前检查所有边$(u, v)$ 。 $u$ 和 $v$ 在同一个连通分量里，那么加入 $(u, v)$ 会产生环，因此不能选择。 $u$ 和 $v$ 不在一个连通分量里，那么加入 $(u, v)$ 一定是最优的。如果不加入，形成生成树 $T$ ，把 $(u, v)$ 加入 $T$ 中，会形成环，环中包含 $(u, v)$ 和另外一条权值不小于 $(u, v)$ 的边，我们把这条边用 $(u, v)$ 替换，不会使结果变差，因此 $(u, v)$ 是最优的选择。 因为会考虑所有边，因此一定能构成一颗完整的最小生成树（除非原图不连通）。 在Kruskal算法中，最关键的地方在于“连通”分量的查询和合并，需要知道两个点是否在一个连通分量中，以及如果不是在一个连通分量，需要将其合并，我们可以使用并查集来支持此操作。 123456789101112131415161718192021222324252627282930struct Edge { int u, v, d; // 表示边两端的点以及边权 bool operator &lt; (const Edge &amp; rhs) const { // 重载小于号，支持比较 return d &lt; rhs.d; }}int p[N];Edge edges[M];int n, m;int find (int x) { return p[x] == x ? x : p[x] = find(p[x]); }int kruskal (){ for (int i = 1; i &lt;= n; i ++ ) p[i] = i; sort(edges + 1, edges + m + 1); // 假设边集从1开始存储 int ret = 0, cnt = 0; // cnt表示目前已经选择了多少条边（生成树只需要n-1条边） for (int i = 1; i &lt;= m &amp;&amp; cnt &lt; n - 1; i ++ ) { int u = edges[i].u, v = edges[i].v, d = edges[i].d; u = find(u), v = find(v); if (u == v) continue; ++ cnt, res += d, p[u] = v; } if (cnt != n - 1) return -1; // 原图不连通，没有生成树，何谈最小 return ret;}","categories":[{"name":"图论","slug":"图论","permalink":"https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"生成树","slug":"生成树","permalink":"https://horb7.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-20T01:38:04.000Z","comments":true,"path":"2022/02/16/扩展欧几里得/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"","text":"拓展欧几里得在拓展欧几里得定理之前，先介绍以下贝祖定理： 如果方程式 $ax + by = m$ 成立，那么 $gcd(a, b) | m$ 显然，我们可以把原方程式写作：$m = k1 \\times g \\times x + k2 \\times g \\times y = g(k1 \\times x + k2 \\times y)$ 根据贝祖定理，如果有 $ax + by = 1$ ，那么 $gcd(a, b) = 1$， 即 $a$ 与 $b$ 互质。 我们可以使用著名的辗转相除法算出来 $gcd(a, v=b)$ : 1234int gcd (int a, int b){ return b ? gcd(b, a % b) : a;} 拓展欧几里得给出 $ax + by = m$ ，如何求出他的一组解？ 根据贝祖定理，只要我们求出 $ax + by = gcd(a, b)$ 即可，由于 $gcd(a, b) | m$ ，所以可以求出原式的一组因子，只需要乘上 $m / gcd(a, b)$ 即为原式的一组解。 那么问题就转化为了，求 $ax + by = gcd(a, b)$ 的一组 $(a, b)$ 。 $gcd(a, b)$ 可以用欧几里得辗转相除求出，而 $a, b$ 可以在求的过程中得出。 假设我们到达了终点，此时 $a = gcd(a, b), b = 0$ ，那么有 $x = 1, y = 0$ 。 由于$gcd(a, b)$ 是递归的，当我们想要求得 $ax + by = m$ 时，我们已经求出了 $bx + (a \\% b)y = m$ 的一组解。 $a \\% b = a - \\lfloor \\dfrac a b \\rfloor \\times b$ 把已有的式子化作：$bx + (a - \\lfloor \\dfrac a b \\rfloor \\times b)y = m$ 那么，可以得到：$ay + b(x - \\lfloor \\dfrac a b \\rfloor \\times y) = m$ 所以我们发现，如果从上一层状态推下来，那么：$x = y, y = x - \\lfloor \\dfrac a b \\rfloor \\times y$ Code1234567int exgcd (int a, int b, int &amp; x, int &amp; y){ if (!b) return x = 1, y = 0, a; int r = exgcd(b, a % b, x, y); tie(x, y) = make_tuple(y, x - (a / b) * y); return r;} 由于 $ax + by \\equiv m \\pmod p$ 有无穷多组，而我们只计算出了一种，那么如何得到其他解？ 假设我们得到解为 $x_0, y_0$ ，还有另外一组解为 $x_1, y_1$ ，那么可以得到： $ax_0 + by_0 \\equiv m \\pmod p$ $ax_1 + by_1 \\equiv m \\pmod p$ 两个柿子相减，得到 $a(x_0 - x_1) \\equiv -b(y_0 - y_1) \\pmod p$ 两边同时除以 $gcd(a, b)$ ，有 $a / gcd(a, b) (x_0 - x_1) \\equiv -b / gcd(a, b)(y_0 - y_1) \\pmod p$ 此时 $a / gcd$ 与 $b / gcd$ 互质，所以一定有 $a / gcd(a, b) | (y_0 - y_1), b / gcd(a, b) | (x_0 - x_1)$ 我们记 $x_1 = x_0 + k \\times \\dfrac{b}{gcd(a, b)}$ ，同理 $y_1 = y_0 + k \\times \\dfrac{a}{gcd(a, b)}$ 。 欧几里得用途求逆元 $a \\times a^{-1} \\equiv 1 \\pmod p$ ，可以写成 $a \\times a^{-1} \\equiv kp + 1 \\pmod p$ ， 这样，我们就可以得到柿子 : $a \\times a^{-1} + kp \\equiv 1 \\pmod p$ 。 这就是拓展欧几里得公式，由于 $a, p$ 都已知，只需要用拓展欧几里得算出 $(a^{-1}, k)$ 即可。 注意拓展欧几里得可以计算 $p$ 与 $a$ 非互质情况下的逆元，而欧拉定理不能算出。 计算同余方程组扩展中国剩余定理","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"最近公共祖先","slug":"最近公共祖先","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-19T14:48:26.000Z","comments":true,"path":"2022/02/16/最近公共祖先/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"","text":"最近公共祖先 (LCA)在一个有根树中，两个结点 $a、b$ 都有若干个祖先(本身也是自己的祖先)，他们也会有公共的祖先，距离他们最近，也就是在有根树中深度最大的祖先，被称做 $a、b$ 的最近公共祖先。 求最近公共祖先向上标记法先从一个点开始向上走到根节点，再由另一个结点开始向上走，走到一个已经被标记过的结点，那么这个结点就是这两个点的最近公共祖先。 最坏情况下树为一条链，时间复杂度为 $O(n)$ 。 由于复杂度比较大，因此这个算法不常用。 倍增法倍增法基于二进制拆分，每次都尽可能向上多跳几步。 $\\displaystyle {fa(i, j})$ 表示结点 $i$ 向上走 $2^j$ 次后到达的结点。 $depth(i)$ 表示结点 $i$ 在有根树中的深度。 对于结点 $a 、 b$ ，假设 $depth(a) &lt; depth(b)$ ，我们先把 $a$ 跳到与 $b$ 相同的深度；如果此时 $a == b$ ，那么LCA就是 $y$ ；否则，我们同时让 $a、b$ 向上跳到不是 LCA 的结点，最后跳到的结点的父节点就是 LCA 。 由于每次跳的步数都是 $2$ 的整数次幂，所以时间复杂度为 $O (log n)$ 。 预处理出所有 $fa(i, j)$ 的时间复杂度为 $O (n log n)$ ，所以倍增法适用于多次查询LCA。 例题：洛谷 P3379 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010, M = N &lt;&lt; 1;int n, qus, root;int fa[N][20]; // fa(i, j) 表示i结点向上走 2^j 步到达的结点int depth[N];int q[N]; bool st[N]; // BFSint h[N], e[M], ne[M], idx;void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}void bfs (){ int hh = 0, tt = 0; q[0] = root; st[root] = true; depth[root] = 1; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i] ) { int j = e[i]; if (!st[j]) { st[j] = true; depth[j] = depth[t] + 1; q[++ tt] = j; fa[j][0] = t; // 初始化 fa(i, 0) 为父节点 } } } // 预处理 fa 数组 for (int j = 1; j &lt; 20; ++ j ) for (int i = 1; i &lt;= n; ++ i ) fa[i][j] = fa[fa[i][j-1]][j-1];}// 返回 (a, b) 的lcaint lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); // 保证 a 的深度大于 b // a 跳到与 b 相同深度的结点 for (int i = 19; i &gt;= 0; -- i ) if (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i]; if (a == b) return b; // a == b ，那么 b 就是 lca // 同时跳上面 for (int i = 19; i &gt;= 0; -- i ) if (fa[a][i] != fa[b][i]) { a = fa[a][i]; b = fa[b][i]; } return fa[a][0]; // 此时 a 父节点就算 lca}int main (){ cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root; memset(h, -1, sizeof h); for (int i = 1; i &lt; n; ++ i ) { int x, y; cin &gt;&gt; x &gt;&gt; y; add (x, y); add (y, x); } bfs (); // 求出每个结点的深度及fa数组 while (qus -- ) { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca (x, y) &lt;&lt; endl; } return 0;} Tarjan离线算法Tarjan算法基于深度优先遍历，本质上是对向上标记法的优化。 遍历有根树，给每个结点分为三类。 已经遍历过并且已经回溯的点 正在被遍历的点 还没有被搜索过的点 当一个结点回溯，我们将它合并到它的父节点上，我们可以发现，如果一次查询包括当前正在被遍历的结点和已经回溯的结点，那么他们的 LCA 就是已经回溯的点所在的集合的祖先结点。而合并及查询集合祖先的操作可以使用并查集。 如图，粉色是未被搜索到的点，蓝色是正在被遍历的点，其他都是已经遍历的点(有些未回溯，所以他们处于不同的集合)。 绿色和黄色任意点的LCA都是黄色点集合的祖先结点，其他也是如此。 例题：洛谷 P3379 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010, M = N &lt;&lt; 1;typedef pair&lt;int, int&gt; PII ;int n, qus, root;int p[N];int st[N]; // 记录每个点的状态：1表示正在搜索，2表示已经回溯，0表示还没有搜索到vector&lt;PII&gt; query[N]; // query[i] -&gt; (j, id) 表示在第id个查询中，查询的结点是(i, j)int ans[N]; // 存储每个查询的结果int h[N], e[M], ne[M], idx;void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}int find (int x){ return p[x] == x ? x : p[x] = find(p[x]);}void tarjan (int u){ st[u] = 1; // 正在搜索 u 结点 for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; // 如果还没有遍历，则遍历子结点 if (!st[j]) { tarjan(j); p[j] = u; } // 回溯后记得及时合并到父节点上 } for (auto t : query[u]) { int y = t.first, id = t.second; if (st[y] == 2) ans[id] = find(y); // 如果j已经回溯 } st[u] = 2; // u 结点回溯}int main (){ cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root; memset(h, -1, sizeof h); for (int i = 1; i &lt; n; ++ i ) { int x, y; cin &gt;&gt; x &gt;&gt; y; add (x, y); add (y, x); } for (int i = 1; i &lt;= qus; ++ i ) { int x, y; cin &gt;&gt; x &gt;&gt; y; if (x != y) { query[x].push_back({y, i}); query[y].push_back({x, i}); } } for (int i = 1; i &lt;= n; ++ i ) p[i] = i; tarjan(root); for (int i = 1; i &lt;= n; ++ i ) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"tree","slug":"tree","permalink":"https://horb7.github.io/tags/tree/"}]},{"title":"素数筛","slug":"素数筛","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-19T14:42:36.000Z","comments":true,"path":"2022/02/16/素数筛/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E7%B4%A0%E6%95%B0%E7%AD%9B/","excerpt":"","text":"质数筛选 质数筛选指在一个范围内筛去非质数，留下质数，通常用单独的质数数组保存留下的质数。 埃氏筛对于每个数字(从2开始)，筛去它所有的倍数，那么留下来的一定都是质数。 证：对于任意和数 $x$ ，一定存在一个质因数 $pj$ ，那么我们一定可以用 $pj$ 筛去 $x$ 。 时间复杂度 $O (n log n)$。 证：对于每个数字 $i$ ，内层循环会执行 $n / i$ 次。那么一共执行 n / 2 + n / 3 + ... n / n = n(1 / 2 + 1 / 3 + ... + 1 / n) = n log n次。 12345678bool st[N];int prime[N], cnt;for (int i = 2; i &lt;= n; i ++ ){ if (!st[i]) prime[++ cnt] = i; for (int j = i + i; j &lt;= n; j += i ) st[j] = true;} 我们发现，对于每个和数 $x$ ，假设存在质因数 $pj$ ，那么如果我们用和数 $x$ 来筛去的数字也一定存在质因数 $pj$ ，也就是在 $x$ 之前这些数字就已经被 $pj$ 筛去，不需要再用 $x$ 筛去。 优化版： 12345678for (int i = 2; i &lt;= n; i ++ ){ if (!st[i]) { prime[++ cnt] = i; for (int j = i + i; j &lt;= n; j += i ) st[j] = true; }} 质数定理: $1 \\sim n$ 中大约有 $n \\ / \\ ln \\ n$ 个质数，那么总执行次数大约为 $n log n / log n = n$ ，实际复杂度大约为 $O(n log log n)$。 欧拉筛又称线性筛，每次我们都只用最小质因数来筛去和数 $x$ ，这样就不会重复筛数。因此时间复杂度为 $O(n)$ 。 原理写在代码块中，例题： [洛谷3383]: https://www.luogu.com.cn/problem/P3383 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000010;int n;int prime[N], idx;bool st[N];void init (){ scanf(\"%d\", &amp;n); // O(n) 线性筛 for (int i = 2; i &lt;= n; i ++ ) { // 没有标记，是质数 if (!st[i]) prime[++ idx] = i; /* 由于被筛选的值 k 可能含有多个质因数，会被筛去多次。 我们只用k的最小质因数筛去k，这样每个数字都只会被筛去一次 k = prime[j] * i i是当前数 从小到大枚举所有质数 1. i % prime[j] == 0 prime[j]是i的最小质因数，那么prime[j]一定是k的最小质因数 2. i % prime[j] != 0 prime[j]小于i的任意质因数，那么prime[j]一定也是k的最小质因数 对于每个和数x，一定存在最小质因数pj，那么当我们枚举到x / pj时，就可以把x筛去 */ for (int j = 1; prime[j] &lt;= n / i; j ++ ) { st[i * prime[j]] = true; if (i % prime[j] == 0) break; /* 为什么这里需要break? 假设当前被筛去的数字是 i * pj，由于i是pj的倍数，那么如果继续递增pj，i的最小质因数 一定还是原来的pj，被筛去的数字最小质因数也一定是pj，那么我们再筛的话就会产生重复 */ } }}void solve (){ int k; scanf(\"%d\", &amp;k); printf(\"%d\\n\", prime[k]);}signed main () { init(); int T; scanf(\"%d\", &amp;T); while (T -- ) solve(); return 0;}","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"环形纸牌均分问题","slug":"环形纸牌均分问题","date":"2022-02-16T14:54:28.239Z","updated":"2022-01-03T13:41:30.000Z","comments":true,"path":"2022/02/16/环形纸牌均分问题/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E7%8E%AF%E5%BD%A2%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/","excerpt":"","text":"环形纸牌均分问题 环形纸牌均分是一道很经典的贪心问题，但是每次遇到类似的都想不出来，于是就有了这篇博客记录QAQ。 问题描述有 $n$ 堆纸牌围成环形，每堆纸牌拥有 $a_i$ 个纸牌，第 $i$ 堆纸牌可以顺时针或者逆时针传播一张牌，代价为 $1$ 。问使得每堆牌的牌数数量都相等，需要的最少代价为多少？ $1 \\le n \\le 10^6, 1 \\le a_i \\le 10^9$ 。 分析假设第 $i$ 堆纸牌顺时针传播了 $s_i$ 张纸牌，那么第 $i$ 堆纸牌最终有 $a_i - s_i + s_{i-1}$ 张纸牌。 由于最终纸牌数量都相等，因此有 $\\overline a = \\dfrac {a_1 + a_2 + \\ldots + a_n} n$ 。 那么有 ： \\begin{aligned} &\\overline a = a_1 - s_1 + s_n \\\\ &\\overline a = a_2 - s_2 + s_1 \\\\ &\\overline a = a_3 - s_3 + s_2 \\\\ & \\ldots \\\\ &\\overline a = a_n - s_n + s_{n - 1} \\\\ \\end{aligned}我们把 $s_i$ 提取出来： \\begin{aligned} &s_1 = s_n - (\\overline a - a_1) \\\\ &s_2 = s_1 - (\\overline a - a_2) = s_n - (\\overline a - a_1) - (\\overline a - a_2) = s_n - (2 \\times \\overline a - (a_1 + a_2)) \\\\ &s_2 = s_2 - (\\overline a - a_3) = s_n - (2 \\times \\overline a - (a_1 + a_2)) - (\\overline a - a_3) = s_n - (3 \\times \\overline a - (a_1 + a_2 + a_3)) \\\\ & \\ldots \\\\ &s_n = s_{n} - (n \\times \\overline a - (a_1 + a_2 + \\ldots + a_n)) \\\\ \\end{aligned}题目要我们求得是 $res = \\sum_{i=1}^n |s_i|$ 。 所以 $res = |s_n - (\\overline a - a_1)| + |s_n - (2 \\times \\overline a - (a_1 + a_2))| + \\ldots + |s_n - (\\overline n \\times a - (a_1 + \\ldots a_n))|$ 。 我们令 $x = s_n, \\ i \\times \\overline a - \\sum_{j = 1}^i a_j = c_i$ 。 那么 $res = |x - c_1| + |x - c_2| + |x - c_3| + \\ldots + |x - c_n|$ 。 问题变成了仓库选址问题，选出一个点在数轴上与各点距离和最小，选择中位数即可。 Code123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;const int N = 1000010;int n;ll s[N], c[N];int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; s[i], s[i] += s[i - 1]; // 求前缀和，方便计算c(i) ll A = s[n] / n; // 均值，最后到达的值 for (int i = 1; i &lt;= n; i ++ ) c[i] = i * A - s[i]; nth_element(c + 1, c + (n + 1) / 2, c + n + 1); // 求出中位数 ll x = c[(n + 1) / 2], res = 0; for (int i = 1; i &lt;= n; i ++ ) res += abs(x - c[i]); cout &lt;&lt; res &lt;&lt; endl; return 0;} 例题AcWing122.糖果传递 模板题 AcWing105.七夕祭 排序+环形均分纸牌 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;const int N = 1000010;int n, m, t;int c[N], r[N], pre[N];// 对n个人均分纸牌ll calc (int a[], int n){ int aver = t / n; for (int i = 1; i &lt;= n; i ++ ) pre[i] = pre[i - 1] + a[i] - aver; sort(pre + 1, pre + n + 1); ll ret = 0; for (int i = 1; i &lt;= n; i ++ ) ret = ret + abs(pre[i] - pre[n + 1 &gt;&gt; 1]); return ret;}int main (){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1, x, y; i &lt;= t &amp;&amp; cin &gt;&gt; x &gt;&gt; y; i ++ ) ++ c[x], ++ r[y]; if (t % n == 0 &amp;&amp; t % m == 0) cout &lt;&lt; \"both \" &lt;&lt; calc(c, n) + calc(r, m) &lt;&lt; endl; else if (t % n == 0) cout &lt;&lt; \"row \" &lt;&lt; calc(c, n) &lt;&lt; endl; else if (t % m == 0) cout &lt;&lt; \"column \" &lt;&lt; calc(r, m) &lt;&lt; endl; else cout &lt;&lt; \"impossible\" &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://horb7.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"线段树入门","slug":"线段树入门","date":"2022-02-16T14:54:28.239Z","updated":"2022-02-18T02:04:59.359Z","comments":true,"path":"2022/02/16/线段树入门/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"线段树介绍线段树是一种基于分治思想的二叉树结构，用于在区间上进行高效的信息统计。 如图是一般的线段树结构，我们可以发现： 线段树的每个节点都代表一个区间，且按照深度递增，代表的区间逐渐缩小。 线段树是单独的一棵树，具有唯一的根节点，它代表需要统计信息的整个区间。 线段树的每个叶子节点都代表一个长度为 $1$ 的区间 $[x, x]$ 。 对于每个非叶子结点 $[l, r]$ ，它的左节点为 $[l, mid]$ ，右节点为 $[mid+1, r]$ ，其中 $mid = (l + r) / 2$ 。 如果去除最后一层，那么线段树是一棵完全二叉树，因此我们可以采用与二叉堆类似的存储形式： 根节点编号为 $1$ 。 对于非叶子节点 $p$ ，左节点为 $p \\times 2$ ，右节点为 $p \\times 2 + 1$ 。 需要注意的是，最后一层是不满的，我们需要空出数组的位置来表示空节点。 除去最后一层，由于最后第二层最多有 $n$ 个节点，因此满二叉树需要 $n + \\dfrac n 2 + \\dfrac n 4 + \\ldots + 1 = 2 \\times n - 1$ 个节点。 最后一层需要开 $n \\times 2$ 个节点，因此我们需要至少 $n \\times 4$ 的空间存储，才能保证数组不会越界。 线段树的建树线段树的基本用途是维护序列的某些属性，最基本的线段树具有查询和修改两个功能。给定长度为 $[1, n]$ 的序列，我们可以按 $[1, n]$ 的区间建一棵线段树。线段树基于分治思想，需要从上往下构建。递归完成后也可以方便地从下往上传递信息。 下面以维护区间最大值为例。 1234567891011121314151617181920212223struct seg_tree{ #define lc(p) (p&lt;&lt;1) #define rc(p) (p&lt;&lt;1|1) int l, r; // 节点的信息，维护 [l, r] 区间内的信息 int maxv; // 需要在区间上维护的信息};const int N = 100010; // 假设序列最长长度为 Nseg_tree t[N &lt;&lt; 2];int a[N]; // 原序列void build (int p, int l, int r) // 当前构建的节点及其需要维护的区间{ t[p].l = l, t[p].r = r; if (l == r) { t[p].maxv = a[l]; return; } // 到达叶子节点，不需要再往下创建节点 int mid = l + r &gt;&gt; 1; // 否则创建左节点 [l, mid] 和右节点 [mid+1, r] build(lc(p), l, mid), build(rc(p), mid+1, r); // 构建完后需要维护这个区间的信息，由于已经创建好左节点(左边一半区间)和右节点(右边一半区间)，根据这两个节点来维护 t[p].maxv = max(t[lc(p)].maxv, t[rc(p)].maxv);}build(1, 1, n); // 从根节点1开始，它维护的是整个区间[1, n] 线段树的单点修改利用线段树递归从下往上传递信息的结构，我们也可以很方便地修改某一个元素。 叶子节点代表单个长度的区间，也就是具体的某一个元素。我们可以递归地找到需要修改的叶子节点，在回溯的过程维护它的父节点(代表的区间包括自己的区间，所以也要修改)。 12345678910void modify (int p, int x, int v) // 需要把x位置的元素改为v，目前为p节点{ if (t[p].l == t[p].r) { t[p].maxv = v; return; } // 已经找到 int mid = t[p].l + t[p].r &gt;&gt; 1; // 否则判断去左区间找还是去右区间找 if (x &lt;= mid) modify(lc(p), x, v); // 左区间为[l, mid]，在这个区间内 else modify(rc(p), x, v); // 右区间为[mid+1, r] t[p].maxv = max(t[lc(p)].maxv, t[rc(p)].maxv); // 注意修改完子区间后，当前区间需要维护}modify(1, x, v); // 从根节点开始找 在线段树的单点修改过程中，每一层只会被调用一次，而线段树的高度为 $log n$ ，因此复杂度为 $log n$ 。 线段树区间查询以维护区间最大值的线段树为例，我们查找区间 $[l ,r]$ 的最大值，需要从根节点开始，递归完成： 如果 $[l, r]$ 区间完全覆盖了当前节点的范围，直接返回当前节点维护的信息。 如果左节点和 $[l, r]$ 有交叉，那么递归查询左节点。 如果右节点和 $[l, r]$ 有交叉，那么递归查询右节点。 1234567891011int query (int p, int l, int r) // 需要查询[l, r]的最大值，当前节点为p{ if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].maxv; // 完全覆盖，节点区间内所有元素都是查询区间内的元素 int mid = t[p].l + t[p].r &gt;&gt; 1; // 否则查询左节点和右节点 int maxv = -2e9; // 设为负无穷 if (l &lt;= mid) maxv = max(maxv, query(lc(p), l, r)); // [l, r]与左节点有交叉 if (r &gt; mid) maxv = max(query(rc(p), l, r)); // [l, r]与右节点有交叉 return maxv;}cout &lt;&lt; query(1, l, r) &lt;&lt; endl; // 从根节点开始查询 关于复杂度： 在任意一个节点，只查询它的左节点/右节点。 显然复杂度是 $O(log n)$ 的。 在某些节点，查询左右节点。 在左节点，显然又有两种可能，如果只查询一遍，那么可以保证 $O(log n)$ 的复杂度，如果查询左右两边，那么左边一定是被完全覆盖的，因此可以直接回溯。右节点同理。 所以查询左右节点，本质只是比查询单边多了一次查询，因此复杂度为 $O(2 log n) = O(log n)$ 。 线段树的区间修改假设现在要把 $[l, r]$ 中所有元素加上 $v$ ，一种显然的做法是对 $[l, r]$ 中所有元素执行一次单点修改，但这样的复杂度为 $O(len \\times log n)$ 的，最坏情况下修改所有元素，则需要修改整棵树，复杂度 $O(n)$ 。 可以发现，如果我们对区间 $[l, r]$ 中所有元素进行修改，但后面的查询中没有用到 $[l, r]$ 的子区间 ，那么这个修改是无意义的。也就是说，最好的办法就是在查询时才更新当前的区间 。 类似于区间查找，当我们发现某一个节点维护的区间被需要修改的区间覆盖，那么我们修改完当前节点后，直接回溯，不用对其递归修改，比如修改区间 $[1, 10]$ ，当我们递归到节点 $[1, 5]$ 时，就可以修改并回溯。同时我们要给这个节点打上标记，表示当前节点已经修改，但其子区间未修改。 在之后的查询过程中，如果需要使用其子结点，则使用标记的信息更新两个子结点，同时为子结点打上标记，再清除当前节点的标记。 类似于区间查询，区间修改会将区间划分为 $O(log n)$ 个小区间，将复杂度降为 $O(log n)$ 。 下面以例题 [模板]线段树1 为例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;// 以维护区间和为例struct seg_tree{ #define lc(x) x&lt;&lt;1 #define rc(x) x&lt;&lt;1|1 int l, r; ll sum, add; // sum为[l, r]区间元素的和，add为懒标记，记录当前这个区间，每个元素加了多少};const int N = 100010;seg_tree t[N &lt;&lt; 2];int a[N], n, m;void pushup (int p) // pushup操作：自下而上维护每个节点的sum值{ t[p].sum = t[lc(p)].sum + t[rc(p)].sum;}void pushdown (int p) // pushdown操作：将懒标记下传，将子节点变为真实值{ if (!t[p].add) return ; // 如果当前位置没有懒标记，直接返回 t[lc(p)].sum += t[p].add * (t[lc(p)].r - t[lc(p)].l + 1); // 左节点 t[rc(p)].sum += t[p].add * (t[rc(p)].r - t[rc(p)].l + 1); // 右节点 t[lc(p)].add += t[p].add; // 给左节点加懒标记，注意左节点可能已经加过懒标记 t[rc(p)].add += t[p].add; // 给右节点加懒标记，注意右节点可能已经加过懒标记 t[p].add = 0; // 清除p的懒标记}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; if (l == r) { t[p].sum = a[l]; return; } // 到达叶子节点，此时区间长度为1，sum即为此位置的值 int mid = l + r &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid+1, r); pushup(p); // 使用pushup自下往上维护信息}void modify (int p, int l, int r, int v) // 为[l, r]区间所有数字增加v{ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) // 当前节点被[l, r]区间覆盖 { // 修改当前区间，打上标记并回溯 t[p].sum += (ll)v * (t[p].r - t[p].l + 1); t[p].add += v; return ; } pushdown(p); // 此时这个点的子节点需要使用，将懒标记下传 int mid = t[p].l + t[p].r &gt;&gt; 1; if (l &lt;= mid) modify(lc(p), l, r, v); // 左节点[t[p].l, mid]有部分被覆盖 if (r &gt; mid) modify(rc(p), l, r, v); // 右节点[mid+1, t[p].r]有部分被覆盖 pushup(p); // 子结点被修改，记得维护当前节点}ll query (int p, int l, int r){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].sum; pushdown(p); // 子节点需要使用，记得下传懒标记 int mid = t[p].l + t[p].r &gt;&gt; 1; ll ret = 0; // 当前节点被[l, r]覆盖的元素的和 if (l &lt;= mid) ret += query(lc(p), l, r); // 左节点[t[p].l, mid]有部分被覆盖 if (r &gt; mid) ret += query(rc(p), l, r); // 右节点[mid+1, t[p].r]有部分被覆盖 return ret;}int main (){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; build(1, 1, n); // 在区间[1, n]上建立线段树 while(m -- ) { int op, l, r, v; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 1) cin &gt;&gt; v, modify(1, l, r, v); else cout &lt;&lt; query(1, l, r) &lt;&lt; endl; } return 0;} 例题 一个简单的整数问题 可以使用树状数组 一个简单的整数问题2 区间加，区间和 进制 维护所有进制 你能回答这些问题吗 比较难的题目，需要维护较多信息 区间最大公约数 更损相减法","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Edu Codeforces Round 121","slug":"Edu-Codeforces-Round-121","date":"2022-02-16T14:54:28.238Z","updated":"2022-01-17T03:11:12.000Z","comments":true,"path":"2022/02/16/Edu-Codeforces-Round-121/","link":"","permalink":"https://horb7.github.io/2022/02/16/Edu-Codeforces-Round-121/","excerpt":"","text":"Edu Codeforces Round 121C. Monsters And Spells题意有 $n$ 只怪物需要被消灭，第 $i$ 只怪物在 $k_i$ 秒出现，有 $h_i$ 点生命值 ，必须在怪物出现的那一秒消灭他。 Monocarp 每秒可以使用一次法咒，可以选择法咒伤害为 $x + 1$ 或 $1$ ，$x$ 为上一秒使用法咒造成的伤害。 使用伤害为 $x$ 的法咒，会消耗 $x$ 点法力值。 问Monocarp至少需要消耗多少法力值才能消灭 $n$ 只怪物。 分析对于第 $i$ 只怪物，需要使用法咒的区间为 $[k_i - h_i + 1, k_i]$ 。也就是至少要从 $k_i - h_i + 1$ 位置开始使用法咒。 这个区间可能会有重复，比如两只怪物的区间为 $[l_1, r_1]$ 和 $[l_2, r_2]$ 。其中 $l_1 \\le l_2 \\le r_1$ 。 那么对于区间 $[l_2, r_2]$ 的怪物，我们需要从 $l_1$ 开始使用法咒，否则不能消灭第一只怪物。 也就是说消灭这两只怪物的区间为两个区间的合并，即 $[l_1, r_2]$ 。 推广到所有怪物，只需要把他们的区间合并即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i++)#define forr(x, s) for (auto x : s)#define all(a) begin(a), end(a)#define pb emplace_backusing namespace std;using T = pair&lt;int, int&gt;;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; k(n), h(n); forr(&amp;x, k) cin &gt;&gt; x; forr(&amp;x, h) cin &gt;&gt; x; vector&lt;T&gt; v, f; // v存储所有怪物的区间，f存储合并后的区间 rep(i, 0, n-1) v.pb(k[i] - h[i] + 1, k[i]); sort(all(v)); int ret = 0; // 合并区间 for (auto &amp; [x, y] : v) { if (f.empty() || f.back().second &lt; x) f.pb(x, y); else f.back().second = max(f.back().second, y); } for (auto &amp; [x, y] : f) { int cost = y - x + 1; ret += (1 + cost) * cost / 2; } cout &lt;&lt; ret &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} D. Martial Arts Tournament题意有 $n$ 个参赛选手，第 $i$ 个选手体重为 $a_i$ ，现在要根据选手的体重分为三个赛区，轻量、中量、重量区。 选择两个标准 $x, y$ ，所有严格小于 $x$ 重量的选手在轻量赛区，所有不小于 $y$ 重量的选手在重量赛区。 现在要使三个赛区的选手数量为 $2$ 的幂，请问至少需要加多少选手？ 分析前缀和思想，令 $f(x)$ 表示轻量赛区需要 $x$ 个人，实际上有多少人(因为间断点左右不能重量相同) 。同理 $g(x)$ 表示重量赛区需要 $x$ 个人，实际上有多少人。 枚举 $f(x)$ 和 $g(y)$ 中的 $x$ 和 $y$ 都为 $2$ 的幂次的情况，求出中量赛区需要多少人，加起来就是总共需要的人数，取最小值即可。 Code12345678910111213141516171819202122232425262728293031323334/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i++)#define per(i, x, y) for (int i = x; i &gt;= y; i--)using namespace std;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n+1), f(n+1), g(n+1); rep(i, 1, n) { int x; cin &gt;&gt; x; ++ a[x]; } int s = 0; // rep(i, 1, n) 枚举重量，s维护前缀和(人数) // 第二个循环rep(j, s, s + a[i] - 1) 其实是枚举中间的间断点，此时应该还是s，不能累加上自己，因为间断点左右不能重量相同。 rep(i, 1, n) { rep(j, s, s + a[i] - 1) f[j] = s; s += a[i]; } s = 0; per(i, n, 1) { rep(j, s, s + a[i] - 1) g[j] = s; s += a[i]; } int ret = 1e9; for (int a = 1; a &lt;= n; a &lt;&lt;= 1) for (int b = 1; b &lt;= n; b &lt;&lt;= 1) { int x = f[a], y = g[b]; int ans = 1; while(ans &lt; n - x - y) ans &lt;&lt;= 1; ret = min(ret, ans + a + b); } cout &lt;&lt; ret - n &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Linux下使用C++连接MySql","slug":"Linux下MySql的使用","date":"2022-02-16T14:54:28.238Z","updated":"2022-01-07T04:36:20.000Z","comments":true,"path":"2022/02/16/Linux下MySql的使用/","link":"","permalink":"https://horb7.github.io/2022/02/16/Linux%E4%B8%8BMySql%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装MySql在Ubuntu 20.04环境下，我们已经安装好MySql，如果想要用C++连接MySql，我们还需要mysql-client，完整的需要以下几项： sudo apt-get install mysql-server sudo apt-get install apache2 sudo apt-get install libmysqlclient-dev 安装后，检查/usr/include/mysql中是否存在mysql.h文件： 如果存在，说明安装成功，可以用C++连接MySql数据库了。 使用C++连接MySql相关API介绍在cpp文件中，我们需要引入mysql.h头文件来使用MySql相关API。 这里列出常用的函数。（注：MYSQL为结构体，存储mysql操作的处理） 函数 说明 MYSQL * mysql_init(MYSQL * mysql) 初始化MYSQL结构体，参数为NULL指针则分配+初始化 MYSQL * mysql_real_connect(MYSQL * mysql, const char * host, const char * user, const char * passwd, const char * db, unsigned int port, const char * unix_socket, unsigned long client_flag) 把mysql结构体连接到具体的服务器的某个用户上，返回非0表示连接成功 int mysql_query(MYSQL * mysql, const char * stmt_str) 执行SQL查询，若成功查询返回0，否则返回1 MYSQL_RES * mysql_store_result(MYSQL * mysql) 存储上次查询的所有结果 int mysql_next_result(MYSQL * mysql) 查看是否存在下一个结果集（一次查询可能返回多个表）并把指针放到下一个表便于查询。返回0表示存在，非0表示不存在。 unsigned int mysql_num_fields(MYSQL_RES * result) 返回结果集的列数 unsigned int mysql_num_rows(MYSQL_RES * result) 返回结果集的行数 MYSQL_ROW mysql_fetch_row(MYSQL_RES * result) 从结果集中返回下一行数据，NULL表示结束 MYSQL_FIELD mysql_fetch_field(MYSQL_RES * result) 从结果集中返回下一列数据，NULL表示结束 char * mysql_error(MYSQL * mysql) 返回上一次的报错信息 void mysql_free_result(MYSQL_RES * result) 释放结果集所占的内存 void mysql_close(MYSQL * mysql) 关闭结构体对数据库的连接 C++连接MqSql基本流程 使用mysql_init()初始化结构体 使用mysql_real_connect()建立结构体与对应数据库的连接 使用mysql_query()进行相关的数据操作 输出查询： 使用res = mysql_store_result(mysql)来获取查询的结果集 使用mysql_num_rows(res)获取行数，mysql_num_fields(res)获取列数 不断通过mysql_fetch_row(res)来获取每一行的查询数据，直到结束 释放结果集所占的内存mysql_free_result(res) mysql_close(mysql)关闭结构体与数据库的连接 注意点：由于我们使用的不是C++原有的库，所以在编译的时候要指明额外使用的库 编译命令：g++ test.cpp -o main -I/usr/include/mysql -lmysqlclient 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;mysql.h&gt;#include &lt;ctime&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define HOST \"*******\" // 此处为你的服务器ip地址，如果为本地则输入localhost#define USERNAME \"*****\" // 服务器用户名#define PASSWORD \"******\" // 用户名对应的密码#define DATABASE \"*******\" // 需要使用的数据库名字using namespace std;void operator_sql(const char * sql);void query_sql(const char * sql);int main (int argc, char * argv[]){ const char * sql_operator = \"insert into student(class, sid, sname) values('cs2001', 111111111, 'i_dont_know')\"; const char * sql_query = \"call attend_exam(1)\"; printf(\"sql_operator: %s\\n\", sql_operator); printf(\"sql_query: %s\\n\", sql_query); // operator_sql(sql_operator); query_sql(sql_query); return 0;}void operator_sql(const char * sql){ MYSQL conn; int res; mysql_init(&amp;conn); if (mysql_real_connect(&amp;conn, HOST, USERNAME, PASSWORD, DATABASE, 0, NULL, CLIENT_FOUND_ROWS)) { printf(\"connect success!\\n\"); res = mysql_query(&amp;conn, sql); if (res) printf(\"%s\\n\", mysql_error(&amp;conn)); // 如果执行不成功，输出报错信息 else printf(\"operator success!\\n\"); } mysql_close(&amp;conn);}void query_sql(const char * sql){ MYSQL my_connection; // 数据库连接 int res; // 执行sql语句后的返回标志 MYSQL_RES * res_ptr; // 指向查询结果的指针 MYSQL_FIELD * field; // 字段结构指针 MYSQL_ROW result_row; // 按行返回的查询信息 int row, column; // 查询返回的行数和列数 mysql_init(&amp;my_connection); // 初始化mysql连接my_connection if (mysql_real_connect(&amp;my_connection, HOST, USERNAME, PASSWORD, DATABASE, 0, NULL, CLIENT_FOUND_ROWS)) { printf(\"connectio success!\\n\"); // 设置查询编码为utf8 mysql_query(&amp;my_connection, \"set names utf8\"); res = mysql_query(&amp;my_connection, sql); // 查询，返回0代表成功 if (res) printf(\"Error: mysql_query!\\n\"); else { // 执行成功 printf(\"query some row\\n\"); int tables = 0; // 把返回信息的所有表都输出 do { printf(\"\\n\"); res_ptr = mysql_store_result(&amp;my_connection); if (res_ptr) // 结果不为空，说明有结果 { column = mysql_num_fields(res_ptr); // 此表的列数 row = mysql_num_rows(res_ptr); // 此表的行数 printf(\"查询到第 %d 行, 此为第 %d 张表\\n\", row + 1, ++ tables); // 输出每一列的属性 for (int i = 0; field = mysql_fetch_field(res_ptr); i ++ ) printf(\"%s\\t\", field-&gt;name); printf(\"\\n\"); while(result_row = mysql_fetch_row(res_ptr)) { for (int j = 0; j &lt; column; j ++ ) printf(\"%s\\t\", result_row[j]); printf(\"\\n\"); } } else mysql_free_result(res_ptr); // 如果以及查询完毕，则释放查询结果占用的内存 } while(!mysql_next_result(&amp;my_connection)); // 返回0则代表还有剩余的结果 } mysql_close(&amp;my_connection); // 查询结束，关闭结构体与数据库的连接 }}","categories":[{"name":"数据库","slug":"数据库","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://horb7.github.io/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"https://horb7.github.io/tags/MySql/"}]},{"title":"MySql安装与简单配置","slug":"MySql的安装和简单配置","date":"2022-02-16T14:54:28.238Z","updated":"2022-01-07T11:58:48.000Z","comments":true,"path":"2022/02/16/MySql的安装和简单配置/","link":"","permalink":"https://horb7.github.io/2022/02/16/MySql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Mysql 安装和配置纯小白开始用 mysql ，记录一下安装与配置的环节，便于以后查看。下文的 mysql 版本均为 $8.0$。 Linux版本为Ubuntu 20.04。 安装在Ubuntu 20.04上，默认情况只有最新版本的mysql包含在apt存储库里，所以要先更新服务器的软件包索引： sudo apt update 接下来安装mysql默认包。 sudo apt install mysql-server 安装完mysql后，它默认是启动的。 配置mysql初始化数据目录mysql安装完毕后，数据目录必须初始化，使用 sudo mysql_secure_installation 来自动初始化数据目录。 之后需要对mysql安装的安全选项做一些修改。 是否安装验证密码插件，用来测试mysql密码的强度。 为mysql root用户设置密码，然后确认。 之后的提示可以按 $enter$ 使用默认值。 修改用户身份验证和使用权限在 mysql8.0 中，mysql root 用户设置为使用默认的 auth_socket 插件进行身份验证，而不是密码。如果要使用外部程序来访问用户，操作会变得繁琐。 我们可以把身份验证修改为使用密码验证。即把 $auth\\_socket$ 变成 $mysql \\_ native \\_ password$ 模式。 首先进入到mysql里，sudo mysql 接下来我们可以查看mysql用户的账号使用的身份验证方式。 SELECT user, plugin, host FROM mysql.user; 由于我这里已经设置了，所以是 $mysql \\_ native \\_ password$ 模式。 我们可以使用 $ALTER \\ \\ USER$ 命令修改root用户。注意要把 $password$ 设置为选择的密码规范（满足一定强度）。 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password by 'password'; ，这里$password$ 填入你需要更改的密码。 然后需要使用 FLUSH PRIVILEGES; 来使服务器重新加载授权表并使新更改生效。 之后我们可以再次使用 SELECT user, plugin, host FROM mysql.user; 来验证是否修改了root 用户的登陆模式。 注意，如果使用了密码登录，我们可以使用 mysql -u root -p 这样的方式来访问mysql root用户。 如何更改密码规范？在我们设置密码的时候可能会出现 “mysql: Your password does not satisfy the current policy requirements” 这样的错误，这是因为密码规范比较高，而你设置的密码太简单。 如果要设置简单一点的密码，我们需要更改密码规范： 使用 show variables like 'validate_password%' 来查看当前的密码规范。 $policy$ 表示当前密码规范强度（有 $LOW$, $MEDIUM$, $HIGH$ 三种强度）。 $length$ 表示密码至少需要多少长度。 我们可以对这两个属性进行设置： set global validate_password.policy=0; set global validate_password.length=1; 接下来我们再次使用 $ALTER \\ \\ USER$ 命令即可更改用户密码。 修改用户或添加权限查看用户如果要查看用户比较少的属性，可以直接使用 use mysql; SELECT user, host FROM mysql.user 来查询。 创建新用户CREATE USER 'user_name'@'host' IDENTIFIED BY 'password' 其中： user_name 是你创建出来的用户的用户名。 host 表示这个新创建的用户登录模式，$localhost$ 表示只能从本服务器登录，$\\%$ 表示可以从远程登录。 password 为新用户的密码，可以不填。 授权用户GRANT privileges ON databasename.tablename TO 'username'@'host' 查看用户权限：SHOW GRANTS FOR USER%host 其中： privileges 表示赋予的权利，如 select，update，insert，delete等，如果要赋予全部权力，可以使用ALL。 databasename.tablename 表示某个数据库的某个表，如果可以对任意数据库的任意表做操作，可以使用 *.* 。 username@host 表示某一个用户。 撤销用户权限REVOKE privileges ON dataname.tablename FROM 'username'@'host' 撤销操作的注意点撤销语句必须和之前的授权语句一模一样，否则无法撤销权限。 删除用户DROP USER 'username'@'host' 修改用户RENAME USER 'name1'@'host1' TO 'name2'@'host2'","categories":[{"name":"数据库","slug":"数据库","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://horb7.github.io/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"https://horb7.github.io/tags/MySql/"}]},{"title":"Manacher算法","slug":"Manacher算法","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-23T09:31:26.000Z","comments":true,"path":"2022/02/16/Manacher算法/","link":"","permalink":"https://horb7.github.io/2022/02/16/Manacher%E7%AE%97%E6%B3%95/","excerpt":"","text":"Manacher算法Manacher是一种处理字符串最长回文子串的算法，由Manacher于1975年发明。 Manacher算法与KMP思想类似，都是反复对以往已经处理过的信息的再次运用，以达到减少重复计算的目的。 在朴素算法中，我们枚举了每个中心点 $i$​​ 的位置，并从中心点由0不断增长，求出以 $i$​ 为中心点时的最长回文串，而Manacher正是对此的优化。 首先，回文串有奇偶之分，在朴素算法中需要分别处理，我们可以直接在每个字符前后加一个字符串中不出现的字符(‘#’)，这样所有的回文串都变成了奇回文串，同时为了处理越界问题，需要在整个字符串前后加两个不同的字符(可以是’@’和’^’等)。 ==”abac” —&gt;”@#a#b#a#c#^”== 我们用 $p[i]$​​ ​表示以 $i$​​​​ 为中心点时的最大回文半径，即，对于上述例子，$p[4] = 4(b作为中心点)$​ 。​ 假设我们正在处理以第 $i+1$ 为中心点的字符串，如果前 $i$ 个字符串中，第 $j$ 个字符串向右延伸地最长，为maxRange，存在下列两种情况： $i+1&lt;maxRange$​​ ，那么，根据回文串的对称性，在 $i+1$​​ 关于$j$​​对称的地方$(记作k)$​，$s[i] == s[k]$，我们可以用之前计算的 $k$ 来​​给 $i$ 赋一个初值。​ $i+1&gt;=maxRange$​，直接记第 $i+1$​ 位初始值为1即可。 Code 1234567891011121314ss[0] = '@'; ss[++len] = '#';for (int i = 0; s[i]; i++){ ss[++len] = s[i]; ss[++len] = '#';}ss[++len] = '^';for (int i = 1; i &lt;= len; i++){ if (maxRange &gt; i) p[i] = min(maxRange - i, p[2 * id - i]); else p[i] = 1; while (s[i + p[i]] == s[i - p[i]]) p[i] ++ ; if (i + p[i] &gt; maxRange) maxRange = i + p[i], id = i;} Manacher算法的时间复杂度时间复杂度为 $O(n)$，朴素算法时间复杂度为 $O(n^2)$。 时间复杂度证明：首先外层循环复杂度是 $O(n)$​ 的，只需要证明内层while循环总次数为 $O(n)$​ 级别即可。对于每个中心点，如果它向右拓展了 $k$​ 次，那么对于后面的 $k$​ 个数字，每个都可以少拓展一次(赋初值)，while总循环次数为 $O(n)$​。所以总复杂度为 $O(n)$​。 例题链接: https://www.acwing.com/problem/content/description/1526/ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int N = 1010;string s;char ss[N &lt;&lt; 1];int p[N &lt;&lt; 1], len;int main (){ getline(cin, s); ss[0] = '@'; ss[++len] = '#'; for (int i = 0; i &lt; s.length(); i++) { ss[++len] = s[i]; ss[++len] = '#'; } ss[++len] = '^'; int maxRange = -1, id = 0; for (int i = 1; i &lt;= len; i++) { if (maxRange &gt; i) p[i] = min(maxRange - i, p[2 * id - i]); else p[i] = 1; while (ss[i + p[i]] == ss[i - p[i]]) p[i]++; if (i + p[i] &gt; maxRange) maxRange = i + p[i], id = i; } int res = 0; for (int i = 1; i &lt;= len; i++) res = max(res, p[i] - 1); // id仅仅是拓展到最右边的位置，这个maxRange受到 i和p[i]共同影响，不能直接用p[id]-1作为结果 cout &lt;&lt; res &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://horb7.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"NOIP2008传球游戏","slug":"NOIP2008传球游戏","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-19T15:09:44.000Z","comments":true,"path":"2022/02/16/NOIP2008传球游戏/","link":"","permalink":"https://horb7.github.io/2022/02/16/NOIP2008%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F/","excerpt":"","text":"NOIP2008 传球游戏题意有 $n$ 个同学围成一个圆圈，有一个球在某一个小蛮手中，每次传球可以向左右传球，问有多少种方案能够使得进行 $m$ 次传球后依然在小蛮手中。 分析每一轮，拿到球的同学都可以向左右传球。 设 $f(i, j)$ 表示第 $i$ 次传球后小球在 $j$ 同学手中的方案数量。注意环形。 Code12345678910111213141516#include &lt;iostream&gt;using namespace std;const int N = 35;int f[N][N]; // f(i, j)表示穿了i次传到j手里的方案数int main (){ int n, m; cin &gt;&gt; n &gt;&gt; m; f[0][1] = 1; for (int i = 1; i &lt;= m; i ++ ) for (int j = 1; j &lt;= n; j ++ ) f[i][j] = f[i-1][j==1?n:j-1] + f[i-1][j==n?1:j+1]; cout &lt;&lt; f[m][1] &lt;&lt; endl; return 0;}","categories":[{"name":"DP","slug":"DP","permalink":"https://horb7.github.io/categories/DP/"}],"tags":[{"name":"环形DP","slug":"环形DP","permalink":"https://horb7.github.io/tags/%E7%8E%AF%E5%BD%A2DP/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-19T08:17:12.000Z","comments":true,"path":"2022/02/16/hello-world/","link":"","permalink":"https://horb7.github.io/2022/02/16/hello-world/","excerpt":"","text":"花了一整天总算是弄好了…","categories":[],"tags":[]},{"title":"zkw树","slug":"zkw树","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-31T02:58:40.000Z","comments":true,"path":"2022/02/16/zkw树/","link":"","permalink":"https://horb7.github.io/2022/02/16/zkw%E6%A0%91/","excerpt":"","text":"zkw树zkw树，又称非递归线段树，它是一种采用自底向上构造的线段树，由于没有递归且全程使用位运算，因此它是一种代码短，常数小且容易调试的线段树写法。 为了方便调写，我们令原序列 $a$ 下标为 $[0, n)$ ，而zkw树下标（根节点）从 $1$ 开始。 zkw树原理zkw树本质是把序列化成一颗满二叉树，然后就可以采用二叉树的性质来自底向上构造线段树。比如当序列长度为 $8$ 时： 满二叉树的叶子结点编号十分有规律，假设序列长度为 $n$ ，第 $i$ 个叶子结点代表的就是 $a[i]$ ，且叶子编号为 $x + n$ 。不仅如此，满二叉树还有如下性质： 整棵树一共有 $2 \\times n - 1$ 个节点，其中最后一层有 $n$ 个节点，也就是我们的原序列。 若某节点编号为 $p$ ，那么它的父节点为 $p / 2$ ，左孩子为 $p \\times 2$ ，右孩子为 $p \\times 2 + 1$ 。 所有的兄弟节点 $p, q$ 满足 $p \\bigoplus q == 1$ 。（二进制下仅有最后一位不同） 除根节点外，编号为偶数的节点都是左兄弟，编号为奇数的都是右孩子。 根据性质 $1$ ，要构造这样一颗树，需要序列长度 $n$ 为二的整数次幂，如果不足，在后面补 $0$ 即可。 设 $N$ 为满足 $N$ 为二的整数次幂且 $N \\ge n$ 的最小整数。 那么，我们zkw树数组中，$[N, N + n - 1]$ 便是原序列（叶子节点）。 于是，我们有了十分简单的建树代码（假设目前需要维护区间和）： 12345void build (){ for (int i = 0; i &lt; n; i ++ ) t[i + N] = a[i]; // 先构造叶子节点 for (int i = N - 1; i; -- i) t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1]; // 自下而上构造} 对于单点修改，我们可以直接更新，然后往上更新父节点。 1234void update(int x, int v){ for (x += N; x; x &gt;&gt;= 1) tree[x] += v;} 是不是觉得很像堆？没错，zkw和堆本质都是二叉树。 对于区间查询，我们把 $[l, r]$ 的查询变为 $(l-1, r+1)$ 的查询，然后从下往上缩小范围。 1234567891011121314int query(int l, int r){ int ans = 0; // 结束条件是l,r为兄弟，也就是中间没有查询的元素 for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) { /* 每次上移的过程，其实是不断把端点和它的兄弟排出区间的过程 因此如果它的兄弟为区间查询的值，应该加上去 */ // 如果左端点是左儿子或右端点是右儿子，那么它的兄弟应该是答案的一部分。 if (~l &amp; 1) ans += t[l ^ 1]; // 左端点是左儿子 if (r &amp; 1) ans += t[r ^ 1]; // 右端点是右儿子 } return ans;} 对于 区间修改 ，因为没有使用递归，因此直接下传懒标记是比较麻烦的，因为树的修改是自底向上的。 比较好的方式是对标记进行永久化存储。 123456789101112void update (int l, int r, int d){ int len = 1, cntl = 0, cntr = 0; // len表示结点表示的区间长度，cntl,cntr表示左右两边实际修改的长度 for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { t[l] += cntl * d, t[r] += cntr * d; // mark(i) 表示以i为根的树，除了根节点，每个节点都需要加上 mark(i) if (~l &amp; 1) t[l ^ 1] += d * len, mark[l ^ 1] += d, cntl += len; if (r &amp; 1) t[r ^ 1] += d * len, mark[r ^ 1] += d, cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) t[l] += cntl * d, t[r] += cntr * d;} 在有懒标记的情况下，区间查询也要考虑懒标记。除了端点的兄弟需要考虑，在路径上遇到的标记也对答案有贡献，贡献依赖于实际查询的长度。 123456789101112int query (int l, int r){ int ans = 0, len = 1, cntl = 0, cntr = 0; for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { ans += cntl * mark[l] + cntr * mark[r]; if (~l &amp; 1) ans += t[l ^ 1], cntl += len; if (r &amp; 1) ans += t[r ^ 1], cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) ans += cntl * mark[l] + cntr * mark[r]; return ans;} 例题例题 线段树模板 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int M = 200010;int n, m, N;int a[M], t[M &lt;&lt; 1], mark[M &lt;&lt; 1];void build (){ for (int i = 0; i &lt; n; i ++ ) t[i + N] = a[i]; for (int i = N - 1; i; -- i) t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1];}void update (int l, int r, int d){ int len = 1, cntl = 0, cntr = 0; // len表示结点表示的区间长度，cntl,cntr表示左右两边实际修改的长度 for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { t[l] += cntl * d, t[r] += cntr * d; if (~l &amp; 1) t[l ^ 1] += d * len, mark[l ^ 1] += d, cntl += len; if (r &amp; 1) t[r ^ 1] += d * len, mark[r ^ 1] += d, cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) t[l] += cntl * d, t[r] += cntr * d;}int query (int l, int r){ int ans = 0, len = 1, cntl = 0, cntr = 0; for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { ans += cntl * mark[l] + cntr * mark[r]; if (~l &amp; 1) ans += t[l ^ 1], cntl += len; if (r &amp; 1) ans += t[r ^ 1], cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) ans += cntl * mark[l] + cntr * mark[r]; return ans;}signed main (){ cin &gt;&gt; n &gt;&gt; m; for (N = 1; N &lt; n; N &lt;&lt;= 1); for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; build(); int op, l, r, d; while(m -- , cin &gt;&gt; op &gt;&gt; l &gt;&gt; r) { -- l, -- r; if (op == 1) cin &gt;&gt; d, update(l, r, d); else cout &lt;&lt; query(l, r) &lt;&lt; endl; } return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://horb7.github.io/tags/%E6%A0%91/"}]},{"title":"乘法逆元","slug":"乘法逆元","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-21T16:02:22.000Z","comments":true,"path":"2022/02/16/乘法逆元/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/","excerpt":"","text":"乘法逆元 乘法逆元可以求出 $ \\displaystyle {\\frac {a}{b}} $ 在取模 $P$ 的意义下的数值。 逆元 若 $a \\times x \\equiv 1 \\pmod q$ ，且 $a$ 与 $b$ 互质，那么我们定义： $x$ 为 $a$ 的逆元，记作 $a^{-1}$ ，也可以称 $x$ 为 $a$ 在 $ \\pmod p$ 意义下的倒数。 对于 $\\displaystyle {\\frac {a} {b}} \\pmod p$ ，它的值为 $a \\times b^{-1} \\ \\ mod \\ \\ p$ 。 求解逆元快速幂 费马小定理 若 $p$ 为素数，$a$ 为正整数，且 $a、p$ 互质。则有 $a^{p-1} \\equiv 1 \\pmod p$ 。 若 $x$ 为 $a$ 的逆元，则: \\begin{aligned} a \\times x &\\equiv 1 \\pmod p \\\\ a \\times x &\\equiv a^{p-1} \\pmod p \\\\ x &\\equiv a^{p-2} \\pmod p \\end{aligned}所以我们可以使用快速幂求出 $a^{p-2} \\pmod p$ 的值，即为 $a$ 的逆元。 1234567891011int qmi (int a, int k, int mod){ int res = 1; while (k) { if (k &amp; 1) res = 1ll * a * res % mod; a = 1ll * a * a % mod; k &gt;&gt;= 1; } return res;} 拓展欧几里得在模数不为质数时，不能使用费马小定理，但是可以使用拓展欧几里得求逆元，参考此处。 线性算法线性算法可以求出连续数字 $1 \\sim n$ 对于 $\\pmod p$ 的逆元。 首先有 $1^{-1} \\equiv 1 \\pmod p$。 假设现在要求 $i$ 的逆元，显然 $p = \\lfloor{\\dfrac p i}\\rfloor \\times i + p \\% i$ 。 那么，在模 $p$ 的情况下： p = \\lfloor{\\dfrac p i}\\rfloor \\times i + p \\% i \\equiv 0 \\pmod p \\begin{equation} \\begin{split} \\lfloor{\\dfrac p i}\\rfloor \\times i &\\equiv -(p \\% i) \\pmod p \\\\ \\lfloor{\\dfrac p i}\\rfloor \\times -(p \\% i)^{-1} &\\equiv i^{-1} \\pmod p \\\\ i^{-1} &\\equiv -\\lfloor{\\dfrac p i}\\rfloor \\times (p \\% i)^{-1} \\pmod p \\\\ \\end{split} \\end{equation}注意到 $p \\% i$ 一定是小于 $i$ 的，这样我们就可以从前面推出后面了。 时间复杂度：$ O(n) $ 123inv[1] = 1;for (int i = 2; i &lt;= n; i ++ ) inv[i] = (p - p / i) * inv[p % i] % p; // 取模意义下 -a = p - a 阶乘逆元根据阶乘递推关系： \\begin{split} inv[i+1] &= \\displaystyle {\\frac{1}{(i+1)!}} \\\\ inv[i+1] \\times (i + 1) &= \\displaystyle {\\frac{1}{i!}} \\end{split}所以我们也可以先求出 $n!$ 的逆元，再逆推，就可以得到 $1! \\sim n!$ 的逆元。 递推式： $inv[i+1] \\times (i+1) = inv[i]$ 最后可以使用 $\\displaystyle {\\frac{1}{i!}} \\times (i-1)! = \\frac{1}{i}$ 。 时间复杂度为 $O(n)$ 。","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"对顶堆","slug":"对顶堆","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-26T15:45:04.000Z","comments":true,"path":"2022/02/16/对顶堆/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%AF%B9%E9%A1%B6%E5%A0%86/","excerpt":"","text":"对顶堆什么是对顶堆对顶堆是一种数据结构，它可以动态地维护某一个临界值，如前 $i$ 个数字的中位数、 前 $i$ 个数字中第 $k$ 小的值等。 对顶堆一般适用一个大根堆维护前面某个状态，小根堆维护后面不同的状态（如大于/小于中位数等）。 我们只需要调整两个堆的元素数量，即可 $O(1)$ 地取出需要维护的值。 例题动态中位数题意每次插入一个数字，当序列中数字数量为奇数时，输出序列的中位数。 分析假设当前序列长度为 $n$ 。 开一个大根堆来维护当前序列中前 $[1, n / 2]$ 小的元素，再开一个小根堆来维护当前序列前 $[n/2+1, n]$ 小的元素。 那么我们只需要维护大根堆的数量为 $n/2$ ，即可知道当前序列的中位数为小根堆的堆顶。 注意大根堆的所有元素一定比小根堆任意元素小。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int T; cin &gt;&gt; T; while( T -- ) { int id, n, cnt = 0; cin &gt;&gt; id &gt;&gt; n; cout &lt;&lt; id &lt;&lt; ' ' &lt;&lt; (n + 1) / 2 &lt;&lt; endl; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; lt; // 小根堆 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; gt; // 大根堆 for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) { if (gt.size() &amp;&amp; x &lt;= gt.top()) gt.push(x); else lt.push(x); if (i &amp; 1) { while(gt.size() &lt; i / 2) gt.push(lt.top()), lt.pop(); while(gt.size() &gt; i / 2) lt.push(gt.top()), gt.pop(); cout &lt;&lt; lt.top() &lt;&lt; \" \\n\"[((cnt += 1) %= 10) == 0]; } } if (cnt) cout &lt;&lt; endl; } return 0;} 黑匣子题意有两种操作： 向序列中插入一个数字。 求出序列中第 $k$ 小的数字。 $k$ 初始为 $0$ ，每次求第 $k$ 小值都要把 $k$ 加一。 分析对顶堆，大根堆维护前 $k-1$ 小的数字，小根堆维护后面的数字。这样小根堆的堆顶就是第 $k$ 小的数字。 每次插入操作都至多交换一次堆元素，我们可以放到查询的时候再维护堆的数字，次数与每次操作维护是一样的。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int a[N], q[N], k;void solve (){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i ++ ) cin &gt;&gt; q[i]; int pos = 1; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pre; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; post; for (int i = 1; i &lt;= n; i ++ ) { if (post.empty() || a[i] &lt; post.top()) pre.push(a[i]); else post.push(a[i]); // 维护post堆顶为k小数 while (q[pos] == i) { ++ k; while(pre.size() &lt; k) pre.push(post.top()), post.pop(); while(pre.size() &gt;= k) post.push(pre.top()), pre.pop(); cout &lt;&lt; post.top() &lt;&lt; endl; pos ++ ; } }}signed main (){ cout.tie(0)-&gt;sync_with_stdio(false); // int _; for (cin &gt;&gt; _; _ --; ) solve(); solve(); return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://horb7.github.io/tags/%E5%A0%86/"}]},{"title":"并查集入门","slug":"并查集","date":"2022-02-16T14:54:28.238Z","updated":"2022-02-18T02:08:49.034Z","comments":true,"path":"2022/02/16/并查集/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集介绍 并查集是一种树形的数据结构，我们可以使用它来进行集合上的合并与查询等问题。具体来说，它支持两种操作： 合并：将两个集合合并成一个集合。 查询：确定某个元素处于哪个集合。 如图，$\\{3, 1, 2, 4, 0, 10\\}$ 表示一个集合，$\\{5, 7, 8, 11\\}$ 表示另一组集合。 可以看出并查集是多叉树结构，我们用根节点来表示这个根节点所在的集合(即根节点作为集合的”代表元素”)。 基础并查集初始化 在我们初始创建数据的时候，由于没有任何操作，所以每个元素都是一个独立的集合，显然，每个元素都是本身集合的根节点。 1for (int i = 0; i &lt; n; i ++ ) p[i] = i; // p(i) 表示i的父节点 查询 假设我们现在要查询元素 $0$ 的父节点，该怎么做呢？ 很简单，由于根节点的父节点就是本身（不知道的可以回顾一下初始化过程）。所以我们直接检查 $0$ 的父节点是否为 $0$ 即可。 如果 $0$ 父节点为 $0$ ，说明 $0$ 是所属集合的根节点，返回 $0$ 即可。（因为我们用根节点代表集合） 如果 $0$ 父节点不为 $0$ ，那么我们只需要递归检查它的父节点是否为 $0$ 即可。 我们发现 $0$ 的父节点是 $2$ ，那么我们继续检查 $2$ 是否为根节点($p[2] == 2$) ，不是，则继续检查 $3$ ，此时 $3$ 为根节点，于是返回 $3$ 。 查询的复杂度为被查询元素在树上的深度。 1234int find (int x) // find函数用来返回x所属集合的代表元素(根节点){ return p[x] == x ? x : find(p[x]);} 合并 如图，如何合并 $6$ 所属集合和 $3$ 所属集合？由于我们知道根节点代表整个集合，合并 $6$ 和 $3$ 即意味着它们合并后根节点相同，我们可以任意取一个子集的根节点作为合并后的根节点，比如取 $3$ 后： 我们选择了把 $2$ 作为合并后集合的根节点（代表元素）。 12345void merge (int x, int y){ x = find(x), y = find(y); // x 和 y 为根节点 p[x] = y; // 直接把其中一个集合合并到另外一个集合} 并查集优化路径压缩我们发现，由于每次查询某个元素需要查询 $r$ 次($r$ 为当前元素在树上的深度)，当树的深度很大，且我们要查询的元素在很深的地方，那么查询所需要耗费的时间就很大，有没有办法优化呢？ 答案是肯定的，我们发现，整个集合只有代表元素是’有用’的，其他元素仅能代表它在这个集合中，与它所处的位置没有关系。 于是，我们在每次查询后，就把当前元素的父节点设置为集合的根节点，根节点就是 $find$ 的返回值，所以： 1234int find (int x) // find 函数返回x所属集合代表元素{ return p[x] == x ? x : p[x] = find(p[x]); // 把x的父节点设置为根节点} 按秩合并（启发式合并）上述提到，树的深度会影响查询的速度，那么我们可以在合并的时候，把集合元素较少的合并到集合元素较大的即可。还可以按照集合树的深度与集合的元素数量评估来得到更好的合并方法。 1234567void merge (int x, int y) // 按秩合并需要用到集合内的数量{ x = find(x), y = find(y); if (siz[x] &gt; siz[y]) swap(x, y); siz[y] += siz[x]; p[x] = y;} 按秩合并在竞赛中不常用，一般来说路径压缩就已经够用了。 模板12345678910111213141516171819const int N = 200010;int p[N]; // p(i)表示i的父节点void init (int n){ for (int i = 0; i &lt; n; i ++ ) p[i] = i;}int find (int x){ return p[x] == x ? x : p[x] = find(p[x]);}void merge (int x, int y){ x = find(x), y = find(y); p[x] = y;} 习题模板 并查集 朋友 此题也可以使用维护集合数量的并查集 村村通 超市 贪心+并查集 维护集合数量的并查集有时候，我们只维护元素所属的集合是不够的，我们还需要知道集合内的数量。 只维护一个集合数量，和基础并查集无任何区别，只需要加上一个 $siz$ 数组维护每个集合内的数量即可。 唯一需要变的就是在合并集合时的操作： 123456void merge (int x, int y) // 按秩合并需要用到集合内的数量{ x = find(x), y = find(y); siz[y] += siz[x]; p[x] = y;} 带权并查集当然，维护了数量在某些情况也是不够用的，我们还需要知道集合内各个元素的关系。我们可以使用带权并查集，使用边权来维护当前元素与父节点的某种关系。 即，带权并查集可以维护元素之间的制约关系。 我们以一道经典例题 食物链 为例。 例题 食物链题意动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。 $A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。 现有 $N$ 个动物，以 $1∼N$ 编号。 每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 $X$ 和 $Y$ 是同类。 第二种说法是 2 X Y，表示 $X$ 吃 $Y$。 此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。 当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话； 当前的话表示 $X$ 吃 $X$，就是假话。 你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。 分析给出两个动物，它们有吃、被吃以及同类三种制约关系，而带权并查集可以很好地维护元素间的制约关系。 设 $d[x]$ 表示元素 $x$ 与其父节点的边的边权。 规定： $d[x] \\% 3 = 0$ 表示 $x$ 与父节点 $p[x]$ 是同类。 $d[x] \\% 3= 1$ 表示 $x$ 可以吃父节点 $p[x]$。 $d[x] \\% 3 = 2$ 表示 $x$ 可以被父节点 $p[x]$ 吃。 那么我们判定假话，只需要不满足 $d[x]$ 即可。 简单来说： 判断 $x$ 与 $y$ 为同类，但已经制约了 $x$ 和 $y$ 为异类（吃或被吃）。 判断 $x$ 吃 $y$ ，但已经制约了 $x$ 和 $y$ 是同类或者 $x$ 被 $y$ 吃。 判断 $x$ 被 $y$ 吃，但已经制约了 $x$ 和 $y$ 是同类或者 $x$ 被 $y$ 吃。（题目不会给定） 首先我们肯定要是有路径压缩来优化查询的，在路径压缩后， $x$ 对应的父节点变为集合根节点，因此 $d[x]$ 也需要做变换。 123456789101112131415int find (int x){ if (x != p[x]) { int u = find(p[x]); /* * 注意此时x还没有路径优化，父节点仍然保持原来的父节点 * 此时 x 以上的节点经过路径优化，d[p[x]] 也修改为正确值(x父节点与根节点的关系) * 那么我们只需要根据x与父节点的关系、x父节点与根节点的关系即可传递得到x与根节点的关系，再路径优化即可。 */ d[x] += d[p[x]]; p[x] = u; } return p[x];} 那么现在的问题就是，如何知道一个集合里两个元素的制约关系？ 由于我们求得 $d[x]$ 都是 $x$ 与根节点的关系，那么 $(d[x] - d[y]) \\% 3$ 即为 $x$ 与 $y$ 的制约关系。 如何合并两个关系呢？ 假设判定 $x$ 和 $y$ 的关系的边权表示为 $op$ ，由于在 $find$ 中我们可以求得 $x$ 、 $y$ 分别与其根节点的关系，且现在 $x$ 与 $y$ 的制约关系也知道了，那么根据传递性我们也可以求出两个集合根节点之间的制约关系，合并两个集合时维护好两个根节点的制约关系即可。 假设 $x$ 的根节点为 $px$ ，$y$ 的根节点为 $py$ 。现在要把 $px$ 合并到 $py$ 。 判定 $x$ 与 $y$ 同类 在合并后的集合里，$x$ 与 $y$ 的关系应该为 $(d[x] - d[y]) \\% 3 = 0$ 。由于此时的 $d[x]$ 是合并后的，所以合并前应该为 $d[x] + d[px]$ 。即 $d[x] + d[px] - d[y] = 0$ ，那么 $d[px] = d[y] - d[x]$ 。 判定 $x$ 与 $y$ 不同类 由于题目给定此时判定为 $x$ 吃 $y$ ，所以我们只需要考虑这一种。 在合并后的集合里，$x$ 与 $y$ 的关系用应该是：$d[x] - d[y] = 1$ ，即 $x$ 可以吃根节点（路径压缩后的父节点），且 根节点与 $y$ 同类，依次推类。 同样此时的 $d[x]$ 是合并后的，合并前应该是 $d[x] + d[px]$ ，所以 $d[x] + d[px] - d[y] = 1$ ，即 $d[px] = 1 + d[y] - d[x]$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;const int N = 50010;int n, m;int p[N], d[N];int find (int x) { if (p[x] != x) { int t = find(p[x]); d[x] += d[p[x]]; p[x] = t; } return p[x];}int main () { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i] = i; int res = 0; while (m--) { int t, x, y; scanf(\"%d%d%d\", &amp;t, &amp;x, &amp;y); if (x &gt; n || y &gt; n) res++; // 谎言1：动物编号超出限制 else { int px = find(x), py = find(y); if (t == 1) { if (px == py &amp;&amp; (d[x] - d[y]) % 3) res++; // 谎言2：判定同类，但已经制约x和y是异类 else if (px != py) { // 否则认为是真话，加上此制约关系 p[px] = py; d[px] = d[y] - d[x]; } } else { if (px == py &amp;&amp; (d[x] - d[y] - 1) % 3) res++; // 谎言3：判定x吃y，但已经制约x和y是同类或者x被y吃 else if(px != py) { // 否则认为是真话，加上此制约关系 p[px] = py; d[px] = d[y] + 1 - d[x]; } } } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 习题关押罪犯 也可以使用二分图解决 奇偶游戏 同样也可以使用二分图 拓展域并查集拓展域并查集和带权并查集功能相同，都是对各个元素的不同关系进行制约。由于拓展域需要对同一个元素开多个域，因此空间复杂度较高，除此之外可以完全代替带权并查集。 同样，我们使用 食物链 这个例子来实现拓展域。 对于元素 $x$ ，其他元素 $y$ 和它一共有三种关系： 与 $x$ 是同类。 被 $x$ 吃，即 $x$ 捕食 $y$ 。 吃 $x$ ，即 $x$ 天敌为 $y$ 。 对于元素 $x$ ，我们开三个域来表示这三种关系。由于一共有 $n$ 个动物，我们有一个很好的开域的方式：我们令 $p[x]$ 表示 $x$ 的天敌域， $p[x + n]$ 表示 $x$ 的同类域， $p[x + 2 * n]$ 表示 $x$ 的捕食域 ，那么谎话只有以下两种： 判定 $x$ 与 $y$ 是同类，但是 $x$ 的捕食域或者天敌域存在 $y$ 。 判定 $x$ 吃 $y$ ，但是 $x$ 的同类域或者天敌域存在 $y$ 。 在合并的过程，比如合并 $x$ 和 $y$ 是同类，那么 $x$ 的天敌也同样是 $y$ 的天敌，即也需要合并 $x$ 与 $y$ 的天敌域。捕食域同理。 通过上述分析，我们可以很简洁地写出如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;functional&gt;using namespace std;const int N = 200010;int p[N]; // 拆点，每个点有三个域，天敌域，同类域，捕食域// 每个集合里的元素都是一类int main (){ function&lt;int(int)&gt; f = [&amp;](int x) { return x == p[x] ? x : p[x] = f(p[x]); } ; function&lt;void(int, int)&gt; mg = [&amp;](int x, int y) { p[f(x)] = f(y); }; int n, k, d, x, y, ret = 0; cin &gt;&gt; n &gt;&gt; k; iota(p + 1, p + 3 * n + 1, 1); while(k -- &amp;&amp; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y) { if (x &gt; n || y &gt; n) { ret ++ ; continue; } // 假话2 if (d == 2 &amp;&amp; x == y) { ret ++ ; continue; } // 假话3 // 假话1，产生冲突 if (d == 1) { // 如果判定x和y是同类，但是x的天敌域或者捕食域有y，一定是假话 if (f(x) == f(y + n) || f(x + 2 * n) == f(y + n)) { ret ++ ; continue; } // 否则这是一句真话，记录一下 mg(x + n, y + n); mg(x, y); // x的天敌和y的天敌是同一类 mg(x + 2 * n, y + 2 * n); // x的捕食域和y的捕食域也是一类 } else { // 如果判定x捕食y，但是x同类域或天敌域有y，假话 if (f(x + n) == f(y + n) || f(x) == f(y + n)) { ret ++ ; continue; } mg(x + 2 * n, y + n); mg(x + n, y); // y的天敌域加上x的同类域 mg(x, y + 2 * n); // x的天敌域加上y的捕食域 } } cout &lt;&lt; ret &lt;&lt; endl; return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://horb7.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"并查集拓展域","slug":"并查集拓展域","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-19T15:05:46.000Z","comments":true,"path":"2022/02/16/并查集拓展域/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95%E5%9F%9F/","excerpt":"","text":"并查集拓展域 并查集是用来维护元素之间的制约关系，并且在更新时可以传递关系的一种数据结构，但有时候只靠是否在集合内不足以表示复杂的关系，因此引入了拓展域的关系. 例题 食物链1. 带权并查集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;functional&gt;using namespace std;const int N = 50010;int p[N], d[N];/* d(i) 表示 i 与父结点的距离。 1 -&gt; i可以吃父结点 2 -&gt; i可以被父结点吃 0 -&gt; i与父结点同类*/int main (){ function&lt;int(int)&gt; f = [&amp;](int x) { if (x != p[x]) { // 维护d数组 int u = f(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } ; // mg 对于同类和不同类的情况不同 int n, k, od, x, y, ret = 0; cin &gt;&gt; n &gt;&gt; k; iota(p+1, p+n+1, 1); while(k -- &amp;&amp; cin &gt;&gt; od &gt;&gt; x &gt;&gt; y) { if (x &gt; n || y &gt; n) { ++ ret; continue; } int px = f(x), py = f(y); if (od == 1) { if (px == py &amp;&amp; (d[x] - d[y]) % 3) { ++ ret; continue; } // 加入一个集合 if (px != py) { p[px] = py; d[px] = d[y] - d[x]; } } else { if (x == y || px == py &amp;&amp; (d[x] - d[y] - 1) % 3) { ++ ret; continue; } if (px != py) { // 加入一个集合 p[px] = py; d[px] = d[y] + 1 - d[x]; } } } cout &lt;&lt; ret &lt;&lt; endl; return 0;} 2. 拆点并查集（拓展域）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;functional&gt;using namespace std;const int N = 200010;int p[N]; // 拆点，每个点有三个域，天敌域，同类域，捕食域/* x : 维护x的所有天敌 x + n : 维护x的所有同类 x + 2 * n : 维护x的所有捕食*/// 每个集合里的元素都是一类int main (){ function&lt;int(int)&gt; f = [&amp;](int x) { return x == p[x] ? x : p[x] = f(p[x]); } ; function&lt;void(int, int)&gt; mg = [&amp;](int x, int y) { p[f(x)] = f(y); }; int n, k, d, x, y, ret = 0; cin &gt;&gt; n &gt;&gt; k; iota(p + 1, p + 3 * n + 1, 1); while(k -- &amp;&amp; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y) { if (x &gt; n || y &gt; n) { ret ++ ; continue; } // 假话2 if (d == 2 &amp;&amp; x == y) { ret ++ ; continue; } // 假话3 // 假话1，产生冲突 if (d == 1) { // 如果判定x和y是同类，但是x的天敌域或者捕食域有y，一定是假话 if (f(x) == f(y + n) || f(x + 2 * n) == f(y + n)) { ret ++ ; continue; } // 否则这是一句真话，记录一下 mg(x + n, y + n); mg(x, y); // x的天敌和y的天敌是同一类 mg(x + 2 * n, y + 2 * n); // x的捕食域和y的捕食域也是一类 } else { // 如果判定x捕食y，但是x同类域或天敌域有y，假话 if (f(x + n) == f(y + n) || f(x) == f(y + n)) { ret ++ ; continue; } mg(x + 2 * n, y + n); mg(x + n, y); // y的天敌域加上x的同类域 mg(x, y + 2 * n); // x的天敌域加上y的捕食域 } } cout &lt;&lt; ret &lt;&lt; endl; return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://horb7.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Codeforces-Global-Round-18","slug":"Codeforces-Global-Round-18","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-26T16:04:50.000Z","comments":true,"path":"2022/02/16/Codeforces-Global-Round-18/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Global-Round-18/","excerpt":"","text":"Global Round 18A. Closing The Gap题意给定 $n$ 个数字，每次操作可以选择其中两个数字 $a_i, a_j$ ，令 $a_i-1$ 且 $a_j + 1$ 。 问若干次操作后，极差最小为多少。 分析显然如果 $n | \\sum_{i=1}^na_i$ ，那么我们一定能找到方案使得每个数字都相同，那么极差为 $0$ 。 否则，我们可以取每个数字为 $\\lfloor \\dfrac {\\sum_{i=1}^n a_i} n \\rfloor$ ，剩下的数量小于 $n$ ，平均地分布在每个数字上，这样极差为 $1$ 。 Code1234567891011121314151617/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve (){ int n, sum = 0; cin &gt;&gt; n; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) sum += x; cout &lt;&lt; (sum % n ? 1 : 0) &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} B. And It’s Non-Zero题意给出范围 $[l, r]$ ，你拥有这个范围内的所有正整数。你可以删除某些数字。 问，最少删除多少数字，满足剩下的数字按位和为 $0$ 。 分析要使得一些数字的按位和不为 $0$ ，那么只需要满足存在某一个位，所有数字在这一个位上都为 $1$ 。 具体来说，我们可以枚举每一位，求出要使所有数字都在这个位上为 $1$ 的最小删除数量，求最小值即可。 预处理 $f(i, j)$ 表示前 $i$ 个数字第 $j$ 位为 $0$ 的数量。 Code123456789101112131415161718192021222324252627/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, INF = 0x3f3f3f3f;int f[N][30]; // 前i个数字第j个位为0的数量void init (){ for (int i = 1; i &lt; N; i ++ ) for (int j = 0; j &lt;= 20; j ++ ) f[i][j] = f[i-1][j] + !(i &gt;&gt; j &amp; 1);}void solve (){ int l, r, res = INF; cin &gt;&gt; l &gt;&gt; r; for (int i = 0; i &lt;= 20; i ++ ) res = min(f[r][i] - f[l-1][i], res); cout &lt;&lt; res &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (init(), cin &gt;&gt; _; _--; ) solve(); return 0;} C. Menorah题意有 $n$ 个蜡烛，给出每个蜡烛的起始状态（亮或者灭）。 每次操作可以选择一个 亮着的 蜡烛，让它保持状态不变，且其他所有蜡烛改变状态。 给出每个蜡烛的目标状态，问从起始状态到目标状态至少需要操作几次，如果无解输出 $-1$ 。 分析首先我们可以发现，对于起始状态 != 目标状态的所有蜡烛，他们被操作的次数的奇偶性是相同的；对于起始状态 == 目标状态的所有蜡烛，他们被操作的次数的奇偶性也是相同的。但是上述两类的蜡烛操作次数奇偶性不同。 证明：设 $x_i$ 表示第 $i$ 个蜡烛的操作次数。 对于第 $i$ 个蜡烛而言，它改变状态的次数为 $S = \\sum_{j=1}^{i-1}x_i + \\sum_{j=i+1}^{n}x_i$ 。 对于任意一个其他的蜡烛 $j$ ，它改变的次数为 $S’ = S + x_i - x_j$ 。 如果 $i$ 蜡烛是需要改变状态的，比如从原始的 $0$ 变成最终的 $1$ ，那么对于 $j$ 而言，如果它也需要改变状态，那么 $S’ = S = 1 \\pmod 2$ ，从而推出 $x_i = x_j \\pmod 2$ 。如果 $j$ 不需要改变状态，那么 $S’ != S \\pmod 2$ ，推出 $x_i != x_j \\pmod 2$ 。 同理如果 $i$ 蜡烛不需要改变状态，我们同理可得上述结论。 然后我们可以发现每个蜡烛如果被操作，它最多被操作一次。 所以我们实际上只有两种可能的解法。 只对所有起始和目标不同的蜡烛每个做一次操作。 只对所有起始和目标相同的蜡烛每个做一次操作。 那么如何求出解法是否可行？ 容易发现，我们的操作对象一定为 $101010101 \\ldots$ 。（这里指的是原始的状态） 我们先对原始状态的 $1$ 操作，由于这个已经操作过了，所以对剩下没有操作的蜡烛，本来是 $0$ 的现在变成 $1$ ，我们对 $1$ 操作，本质上是对原始状态的 $0$ 操作。 同时，我们对 $10$ 操作后，本质上是交换了这两个状态，其他状态没有改变。 第一种解法： ​ 假设起始和目标为 $01$ 的蜡烛数量为 $k_0$ ，起始和目标为 $10$ 的蜡烛数量为 $k_1$ 。那么我们只能每次交换一个 $01$ 。所以如果 $k_0 != k_1$ ，那么无法通过交换来达到目标，无解。否则我们交换 $2 \\times k_0$ 次即可交换所有的 $01$ 对。 第二种解法： ​ 假设起始和目标为 $00$ 的蜡烛数量为 $e_0$ ，起始和目标为 $11$ 的蜡烛数量为 $e_1$ 。那么我们需要交换 $01$ 使得他们与目标都不相同，这样如果最后只剩下一个 $1$ （也就是 $e_0 = e_1 - 1$） ，那么操作这个 $1$ 就可以把其他所有状态改变，也就是全部变成目标状态。 注意特判起始和目标相同的情况。 Code123456789101112131415161718192021222324252627282930313233/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve (){ int n; cin &gt;&gt; n; string a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) return cout &lt;&lt; 0 &lt;&lt; endl, void(); int k1 = 0, k0 = 0; int e1 = 0, e0 = 0; for (int i = 0; i &lt; n; i ++ ) { if (a[i] == '1' &amp;&amp; b[i] == '0') ++ k1; else if (a[i] == '0' &amp;&amp; b[i] == '1') ++ k0; else if (a[i] == '1' &amp;&amp; b[i] == '1') ++ e1; else if (a[i] == '0' &amp;&amp; b[i] == '0') ++ e0; } if (k1 != k0) { if (e0 == e1 - 1) return cout &lt;&lt; e0 * 2 + 1 &lt;&lt; endl, void(); return cout &lt;&lt; -1 &lt;&lt; endl, void(); } if (e0 == e1 - 1) return cout &lt;&lt; min(e0 * 2 + 1, k1 + k0) &lt;&lt; endl, void(); cout &lt;&lt; k1 + k0 &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} D. X(or)-mas Tree题意给定 $n$ 个结点的带权无根树和 $m$ 个限定条件 $(u, v, w)$ 。求出任意一个满足限制的树。 给出的边权如果为 $-1$ ，表示这个边权待定。 限定条件 $(u, v, w)$ ，表示从 $u$ 出发到达 $v$ 的路径上的所有边的异或和的 $popcount$ 的奇偶性 。 $popcount$ 指一个数字二进制位下 $1$ 的数量。 分析首先有一个等式 $popcount(x \\bigoplus y) = popcount(x) \\bigoplus popcount(y) \\pmod 2$ 。 证明：假设 $popcount(x) = k_1, popcount(y) = k_2$ 。 那么 $popcount(x \\bigoplus y) = k_1 + k_2 - cnt \\times 2$ ，其中，$cnt$ 表示在某一位上 $x = y = 1$ ，这样的位的个数。 显然 $k1 + k2 - cnt \\times 2 = k_1 + k_2 \\pmod 2$ 。 设 $a(u)$ 表示从结点 $u$ 到达根节点的路径异或和的 $popcount$ 。 对于限制条件 $(u, v, w)$ ， 其实就是 $a(u) \\bigoplus a(v) = w$ 。 对于给出的边 $(u, v, w)$ ，如果给定了边权，其实也是一个限制条件，因为 $a(u) \\bigoplus a(v) = popcount(w)$ 。 我们先把这些限制条件全部扔到另外一张图上。 容易发现，我们给边权填上 $0, 1$ 即产生两种不同的奇偶性，只需要填 $0$ 或者 $1$ 即可。 那么我们对限制图做染色法求出 $a(i)$ 即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, M = 1200010;#define pop(x) __builtin_popcount(x)int n, m;int h[N], rh[N], e[M], w[M], ne[M], idx;int a[N];bool vis[N]; // vis 用来染色bool cant;/* a(i) 表示从i到根节点路径上的异或和的popcount cant 表示无解*/void init (int n){ for (int i = 1; i &lt;= n; i ++ ) h[i] = rh[i] = -1; idx = 0; for (int i = 1; i &lt;= n; i ++ ) a[i] = vis[i] = 0; cant = 0;}void add (int h[], int a, int b, int c){ e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++ ;}void dfs (int u, int fa, int c){ if (cant) return ; a[u] = c; vis[u] = true; for (int i = rh[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; if (!vis[j]) dfs(j, u, c ^ w[i]); else if ((a[j] ^ a[u]) != w[i]) { cant = true; return; } // 如果j被染色过，需要满足限制，否则无解 }}void print (int u, int fa){ for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; if (w[i] != -1) cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; w[i] &lt;&lt; endl; else cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; (a[u] ^ a[j]) &lt;&lt; endl; print(j, u); }}void solve (){ cin &gt;&gt; n &gt;&gt; m; init(n); for (int i = 1; i &lt; n; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(h, a, b, c); add(h, b, a, c); if (c != -1) // 边不为-1，做一条限制 add(rh, a, b, pop(c) &amp; 1), add(rh, b, a, pop(c) &amp; 1); } // 后面还有m条限制 for (int i = 1; i &lt;= m; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(rh, a, b, c); add(rh, b, a, c); } // 染色 for (int i = 1; i &lt;= n; i ++ ) if (!vis[i]) dfs(i, -1, 0); if (cant) return cout &lt;&lt; \"NO\\n\", void(); cout &lt;&lt; \"YES\\n\"; print(1, -1);}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Good Bye 2021","slug":"Codeforces-Good-Bye-2021","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-31T13:26:48.000Z","comments":true,"path":"2022/02/16/Codeforces-Good-Bye-2021/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Good-Bye-2021/","excerpt":"","text":"Good Bye 2021A. Interger Diversity题意给定 $n$ 个整数，你可以选择其中的任意项，使其变成它的相反数(如把 $x$ 变成 $-x$) ，问操作后的序列中最多有多少个不同的数字。 分析记录每个数字是否出现过，如果出现过而相反数没有出现过就把它变成相反数。 Code123456789101112131415161718192021222324/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, res = 0; cin &gt;&gt; n; map&lt;int, bool&gt; ex; for (int i = 1; i &lt;= n; i ++ ) { int x; cin &gt;&gt; x; if (ex[x] &amp;&amp; ex[-x]) continue; res ++ ; if (!ex[x]) ex[x] = true; else ex[-x] = true; } cout &lt;&lt; res &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} B. Mirror in the String题意给定长度为 $n$ 的字符串 $s_1s_2 \\ldots s_n$ ，选择一个数字 $k(1 \\le k \\le n)$ ，使其变成 $s_1s_2 \\ldots s_ks_ks_{k-1} \\ldots s_1$ 。问操作后能得到的字符串的最小字典序为多少。 分析 $n = 1 \\ or \\ s_1 = s_2$ 选择 $k=1$ 即可得到字典序最小，因为选择 $k(k \\ge 2)$ 时，前两个字符依然是 $s_1s_2$ ，后面又多了字符导致字典序不是最小。 $s1 \\ != \\ s2$ 对于字符 $s_i$ ，如果 $s_{i+1} \\gt s_i$ ，那么选择 $k=i$ ，因为如果选择 $k \\gt i$ ，那么得到的字符串第 $i+1$ 位一定变大了，就不是字典序最小。 Code12345678910111213141516171819202122/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if (n == 1 || s[0] == s[1]) return cout &lt;&lt; s[0] &lt;&lt; s[0] &lt;&lt; endl, void(); int p = 0; while(p &lt; n - 1 &amp;&amp; s[p + 1] &lt;= s[p]) p ++ ; for (int i = 0; i &lt;= p; i ++ ) cout &lt;&lt; s[i]; for (int i = p; i &gt;= 0; i -- ) cout &lt;&lt; s[i]; cout &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} C. Representative Edges题意给定长度为 $n$ 的序列 $a$ ，每次操作可以修改其中某一个元素的值，问最小操作多少次，使得对于任意 $1 \\le l \\le r \\le n$ ，满足 $a_l + a_{l+1} + \\ldots + a_r = \\dfrac 1 2(a_l + a_r) \\times (r - l + 1)$ 。 分析可以发现题目要求的性质为等差数列的性质，题目变为：求最少修改多少次使得序列变为等差数列。 由于数据很小 $1 \\le n \\le 70$ 。我们可以固定数列任意两项作为要求的等差数列的一部分，求出其他满足该等差数列性质的个数。 假设固定 $i, j$ ，那么对于任意一项 $k$ ，满足等差数列性质需要: $\\dfrac {a_j - a_i} {j-i} = \\dfrac {a_k - a_i} {k - i} $ ，即 $(a_j - a_i) \\times (k - i) = (a_k - a_i) \\times (j - i)$ 。 Code123456789101112131415161718192021222324252627/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )using namespace std;const int N = 1000;int a[N];void solve(){ int n, ret; cin &gt;&gt; n; ret = max(0, n - 2); for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; rep(i, 1, n) rep(j, i + 1, n) { int save = 0; rep(k, 1, n) if ((a[k] - a[i]) * (j - i) == (a[j] - a[i]) * (k - i)) ++ save; ret = min(ret, n - save); } cout &lt;&lt; ret &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} D. Keep the Average High题意给定长度为 $n$ 的序列 $a$ ，选出最多的元素，满足对于任意 $1\\le l \\lt r \\le n$ （$l, r$ 均指原序列的下标），满足以下至少一项： 存在至少一项 $l \\le k \\le r$ 没有被选择。 $a_l + a_{l+1} \\ldots a_r \\ge x \\times (r - l + 1)$ 。 问能够选择最多多少个元素。 分析对于任意 $l, r$ ，如果其中有一个没有被选择，那么一定满足限制，所以只需要考虑 $[l, r]$ 都被选择时是否满足限制。 注意第 $2$ 个限制，等价于 $(a_l - x) + (a_{l + 1} - x) + \\ldots + (a+r - x) \\ge 0$ 。 注意到 $[l, r]$ 是连续的，我们设 $p(i) = \\sum_{i=1}^i a_i - x$ ，那么上述限制等价于 $p(r) - p(l-1) \\ge 0$ 。 假设目前枚举到第 $i$ 位，那么我们需要考虑后两位，如果 $p(i + 2) - p(i) \\lt 0$ ，即 $a(i+1) + a(i+2) \\lt 0$ ，那么我们不能全部取到，否则令 $l = i+1, r=i+2$ ，不满足限制。如果满足 $p(i+2) - p(i) \\ge 0$ ，因为前面满足的序列加上第 $i+1$ 位不一定不小于 $0$ ，那么我们取最大值，把 $i+1$ 位放到待判断的序列中，即：$a_1 \\ldots a_qq_{q+1} \\ldots a_i \\ldots a_n$ ，区间 $[q, i]$ 为满足限制的区间，而 $i+1$ 进入到待选择区域。这样我们就不仅只考虑满足限制的最后一个位置后面的两个位置了。对于带选择区间 $[l, r]$ ，因为加上了 $a_r$ 导致 $p(r) - p(l-1) &lt; 0$ ，那么只需要不选择 $r$ 即可，因为 $[l, r-1]$ 加上前面满足的区间依然不小于零。 Code123456789101112131415161718192021222324252627/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 200010;int a[N], pre[N];void solve(){ int n, x, ret, mx = 0; cin &gt;&gt; n; ret = n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; cin &gt;&gt; x; for (int i = 1; i &lt;= n; i ++ ) pre[i] = pre[i-1] + a[i] - x; for (int i = 2; i &lt;= n; i ++ ) if (pre[i] &lt; mx) { -- ret; mx = pre[i]; ++ i; } else mx = max(mx, pre[i-1]); cout &lt;&lt; ret &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces-Round-762-Div-3","slug":"Codeforces-Round-762-Div-3","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-21T03:25:48.000Z","comments":true,"path":"2022/02/16/Codeforces-Round-762-Div-3/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Round-762-Div-3/","excerpt":"","text":"#762(Div.3)B. Squares and Cubes题意给定数字 $n$ ，求 $1 \\sim n$ 中有多少平方数和立方数。 分析由于只需要找平方数和立方数，我们可以暴力找出所有平方数和立方数，复杂度为 $log n$ ，注意判重。 Code1234567891011121314151617181920212223242526/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 200010;void solve (){ map&lt;int, bool&gt; ex; // 判重数组 int n, ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n / i; i ++ ) { ans ++ ; ex[i * i] = 1; } for (int i = 1; i * i &lt;= n / i; i ++ ) if (!ex[i * i * i]) ans ++ ; cout &lt;&lt; ans &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} C. Wrong Addition题意给定加法法则为：从右到左计算，每次把各位相加的结果填充到结果而不是进位。 即： $88 + 99 = 1717$ 。 给出加数、和，求另一个加数。 分析从加数、和的最后一位开始，如果在当前位，加数小于和，那么一定存在进位，否则一定不存在进位。 不存在解的情况： 在某一位上，当前加数的位数大于和的位数 在进位的时候发现和的前一位不是1 Code1234567891011121314151617181920212223242526272829303132333435363738394041/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define all(a) begin(a),end(a)using namespace std;void solve (){ string a, s, ans; cin &gt;&gt; a &gt;&gt; s; for (int p = s.size() - 1, pa = a.size() - 1; p &gt;= 0; ) { // 存在某一位，使得当前加数的数量大于和 if (pa &gt; p) return cout &lt;&lt; -1 &lt;&lt; endl, void(); if (pa &lt; 0) // 加数已经结束了，直接把和加上去 { ans += s[p--]; continue; } if (s[p] &gt;= a[pa]) // 不存在进位 { ans += s[p] - a[pa] + '0'; p -- ; pa -- ; } else // 存在进位 { // 存在进位，那么和的前一位一定是1 if (s[p - 1] != '1') return cout &lt;&lt; -1 &lt;&lt; endl, void(); ans += s[p] + 10 - a[pa] + '0'; p -= 2; pa -- ; } } reverse(all(ans)); while(ans[0] == '0') ans = ans.substr(1); cout &lt;&lt; ans &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} D. New Year’s Problem题意给出矩阵 $p_{ij}$ ，$1 \\le i \\le m, \\ 1 \\le j \\le n$ 。 选择至多 $n-1$ 行，然后在选择的行中，每一列挑选一个数字，求选择的数字的最小值的最大值。 分析要求最小值的最大值，可以想到用二分答案。 由于要选择至多 $n-1$ 行，那么我们只需要找出有 $2$ 个数字在同一行即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for(int i = x; i &lt;= y; i++)#define int long longusing namespace std;void solve (){ int n, m; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; p(m, vector&lt;int&gt;(n)); rep(i, 0, m-1) rep(j, 0, n-1) cin &gt;&gt; p[i][j]; auto check = [&amp;] (int mid) -&gt; bool { map&lt;int, bool&gt; ex; // 存储满足的商店 bool may = 0; // may表示存在两列可以选择同一行 // 使用may是为了防止后面的列中不存在大于等于mid的数字 for (int i = 0; i &lt; n; i ++ ) { bool f = 0; // 是否存在至少一个数字满足大于等于mid for (int j = 0; j &lt; m; j ++ ) if (p[j][i] &gt;= mid) { if (ex[j]) may = 1; ex[j] = 1; f = 1; } if (!f) return false; } return may; }; int l = 1, r = 1e9 + 10; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; r &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} E. MEX and increments题意给出 $n$ 个数字，每次操作可以把一个数字加1。可以操作任意次。 问：对于数字 $i \\ (0 \\le i \\le n)$ ，是否存在一种操作，可以满足序列的 $mex$ 为 $i$ 。输出它的最小操作次数。 分析对于数字 $i$ ，假设 $cnt([0, i-1]) &lt; i$ ，那么一定不能把前面 $i$ 个数字填满，一定无解。 否则，我们可以选择把离它最近的位置，填到 $i-1$ 的位置，使得序列的 $mex$ 为 $i$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;using PII = pair&lt;int, int&gt;;#define int long longconst int N = 200010;int cnt[N];void solve (){ int n; cin &gt;&gt; n; vector&lt;PII&gt; mct; // mct 用来动态记录cnt for (int i = 0; i &lt;= n; i ++ ) cnt[i] = 0; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) ++ cnt[x]; int precnt = 0, d = 0; // 对于0，特殊判断 cout &lt;&lt; cnt[0] &lt;&lt; ' '; if (cnt[0] &gt; 1) mct.push_back({0, cnt[0] - 1}); for (int i = 1; i &lt;= n; i ++ ) { precnt += cnt[i-1]; if (precnt &lt; i) { while(i ++ &lt;= n) cout &lt;&lt; -1 &lt;&lt; \" \\n\" [i - 1 == n]; return ; } // 如果i-1的位置没有元素，要把i-1铺掉 if (!cnt[i-1]) { while (!mct[mct.size() - 1].second) mct.pop_back(); -- mct[mct.size() - 1].second; d += i - 1 - mct[mct.size() - 1].first; } cout &lt;&lt; d + cnt[i] &lt;&lt; ' '; if (cnt[i] &gt; 1) mct.push_back({i, cnt[i] - 1}); } cout &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 764 (Div.3)","slug":"Codeforces-Round-764-Div-3","date":"2022-02-16T14:54:28.237Z","updated":"2022-01-12T04:47:30.000Z","comments":true,"path":"2022/02/16/Codeforces-Round-764-Div-3/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Round-764-Div-3/","excerpt":"","text":"A. Plus One on the Subset题意给定一个长度为 $n$ 的序列，每次选择若干个数字加 $1$ ，问最少操作几次可以使所有数字相同。 分析每次操作最小的数字，顺便补上其他小于最大值的数字，因此最少次数为极差。 Code12345678910111213141516171819202122/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; int maxv = -1, minv = 1e9; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) { maxv = max(maxv, x); minv = min(minv, x); } cout &lt;&lt; maxv - minv &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} Make AP题意给出三个数字，可以选择其中一个数字（也可以不选），使其乘上任意一个正数。 问能否让这三个数字成为等差数列（顺序不能换）。 分析由于只有三个数字，枚举哪个数字用来乘即可。 类似的题目： CF Good bye 2021 C题 Code12345678910111213141516171819202122232425/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longvoid solve(){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; bool ok = 0; int na = 2 * b - c; ok |= (na % a == 0 &amp;&amp; (c - b) == (b - na) &amp;&amp; (na * a) &gt; 0); int nb = (a + c) / 2; ok |= (nb % b == 0 &amp;&amp; (c - nb) == (nb - a) &amp;&amp; (nb * b) &gt; 0); int nc = (2 * b - a); ok |= (nc % c == 0 &amp;&amp; (nc - b) == (b - a) &amp;&amp; (nc * c) &gt; 0); cout &lt;&lt; (ok ? \"YES\" : \"NO\") &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} C. Division by Two and Permutation题意给定长度为 $n$ 的序列，每次可以选择一个数字 $x$ 使其变为 $\\lfloor \\dfrac x 2 \\rfloor$ 。问能否使序列变为一个 $1 \\sim n$ 的排列。 分析每个数字都必须为 $[1, n]$ 的数字，所以第一步要把所有大于 $n$ 的数字变为 $[1, n]$ 之间的数字。 从后往前遍历，由于每个数字都需要恰好 $1$ 个。那么如果当前数字没有，一定不能成功，如果有多个，留下一个并且把剩下的转化为 $\\lfloor \\dfrac x 2 \\rfloor$ 即可。 Code123456789101112131415161718192021222324252627282930/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;int cnt[N];void solve(){ memset(cnt, 0, sizeof cnt); int n; cin &gt;&gt; n; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) { while (x &gt; n) x /= 2; cnt[x] ++ ; } for (int i = n; i &gt;= 1; i -- ) { if (!cnt[i]) return cout &lt;&lt; \"NO\\n\", void(); while(cnt[i] &gt; 1) cnt[i / 2] ++, cnt[i] -- ; } cout &lt;&lt; \"YES\\n\";}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} D. Palindromes Coloring题意给出长度为 $n$ 的字符串和 $k$ 种染料，每种染料都至少染 $1$ 个字符，被染上相同染料的字符可以任意调换顺序。 给字符串染上染料，使得所有被染上相同染料的字符串（子串）为回文串。问长度最小的字符串的最大长度为多少。 分析由于可以任意调换顺序，因此字符串顺序不是考虑因素。 要把一个子串变成回文串，我们需要任意个偶数对和至多一个任意字符。 那么我们可以求出偶数对的数量以及单个的字符的数量，然后二分答案即可。 注意如果一个字符出现了奇数次，我们可以把它拆成若干个偶数对和一个单独的字符。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint even, odd, k; // 能构成偶数对的字符数量、单独的字符数量bool check (int x){ int nt = even, no = odd; if (x &amp; 1) { if (k * (x - 1) &gt; nt) return false; // 每个子串至少要 (x-1) 个even nt -= k * (x - 1); if (nt + no &lt; k) return false; // 注意可以把能构成偶数对的字符数量变成单独的字符使用 return true; } else { if (k * x &lt;= nt) return true; else return false; }}void solve(){ even = odd = 0; vector&lt;int&gt; a(26); int n; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; for (char c : s) a[c - 'a'] ++ ; for (int x : a) { if (x &amp; 1) even += x - 1, odd ++ ; else even += x; } int l = 0, r = n; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; r &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} E.Masha-forgetful题意给出 $n$ 个长度为 $m$ 的字符串，以及需要匹配的字符串 $s$ （长度也为 $m$），问能否把 $s$ 拆成任意多段（每段长度至少为 $2$），使得每一段在前 $n$ 个字符串出现过。如果满足，输出 $k$ 段，且输出每一段在其他字符串出现的首尾位置，以及它出现在哪个字符串。 分析首先，任何一个不小于 $2$ 的数字都可以由若干个 $2$ 和 $3$ 组成 。 这就意味这我们只需要把 $s$ 拆成若干个长度为 $2$ 和 $3$ 的段即可。 $dp(i)$ 表示前 $i-1$ 个字符是匹配的。 在前 $n$ 个字符串中，找出所有段长度为 $2$ 和 $3$ 的信息（即题目要求的首尾位置和出现在第几个字符串）。 然后从前往后遍历 $s$ ，求出那些位置是匹配的。最后从后往前找到路径即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;using tp = tuple&lt;int, int, int&gt;;void solve(){ tp f2[10][10], f3[10][10][10]; // f2(i, j)表示 ij 这样的段出现的信息 int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { string s; cin &gt;&gt; s; for (int j = 0; j &lt; m; j ++ ) { if (j + 1 &lt; m) f2[s[j]-'0'][s[j+1]-'0'] = {j + 1, j + 2, i + 1}; if (j + 2 &lt; m) f3[s[j]-'0'][s[j+1]-'0'][s[j+2]-'0'] = {j + 1, j + 3, i + 1}; } } string s; cin &gt;&gt; s; vector&lt;bool&gt; dp(m + 1); // dp(i)表示前面i-1个位置是否可以 dp[0] = true; for (int i = 0; i &lt; m; i ++ ) { if (!dp[i]) continue; if (i + 1 &lt; m &amp;&amp; f2[s[i]-'0'][s[i+1]-'0'] != tp(0, 0, 0)) dp[i + 2] = true; if (i + 2 &lt; m &amp;&amp; f3[s[i]-'0'][s[i+1]-'0'][s[i+2]-'0'] != tp(0, 0, 0)) dp[i + 3] = true; } if (!dp[m]) return cout &lt;&lt; \"-1\\n\", void(); int i = m; // 记录路径 vector&lt;tp&gt; ans; while(i) { if (i &gt;= 1 &amp;&amp; dp[i - 2] &amp;&amp; f2[s[i-2]-'0'][s[i-1]-'0'] != tp{0, 0, 0}) { ans.push_back(f2[s[i-2]-'0'][s[i-1]-'0']); i -= 2; } else { ans.push_back(f3[s[i-3]-'0'][s[i-2]-'0'][s[i-1]-'0']); i -= 3; } } reverse(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto t : ans) cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; ' ' &lt;&lt; get&lt;1&gt;(t) &lt;&lt; ' ' &lt;&lt; get&lt;2&gt;(t) &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} F. Interacdive Problem题意给出数字 $n$ ，要求猜出数字 $x$ ，其中 $1 \\le x \\lt n \\le 1000$ 。 可以给出询问 $+ \\ \\ c$ ，表示令 $x = x + c$ ，之后给出 $\\lfloor \\dfrac x n \\rfloor$ 。 最多可以操作 $10$ 次。 分析可以把 $x$ 写成 $x / n * n + x \\% n$ 。 二分答案，假设 $mid = x$ ，即 $mid = mid / n * n + mid \\% n$ 。 询问 $n - mid \\% n$ ，这样可以使 $x + n - mid \\% n = x / n * n + n + x \\% n - mid \\% n$ 。 发现倍数增加了，那么有 $x \\% n \\ge mid \\% n$ ，即 $mid \\le x$ 。 否则 $mid \\gt x$ 。 注意由于 $x$ 已经加上了 $n - mid \\% n$ ，那么 $l$ 和 $r$ 也要加上，保证 $l \\le x \\le r$ 。 Code12345678910111213141516171819202122232425262728293031323334353637/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ auto query = [&amp;] (int add) { cout &lt;&lt; \"+ \" &lt;&lt; add &lt;&lt; endl; return cin &gt;&gt; add, add; }; auto submit = [&amp;] (int ans) { cout &lt;&lt; \"! \" &lt;&lt; ans &lt;&lt; endl; exit(0); }; int n; cin &gt;&gt; n; int l = 1, r = n - 1; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; int to = n - mid % n, now = query(to); if (now &gt;= mid / n + 1) l = mid; else r = mid - 1; l += to, r += to; } submit(r);}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); // int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} G. MinOr Tree题意给出一张无向图，求或和最小的生成树。 分析按位分析，从大到小，假设当前位为 $bit$ 。 由于要求最小或和，那么最好情况下，我们只合并所有在 $bit$ 位上为 $0$ 和点。 如果合并完发现没有用上所有点，那么说明要想生成最小生成树，必须要 $bit$ 位上为 $1$ 的点。 考虑下一位前，由于当前位已经被考虑过，所以要把所有在当前位为 $1$ 的边变为当前位为 $0$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; u(m), v(m), w(m); for (int i = 0; i &lt; m; i ++ ) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; -- u[i], -- v[i]; } int ans = 0; for (int j = 29; j &gt;= 0; j -- ) { vector&lt;vector&lt;int&gt;&gt; E(n); for (int k = 0; k &lt; m; k ++ ) { if (w[k] &lt; (1 &lt;&lt; j)) { E[u[k]].push_back(v[k]); E[v[k]].push_back(u[k]); } } vector&lt;bool&gt; used(n, false); used[0] = true; // 从0号点开始bfs queue&lt;int&gt; Q; Q.push(0); while(!Q.empty()) { int x = Q.front(); Q.pop(); for (int y : E[x]) { if (!used[y]) { used[y] = true; Q.push(y); } } } if (used != vector&lt;bool&gt; (n, true)) { ans |= 1 &lt;&lt; j; // 这一位已经考虑过了，把j位上为1的数字去掉 for (int k = 0; k &lt; m; k ++ ) if (w[k] &gt;&gt; j &amp; 1) w[k] ^= 1 &lt;&lt; j; } } cout &lt;&lt; ans &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 767(Div.2)","slug":"Codeforces-Round-767-Div-2","date":"2022-02-16T14:54:28.237Z","updated":"2022-01-23T08:05:14.000Z","comments":true,"path":"2022/02/16/Codeforces-Round-767-Div-2/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Round-767-Div-2/","excerpt":"","text":"Codeforces Round #767 (Div.2)C. Meximum Array题意给定序列 $a$ ，以下列方式构造序列 $b$ ，使得 $b$ 的字典序最大。 当序列 $a$ 不为空时： 选择一个序列 $a$ 的前缀区间。 将此前缀区间的 $mex$ 值放置 $b$ 序列的末尾，然后在 $a$ 序列中删除此前缀。 分析题目要求将 $a$ 序列进行划分，使得每个集合的 $mex$ 值按顺序拼接起来字典序最大。 根据贪心，对于每个 $mex$ ，我们一定要选择值最大的前缀，如果有多个则选择前缀区间最短的。 如何算一个区间 $mex$ ？int p = 0; while(sum[p]) ++ p; 枚举每个元素，计算以它为结尾的区间 $mex$ ，如果后面的元素不存在 $mex$ 元素，那么就不可能对此 $mex$ 产生贡献，无论加再多元素，$mex$ 值也不会变，所以直接贪心取这个 $mex$ 值即可。 具体来说，只需要开两个桶，第一个桶用来记录当前区间的元素，第二个桶用来记录后面区间的元素即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/* さあ，Games始めましょうか */#include &lt;bits/stdc++.h&gt;using namespace std;/* all表示总桶，cur表示当前桶 */const int N = 200010;int a[N], all[N], cur[N], ret[N];void solve (){ int n, cnt = 0; cin &gt;&gt; n; for (int i = 0; i &lt;= n; i ++ ) all[i] = cur[i] = 0; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], ++ all[a[i]]; // p表示当前的mex值，last表示上一段区间的末尾位置 for (int i = 1, p = 0, last = 0; i &lt;= n; i ++ ) { ++ cur[a[i]]; while(cur[p]) ++ p; // 统计以当前元素为末尾的mex值 // 后面不存在p元素，那么后面的元素不会对mex产生贡献 if (!all[p]) { ret[++ cnt] = p; // 清空当前桶(cur)，更新记录后面元素的桶(all) for (int j = last + 1; j &lt;= i; j ++ ) cur[a[j]] = 0, -- all[a[j]]; last = i; p = 0; } } cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 1; i &lt;= cnt; i ++ ) cout &lt;&lt; ret[i] &lt;&lt; \" \\n\"[i == cnt];}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} D. Peculiar Movie Preferences题意给定 $n$ 个长度不超过 $3$ 的字符串，问是否存在一个子序列，使得其相应的字符串按顺序拼接后是一个回文串。 分析如果一个字符串本身就是回文，那么一定存在。 首先可以明确，如果存在一个子序列满足条件，那么一定存在长度为 $2$ 的子序列满足条件(因为长度最多为 $3$ ，只需要取满足条件的子序列的首尾元素即可)。 对于长度为 $2$ 的字符串，也就是 $2 + 2$ 的情况 ，只需要检查是否存在其逆序即可。 对于长度为 $3$ 的字符串，有 $3 + 3, 2 + 3, 3 + 2$ 三种情况，先检查其逆序是否存在，对于 $2 + 3$ ，把左端去掉，检查逆序是否在前面出现过即可，$3 + 2$ 同理。 Code1234567891011121314151617181920212223242526272829303132333435363738394041/* さあ，Games始めましょうか */#include &lt;bits/stdc++.h&gt;#define all(x) begin(x), end(x)using namespace std;void solve (){ int n; cin &gt;&gt; n; map&lt;string, int&gt; pre, post; vector&lt;string&gt; s(n); for (string &amp; str : s) cin &gt;&gt; str, ++ post[str]; for (string k : s) { string oth = k; reverse(all(oth)); // 2 + 2 or 3 + 3 if (pre[oth] || post[oth]) return cout &lt;&lt; \"YES\\n\", void(); if (k.size() == 3) { // 3 + 2 oth = k.substr(0, 2); reverse(all(oth)); if (post[oth]) return cout &lt;&lt; \"YES\\n\", void(); // 2 + 3 oth = k.substr(1, 2); reverse(all(oth)); if (pre[oth]) return cout &lt;&lt; \"YES\\n\", void(); } pre[k] ++ ; post[k] -- ; } cout &lt;&lt; \"NO\\n\";}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} E. Grid Xor题意存在 $n \\times n$ 的矩阵，每个位置 $a_{ij}$ 表示一个数。 给出另一个 $n \\times n$ 的矩阵，每个位置 $b_{ij}$ 表示矩阵 $a$ 对应位置相邻格子的值的异或和(相邻指上下左右四个方向)。 问矩阵 $a$ 所有元素的异或和为多少？(矩阵 $a$ 不唯一，但是其异或和一定是唯一的)。 分析要求矩阵 $a$ 所有元素的异或和，我们只要异或每个元素的奇数次即可。 根据递推，先异或所有 $b_{1j}$ ，这样第一行的所有元素的异或次数就确定了，从第二行开始递推，如果上一行异或次数为偶数，只能从这一行来异或。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344/* さあ，Games始めましょうか */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;const int dr[] = { -1, 0, 1, 0 }, dc[] = { 0, 1, 0, -1 };int n, g[N][N];bool is_even[N][N];void solve (){ int ret = 0; auto modify = [&amp;](int x, int y) -&gt; void { for (int i = 0; i &lt; 4; i ++ ) { int dx = x + dr[i], dy = y + dc[i]; is_even[dx][dy] = !is_even[dx][dy]; } ret ^= g[x][y]; }; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) cin &gt;&gt; g[i][j], is_even[i][j] = true; // 修改第一行 for (int i = 1; i &lt;= n; i ++ ) modify(1, i); for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (is_even[i - 1][j]) modify(i, j); cout &lt;&lt; ret &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Devu和鲜花","slug":"Devu和鲜花","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-23T05:14:40.000Z","comments":true,"path":"2022/02/16/Devu和鲜花/","link":"","permalink":"https://horb7.github.io/2022/02/16/Devu%E5%92%8C%E9%B2%9C%E8%8A%B1/","excerpt":"","text":"Devu 和鲜花题意Devu 有 $N$ 个盒子，第 $i$ 个盒子中有 $A_i$ 枝花。 同一个盒子内的花颜色相同，不同盒子内的花颜色不同。 Devu 要从这些盒子中选择 $M$ 枝花组成一束，求共有多少种方案。 若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。 结果需对 $10^9 + 7$ 取模之后方可输出。 输入格式第一行包含两个整数 $N$ 和 $M$ 。 第二行包含 $N$ 个空格隔开的整数，表示 $A_1, A_2, \\ldots , A_N$ 。 数据范围$1 \\le N \\le 20, 0 \\le M \\le 10^{14}, 0 \\le A_i \\le 10^{12}$ 。 分析 假设每个盒子的花的数量是无限的。 设 $x_i$ 为第 $i$ 个盒子取出来的花的数量。则求解 $x_1 + x_2 + \\ldots + x_N = M$ 的方案数，其中 $x_i \\ge 0$ 。 设 $y_i = x_i + 1$ 。 则问题变为 $y_1 + y_2 + \\ldots + y_n = M + N$ 的方案数，其中 $y_i \\ge 1$ 。 用隔板法求解，在 $M + N - 1$ 个间隔中插入 $N - 1$ 个隔板，则有 $C_{M + N - 1}^{N - 1}$ 中方案。 对于有限制的方案数量。 题目限制了 $x_i \\le A_i$ 。正难则反，我们用总方案数量减去不满足限制的方案数量就是满足限制的方案数量。 设 $s_i$ 表示第 $i$ 个限制不满足，即 $s_i : \\ x_i \\ge A_i + 1$ 。 记 $s_0$ 为所有方案。 那么总满足限制的方案数量为： $s_0 - |s_1 \\bigcup s_2 \\bigcup s_3 \\ldots \\bigcup s_N|= s_0 - \\sum_{1 \\le i \\le N}|s_i| + \\sum_{1 \\le i \\lt j \\le N}|s_i \\bigcap s_j| - \\ldots$ 求解 $s_i: $ 即求 $x_1 + x_2 + \\ldots + x_N = M$ ，其中 $x_i \\ge A_i + 1$ ，其他 $x \\ge 0$ 。 两边同时减 $A_i + 1$ ，则 $x_1 + x_2 + \\ldots + x_N = M - (A_i + 1)$ ，其中 $x_i \\ge 0$ 。 同理令 $y_i = x_i + 1$ 。 即 $y_1 + y_2 + \\ldots + y_N = M - (A_i + 1) + N$ ，$y_i \\ge 1$ 。 方案数量为 $C_{M - (A_i + 1) + N - 1}^{N - 1}$ 。 同理 $|s_i \\bigcap s_j| = C_{M - (A_i + 1) - (A_j + 1) + N - 1}^{N - 1}$ 。 由于 $N$ 范围很小，我们可以使用二进制枚举求出所有情况。 容斥复杂度为 $O(2^n)$ ，而每种情况处理需要 $O(n)$ 复杂度，所以总复杂度为 $O(2^n \\times n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;using ll = long long;const int N = 25, mod = 1e9 + 7;int qmi (int a, int k, int p = mod){ int res = 1; for (a %= p; k; k &gt;&gt;= 1, a = 1ll * a * a % p) if (k &amp; 1) res = 1ll * res * a % p; return res;}int down = 1;int C (ll m, int n){ if (m &lt; n) return 0; int res = 1; for (ll i = m; i &gt; m - n; i -- ) res = i % mod * res % mod; return 1ll * res * down % mod;}ll a[N];signed main (){ ll n, m, ret = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; i ++ ) down = 1ll * down * i % mod; down = qmi(down, mod-2); for (int s = 0; s &lt; 1 &lt;&lt; n; s ++ ) { int sign = 1; ll cm = m + n - 1; for (int j = 0; j &lt; n; j ++ ) if (s &gt;&gt; j &amp; 1) { cm -= a[j] + 1; sign *= -1; } ret = (ret + sign * C(cm, n-1)) % mod; } cout &lt;&lt; (ret + mod) % mod &lt;&lt; endl; return 0;}","categories":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/categories/math/"}],"tags":[{"name":"容斥原理","slug":"容斥原理","permalink":"https://horb7.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}]},{"title":"C++实现简易对拍器","slug":"c++实现简易对拍器","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-22T12:53:30.000Z","comments":true,"path":"2022/02/16/c++实现简易对拍器/","link":"","permalink":"https://horb7.github.io/2022/02/16/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/","excerpt":"","text":"利用C++实现简易对拍器我们有的时候写完了代码，提交到OJ上莫名其妙却wrong answer了，通常是算法写假了或者一些边界没有考虑。 为了减少手动造数据的耗时，我们可以使用对拍器自动生成数据并进行运算找到错误数据。 使用对拍器需要： 你的正确的看起来正确的代码和一份正确的代码（在比赛中可以写一份会TLE但是一定正确的代码）。 生成随机数据的文件。 用来实现对比两份代码输出结果的文件。 为了方便管理文件，不显得很乱，我把对拍器单独放进了当前目录下的一个文件夹，如图： 其中: check用来实现两份代码输出的比较 gen用来生成随机数据 force实现暴力算法 上一层目录的Horb7实现看起来正确的算法 toexe用来实现cpp文件的编译(太菜了用不来makefile) 原理根据gen文件生成随机数据至data.txt，再调用Horb7.exe和force.exe生成两份输出结果，再比较两份输出结果是否有不同，如果不同则显示 error 。 用法 编译好你写的两份代码 在gen.cpp中写入针对这道题目的数据的输入格式 运行check.exe 如果完全相同则会显示your program may be right.，否则会显示error!，并输出两份不同的输出结果。 实现由于我不会bat脚本各种原因，我选择用cpp文件实现输出比较，本质还是通过 windows.h 库调用dos命令。 check code12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;int main (){ int cnt = 32; // 比较32次 while (cnt -- ) { system(\"gen.exe &gt; data.txt\"); // 调用上一级写的可执行文件(system不支持相对路径) system(\"D:/VsCode/Code/Horb7.exe &lt; data.txt &gt; pros.txt\"); system(\"force.exe &lt; data.txt &gt; std.txt\"); if (system(\"fc pros.txt std.txt\")) { cout &lt;&lt; \"error!\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"your program may be right.\" &lt;&lt; endl; return 0;} gen code12345678910111213141516171819202122232425#include &lt;ctime&gt;#include &lt;random&gt;#include &lt;iostream&gt;using namespace std;// 获取一个[a, b]之间的整数（最大范围[0, 32757]）#define rd(a, b) (rand() % (b - a + 1) + a)int main(){ srand(time(0)); // 随机数种子 /* ---------------------------------------------------------*/ // 写出随机数据 int cases = 1; // T 组数据 cout &lt;&lt; cases &lt;&lt; endl; while(cases -- ) { // 根据题目输出具体格式的数据 for (int i = 1; i &lt;= 10; i ++ ) cout &lt;&lt; rd(1, 5) &lt;&lt; endl; }} toexe code12345678910#include &lt;windows.h&gt;int main (){ system(\"g++ check.cpp -o check\"); system(\"g++ force.cpp -o force\"); system(\"g++ gen.cpp -o gen\"); system(\"g++ D:/VsCode/Code/Horb7.cpp -o D:/VsCode/Code/Horb7\"); return 0;}","categories":[],"tags":[{"name":"project","slug":"project","permalink":"https://horb7.github.io/tags/project/"}]},{"title":"2021ICPC沈阳站","slug":"2021ICPC沈阳","date":"2022-02-16T14:54:28.236Z","updated":"2021-12-21T16:02:54.000Z","comments":true,"path":"2022/02/16/2021ICPC沈阳/","link":"","permalink":"https://horb7.github.io/2022/02/16/2021ICPC%E6%B2%88%E9%98%B3/","excerpt":"","text":"2021ICPC沈阳站B. Bitwise Exclusive-OR Sequence题意对于长度为 $n$ 的序列，给出 $m$ 个关系，第 $i$ 个关系形如 $a_j \\bigoplus a_k = w_i$ ，表示第 $j$ 个元素和第 $k$ 个元素的异或值为 $w_i$ ，问满足所有关系的条件下，这个序列的和最小为多少。如果无解，输出 $-1$ 。 分析对于关系 $a_j \\bigoplus a_k = w_i$ ，把 $j$ 点和 $k$ 点连一条边，边权为 $w_i$ 。 无解的情况下，明显一定是存在一个环，在环内各边权存在矛盾。对于每一个连通块，当我们确定其中一个点的点权，其他点的点权是确定的。 判断是否无解，我们只需要看边权是否矛盾，可以 $dfs$ 每个连通块，如果某个点的点权和邻接点的点权异或值不为边权，则无解。 对于有解的情况，枚举每个连通块的每一个位，对于其中一个点(初始点)可以为 $0$ 或 $1$ 。那么在某一位上我们只需要取这个连通块内所有点的 $min(nums_0, nums_1)$ 作为答案的贡献即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010, M = 400010;int n, m;int h[N], e[M], w[M], ne[M], idx;int val[N]; // 判断无解时用的点值bool st[N]; // dfs连通块，判断某个点是否遍历过int color[N][31]; // color(i, j) 表示第i个点在j位上的值（0 -&gt; 未涂色, 1 -&gt; 1, 2 -&gt; 0）void add (int a, int b, int c){ e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++ ;}// 判断是否无解void dfs (int u, int v){ val[u] = v; st[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (st[j]) continue; if (val[j] == -1) dfs(j, w[i] ^ val[u]); } for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if ((val[u] ^ val[j]) != w[i]) // 矛盾 { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); } }}// 找出某一位0和1的数量void dfs (int u, int &amp; one, int &amp; zero, int c, int bit){ color[u][bit] = c; st[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!color[j][bit]) { if (w[i] &gt;&gt; bit &amp; 1) { if (c == 1) ++ zero; else ++ one; dfs(j, one, zero, 3 - c, bit); } else { if (c == 1) ++ one; else ++ zero; dfs(j, one, zero, c, bit); } } }}int main (){ cout.tie(0)-&gt;sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for (int i = 0, u, v, w; i &lt; m &amp;&amp; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; i++ ) add(u, v, w), add(v, u, w); memset(val, -1, sizeof val); for (int i = 1; i &lt;= n; i ++ ) if (!st[i]) dfs(i, 1); long long res = 0; memset(st, 0, sizeof st); for (int i = 1; i &lt;= n; i ++ ) if (!st[i]) { for (int b = 30; b &gt;= 0; b -- ) { int one = 1, zero = 0; dfs(i, one, zero, 1, b); res = res + min(one, zero) * (1ll &lt;&lt; b); } } cout &lt;&lt; res &lt;&lt; endl; return 0;} F. Encoded Strings I题意给定一个长度为 $n$ 的字符串 $s$ 。对于每个前缀字符串 $pre_s$ ，将其重新编码，规则为： 设某个字符 $c$ 在 $pre_s$ 中最后一个位置为 $k$ ，$chr$ 为 $[k, len(pre_s)]$ 中不同字符的数量。那么把 $c$ 映射为第 $chr+1$ 个阿拉伯字母。 求出所有前缀字符串 $pre_s$ 最大的映射字符串。 分析$cnt$ 存储每个字符最后一位后面的不同字符。 从前往后遍历前缀，当加入一个字符时，这个字符最后一个位置变为末尾，$cnt$ 清空。对于其他在前面出现的字符，它的 $cnt$ 数组加上这个字符即可。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;int main (){ int n; cin &gt;&gt; n; string s, ret; cin &gt;&gt; s; map&lt;char, set&lt;char&gt; &gt; cnt; set&lt;char&gt; appear; for (int i = 0; i &lt; s.size(); i ++ ) { string cur; cnt[s[i]].clear(); appear.insert(s[i]); for (auto c : appear) if (s[i] != c) cnt[c].insert(s[i]); for (int j = 0; j &lt;= i; j ++ ) cur += char('a' + cnt[s[j]].size()); ret = max(ret, cur); } cout &lt;&lt; ret &lt;&lt; endl; return 0;} J. Luggage Lock题意有四位的密码锁，每次可以选择把一段连续的区间向上或者向下转动一格，问把初始状态转成目标状态至少需要多少次旋转。 分析对于某一位数字 $a_i$ ，如果要把他向上转动 $k$ 次，我们同样可以让他向下转动 $10 - k$ 次，每个数字都有两种状态（除了 $k=0$ ，也就是初始和目标相同，它可以向上转动 $10$ 次，也可以向下转动 $10$ 次，也可以选择不转动）。所以我们可以三进制枚举每一个旋转状态 $b_1b_2b_3b_4$ 。 当我们得到一个旋转状态后呢？我们需要把这个状态变为全 $0$ ，由于每次可以选择一段连续区间 $+1 \\ \\ or \\ \\ -1$ ，可以想到 差分数组 ，我们把状态变为全 $0$ 也就是意味着把差分数组变为全 $0$ 。 在一个差分数组中，变为全 $0$ 的最小代价为 $max(posi, |neg|)$ ，$posi$ 表示正数总和，$neg$ 表示负数总和。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;int rot[5], back[5];int main (){ int T; cin &gt;&gt; T; while( T -- ) { string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; 4; i ++ ) rot[i] = a[i] - b[i]; // 向上为正，向下为负 // 枚举每个数字的转动，向上或者向下（0有三种，所以要三进制枚举） int m = 3 * 3 * 3 * 3, ret = 1e9; for (int i = 0; i &lt; m; i ++ ) { int state = i; for (int j = 0; j &lt; 4; j ++ ) { if (state % 3 == 1) { // 为1，反方向旋转 if (rot[j] &gt; 0) back[j] = rot[j] - 10; else back[j] = 10 + rot[j]; } else if (state % 3 == 2 &amp;&amp; !rot[j]) { // 为2，特判rot为0，由于在模1的时候0为10，所以这里为-10 back[j] = -10; } else back[j] = rot[j]; state /= 3; } // 把旋转数组变为全0，即差分数组变为0 int posi = 0, neg = 0; // 差分数组变为0的次数：max(posi, neg) for (int j = 0; j &lt; 4; j ++ ) { int dif = (j ? back[j] - back[j-1] : back[j]); if (dif &gt; 0) posi += dif; else neg += dif; } ret = min(ret, max(posi, abs(neg))); } cout &lt;&lt; ret &lt;&lt; endl; } return 0;} J. Perfect Matchings题意对于一个 $2 * n$ 个顶点的完全图，删除给定的一颗生成树，求剩下图的完美匹配数量有多少。 完美匹配，指最大数量的边集合，集合内任意两条边都没有公共顶点。 分析 对于一个 $2 n$ 顶点的完全图，它的完美匹配数量有 $\\prod_{i=1}^{n}2i - 1$ 个。 把 $n$ 个顶点放到左边去匹配右边 $n$ 个，选择 $n$ 个顶点 $C_{2n}^{n}$ ，匹配为 $n!$ 。 然后对于每一个匹配边，它的一个结点在右边时贡献一次，左边时又贡献一次，所以要除以二。 所以完美匹配数量为 $\\dfrac{C_{2n}^{n} \\times n!}{2}$ 个。 把 $C_{2n}^{n}$ 中的偶数项除以二后与 $n!$ 抵消，所以匹配数量为 $1 \\times 3 \\times 5 \\ldots (2 \\times n - 1) = \\prod_{i=1}^{n}2*i - 1$ 。 容斥原理 用总的图的所有匹配数量减去其中有一些匹配边在生成树上的数量，枚举有几条边在生成树，减去所有不合法情况就是合法的情况。 计数dp，枚举在生成树上的不合法情况 设 $f(i, j, 0/1)$ 表示以 $i$ 为子树，匹配数量为 $j$ ，$i$ 参与/不参与匹配时的方案数量。 树上背包问题，设 $j$ 为 $i$ 的儿子，转移方程为： f(i, x + y, 0) += f(i, x, 0) * (f(j, y, 0) + f(j, y, 1)), y > 0 \\\\ f(i, x + y, 1) += f(i, x, 1) * (f(j, y, 0) + f(j, y, 1)), y > 0 \\\\ f(i, x + y + 1, 1) += f(i, x, 0) * f(j, y, 0)可以枚举每个 $i$ 子树的大小使复杂度达到 $O(n^2)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 4010, M = 8010, mod = 998244353;int n, m;int h[N], e[M], ne[M], idx;int siz[N]; // 每个子树的结点个数int f[N][N][2]; // f(i, j, k) 表示以i为根的树，取j个配对，i有无选中的方案数量int p[N]; // p(i) 表示i个结点组成的完全图可配对的数量void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}void dfs (int u, int fa){ f[u][0][0] = 1; siz[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; dfs(j, u); for (int x = siz[u] / 2; x &gt;= 0; x -- ) for (int y = siz[j] / 2; y &gt;= 0; y -- ) { if (y &gt; 0) { f[u][x + y][0] = (f[u][x + y][0] + 1ll * f[u][x][0] * (f[j][y][0] + f[j][y][1]) % mod) % mod; f[u][x + y][1] = (f[u][x + y][1] + 1ll * f[u][x][1] * (f[j][y][0] + f[j][y][1]) % mod) % mod; } f[u][x + y + 1][1] = (f[u][x + y + 1][1] + 1ll * f[u][x][0] * f[j][y][0] % mod) % mod; } siz[u] += siz[j]; }}signed main (){ int n; cin &gt;&gt; n; p[0] = 1; for (int i = 1; i &lt;= n; i ++ ) p[i] = 1ll * p[i-1] * (2 * i - 1) % mod; memset(h, -1, sizeof h); for (int i = 1, u, v; i &lt; 2 * n &amp;&amp; cin &gt;&gt; u &gt;&gt; v; i ++ ) add(u, v), add(v, u); dfs(1, -1); int res = 0; for (int i = 0; i &lt;= n; i ++ ) // 枚举生成树里的配对数量 { if (i &amp; 1) res = (1ll * res - 1ll * (f[1][i][0] + f[1][i][1]) * p[n - i] % mod) % mod; else res = (1ll * res + 1ll * (f[1][i][0] + f[1][i][1]) * p[n-i] % mod) % mod; } cout &lt;&lt; (res % mod + mod) % mod &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"区域站","slug":"区域站","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%AB%99/"}]},{"title":"钉子和小球","slug":"洛谷P5750-钉子和小球","date":"2021-12-15T04:34:12.000Z","updated":"2022-02-17T04:24:32.841Z","comments":true,"path":"2021/12/15/洛谷P5750-钉子和小球/","link":"","permalink":"https://horb7.github.io/2021/12/15/%E6%B4%9B%E8%B0%B7P5750-%E9%92%89%E5%AD%90%E5%92%8C%E5%B0%8F%E7%90%83/","excerpt":"","text":"钉子和小球题意如图的三角形木板上钉着 $\\dfrac{n(n+1)}{2}$ 个钉子，还有 $(n+1)$ 个格子，钉子均匀分布，其中有一些钉子被拆掉，问最后小球落在 $m$ 格子的概率为多少？ 分析概率DP，把格子也看作钉子。 设 $f(i, j)$ 表示经过 $(i, j)$ 位置的所有路径数量，那么到达 $m$ 格子的概率就是 $f(n+1, m) / f(1, 1)$ ，这是因为任何一个路径一定经过 $(1, 1)$ ，所以 $f(1, 1)$ 为 $2^n$ 。 对于一个位置 $(i, j)$ ，如果它有钉子，那么可以转移到左下角 $(i+1, j)$ 或者右下角 $(i+1, j+1)$ ，路径数量为一半。 如果它没有钉子，那么它会直接转移到下面正对着的两行的位置 $(i+2, j+1)$ 。 我们可以从上往下枚举。 注意初始化 $f(1, 1)$ 和 $f(2, 1) 、 f(2, 2)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 55;bool ext[N][N]; // 表示在(i, j)这个位置有无钉子ll f[N][N]; // f(i, j) 表示存在(i, j)的路径的数量void solve (){ int n, m; cin &gt;&gt; n &gt;&gt; m; m += 1; f[1][1] = (1ll &lt;&lt; n+1); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) { char c; cin &gt;&gt; c; if (c == '*') ext[i][j] = true; } if (ext[1][1]) f[2][1] = f[2][2] = (1ll &lt;&lt; n); // 每个位置有三种情况 for (int i = 3; i &lt;= n + 1; i ++ ) { for (int j = 1; j &lt;= i; j ++ ) { f[i][j] = f[i-1][j-1] / 2 * ext[i-1][j-1] + \\ f[i-1][j] / 2 * ext[i-1][j] + \\ f[i-2][j-1] * (!ext[i-2][j-1]); } } ll g = __gcd(f[n+1][m], f[1][1]); cout &lt;&lt; f[n+1][m] / g &lt;&lt; '/' &lt;&lt; f[1][1] / g &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(false); // int _; for (cin &gt;&gt; _; _ --; ) solve(); solve(); return 0;}","categories":[{"name":"DP","slug":"DP","permalink":"https://horb7.github.io/categories/DP/"}],"tags":[{"name":"期望DP","slug":"期望DP","permalink":"https://horb7.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]}],"categories":[{"name":"项目学习","slug":"项目学习","permalink":"https://horb7.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数据库","slug":"数据库","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"DP","slug":"DP","permalink":"https://horb7.github.io/categories/DP/"},{"name":"math","slug":"math","permalink":"https://horb7.github.io/categories/math/"}],"tags":[{"name":"区域赛","slug":"区域赛","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"},{"name":"每日一题","slug":"每日一题","permalink":"https://horb7.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Django","slug":"Django","permalink":"https://horb7.github.io/tags/Django/"},{"name":"树状数组","slug":"树状数组","permalink":"https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"LCA","slug":"LCA","permalink":"https://horb7.github.io/tags/LCA/"},{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"},{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"},{"name":"生成树","slug":"生成树","permalink":"https://horb7.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"tree","slug":"tree","permalink":"https://horb7.github.io/tags/tree/"},{"name":"贪心","slug":"贪心","permalink":"https://horb7.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"线段树","slug":"线段树","permalink":"https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"},{"name":"Linux","slug":"Linux","permalink":"https://horb7.github.io/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"https://horb7.github.io/tags/MySql/"},{"name":"字符串","slug":"字符串","permalink":"https://horb7.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"环形DP","slug":"环形DP","permalink":"https://horb7.github.io/tags/%E7%8E%AF%E5%BD%A2DP/"},{"name":"树","slug":"树","permalink":"https://horb7.github.io/tags/%E6%A0%91/"},{"name":"堆","slug":"堆","permalink":"https://horb7.github.io/tags/%E5%A0%86/"},{"name":"并查集","slug":"并查集","permalink":"https://horb7.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://horb7.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"project","slug":"project","permalink":"https://horb7.github.io/tags/project/"},{"name":"区域站","slug":"区域站","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%AB%99/"},{"name":"期望DP","slug":"期望DP","permalink":"https://horb7.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]}