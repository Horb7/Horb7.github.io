{"meta":{"title":"Horb7's blog","subtitle":"一日事，一日毕","description":"","author":"Horb7","url":"https://horb7.github.io","root":"/"},"pages":[{"title":"Gallery","date":"2022-02-24T16:07:11.471Z","updated":"2021-12-21T15:03:44.000Z","comments":true,"path":"gallery/index.html","permalink":"https://horb7.github.io/gallery/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-19T02:31:54.000Z","updated":"2022-02-25T02:11:16.425Z","comments":true,"path":"categories/index.html","permalink":"https://horb7.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2019-10-13T07:49:05.000Z","updated":"2022-02-24T16:08:40.191Z","comments":true,"path":"/404.html","permalink":"https://horb7.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2022-02-24T16:02:30.695Z","comments":true,"path":"link/index.html","permalink":"https://horb7.github.io/link/index.html","excerpt":"","text":""},{"title":"About","date":"2022-02-16T14:54:28.240Z","updated":"2021-12-25T01:10:44.000Z","comments":true,"path":"about/index.html","permalink":"https://horb7.github.io/about/index.html","excerpt":"","text":"关于我菜到无法自拔却想学各种东西那件事。 Profile 计算机本科在读（就读于全球某工商大学） 六级可能没过 想要入门全栈 codeforces想要上16001900 $Nothing \\ \\ to \\ \\ write.$"},{"title":"记录一些遇到的编程语法问题","date":"2022-02-16T14:54:28.251Z","updated":"2022-01-26T14:10:18.000Z","comments":true,"path":"trick/index.html","permalink":"https://horb7.github.io/trick/index.html","excerpt":"","text":"关于sort中cmp的写法在比较函数中，一定要按照比较函数规定写，即只能写 $a &gt; b$ 或 $a &lt; b$ 。 坚决不能写 $a \\le b$ 或 $a &gt;= b$ 或 $a = b$ 等形式。一来加上等于不会改变结果（本身就是不稳定排序），二来加了等于可能会引起段错误。"},{"title":"标签","date":"2021-12-19T02:33:11.000Z","updated":"2022-02-25T02:10:53.481Z","comments":true,"path":"tags/index.html","permalink":"https://horb7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2022昆明","slug":"2022昆明","date":"2022-04-19T01:09:19.000Z","updated":"2022-04-19T01:09:41.936Z","comments":true,"path":"2022/04/19/2022昆明/","link":"","permalink":"https://horb7.github.io/2022/04/19/2022%E6%98%86%E6%98%8E/","excerpt":"","text":"K. King of Games题意给定一个系数 $x = \\dfrac a b$ 。 进行 $n$ 次比赛，如果对于当前比赛，在之前进行过 $m$ 次比赛，已经产生 $k$ 次胜场，则： $\\dfrac k m \\le x$ ，则当前比赛胜利。 否则当前比赛失败。 给定 $n, a, b$ ，求进行 $n$ 局后，一共有多少胜场。 分析结论是 $(n-1) \\times a / b + 1$ ，不能取 $double$ ，具体原因还不清楚，等之后再更新。 Code1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int T; cin &gt;&gt; T; while( T -- ) { int n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (long long) (n - 1) * a / b + 1 &lt;&lt; endl; } return 0;} D. Divisions题意对于长度为 $n$ 的序列 $S$ ，将其划分为两个子序列 $S_1, S_2$ ，一共有 $2^n$ 种划分方式。 定义序列的权值 $k$ 为：有 $k$ 种方式划分两个子序列，使得 $S_1, S_2$ 满足： $S_1$ 单调不下降，$S_2$ 单调不上升。 给定 $k$ ，构造出 $S$ ，要求 $|S| \\le 365$ 。 其中 $0 \\le k \\le 10^8$ 。 分析因为划分其中一个之后，还要判断剩下的是否满足另外一个条件，这样很不好判断。 我们可以 “固定” 其中一个子序列 $S_1$ ：构造出如 “112233344……” 这样的形式。 那么，对于任意一种划分，$S_1$ 一定满足，有 $2^n &gt; k$ ，那么只需要构造 $k$ 个$S_2$ 即可 。 由于构造的是最长不下降序列，那么 $S_2$ 一定是在某一个数字段上选择，即选择相同的数字 。 对于每一段数字段，假设长度为 $n$ ，那么会产生 $2^n - 1$ 个对 $S_2$ 的贡献。 注意： $S_2$ 可以取空集，所有要使 $k -= 1$ ，即构造 $k-1$ 个非空 $S_2$ 。 坑点：由于每次只能构造 $2^n - 1$ 的贡献，因此不能根据 “每个数字能被若干个二次幂表示，所以要使用 while” ，具体看代码。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int k; cin &gt;&gt; k; if (k == 1) { cout &lt;&lt; \"6\\n1 1 4 5 1 4\\n\"; return 0; } else if (k == 0) { cout &lt;&lt; \"8\\n1 2 3 1 2 3 1 2\\n\"; return 0; } vector&lt;int&gt; ans; int now = 1; k -= 1; for (int i = 29; i &gt;= 1; i -- ) { // 这里是产生 2^n-1 的贡献，注意要使用while, 比如 k = 30, 只能取 2^4-1，需要取两次，因为 [1, 3] 的幂不能构造出剩下的 15 while (k &gt;= (1 &lt;&lt; i) - 1) { k -= (1 &lt;&lt; i) - 1; for (int j = 0; j &lt; i; j ++ ) { ans.push_back(now); } ++ now; } } cout &lt;&lt; ans.size() &lt;&lt; endl; for (int v: ans) cout &lt;&lt; v &lt;&lt; ' '; return 0;} F. Find the Maximum题意给定一棵 $n$ 节点的树，选出一条简单路径，求 $\\max \\dfrac {\\sum_{u \\in V} (-x^2 + b_ux)} {|V|}$ 。其中 $V$ 表示路径上的点集，$x$ 为任意实数。 分析假设 $|V| = j$ 。 那么有 \\begin{equation} \\dfrac {\\sum_{u \\in V} (-x^2 + b_ux)} {|V|} \\\\ = \\dfrac {-jx^2 + (\\sum_{i=1}^j b_i)x} {j} \\\\ = -x^2 + \\dfrac {(\\sum_{i=1}^j b_i)x} {j} \\\\ = -(x - \\dfrac {\\sum_{i=1}^j b_i} {2j})^2 + (\\dfrac {\\sum_{i=1}^j b_i} {2j})^2 \\\\ = -(x - \\dfrac {\\sum_{i=1}^j b_i} {2j})^2 + (\\dfrac {\\sum_{i=1}^j b_i} {j})^2 \\times \\dfrac 1 4 \\end{equation}关于 $x$ 的项一定 $\\le 0$ ，取其为 $0$ 即可。 那么最大值就是取得的所有点值的平均值，平方后再乘上 $\\dfrac 1 4$ 。 因为要取平方，所以要取的应该是平均值的绝对最大值。 对于平均值的最大值，它一定出现在选 $2$ 个点或者 $3$ 个点的情况下，所以枚举选哪个即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int n, b[N];vector&lt;int&gt; g[N];double solve (){ double ans = 0; for (int i = 1; i &lt;= n; i ++ ) { vector&lt;int&gt; v; for (int j: g[i]) v.push_back(b[j]); sort(v.begin(), v.end(), greater&lt;&gt;()); ans = max(ans, (v[0] + b[i]) / 2.0); if (v.size() &gt;= 2) ans = max(ans, (v[0] + v[1] + b[i]) / 3.0); } return ans;}int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i]; for (int i = 1; i &lt; n; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } double ans = solve(); for (int i = 1; i &lt;= n; i ++ ) b[i] = -b[i]; ans = max(ans, solve()); cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; (ans * ans / 4) &lt;&lt; endl; return 0;} B. Blocks题意给定 $n$ 个矩形，最初整个二维平面都是白色的。 每次随机从 $n$ 个矩形中选择一个，将其涂成黑色（已经涂过的也可能被选择）。 问：将 $[(0, 0), (W, H)]$ 矩形填满的期望次数是多少，答案对 $998244353$ 取模。 其中 $1 \\le n \\le 10$ 。 分析由于 $n$ 很小，可以考虑使用状态压缩，即状压dp。 使用 $dp$ 来记录到达目标状态的期望步数，那么只需要输出 $dp[0]$ 即可。 能够将给定矩形涂满的状态有多个，我们可以使用 $good$ 数组记录所有这样的状态。 从目标状态出发，即倒着枚举所有的状态，进行状态转移。 对于当前状态，我们记录 $1$ 的个数为 $cnt$ 。 那么有转移公式： \\begin{equation} dp[i] = 1 + \\dfrac {cnt} n \\times dp[i] + \\sum_{第j位为0} \\dfrac {dp[i|(1","categories":[],"tags":[{"name":"区域站","slug":"区域站","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%AB%99/"}]},{"title":"计算机组成原理复习","slug":"计算机组成原理复习","date":"2022-03-24T04:35:43.000Z","updated":"2022-03-24T04:35:43.247Z","comments":true,"path":"2022/03/24/计算机组成原理复习/","link":"","permalink":"https://horb7.github.io/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Codeforces Round 659(Div.2)","slug":"Codeforces-Round-659-Div-2","date":"2022-03-23T08:05:10.000Z","updated":"2022-03-23T08:37:34.912Z","comments":true,"path":"2022/03/23/Codeforces-Round-659-Div-2/","link":"","permalink":"https://horb7.github.io/2022/03/23/Codeforces-Round-659-Div-2/","excerpt":"","text":"A. Common Prefixed题意构造一个字符串数组，使得对于给定的序列 $a$ ，满足第 $i$ 个和第 $i+1$ 个字符串的最长公共前缀为 $a_i$ 。 分析初始构造一个足够长的字符串，每次只需要修改 $a_i$ 的位置上的字符即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;void solve (){ string now = string(55, 'a'); int n; cin &gt;&gt; n; cout &lt;&lt; now &lt;&lt; endl; for (int i = 1; i &lt;= n; i ++ ) { int x; cin &gt;&gt; x; if (now[x] == 'a') now[x] = 'b'; else now[x] = 'a'; cout &lt;&lt; now &lt;&lt; endl; }}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} B. Koa and the Beach题意给定长度为 $n$ 的数组 $d$ ，在一个长度为 $2 \\times k$ 的循环周期内，前 $k$ 秒中的每一秒，$d_i = d_i + 1$，后 $k$ 秒中的每一秒，$d_i = d_i - 1$ ，从数组左端点(第一个元素的左边)出发，每次可以选择走到下一个位置或者等待，需要满足任意时刻所在的元素 $d_i \\le l$ ，问最少需要多少秒才能走出这个数组(最后一个元素的右边) 。 其中 $1 \\le n \\le 3 \\times 10^5, 1 \\le k, l \\le 10^9$ 。 分析贪心，从所有绝对安全点（即满足 $d_i + k &lt;= l$ 的点）出发，此时最好的情况一定是从第 $k$ 秒出发，这样后面的元素都是往下的。 注意 $0$ 号点和 $n + 1$ 号点，即起点和终点也是绝对安全点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 300010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int n, k, l;int a[N];void solve (){ cin &gt;&gt; n &gt;&gt; k &gt;&gt; l; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; vector&lt;int&gt; safe(1, 0); // 初始点 for (int i = 1; i &lt;= n; i ++ ) if (a[i] + k &lt;= l) safe.push_back(i); safe.push_back(n + 1); for (int i = 1; i &lt; safe.size(); i ++ ) { int down = true, tide = k; for (int j = safe[i-1] + 1; j &lt; safe[i]; j ++ ) { tide += down ? -1 : 1; // 需要在前面的位置等待多少秒 if (down) tide -= max(0, a[j] + tide - l); if (tide &lt; 0 || a[j] + tide &gt; l) return cout &lt;&lt; \"NO\\n\", void(); if (tide == 0) down = false; } } cout &lt;&lt; \"YES\\n\";}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} C. String Transformation 1题意给定长度为 $n$ 的两个字符串 $a, b$ 。每次可以选择 $a$ 字符串中的若干个相同的字符，将他们统一变成更大的字符。 问最少需要操作多少次才能使 $a = b$ ？ 分析首先，如果可以在若干次操作后使得 $a = b$ ，那么对于任意位置 $i$ ，满足 $a_i \\le b_i$ 。 从小的字符开始转换，把他们全部转化为最小的 $b_i$ 。比如对于 $a-c, a-f, a-t$ ，把 $a$ 全部变为最小的 $c$ 。 这样不会使结果更差。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 300010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;bool f[26][26];string s1, s2;void solve (){ memset(f, 0, sizeof f); int n; cin &gt;&gt; n; cin &gt;&gt; s1 &gt;&gt; s2; for (int i = 0; i &lt; n; i ++ ) { if (s1[i] &gt; s2[i]) return cout &lt;&lt; \"-1\\n\", void(); if (s1[i] &lt; s2[i]) f[s1[i]-'a'][s2[i]-'a'] = true; } int ans = 0; rep(i, 0, 25) rep(j, i + 1, 25) if (f[i][j]) { ++ans; rep(k, j + 1, 25) f[j][k] |= f[i][k]; break; } cout &lt;&lt; ans &lt;&lt; endl;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} D. GameGame题意给定长度为 $n$ 的序列，两位选手每次选择其中一个元素，并把该元素从序列中删除。 两位选手最后的得分为所选择的元素的异或和，问是否先手必胜，或者平局。 分析异或操作不会产生进位，对于每一位，异或操作都是独立的，那么我们可以对于每一位独立分析。 从高位到低位分析，对于当前位： 假设有 $c1$ 个 $1$ ，$c0$ 个 $0$ 。那么有如下结论: $c1 \\ \\ \\% \\ \\ 2 \\ \\ = \\ \\ 0$ ：一定为平局。 记两个选手拿的 $1$ 数量为 $k_1, k_2$ ，那么显然有 $k_1$ 和 $k_2$ 同奇同偶，在这一位异或值相同。 $c1 \\ \\ \\% \\ \\ 4 \\ \\ = \\ \\ 3 \\ \\ \\&amp;\\&amp; \\ \\ c0 \\ \\ \\% \\ \\ 2 \\ \\ = \\ \\ 0$ ：先手必败 后手模仿先手的动作，最后一定会等价于 $(c1=3, c0=0)$ 的状态，那么先手拿 $2$ 个 $1$ ，异或为 $0$ ，后手拿 $1$ 个 $1$ ，异或为 $1$ 。 $c1 \\ \\ \\% \\ \\ 4 \\ \\ = \\ \\ 3 \\ \\ \\&amp;\\&amp; \\ \\ c0 \\ \\ \\% \\ \\ 2 \\ \\ != \\ \\ 0 \\ \\ || \\ \\ c1 \\ \\ \\% \\ \\ 4 \\ \\ = \\ \\ 1$ ：先手必胜 对于前面的情况，最后等价于 $(c1=3, c0=1)$ 的状态，先手拿一个 $0$ ，转化为先手必败。 对于后面的情况，先手先拿 $1$ 个 $1$ ，再模仿后手的动作，即最后先手拿到 $2 \\times k + 1$ 个 $1$ ，异或为 $1$ ，后手拿到 $2 \\times k$ 个 $1$ ，异或为 $0$ 。 当某一位确定必胜或者必败后，剩下的位不需要再判断，否则继续向低位判断即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 300010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int n, a[N];void solve (){ cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i]; bool win = 0, lose = 0; for (int i = 30; i &gt;= 0; i -- ) { int c1 = count_if(a + 1, a + n + 1, [&amp;](int x) { return x &gt;&gt; i &amp; 1; }); int c0 = n - c1; if (c1 % 2 == 0) continue; if (c1 % 4 == 3 &amp;&amp; c0 % 2 == 0) lose = true; else win = true; if (win || lose) break; } if (win) cout &lt;&lt; \"WIN\\n\"; else if (lose) cout &lt;&lt; \"LOSE\\n\"; else cout &lt;&lt; \"DRAW\\n\";}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 717(Div.2)","slug":"Codeforces-Round-717-Div-2","date":"2022-03-18T09:26:05.000Z","updated":"2022-03-23T08:07:23.840Z","comments":true,"path":"2022/03/18/Codeforces-Round-717-Div-2/","link":"","permalink":"https://horb7.github.io/2022/03/18/Codeforces-Round-717-Div-2/","excerpt":"","text":"B. AGAGA XOOORRR题意给出长度为 $n$ 的序列，每次操作可以选择两个相邻的元素 $a, b$ ，将其合并为一个数字 $a \\bigoplus b$ 。 问：若干次操作后，能否使得序列长度不为 $1$ 且所有数字都相同？ 分析对于 $n = 2$ 的情况，直接判断两个元素是否相同即可。 当 $n &gt; 2$ 时，由于 $\\bigoplus$ 具有交换性，即 $a \\bigoplus b = c$ ，则 $a = b \\bigoplus c$ ，所以如果所有元素异或和为 $0$ ，就一定可以使操作后序列长度为 $2$ 且元素相等。 如果元素异或和不为 $0$ ，要想使最后所有元素相等，即最后一定剩下奇数个相等的元素，其值就是所有元素的异或和，直接模拟判断即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int a[N];void solve (){ int n, sum = 0; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i], sum ^= a[i]; if (n == 2) return cout &lt;&lt; (a[1] == a[2] ? \"YES\\n\" : \"NO\\n\"), void(); if (!sum) return cout &lt;&lt; \"YES\\n\", void(); int ans = 0, now = 0; rep(i, 1, n) { now ^= a[i]; if (now == sum) ++ ans, now = 0; } cout &lt;&lt; (ans &gt;= 2 ? \"YES\\n\": \"NO\\n\");}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} C. Baby Ehab Partitions Again题意给定长度为 $n$ 的序列，定义 $good$ 序列为： 将序列划分为任意两个子序列 $s_1, s_2$ ，都不存在 $sum_{s_1} = sum_{s_2}$ ，则称这个序列为 $good$ 序列。 问：需要删除最少多少个元素，可以使得给定序列为 $good$ 序列？ 分析 序列和为奇数，那么一定为 $good$ 序列，因为不可能存在两个划分的子序列和相等。 序列和为偶数： 如果这个序列为 $good$ 序列，输出 $0$ 即可。 否则我们可以每次将序列里元素除以 $2$ ，因为这不会改变非 $good$ 序列的性质，也就是元素和一定也为偶数。如果有一个元素为奇数，那么直接将这个元素删除即可。 接下来只需要知道如何判断原始序列是否为 $good$ 序列了。 设 $f(i)$ 表示取序列若干元素可以达到 $i$ 这个元素和，那么考虑所有元素对 $f$ 的影响，也就是01背包，判断 $f(sum/2)$ 是否可以就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int a[N];void solve (){ int n, sum = 0; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i], sum += a[i]; if (sum &amp; 1) return cout &lt;&lt; \"0\\n\", void(); bitset&lt;200010&gt; bit; bit[0] = 1; rep(i, 1, n) bit |= bit &lt;&lt; a[i]; if (!bit[sum / 2]) return cout &lt;&lt; \"0\\n\", void(); while(true) rep(i, 1, n) if (a[i] &amp; 1) return cout &lt;&lt; \"1\\n\" &lt;&lt; i &lt;&lt; '\\n', void(); else a[i] &gt;&gt;= 1;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;} D. Cut题意给定长度为 $n$ 的序列，给定 $q$ 次询问，每次询问如下： 给定 $l, r$ ，问：将 $[l, r]$ 划分为若干子区间，使每个子区间的乘积等于子区间元素的最小公倍数，问划分子区间数量最小为多少？ 其中 $1 \\le n, q \\le 10^5, 1 \\le a_i \\le 10^5$ 。 分析从区间为 $2$ 分析：$LCM(a, b) = a \\times b / GCD(a, b)$ ，所以如果要满足区间元素乘积等于区间元素最小公倍数，必须要满足区间内所有元素互质 。 设 $go(i)$ 表示 $i$ 位置之后与 $a_i$ 不互质 的元素的位置，每一次都往 $go(i)$ 跳，即跳到下一个区间的第一个元素位置，一定可以使得子区间划分数量最小。 在最坏情况下，所有元素都是不互质的，那么每次询问都是 $O(n)$ 的复杂度，会超时。 可以采用倍增思想，设 $st(i, j)$ 表示 $i$ 位置元素跳了 $2^j$ 步后到达的位置，每一次跳都是跳不互质的下一个位置。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int n, q;int a[N], go[N], st[N][21], nxt[N]; // nxt记录质因子出现的最近位置void solve (){ cin &gt;&gt; n &gt;&gt; q; rep(i, 1, n) cin &gt;&gt; a[i]; // go记录每个数字跳到下一个与其不互质的数字的位置，也就是下一个区间第一个数字 memset(nxt, INF, sizeof nxt); memset(go, INF, sizeof go); memset(st, INF, sizeof st); // 求go数组 for (int i = n; i &gt;= 1; i -- ) { int t = a[i]; for (int j = 2; j &lt;= t / j; j ++ ) { if (t % j) continue; go[i] = min(go[i], nxt[j]); while(t % j == 0) t /= j; nxt[j] = i; } if (t != 1) { go[i] = min(go[i], nxt[t]); nxt[t] = i; } go[i] = min(go[i], go[i+1]); } // 预处理st表 for (int i = 1; i &lt;= n; i ++ ) st[i][0] = go[i]; for (int j = 1; j &lt; 21; j ++ ) for (int i = 1; i &lt;= n; i ++ ) { if (st[i][j-1] &gt; n) break; st[i][j] = st[st[i][j - 1]][j - 1]; } // 求出答案 while(q -- ) { int l, r, ans = 1; cin &gt;&gt; l &gt;&gt; r; for (int i = 20; i &gt;= 0; i -- ) if (st[l][i] &lt;= r) { ans += 1 &lt;&lt; i; l = st[l][i]; } cout &lt;&lt; ans &lt;&lt; endl; }}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 692(Div.2)","slug":"Codeforces-Round-692-Div-2","date":"2022-03-17T15:44:51.000Z","updated":"2022-03-23T08:06:54.925Z","comments":true,"path":"2022/03/17/Codeforces-Round-692-Div-2/","link":"","permalink":"https://horb7.github.io/2022/03/17/Codeforces-Round-692-Div-2/","excerpt":"","text":"C. Peaceful Rooks题意在 $n \\times n$ 的棋盘上有 $m$ 个车，每辆车都能对同行或者同列的其他车造成攻击。 给定 $m$ 个棋盘的初始状态（保证不互相攻击），每次操作都可以移动一次车到同行或者同列的位置，但要保证放置后不能处在可以被攻击的位置上。 问：至少需要操作几次，可以使得每辆车都处在正对角线上。 其中 $2 \\le n \\le 2 \\times 10^5, 1 \\le m \\lt n$ 。 分析在不考虑移动的位置会造成攻击的情况下，由于初始位置保证互相不处在攻击位置，所以每辆车，如果不处在主对角线上，那么将其 $(x, y)$ 移动到 $(y, y)$ ，即每辆车都向 $y$ 移动，这样保证不会有冲突，那么最少的移动次数就是不在主对角线的车的数量。 考虑移动会造成冲突的情况，由于每辆车都是沿 $y$ 轴移动的，我们把 $x -&gt; y$ 这样的移动看作一条边，那么当图出现环的时候，比如 $1-&gt;2-&gt;3-&gt;1$ ，那么我们可以选择一个点移动到不产生冲突的位置，破坏环，然后环上的每辆车都可以只移动一次，比如移动 $1$ ，那么就可以把 $y=3$ 移动到 $y=1$ ，然后把 $y=2$ 移动到 $y=3$ ，再移动 $y = 1$ 到 $y=3$ 即可。 也就是说，对于每个环，都会多产生一次移动，只需要求出有多少环即可。 由于这一题的环只可能是简单环，那么可以使用并查集求联通块，如果 $x-&gt;y$ 且 $x$ 和 $y$ 在一个联通块，就是形成了环。（可以画图理解形成环的过程） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int n, m, p[N];int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void solve (){ cin &gt;&gt; n &gt;&gt; m; iota(p + 1, p + n + 1, 1); int ans = 0; rep(i, 1, m) { int x, y; cin &gt;&gt; x &gt;&gt; y; if (x == y) continue; ++ ans; x = find(x), y = find(y); if (x == y) ++ ans; else p[x] = y; } cout &lt;&lt; ans &lt;&lt; endl;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} D. Grime Zoo题意给出由 $0, 1, ?$ 组成的字符串 $s$ ，你可以向每个 $?$ 填入 $0$ 或 $1$ 。 定义字符串的价值为 $x \\times a + y \\times b$ ，其中 $x, y$ 为给定的系数，$a, b$ 分别表示 $01$ 和 $10$ 子序列的数量。 求出字符串 $s$ 的最小价值。 分析当字符串的 $0$ 的数量和 $1$ 的数量固定时，$01$ 子序列数量 $+$ $10$ 子序列的数量是相等的。 当 $x \\le y$ 时，我们要尽量让 $01$ 子序列出现的次数多，也就是要让 $1$ 尽量出现在后面，那么在问号里填的数字一定是 $0$ 在前面， $1$ 在后面。 同理，当 $x \\gt y$ 时，我们要尽量让 $10$ 子序列出现的次数多，也就是让 $0$ 尽量出现在后面，那么在问号里填的数字一定是 $1$ 在前面，$0$ 在后面。 虽然不知道问号里 $0$ 和 $1$ 的数量，但是它们都是全部出现在一侧的，所以我们可以先假设问号全为 $1$ ，然后枚举某一侧 $0$ 的数量 (就是把 $1$ 改为 $0$) 。 比如现在 $x \\le y$ ，那么从前往后枚举 $?$ 序列的各位置，把当前数字改为 $0$ ，我们可以先求出一开始（问号全为 $1$）的价值，然后减去当前问号为 $1$ 时对价值的贡献(前面有多少个 $0$ 和已经修改过的 $?$， 以及后面有多少 $0$)，再加上当前问号为 $0$ 时对价值的贡献，这样就求出了到这个位置所有问号都为 $0$ 且后面问号都为 $1$ 时的价值。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;vector&lt;int&gt; all_qus; // 所有问号的位置int st[N][3], ed[N][3]; // st记录前缀，ed记录后缀void solve (){ string s; cin &gt;&gt; s; s = ' ' + s; int x, y; cin &gt;&gt; x &gt;&gt; y; // 预处理每个元素的前缀和后缀数量 for (int i = 1; i &lt; s.size(); i ++ ) { if (s[i] == '?') st[i][2] = 1, all_qus.push_back(i); else st[i][s[i]-'0'] = 1; for (int j = 0; j &lt; 3; j ++ ) st[i][j] += st[i-1][j]; } for (int i = s.size() - 1; i &gt;= 1; i -- ) { if (s[i] == '?') ed[i][2] = 1; else ed[i][s[i]-'0'] = 1; for (int j = 0; j &lt; 3; j ++ ) ed[i][j] += ed[i+1][j]; } // 一开始把所有的？当作1处理，最后枚举分割线的时候，其实就是把某一段变成0的过程 ll ans = 0; for (int i = 1; i &lt;= s.size() - 1; i ++ ) { if (s[i] == '0') ans += (ll)(st[i-1][1] + st[i-1][2]) * y; else ans += (ll)st[i-1][0] * x; } ll ret = ans; // res为最终的答案 if (x &lt; y)// 假如01的代价小，那么尽量把1放在后面，问号整体分为01 { // 枚举分割点 for (int i = 0; i &lt; all_qus.size(); i ++ ) { int p = all_qus[i]; // 把当前点改为0，减去当前点为1的贡献 ans -= (ll)(st[p-1][0]+st[p-1][2]) * x + (ll)ed[p+1][0] * y; // 增加当前点为0的贡献 ans += (ll)st[p-1][1] * y + (ll)(ed[p+1][1] + ed[p+1][2]) * x; ret = min(ret, ans); } } else { // 把问号分割为10 for (int i = all_qus.size() - 1; i &gt;= 0; i -- ) { int p = all_qus[i]; // 把当前点改为0，减去当前点为1的贡献 ans -= (ll)st[p-1][0] * x + (ll)(ed[p+1][2] + ed[p+1][0]) * y; // 增加当前点为0的贡献 ans += (ll)(st[p-1][1] + st[p-1][2]) * y + (ll)ed[p+1][1] * x; ret = min(ret, ans); } } cout &lt;&lt; ret &lt;&lt; endl;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;} E. Poman Numbers题意给出长度为 $n$ 的字符串 $s$ (小写字符组成)，定义字符串区间为 $[l, r]$ 的价值 $f([l, r])$ 为： $f[l, r] = f[m+1, r] - f[l, m]$ ，当 $l \\ \\ != \\ \\ r$ $f[l, l] = 2^k$ ，其中 $k$ 为 $s[l]$ 在字符集的次序，即 $k = s[i] - ‘a’$ 。 其中 $m$ 为你自己选择的数字，介于 $[l, r]$ 之间。 问能否在每次决策的时候都选择合适的 $m$ 值，使得 $f(1, n) = T$ 。 分析首先，根据递归性质，每个字符都会造成绝对值为 $2^{k_i}$ 的贡献，但是系数有正有负。 注意到最后一个字符造成的贡献一定为正的，因为它一定是每次选择右区间才能达到。 同时倒数第二个字符造成的贡献一定是负的，因为它一定是恰好选择一次左区间达到的。 而前面 $n-2$ 个字符的系数都是可正可负的，都是合法的。 证明： 当 $s$ 只有一个字符造成正贡献，那么对于每一段，取 $m = l$ 即可。 假设 $s$ 有至少两个正贡献，由于前面分析了对于合法方案的序列，最后两个符号一定是 $-+$ ，也就是对于选定的 $m$ ，一定有 $s[m-1] = ‘+’, s[m] = ‘-‘$ （这是因为倒数第二个字符一定为 $’-‘$，所以一定可以构造）。然后划分成两个子问题，从而递归地证明。 那么问题就变成了：给定 $n$ 个数字，最后两个数字的系数为 $-+$ ，前面 $n-2$ 个数字系数可正可负，问能否构造 $T$ 。 先令 $T = T - a[n] + a[n-1]$ ，去除后面两个数字的影响。 然后对前面 $n-2$ 个数字降序排序，贪心地构造：当 $T &lt; 0$ 时，取当前数字为正数，否则取负数。 证明：当 $T &lt; 0$ 时取当前数字为负数，并且可以使最后 $T = 0$ ，那么可以简化为： 发现这就是前后顺序的关系，但是这样很难知道是否后面一定能构造，所以选前面的方案不会更差。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;void solve (){ ll n, t; cin &gt;&gt; n &gt;&gt; t; string s; cin &gt;&gt; s; s = ' ' + s; if (n == 1) return cout &lt;&lt; ((1 &lt;&lt; (s[n] - 'a') == t ? \"Yes\\n\" : \"No\\n\")), void(); t = t - (1 &lt;&lt; (s[n] - 'a')) + (1 &lt;&lt; (s[n-1] - 'a')); vector&lt;ll&gt; a(n-2); rep(i, 1, n-2) a.push_back(1 &lt;&lt; (s[i] - 'a')); sort(all(a), greater&lt;int&gt;()); forr(x, a) if (t &lt; 0) t += x; else t -= x; cout &lt;&lt; (t ? \"No\\n\" : \"Yes\\n\");}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 695(Div.2)","slug":"Codeforces-Round-695-Div-2","date":"2022-03-15T16:37:05.000Z","updated":"2022-03-15T17:21:38.286Z","comments":true,"path":"2022/03/16/Codeforces-Round-695-Div-2/","link":"","permalink":"https://horb7.github.io/2022/03/16/Codeforces-Round-695-Div-2/","excerpt":"","text":"A. Wizard Orz题意给定长度为 $n$ 的序列，初始每个元素都为 $0$ ，每一时刻过后，每个元素值加一（模10意义下）。 选择一个下标 $index$ ，将其在某个时刻时间暂停，与他距离为 $d$ 的元素会在 $d$ 时刻后时间暂停。 在所有元素都暂停后，可以得到一个新序列。 输出这个序列的字典序最大值。 分析因为所有可能的序列的长度都是相等的，所以只需要让前面的元素尽量大即可。 第一个元素必须为 $9$ ，如果在这个下标暂停，那么第二个元素为 $0$ 。 否则，第二个元素为 $8$ ，在这里暂停，可以使第三个元素为 $9$ ，由于前两个都是固定的，而第三个又是最大，所以这种情况字典序最大。 也就是输出 $989012345 \\ldots$ 即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;void solve (){ int n; cin &gt;&gt; n; if (n == 1) return cout &lt;&lt; \"9\\n\", void(); if (n == 2) return cout &lt;&lt; \"98\\n\", void(); cout &lt;&lt; \"989\"; n -= 3; for (int i = 0; i &lt; n; i ++ ) cout &lt;&lt; i % 10; cout &lt;&lt; endl;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} B. Hills And Valleys题意给定长度为 $n$ 的序列。 我们将值大于两边的元素称为谷峰，值小于两边的元素称为谷底。 至多修改一个元素，使序列的谷峰+谷底的数量最小，输出这个最小值。 分析每个元素要么不改，要么改为左边元素，要么改为右边元素。 直接模拟每个数字对两边元素的影响即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 300010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;int n, a[N];bool is_ok (int i){ return (a[i] &gt; a[i-1] &amp;&amp; a[i] &gt; a[i+1]) || (a[i] &lt; a[i-1] &amp;&amp; a[i] &lt; a[i+1]);}void solve (){ cin &gt;&gt; n; int tot = 0, ans; rep(i, 1, n) cin &gt;&gt; a[i]; rep(i, 2, n-1) tot += is_ok(i); ans = tot; rep(i, 2, n-1) { int cnt = 0, c = 0; if (i != 2 &amp;&amp; is_ok(i-1)) ++ cnt; if (is_ok(i)) ++ cnt; if (i != n-1 &amp;&amp; is_ok(i+1)) ++ cnt; // del int st = a[i]; a[i] = a[i-1]; if (i != 2 &amp;&amp; is_ok(i-1)) ++ c; if (is_ok(i)) ++ c; if (i != n-1 &amp;&amp; is_ok(i+1)) ++ c; ans = min(ans, tot - cnt + c); c = 0; a[i] = a[i+1]; if (i != 2 &amp;&amp; is_ok(i-1)) ++ c; if (is_ok(i)) ++ c; if (i != n-1 &amp;&amp; is_ok(i+1)) ++ c; ans = min(ans, tot - cnt + c); a[i] = st; } cout &lt;&lt; ans &lt;&lt; endl;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init(); multiCase solve(); return 0;} C. Tree Bags题意给定三个背包，每个背包存储若干个元素。 重复以下操作，直到三个背包只剩下一个元素： 选择两个背包，每个背包选择一个元素 $a, b$ 将 $b$ 从所属背包删除，将 $a$ 变为 $a - b$ 输出剩下的元素的最大值。 分析假设三个背包为： \\begin{aligned} &a_1 a_2 a_3 a_4 \\ldots \\\\ &b_1 b_2 b_3 b_4 \\ldots \\\\ &c_1 c_2 c_3 c_4 \\ldots \\\\ \\end{aligned}假设最后剩下的元素为 $c_1$ 。 观察性质可以发现：一个数字移动偶数次到达 $c$ 背包，那么这个元素为正贡献，否则为负贡献。每次移动需要一个介质。 首先大的数字一定优先产生正贡献，所以对每个背包排序。 我们可以选择将 $b_1$ 到 $b_n$ 全部通过 $a_1$ 到达 $c$ 背包，产生正贡献，那么剩下的所有 $a$ 背包元素都只能产生负贡献。这样产生的总贡献就是 $- s_a + s_b + s_c$ 。其中 $s_a$ 表示 $a$ 背包的总值。 或者将 $a_2$ 到 $a_n$ 通过 $b_1$ 到达 $c$ ，然后将 $b_2$ 到 $b_n$ 通过 $a_1$ 到达 $c$ ，这样就是 $a_1$ 和 $b_1$ 产生负贡献。总贡献为 $s_a + s_b + s_c - a_1 - b_1$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 300010, M = N &lt;&lt; 1, mod = 998244353, INF = 0x3f3f3f3f;#define int long longvoid solve (){ int n1, n2, n3; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; n3; vector&lt;int&gt; a(n1), b(n2), c(n3); ll s1 = 0, s2 = 0, s3 = 0; forr(&amp;x, a) cin &gt;&gt; x, s1 += x; forr(&amp;x, b) cin &gt;&gt; x, s2 += x; forr(&amp;x, c) cin &gt;&gt; x, s3 += x; sort(all(a)); sort(all(b)); sort(all(c)); ll sub = min({s1, s2, s3}); sub = min({sub, a[0] + b[0], a[0] + c[0], b[0] + c[0]}); cout &lt;&lt; s1 + s2 + s3 - sub * 2 &lt;&lt; endl;}signed main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;} D. Sum of Paths题意给定长度为 $n$ 的序列，robot一开始可以站在任意位置，并且需要走正好 $k$ 次，每次向左走或者向右走，但不能出界。行走 $k$ 次将停留在 $k+1$ 个位置上，贡献为这些位置的元素值的和。 一共有 $q$ 次询问：修改某个位置的元素值，求出所有合法的行走路径的贡献和为多少。答案对 $1e9+7$ 取模。 其中 $1 \\le n, k \\le 5000$ 。 分析根据数据范围可以往dp方向想。 对于元素值的修改，只需要求出每个点的贡献，就可以求出修改了多少贡献和。 记 $dp[j][i]$ 表示走了 $j$ 步，到达 $i$ 位置的方案数量。 注意这个状态是可逆的，即也可以表示从 $i$ 位置出发，走了 $j$ 步的方案数量。 记 $cnt[i]$ 表示 $i$ 位置的贡献数，有 $cnt[i] = \\sum_{j=0}^{k}dp[j][i] \\times dp[k-j][i]$ 。 这是因为在走了 $j$ 步到达 $i$ 后，因为需要走 $k$ 步，所以还有 $k-j$ 步没有走，而从 $i$ 走 $k-j$ 的方案数量为 $dp[k-j][i]$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 5010, M = N &lt;&lt; 1, mod = 1e9 + 7, INF = 0x3f3f3f3f;ll a[N], dp[N][N], cnt[N];void solve (){ int n, k, q; cin &gt;&gt; n &gt;&gt; k &gt;&gt; q; rep(i, 1, n) cin &gt;&gt; a[i]; rep(i, 1, n) dp[0][i] = 1; rep(j, 1, k) rep(i, 1, n) { if (i == 1) dp[j][i] = dp[j-1][i+1]; else if (i == n) dp[j][i] = dp[j-1][i-1]; else dp[j][i] = (dp[j-1][i-1] + dp[j-1][i+1]) % mod; } // calc cnt rep(i, 1, n) rep(j, 0, k) (cnt[i] += (ll)dp[j][i] * dp[k-j][i]) %= mod; // calc sum ll sum = 0; rep(i, 1, n) ((sum += (ll) cnt[i] * a[i]) %= mod); while(q -- ) { int id, x; cin &gt;&gt; id &gt;&gt; x; sum = ((sum + (ll)(x - a[id]) * cnt[id]) % mod + mod) % mod; a[id] = x; cout &lt;&lt; sum &lt;&lt; endl; }}signed main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;} E. Distinctive Roots in a Tree题意给定一棵 $n$ 个节点的树，每个节点有权值 $a_i$ ，问有多少个节点满足： 以这个点为根时，它到达其他任何节点的路径上不出现重复数字。 其中 $1 \\le n \\le 2 \\times 10^5, 1 \\le a_i \\le a_i$ 。 分析我们假设这棵树以 $1$ 为根。 直接求满足的不好求，可以求出哪些不满足，剩下的就是满足的了。 对于 $u$ 节点而言，假如它的子树 $v$ 里出现 $a_u$ ，那么除了 $v$ 子树里的点外，其他任何点都一定不能满足。 同时，如果除了 $u$ 树外还有 $a_u$ ，那么这个 $u$ 树上任何节点都不能满足。 记 $d_u$ 表示以 $u$ 为根的树是否满足（$0$ 为满足，非 $0$ 为不满足），只需要树上差分一下就行。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define IOS cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false);#define multiCase int _; for (cin &gt;&gt; _; _ -- ; )#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )#define per(i, x, y) for (int i = x; i &gt;= y; i -- )#define forr(x, a) for (auto x: a)#define all(a) begin(a), end(a)#define rall(a) rbegin(a), rend(a)using namespace std; using ll = long long;void debug(){cerr&lt;&lt;'\\n';}template&lt;typename T,typename... Args&gt;void debug(T x,Args... args){cerr&lt;&lt;\"[ \"&lt;&lt;x&lt;&lt; \" ] , \";debug(args...);}const int dr[] = { -1, 0, 1, 0, -1, 1, 1, -1 };const int dc[] = { 0, 1, 0, -1, 1, 1, -1, -1 };const int N = 200010, M = N &lt;&lt; 1, mod = 1e9 + 7, INF = 0x3f3f3f3f;int n, ans, a[N], d[N]; // d为树上差分数组int cnt[N], now_cnt[N];vector&lt;int&gt; g[N];vector&lt;int&gt; alls;void dfs (int u, int fa){ int c1 = now_cnt[a[u]]; ++ now_cnt[a[u]]; for (int v: g[u]) { if (v == fa) continue; int c2 = now_cnt[a[u]]; dfs(v, u); if (c2 != now_cnt[a[u]]) // v子树上有a[u]元素 ++ d[1], -- d[v]; // 做树上差分 } if (now_cnt[a[u]] - c1 != cnt[a[u]]) // 全部的a[u]元素不都在u树上 ++ d[u]; // 这一个树都不能使用}void redfs (int u, int fa, int now){ ans += !now; for (int v: g[u]) if (v != fa) redfs(v, u, now + d[v]);}void solve (){ cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i], alls.push_back(a[i]); // 离散化 sort(all(alls)); alls.erase(unique(all(alls)), alls.end()); auto find = [&amp;](int x) { return lower_bound(all(alls), x) - alls.begin() + 1; }; rep(i, 1, n) a[i] = find(a[i]), ++ cnt[a[i]]; rep(i, 1, n-1) { int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); redfs(1, 0, d[1]); cout &lt;&lt; ans &lt;&lt; endl;}signed main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif IOS// init();// multiCase solve(); return 0;}","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://horb7.github.io/tags/Codeforces/"}]},{"title":"数字图像处理实验","slug":"数字图像处理实验","date":"2022-03-10T07:45:32.000Z","updated":"2022-03-11T02:52:57.203Z","comments":true,"path":"2022/03/10/数字图像处理实验/","link":"","permalink":"https://horb7.github.io/2022/03/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"Opencv-Python 教程 实验1A. 设置Python+OpenCV环境在命令行终端，输入 pip install opencv-python ，使用 $pip$ 安装 opencv ，注意 $pip$ 必须为最新版。 如果下载速度太慢，可以换成清华源进行下载：pip3 install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple 。 安装后，可以在 Pycharm专业版中输入 ： 12345import cv2img = cv2.imread('avatar.jpg')cv2.imshow('My Avatar', img)cv2.waitKey()cv2.destroyWindow('My Avatar') 测试结果： 其中： cv2.imread 函数表示读取一张图像，返回一个三维 ndarray ，前两维分别表示图像的长和宽，第三维表示图像的通道。 cv2.imshow 可以展示一张图像，第一个参数为窗口名称，第二个参数为需要展示的图像(以ndarray表示)。 cv2.waitkey 是一个窗口绑定函数，等待键盘符号的读入，并返回对应的 Ascii 码。 cv2.destroyAllWindows 可以销毁所有窗口，也可以使用 cv2.destroyWindow 来销毁具体的某个窗口。 RGB图像之灰度级和通道的理解 B. 练习图像分离、截取、转换等函数分离cv2.split 函数可以分离图像的蓝、绿、红三种颜色，分离后的形成一个三个元素的列表，分别表示蓝、绿、红三种颜色在图像每个像素点的信息，为二维 ndarray 类型，可以对其进行展示等。 使用 cv2.merge 函数可以将三个分离的通道合并形成图像，在这之前可以对单独的通道进行修改等。 我们也可以使用内置的方法进行图像的分离，比如使用 cvtColor 将图像进行转换。 下面为使用 cv2.cvtColor(src, cv2.COLOR_BGR2GRAY) 将图像转换为灰度图的例子。 截取上面提到了 cv2.imread 将图像转变为三维 ndarray 进行存储。我们可以提取出某一部分子矩阵作为新的图像，使用 cv2.imwrite 进行图像保存。 转换使用 cv2.flip 可以对图像进行转换，如垂直翻转，水平翻转，垂直+水平翻转。 param 效果 1 水平翻转 0 垂直翻转 -1 垂直+水平翻转 注意cv2.flip 返回的是新图像的存储，而不是对传进去的图像进行直接修改，可以使用 new_img = cv2.flip(img, 1) 来存储。 C. 图像颜色变换根据上述图像的图像截取，我们可以将一部分图像截取，然后修改其通道信息即可修改部分图像的颜色。 D. 计算和显示直方图cv2.calcHist 函数用于计算图像直方图。 函数原型：cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) #返回hist 其中： images:：输入的图像 channels：选择图像的通道 mask：掩码，是一个大小的iamges一样的 $ndarray$ 数组，其中把需要处理的部分指定为 $1$ ，不需要处理的部分指定为 $0$ 。一般设置为 $None$ ，表示处理整幅图像 histSize：使用多少个bin(柱子)，一般为256 ranges：像素值的范围，一般为 $[0, 255]$ 表示 $0 \\sim 255$ 后面两个参数基本不用输入，注意除了mask，其他四个参数都要带 [] 号。 计算灰度图像的直方图，输出 $100-128$ 的灰度值的像素数目： 搜索查找具有最多像素数目的灰度级： 使用 matplotlib 包画出直方图： 教程 效果： E. 图像统计处理cv2.minMaxLoc 函数可以在数组中寻找全局最小值和全局最大值，以及他们所处的位置。 由 cv2.split 分离出的通道属于二维 ndarray ，我们可以结合起来求出某一个通道中图像的最大值和最小值。 cv2.meanStdDev 函数可以统计矩阵的均值和标准偏差。 同理，我们可以结合 cv2.split ，求出绿色通道的图像矩阵的均值和标准差。 F. 图像缩放处理cv2.resize 函数可以用来处理图像的缩放。 函数需要用到的形参： 原图片 dsize ：代表期望的输出图像的尺寸 fx, fy ：表示沿 x, y 轴的缩放比例 interpolation ：插值方式，默认为线性插值。 注意，如果 $dsize$ 设置为 $None$ ，则以 $fx \\times fy$ 作为输出图片的尺寸。 插值算法","categories":[],"tags":[{"name":"数字图像处理","slug":"数字图像处理","permalink":"https://horb7.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"动态开点线段树+线段树合并","slug":"动态开点线段树-线段树合并","date":"2022-03-09T05:52:35.000Z","updated":"2022-03-09T05:52:59.668Z","comments":true,"path":"2022/03/09/动态开点线段树-线段树合并/","link":"","permalink":"https://horb7.github.io/2022/03/09/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 树上差分+动态开点线段树合并 */// 线段树维护最大值和最大值所在的位置#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;struct Node { int l, r, Max, Pos; } t[N * 100];int n, m;vector&lt;int&gt; g[N];int depth[N], f[N][21]; // 求lcaint X[N], Y[N], Z[N], Ans[N]; // 离线查询int root[N], idx;int R; // R为救济品编号最大值/* --------- lca --------- */void dfs (int u, int fa){ depth[u] = depth[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt; 21; i ++ ) f[u][i] = f[f[u][i-1]][i-1]; for (int v: g[u]) if (v != fa) dfs(v, u);}int lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); for (int i = 20; i &gt;= 0; i -- ) if (depth[f[a][i]] &gt;= depth[b]) a = f[a][i]; if (a == b) return b; for (int i = 20; i &gt;= 0; i -- ) if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i]; return f[a][0];}/* --------- lca --------- *//* --------- 动态开点线段树，维护区间最大值及对应的位置 --------- */void pushup (int p){ if (t[t[p].l].Max &gt;= t[t[p].r].Max) t[p].Max = t[t[p].l].Max, t[p].Pos = t[t[p].l].Pos; else t[p].Max = t[t[p].r].Max, t[p].Pos = t[t[p].r].Pos;}int update (int p, int l, int r, int x, int v){ if (!p) p = ++ idx; // 没有点，创建新的节点 if (l == r) { t[p].Max += v; t[p].Pos = l; return p; } int mid = l + r &gt;&gt; 1; if (x &lt;= mid) t[p].l = update(t[p].l, l, mid, x, v); else t[p].r = update(t[p].r, mid + 1, r, x, v); pushup(p); return p;}/* --------- 线段树 --------- *//* --------- 树上差分求子树前缀和，线段树合并 --------- */int merge (int p, int q, int l, int r) // 把q线段树合并到p线段树上{ if (!p) return q; if (!q) return p; if (l == r) { t[p].Max += t[q].Max; t[p].Pos = l; return p; } int mid = l + r &gt;&gt; 1; t[p].l = merge(t[p].l, t[q].l, l, mid); t[p].r = merge(t[p].r, t[q].r, mid + 1, r); pushup(p); return p;}void Redfs (int u, int fa){ for (int v: g[u]) { if (v == fa) continue; Redfs(v, u); root[u] = merge(root[u], root[v], 1, R); } if (t[root[u]].Max) Ans[u] = t[root[u]].Pos;}/* --------- 树上差分求子树前缀和，线段树合并 --------- */int main (){ cin.tie(0)-&gt;sync_with_stdio(0); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); // 预处理倍增数组求lca for (int i = 1; i &lt;= m; i ++ ) { cin &gt;&gt; X[i] &gt;&gt; Y[i] &gt;&gt; Z[i]; R = max(Z[i], R); } // 每个点都有一棵线段树 for (int i = 1; i &lt;= m; i ++ ) { int Lca = lca(X[i], Y[i]); root[X[i]] = update(root[X[i]], 1, R, Z[i], 1); root[Y[i]] = update(root[Y[i]], 1, R, Z[i], 1); root[Lca] = update(root[Lca], 1, R, Z[i], -1); int gfa = f[Lca][0]; if (gfa) root[gfa] = update(root[gfa], 1, R, Z[i], -1); } Redfs(1, 0); for (int i = 1; i &lt;= n; i ++ ) cout &lt;&lt; Ans[i] &lt;&lt; endl; return 0;}","categories":[],"tags":[]},{"title":"扫描线","slug":"扫描线","date":"2022-03-07T15:56:09.000Z","updated":"2022-03-07T16:27:49.116Z","comments":true,"path":"2022/03/07/扫描线/","link":"","permalink":"https://horb7.github.io/2022/03/07/%E6%89%AB%E6%8F%8F%E7%BA%BF/","excerpt":"","text":"扫描线扫描线是一种ACM中矩阵面积交以及矩阵周长和问题的解法，通常使用线段树解决。 矩阵面积交[模板]扫描线 在进行矩阵面积运算时，我们将一条垂直与 $x$ 轴的直线，从 $y$ 轴 $-\\infty$ 向 $+\\infty$ 扫描，可以将所有矩阵交分割为若干个规则矩阵，如图所示： 计算所有矩阵面积交，只需要算出每个规则矩阵的面积和即可。 对于每个规则矩阵，我们可以知道它的宽为 $x_i - x_{i-1}$ ，只需要知道它的高即可。 比如，对于 $[x_1, x_2]$ 区间内的规则矩阵，他们的高为两个矩阵的高之和，这个距离我们可以使用线段树维护。 具体来说，需要维护 $y$ 轴上有多少长度为区间内矩阵的高。 对于每个规则矩阵，我们设它的左边为入边，右边为出边，那么对于左边，给对应 $y$ 轴上所有点（规则矩阵的高上的所有点）加上权值 $1$ ，当扫描线扫出这个矩阵，也就是经过出边，就同理减去权值 $1$ 。 由于我们在查询的时候，只需要知道整个 $y$ 轴上有多少长度被覆盖，也就是只查询线段树第一个节点的信息，不需要知道线段树内部节点，那么就可以不使用PushDown操作。整个线段树自下往上传递信息，不需要自上往下传递信息。 由于 $y$ 轴上的点范围很大，可以对其离散化后，在离散化区间上作线段树，注意对于线段树所维护的区间，它的每个点表示的是与后面的点的边的覆盖次数，也就是把点映射为边。 剩下的有时间再写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;struct Line { int x, y1, y2, k; };struct Node{ #define lc p&lt;&lt;1 #define rc p&lt;&lt;1|1 #define mid (t[p].l + t[p].r &gt;&gt; 1) int l, r; int len, cover;};int n;vector&lt;int&gt; Y;Line line[N &lt;&lt; 1];Node t[N &lt;&lt; 3];void build (int p, int l, int r){ t[p] = { l, r, 0, 0 }; if (l != r) { build(lc, l, mid); build(rc, mid + 1, r); }}void pushup (int p){ if (t[p].cover) t[p].len = Y[t[p].r + 1] - Y[t[p].l]; else if (t[p].l == t[p].r) t[p].len = 0; else t[p].len = t[lc].len + t[rc].len;}void update (int p, int l, int r, int k){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) { t[p].cover += k; pushup(p); return ; } if (l &lt;= mid) update(lc, l, r, k); if (r &gt; mid) update(rc, l, r, k); pushup(p);}int main (){ cin &gt;&gt; n; for (int i = 1, j = 1; i &lt;= n; i ++ ) { int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; line[j ++ ] = { x1, y1, y2, 1 }; line[j ++ ] = { x2, y1, y2, -1 }; Y.push_back(y1), Y.push_back(y2); } sort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end()); auto find = [&amp;](int x) { return lower_bound(Y.begin(), Y.end(), x) - Y.begin(); }; sort(line + 1, line + n * 2 + 1, [&amp;](Line a, Line b){ return a.x &lt; b.x; }); build(1, 0, Y.size() - 2); // 在Y轴上建立线段树,点映射为边，最后的点无用 long long ans = 0; for (int i = 1; i &lt;= n * 2; i ++ ) { ans = ans + (long long)t[1].len * (line[i].x - line[i-1].x); update(1, find(line[i].y1), find(line[i].y2) - 1, line[i].k); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Codeforces Round 774(Div.2)","slug":"Codeforces-Round-774-Div-2","date":"2022-03-05T03:42:20.000Z","updated":"2022-03-23T08:06:10.329Z","comments":true,"path":"2022/03/05/Codeforces-Round-774-Div-2/","link":"","permalink":"https://horb7.github.io/2022/03/05/Codeforces-Round-774-Div-2/","excerpt":"","text":"C. Factorials and Powers of Two题意给定数字 $n$ ，它可以由 $k$ 个不同的阶乘数和 $2$ 的幂次数组成。求出最小的 $k$ 。 其中 $1 \\le n \\le 10^{12}$ 。 分析由于在 $10^{12}$ 内直接只有 $0 \\sim 15$ 的阶乘，所以可以二进制枚举需要累加哪些阶乘。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define popll(x) (ll)__builtin_popcountll(x)const int N = 20;ll fac[N];void solve (){ ll n, k = 2e9 + 10; cin &gt;&gt; n; for (int s = 0; s &lt; (1 &lt;&lt; 15); s ++ ) { ll now = n; for (int i = 0; i &lt;= 15; i ++ ) if (s &gt;&gt; i &amp; 1) now -= fac[i]; if (now &lt; 0) break; k = min(k, popll(s) + popll(now)); } cout &lt;&lt; k &lt;&lt; endl;}int main (){ fac[0] = 1; for (int i = 1; i &lt;= 15; i ++ ) fac[i] = fac[i-1] * i; int _; for (cin &gt;&gt; _; _ -- ; ) solve(); return 0;} D. Weight the Tree题意给定一棵 $n$ 个节点的树，为每个节点赋一个正数，使得树上好点最多。如果有多种方案，输出点权和最小的一种方案。 好点：点权等于邻接点的点权之和的点。 分析对于 $n = 2$ 的树，明显两个点都可以作为好点，并且每个点点权为 $1$ 。 对于 $n \\gt 2$ 的树，对于任意一条边 $(u, v)$ ，至多只有一个点为好点。 使用树形DP，$dp(i, 0)$ 表示以 $i$ 为根的树，且 $i$ 不作为好点时，最大的好点数量，以及对应的所有好点的边权。同理 $dp(i, 1) $ 表示 $i$ 作为好点。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int n, val[N];pair&lt;int, int&gt; dp[N][2];vector&lt;int&gt; g[N];void dfs (int u, int fa){ dp[u][0] = { 0, 0 }; dp[u][1] = { 1, -(int)g[u].size() }; for (int v: g[u]) { if (v == fa) continue; dfs(v, u); dp[u][1].first += dp[v][0].first; dp[u][1].second += dp[v][0].second; auto M = max(dp[v][0], dp[v][1]); // 在好点相同的情况下，要选择权值小的 dp[u][0].first += M.first; dp[u][0].second += M.second; }}void get_val (int u, int type, int fa){ if (type == 0) val[u] = 1; else val[u] = g[u].size(); for (int v: g[u]) { if (v == fa) continue; if (type == 1) get_val(v, 0, u); else { if (dp[v][0] &gt; dp[v][1]) get_val(v, 0, u); else get_val(v, 1, u); } }}int main (){ cin &gt;&gt; n; for (int i = 1; i &lt; n; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } if (n == 2) return cout &lt;&lt; \"2 2\\n1 1\\n\", 0; dfs(1, 0); auto M = max(dp[1][0], dp[1][1]); cout &lt;&lt; M.first &lt;&lt; ' ' &lt;&lt; -M.second + n - M.first &lt;&lt; endl; if (M == dp[1][0]) get_val(1, 0, 0); else get_val(1, 1, 0); for (int i = 1; i &lt;= n; i ++ ) cout &lt;&lt; val[i] &lt;&lt; \" \\n\"[i == n]; return 0;} E. Power Board题意给定 $n \\times m$ 的矩阵，其中 $(i, j)$ 位置上的数字为 $i^j$ 。问矩阵中不同的数字的个数。 其中 $1 \\le n, m \\le 10^6$ 。 分析首先，第一列的元素一定为 $[1, 2, 3, \\ldots, n]$ 。 对于第 $2, 4, 8$ 行，他们是有公共元素的。 比如第 $2$ 行为 $2, 4, 8, 16, \\ldots, 2^m$ 。 第 $4$ 行为 $4, 16, 64, \\ldots, 4^m$ 。 第 $8$ 行为 $8, 64, 512, \\ldots , 8^m$ 。 我们把他们都按照 $2$ 的幂次方来表示： \\begin{aligned} &2^1, 2^2, 2^3, \\ldots, 2^m \\\\ &2^2, 2^4, 2^6, \\ldots, 2^{2m} \\\\ &2^3, 2^6, 2^{12}, \\ldots, 2^{3m} \\end{aligned}那么不同的数字仅仅区别于他们的指数，也就是说，我们只需要知道这里有多少个不同的指数即可。 而上面的指数，在不同的底数情况下都是一样的，他们的答案仅仅区别于行数的多少( $3, 9, 27$ 的指数也是如此)。 也就是说，我们只需要对于 $n$ 的所有质数行进行分解，然后算出他们在 $n$ 行内有多少倍数(行)。行数最多为 $log_2n$ （即以 $2$ 为底数时所有的倍数行）， 大概在 $20$ 左右，所以只需要预处理最多 $20$ 行不同的指数数量即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1000010;int del[N], rows[N], cnt[20];bool used[N * 20];int main (){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 2; i &lt;= n / i; i ++ ) for (ll p = i * i; p &lt;= n; p *= i) del[p] = true, ++ rows[i]; int c = 0; for (int i = 1; i &lt;= 20; i ++ ) { for (int j = 1; j &lt;= m; j ++ ) if (!used[i * j]) ++ c, used[i * j] = true; cnt[i] = c; } ll ans = 1; for (int i = 2; i &lt;= n; i ++ ) if (!del[i]) ans = ans + cnt[rows[i] + 1]; cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"小白月赛45F.交换","slug":"小白月赛45F-交换","date":"2022-03-04T14:14:10.000Z","updated":"2022-03-04T14:54:04.597Z","comments":true,"path":"2022/03/04/小白月赛45F-交换/","link":"","permalink":"https://horb7.github.io/2022/03/04/%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B45F-%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"交换题意给定 $n$ 个操作指令和 $m$ 个查询。 每个操作指令形如 $x \\ \\ y$ ，表示交换下标为 $x \\ 、 \\ y$ 的数字。 对于每个查询，给出一段长度为 $k$ 的序列，你可以选择操作指令中的一段连续区间，使得操作完后，这个序列为升序。 对于每个查询，输出使得序列变为升序所需要的最小连续操作区间的长度，否则输出 $-1$ 。 其中， $1 \\le n \\le 2 \\times 10^3, 1 \\le m \\le 10^4, 1 \\le x, y, k \\le 10$ 。保证每个查询给出的序列为 $[1, k]$ 的排列。 分析对于每个连续的指令区间，一定有且仅有一个排列使得操作完后变为升序。（这里指长度最小的排列，因为任何以它为前缀的排列也一定可以变为升序）。 假设这个排列为 $P$ ，执行的指令区间为 $[l, r]$ ，那么有：$P -&gt; [l, r] -&gt; [1, 2, \\ldots, k]$ 。 那么，反过来就是：$[1, 2, \\ldots , k] -&gt; [r, l] -&gt; P$ 。 也就是说，对于每个连续指令区间，我们可以预处理出这个 $P$ 。 所以可以使用 $map \\lt vector \\lt int \\gt , int \\gt $ 来存储对于每个 $P$ ，能使它变升序的最小指令区间的长度。 或者把 $P$ 看作字符串，使用 $map \\lt string, int \\gt$ 存储。 这里有一个问题，预处理是 $O(n^3)$ 的。因为需要枚举 $l, r$ ，还要对于 $[l, r]$ 模拟指令来获得 $P$ 。 一种好的方法是，先正序枚举 $r$ ，再倒序枚举 $l$ ，这样模拟指令就是 $O(1)$ 了，预处理复杂度降为 $O(n^2)$ 。 本来本题到此为止了，但是由于出题人太毒瘤，使用 $map$ 被卡常了，所以还需要换一种策略。 我们可以使用 $Trie$ 树，把所有的查询都存储起来(离线)，记录每个查询所在的节点位置。 按照上述方法模拟所有区间的指令，预处理出来 $P$ 的最小升序所需区间长度。 注意如果长度最小的排列被 $[l, r]$ 满足，那么任意以它为前缀的排列也一定满足，所以在 $Trie$ 上要更新到底。 在查询中可能有本来就是升序的序列，需要特殊处理一下。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, INF = 0x3f3f3f3f;int trie[N][12], ans[N], qid[N], idx; // ans(i)表示Trie上i节点的答案void ins (int *s, int len, int id){ int p = 0; for (int i = 1; i &lt;= len; i ++ ) { int x = s[i]; if (!trie[p][x]) trie[p][x] = ++ idx; p = trie[p][x]; } qid[id] = p; // 查询次序为id，它所在的Trie树上的位置}void update (vector&lt;int&gt; &amp;s, int len){ int p = 0; for (int i = 1; i &lt;= 10; i ++ ) // 注意更新所有长度 { int x = s[i]; if (trie[p][x]) { p = trie[p][x]; ans[p] = min(ans[p], len); } else break; }}int n, m, x[N], y[N], q[20];int main (){ cin &gt;&gt; n &gt;&gt; m; memset(ans, INF, sizeof ans); for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; x[i] &gt;&gt; y[i]; for (int i = 1; i &lt;= m; i ++ ) { int k; cin &gt;&gt; k; for (int j = 1; j &lt;= k; j ++ ) cin &gt;&gt; q[j]; ins(q, k, i); } for (int r = 1; r &lt;= n; r ++ ) { vector&lt;int&gt; p(11); for (int i = 1; i &lt;= 10; i ++ ) p[i] = i; update(p, 0); // 特殊处理本来就是升序的查询 for (int l = r; l &gt;= 1; l -- ) { swap(p[x[l]], p[y[l]]); update(p, r - l + 1); } } for (int i = 1; i &lt;= m; i ++ ) { if (ans[qid[i]] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans[qid[i]] &lt;&lt; endl; } return 0;}","categories":[],"tags":[]},{"title":"2021浙江省赛题解","slug":"2021浙江省赛题解","date":"2022-03-02T05:38:31.000Z","updated":"2022-03-02T08:50:21.516Z","comments":true,"path":"2022/03/02/2021浙江省赛题解/","link":"","permalink":"https://horb7.github.io/2022/03/02/2021%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"","text":"D. Shortest Path QueryCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using T = pair&lt;ll, int&gt;;const int N = 100010;vector&lt;T&gt; g[N];int n, m, vis[N];ll f[N][21]; // f(i, j)表示i点删了j个后面的数字的点走过的最短路void dijkstra (int root) // 以root点作为前缀，在它后面加数字，与其他各数字的最短路{ priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; q; vector&lt;int&gt; c; q.push({0, root}); int j; f[root][0] = 0; while(!q.empty()) { T t = q.top(); q.pop(); ll dist = t.first, u = t.second; if (vis[u]) continue; vis[u] = true; c.push_back(u); for (j = 0; (u &gt;&gt; j) != root; ++ j); f[u][j] = min(f[u][j], dist); for (auto &amp;[v, w]: g[u]) if (!vis[v] &amp;&amp; v &gt;= root) q.push({w + dist, v}); } for (int v: c) vis[v] = false;}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); memset(f, 0x3f, sizeof f); for (int i = 1; i &lt;= m; i ++ ) { ll u, v, w, j; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); if (u &gt; v) swap(u, v); g[u].push_back({v, w}); g[v].push_back({u, w}); // v删除j个末尾数字，到达u for (j = 0; (v &gt;&gt; j) != u; ++ j); f[v][j] = min(f[v][j], w); } for (int i = 1; i &lt;= n; i ++ ) dijkstra(i); int q; scanf(\"%d\", &amp;q); while(q -- ) { int u, v, j = 0; scanf(\"%d%d\", &amp;u, &amp;v); ll ans = (1ll &lt;&lt; 60); // 枚举u和v的公共前缀 for (int i = 0; i &lt; 28; i ++ ) { while((v &gt;&gt; i) &lt; (u &gt;&gt; j)) ++ j; if ((v &gt;&gt; i) == (u &gt;&gt; j)) ans = min(ans, 1ll * f[u][j] + f[v][i]); } if (ans &gt; 60ll * 1e9) printf(\"-1\\n\"); else printf(\"%lld\\n\", ans); } return 0;} F. Fair Distribution题意给定两个数字 $a, b$ ，每次操作可以使 $a - 1$ ，或者 $b + 1$ ，问使 $b \\% a == 0$ 的最小操作数量。 分析假设 $a$ 减小了 $x$ ，那么有 $x \\in [0, a-1]$ ，即 $a - x \\in [1, a]$ 。 那么对于 $b$ ，它为了使 $b \\% a == 0$ 的最小步数为 $\\lceil \\dfrac b {a-x} \\rceil \\times (a - x)$ ，注意 $b$ 只能向上增加，所以要向上取整。 令 $a - x = i$ ，那么有 $i \\in [1, a]$ 。 总操作数为： \\begin{aligned} &x + \\lceil \\dfrac b i \\rceil \\times i - b \\\\ = &a - i + \\lceil \\dfrac b i \\rceil \\times i - b \\\\ = &a - i + \\lfloor\\dfrac {b + i - 1} i \\rfloor \\times i - b \\\\ = &(a - b) + \\lfloor\\dfrac {b - 1} i \\rfloor \\times i \\end{aligned}可以使用整除分块，枚举 $i$ 的值。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for(cin &gt;&gt; _; _ -- ; ) { int a, b, ans = 2e9; cin &gt;&gt; a &gt;&gt; b; if (a &gt;= b) { cout &lt;&lt; a - b &lt;&lt; endl; continue; } for (int l = 1, r; l &lt;= a; l = r + 1 ) { r = min(a, (b - 1) / ((b - 1) / l)); ans = min(ans, (b - 1) / l * l + a - b); } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} G. Wall Game题意 如图，有 $n$ 个操作，每个操作为： 在图上添加点（图中单个的的六边形），并和相邻的点联通。 查询这个点所在的联通块与外界的边的数量。 分析使用并查集维护集合内的边的数量。 由于直接维护边不好维护，可以开两个数组，一个维护集合点的数量，一个维护集合内失效边的数量。 在合并集合时，遍历点所在的六个相邻点，查询是否已经在同一个联通块，如果在，则失效边增加 $2$ ，否则需要合并两个集合，且失效边加 $2$ 。 由于点是二维的，可以使用 $map$ 来把点映射为数值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;pair&lt;int, int&gt;, int&gt; Map; // 把点映射为数值const int dr[] = { 0, 1, 1, 0, -1, -1 };const int dc[] = { 1, 0, -1, -1, 0, 1 };const int N = 500010;int p[N], siz[N], decr[N]; // decr表示联通块有多少边无效int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void merge (int x, int y){ static int cnt = 0; Map[{x, y}] = ++ cnt; siz[cnt] = 1; for (int i = 0; i &lt; 6; i ++ ) // 枚举他的6个相邻块 { int dx = x + dr[i], dy = y + dc[i]; if (!Map.count({dx, dy})) continue; int pdx = find(Map[{dx, dy}]); if (pdx != cnt) { siz[cnt] += siz[pdx]; decr[cnt] += decr[pdx] + 2; p[pdx] = cnt; } else decr[cnt] += 2; }}int main (){ cin.tie(0)-&gt;sync_with_stdio(0); int n; cin &gt;&gt; n; iota(p + 1, p + N, 1); while(n -- ) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) merge(x, y); else { int key = find(Map[{x, y}]); cout &lt;&lt; siz[key] * 6 - decr[key] &lt;&lt; endl; } } return 0;}","categories":[],"tags":[{"name":"区域赛","slug":"区域赛","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"}]},{"title":"Namomo Spring Camp 2022每日一题","slug":"Namomo-Spring-Camp-2022每日一题","date":"2022-02-26T11:54:39.000Z","updated":"2022-03-27T01:44:05.282Z","comments":true,"path":"2022/02/26/Namomo-Spring-Camp-2022每日一题/","link":"","permalink":"https://horb7.github.io/2022/02/26/Namomo-Spring-Camp-2022%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"子串的最大差题意定义序列的最大差为序列中最大数与最小数的差。比如 $(3,1,4,5,6)$ 的最大差为 $6−1=5 , (2,2)$ 的最大差为 $2−2=0$ 。 定义一个序列的子串为该序列中连续的一段序列。 给定一个长度为 $n$ 的数组 $a_1,a_2, \\ldots ,a_n$，请求出这个序列的所有子串的最大差之和。 分析所有子串的最大差之和 = 所有子串最大值之和 - 所有子串最小值之和。 所以可以单独算出最大值之和与最小值之和。 考虑每个元素作为最大值/最小值的贡献，以最大值为例，假设它前面最近的大于它的元素位置为 $lmax$ ，同理右边为 $rmax$ ，则左边可作为端点的数量为 $i - (lmax-1) + 1$ ，同理右边为 $(rmax-1) - i + 1$ 。那么当前点作为最大值的贡献为 $((rmax-1)-i+1) * (i-(lmax-1)+1) - 1$ 。 计算每个点的 $lmax$ 和 $rmax$ 可以使用单调栈，具体可参考这里。 注意点：在最大值有多个的区间，如 $[5, 1, 5]$ ，对于所有的 $5$ ，对这个区间一共只能有一个贡献，我们可以让最后面的元素产生贡献，为此，在计算 $lmax$ 时，应该使其取非单调上升序列，而 $rmax$ 取严格下降序列。 小Trick，在计算完最大值后将所有元素乘上 $-1$ ，这样就又是求最大值，可以复用代码。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int N = 500010;int n, a[N], stk[N], top, lmax[N], rmax[N], lmin[N], rmin[N];// 使用单调栈解决离元素最近且大于它的元素位置void calc (int *left, int *right){ // left top = 0; for (int i = 1; i &lt;= n; i ++ ) { while(top &amp;&amp; a[stk[top]] &lt; a[i]) -- top; left[i] = (top ? stk[top] + 1 : 1); stk[++ top] = i; } // right top = 0; for (int i = n; i &gt;= 1; i -- ) { while(top &amp;&amp; a[stk[top]] &lt;= a[i]) -- top; right[i] = (top ? stk[top] - 1: n); stk[++ top] = i; }}int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; calc(lmax, rmax); for (int i = 1; i &lt;= n; i ++ ) a[i] *= -1; calc(lmin, rmin); for (int i = 1; i &lt;= n; i ++ ) a[i] *= -1; long long ans = 0; for (int i = 1; i &lt;= n; i ++ ) { ans += 1ll * a[i] * (rmax[i] - i + 1) * (i - lmax[i] + 1); ans -= 1ll * a[i] * (rmin[i] - i + 1) * (i - lmin[i] + 1); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} no crossing题意给出一个有向图，找一条恰好经过 $k$ 个点的最短路径，要求每次选的边不能越过之前选择的点，即：对于路径中的边 $x -&gt; y$ ，不存在以前经过的点使得三者关系为：$min(x, y) \\le t \\le max(x, y)$ 。 其中 $1 \\le n, k \\le 100, 0 \\le m \\le 2000, 1 \\le a_i, b_i \\le n, 1 \\le c_i \\le 1000$ 。 分析区间DP，记 $f(l, r, dir, step)$ 表示 $[l, r]$ 区间，且方向为 $dir$ ，走过的步数为 $step$ 时最短的路径。 $dir$ ：$dir$ 为 $0$ 时表示从 $l$ 跳到 $[l+1, r-1]$ 中的某个点，为 $1$ 时表示从 $r$ 跳到 $[l+1, r-1]$ 的某个点。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int n, k, m, ans = 2e9 + 10;int g[N][N];int dp[N][N][2][N]; // dp(l, r, dir, step) 表示[l, r]，方向为dir，步数为step的最短路径int work (int l, int r, int dir, int step){ if (step == k - 1) return 0; int &amp;ans = dp[l][r][dir][step]; if (~ans) return ans; else ans = 2e9 + 10; // 转移 int from = dir ? r : l; for (int to = l + 1; to &lt; r; to ++ ) if (g[from][to]) { ans = min(ans, work(to, r, 0, step + 1) + g[from][to]); ans = min(ans, work(l, to, 1, step + 1) + g[from][to]); } return ans;}int main (){ memset(dp, -1, sizeof dp); cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= m; i ++ ) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (g[u][v]) g[u][v] = min(g[u][v], w); else g[u][v] = w; } for (int i = 1; i &lt;= n; i ++ ) { ans = min(ans, work(0, i, 1, 0)); ans = min(ans, work(i, n+1, 0, 0)); } if (ans &gt; 2e9) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; return 0;} Dis题意给出 $n$ 个点的一棵树，每个点有各自的点权，多次询问两个点简单路径所构成的点集的异或和。 分析$Xor(u, v) = Xor(u, root) \\bigoplus Xor(v, root) \\bigoplus LCA(u, v)$ 。 $dfs$ 或者 $bfs$ 求出根节点到每个点的路径上点权异或和，同时预处理 $lca$ 的倍增数组即可。 也可以使用 $Tarjan$ 离线求 $lca$ ，单次处理复杂度降到 $O(1)$ 。 如果题目要求点权可以修改，则可以使用树链刨分转换为序列，使用线段树或者树状数组维护。 Code倍增LCA求法 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int n, m, a[N];vector&lt;int&gt; g[N];int depth[N], f[N][21], Xor[N]; // Xor(i)表示从根节点到i的路径上的异或和void dfs (int u, int fa){ depth[u] = depth[fa] + 1; Xor[u] = Xor[fa] ^ a[u]; f[u][0] = fa; for (int i = 1; i &lt; 21; i ++ ) f[u][i] = f[f[u][i-1]][i-1]; for (int v: g[u]) if (v != fa) dfs(v, u);}int lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); for (int i = 20; i &gt;= 0; i -- ) if (depth[f[a][i]] &gt;= depth[b]) a = f[a][i]; if (a == b) return b; for (int i = 20; i &gt;= 0; i -- ) if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i]; return f[a][0];}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); // 以1为树的根 while(m -- ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); printf(\"%d\\n\", Xor[u] ^ Xor[v] ^ a[lca(u, v)]); } return 0;} 离线Tarjan求法 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using T = pair&lt;int, int&gt;;struct A { int id, u, v, _lca; };const int N = 1000010;int n, m, a[N], Xor[N];int p[N], st[N];vector&lt;int&gt; g[N];vector&lt;A&gt; ans;vector&lt;T&gt; query[N]; // query(i) 表示以i为某一点的所有lca查询int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void Tarjan (int u){ st[u] = 1; // 正在搜索 for (int v: g[u]) if (!st[v]) { Xor[v] ^= Xor[u]; Tarjan(v); p[v] = u; } for (auto &amp;[v, id]: query[u]) if (st[v] == 2) ans.push_back(A{ id, u, v, find(v) }); st[u] = 2; // 完成搜索，回溯}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]), Xor[i] = a[i]; for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } iota(p + 1, p + n + 1, 1); for (int i = 1; i &lt;= m; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); query[u].push_back({v, i}); query[v].push_back({u, i}); } Tarjan(1); sort(ans.begin(), ans.end(), [&amp;](A a, A b){ return a.id &lt; b.id; }); for (auto &amp;[id, u, v, _lca]: ans) printf(\"%d\\n\", Xor[u] ^ Xor[v] ^ a[_lca]); return 0;} 树链刨分求法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;struct fenwick{ int c[N]; void add (int x, int v) { if (x) for (; x &lt; N; x += x &amp; -x) c[x] ^= v; } int query (int x) { int ans = 0; if (x) for (; x; x -= x &amp; -x) ans ^= c[x]; return ans; } int query (int l, int r) { return query(r) ^ query(l - 1); }};int n, m, a[N];vector&lt;int&gt; g[N];fenwick F;int son[N], top[N], depth[N], siz[N], father[N], id[N], wt[N], cnt;void dfs1 (int u, int fa){ depth[u] = depth[fa] + 1; father[u] = fa; siz[u] = 1; int maxson = -1; for (int v : g[u]) { if (v == fa) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; maxson) son[u] = v, maxson = siz[v]; }}void dfs2 (int u, int topfather){ top[u] = topfather; id[u] = ++ cnt; wt[cnt] = a[u]; F.add(cnt, wt[cnt]); if (!son[u]) return ; dfs2(son[u], topfather); for (int v : g[u]) if (v != son[u] &amp;&amp; v != father[u]) dfs2(v, v);}int query (int u, int v){ int ans = 0; while(top[u] != top[v]) { if (depth[top[u]] &lt; depth[top[v]]) swap(u, v); ans ^= F.query(id[top[u]], id[u]); u = father[top[u]]; } if (depth[u] &gt; depth[v]) swap(u, v); ans ^= F.query(id[u], id[v]); return ans;}int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs1(1, 0); // 第一次dfs求出depth, siz, father, son dfs2(1, 1); // 第二次dfs链接重链, 求出top, id, wt for (int i = 1; i &lt;= m; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); printf(\"%d\\n\", query(u, v)); } return 0;} 选数题意给定 $N$ 个正整数 $a_1, a_2, \\ldots , a_n$ 。要求从其中选出若干个数字，使得这些数字的和 $sum \\equiv 0 \\pmod N$ ，对于每个下标只能选择一次。若存在则输出选择的数字个数及其下标，否则输出 $-1$ 。 分析对于 $n$ 个数字，作前缀和，一共有 $n + 1$ 个模数(注意还有全不选的情况)，根据鸽巢原理一定有两个模数相等，假设其在前缀和中的下标为 $i, j$ ，则对于 $[i+1, j]$ 区间的数字，它们的和一定 $sum \\equiv 0 \\pmod N$ 。 Code123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int n, a[N], pre[N];int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], pre[i] = (pre[i-1] + a[i]) % n; map&lt;int, int&gt; exist{{0, 0}}; // 记录模数是否出现过，以及出现的下标 for (int i = 1; i &lt;= n; i ++ ) { if (exist.count(pre[i])) { cout &lt;&lt; i - exist[pre[i]] &lt;&lt; endl; for (int j = exist[pre[i]] + 1; j &lt;= i; j ++ ) cout &lt;&lt; j &lt;&lt; \" \\n\"[j == i]; return 0; } exist[pre[i]] = i; } cout &lt;&lt; -1 &lt;&lt; endl; return 0;} 序列操作题意给定一个长度为 $n$ 的序列 $a_1, a_2 , \\ldots , a_n$ 。 你需要进行两种操作： $1 \\ \\ x \\ \\ y$ ，表示将第 $x$ 个数字变为 $y$ $2 \\ \\ y$ ，表示将所有小于 $y$ 的数字修改为 $y$ 一共进行 $q$ 次操作，输出执行完所有操作后的序列。 其中 $1 \\le n , q \\le 10^6, 0 \\le a \\le 10^9, 1 \\le x \\le n, 0 \\le y \\le 10^9$ 。 分析离线+ST表 操作 $1$ 的优先级大于 $2$ ，对于每个数字，当执行操作 $1$ 时，前面所有对这个数字的操作 $2$ 都无效。 所以对于每个数字，我们只需要知道，所有在它最后一次操作 $1$ 之后的操作 $2$ ，对它的影响即可。 可以把操作 $2$ 存储起来，然后记录每个数字最后一次操作 $1$ 的位置，二分找到对应的操作 $2$ ，然后查询之后所有操作 $2$ 的最大值，与当前数字取最大值即可。 (看了一眼题解emmm….. 我是SB，每次查询区间最大值都是以最后一个操作 $2$ 为右端点，所以只需要做一个后缀最大值计算即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;struct Q { int id, x; };struct SparseTable{ int n, st[N][21], Lg[N]; void init(int n, Q *a) { this-&gt;n = n; for (int i = 2; i &lt;= n; i ++ ) Lg[i] = Lg[i&gt;&gt;1] + 1; for (int i = 1; i &lt;= n; i ++ ) st[i][0] = a[i].x; for (int j = 1; j &lt; 21; j ++ ) for (int i = 1; i &lt;= n; i ++ ) st[i][j] = max(st[i][j-1], st[i + (1&lt;&lt;j-1)][j-1]); } int query (int l, int r) { int k = Lg[r - l + 1]; return max(st[l][k], st[r - (1&lt;&lt;k) + 1][k]); }};int n, m, a[N], ans[N], last[N]; // last统计每个下标最后更改的位置Q q[N];int cnt;SparseTable ST;int main (){ int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; i ++ ) { int op, x, y; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) scanf(\"%d\", &amp;y), last[x] = i, a[x] = y; if (op == 2) q[++ cnt] = { i, x }; } ST.init(cnt, q); for (int i = 1; i &lt;= n; i ++ ) { if (!last[i]) a[i] = max(a[i], ST.query(1, cnt)); else { int pos = lower_bound(q + 1, q + cnt + 1, last[i], [](Q a, int val){ return a.id &lt; val; }) - q; if (pos != cnt + 1) a[i] = max(a[i], ST.query(pos, cnt)); } } for (int i = 1; i &lt;= n; i ++ ) printf(\"%d \", a[i]); return 0;} 数数题意在给定 $N$ 长的数组 $\\{A\\}$ 中进行 $Q$ 次查询 $[L_i, R_i]$ 区间中不大于 $H_i$ 的元素个数。 分析离线处理，把所有元素和查询按照权值排序，对于查询 $i$ ，只需要统计之前的数字在 $[L_i, R_i]$ 区间出现多少次即可，可以使用树状数组维护前缀和。 数据有锅， $L_i$ 可以为 $0$ ，还需要特判一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;using T = pair&lt;int, int&gt;;const int N = 100010;struct Q { int id, l, r, h; };struct fenwick{ int c[N]; void init (int n) { fill(c, c + n + 1, 0); } void add (int x, int v) { if (x) for (; x &lt; N; x += x &amp; -x) c[x] += v; } int query (int x) { int ans = 0; if (x) for (; x; x -= x &amp; -x) ans += c[x]; return ans; } int query (int l, int r) { return query(r) - query(l - 1); }};int n, m, ans[N];T a[N];Q query[N];fenwick F;void solve (){ cin &gt;&gt; n &gt;&gt; m; F.init(n); for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i].first, a[i].second = i; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= m; i ++ ) { cin &gt;&gt; query[i].l &gt;&gt; query[i].r &gt;&gt; query[i].h; if (!query[i].l) ++ query[i].l; query[i].id = i; } sort(query + 1, query + m + 1, [&amp;](Q a, Q b){ return a.h &lt; b.h; }); for (int i = 1, j = 1; i &lt;= m; i ++ ) { while(j &lt;= n &amp;&amp; a[j].first &lt;= query[i].h) F.add(a[j].second, 1), ++ j; ans[query[i].id] = F.query(query[i].l, query[i].r); } for (int i = 1; i &lt;= m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; \" \\n\"[i == m];}int main (){ cin.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _ -- ; ) solve(); return 0;} Minimum Or Spanning Tree题意给定 $n$ 个点和 $m$ 条边的无向图，每条边连接 $u,v$ 两个端点，边权为 $w$ ，问图的生成树的最小代价。 这里，我们定义一棵生成树的代价为它所有边的边权按位或得到的值。 分析贪心，由于位运算的每个位都是独立运算的，所以我们一定要让高位尽量小。 从高到低枚举每个位，如果在当前位为 $0$ 的边可以生成树，那么这一位就可以不用作贡献，否则这一位一定会产生贡献。 注意，如果某一位不作贡献，那么我们要把其他作贡献的 $ban$ 掉，在接下来考虑低位时，不能使用不作贡献但在低位为 $0$ 的边。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;struct T { int u, v, w; bool ban; };const int N = 400010;int n, m, ans;T e[N];int main (){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i ++ ) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; e[i] = { -- u, -- v, w, 0 }; } for (int i = 30; i &gt;= 0; i -- ) { vector&lt;bool&gt; vis(n); for (int j = 1; j &lt;= m; j ++ ) if (!e[j].ban &amp;&amp; !(e[j].w &gt;&gt; i &amp; 1)) vis[e[j].u] = vis[e[j].v] = 1; if (vis != vector&lt;bool&gt;(n, true)) ans |= 1 &lt;&lt; i; else for (int j = 1; j &lt;= m; j ++ ) if (e[j].w &gt;&gt; i &amp; 1) e[j].ban = 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 函数求和题意给定 $n$ 个整数 $a_1, a_2, \\ldots, a_n$ 和正整数 $k$ 满足 $(0 \\le a_i \\le 2^k - 1)$ 。 定义函数 $f(x)$ 为满足 $a_i \\&amp; x != a_i$ 的最小的 $i$ ，当满足条件的 $i$ 不存在时 $f(x) = 0$ 。 求 $\\sum_{i=0}^{2^k-1} f(x)$ 。由于答案可能很大，输出答案取模 $998244353$ 后的值。 其中 $1 \\le n \\le 100, 1 \\le k \\le 60$ 。 分析考虑每个数字对答案的贡献。 对于第一个数字，假设它二进制为 $00101$ ，那么，只要它上面的 $1$ ，在 $x$ 的二进制同样的位上为 $0$ ，就会将 $a_1$ 上的 $0$ 变为 $1$ ，则 $a_1 \\&amp; x != a_1$ 。所以贡献为 $(2^{cnt} - 1) \\times 2^{leave} \\times i$ ，其中 $cnt$ 为二进制下为 $1$ 的数量，$leave$ 表示 $0$ 的数量。 对于第二个数字，想要让它产生贡献，就必须满足 $a_1 \\&amp; x == a_1$ ，即 $a_1$ 二进制上的 $1$ ，在 $x$ 中也同样出现。 比如 $a_2 = 10101$ ，那么只有第一个位会让 $a_2$ 产生贡献，即 $(2^{new\\_cnt} - 1) * 2^{k - new\\_cnt - cnt}\\times i $ 。其中 $cnt$ 指前面的数字出现的 $1$ 的位数。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int P = 998244353;int main (){ bitset&lt;60&gt; bit; int n, k, ans = 0; cin &gt;&gt; n &gt;&gt; k; vector&lt;long long&gt; a(n); for(long long &amp;v: a) cin &gt;&gt; v; for (int i = 0; i &lt; n; i ++ ) { int cnt = 0; for (int j = 0; j &lt; k; j ++ ) if (a[i] &gt;&gt; j &amp; 1 &amp;&amp; !bit[j]) ++ cnt; ans = (ans + (((1ll &lt;&lt; cnt) - 1) % P) * ((1ll &lt;&lt; k - bit.count() - cnt) % P) * (i + 1) % P) % P; bit |= a[i]; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} Closest Equals题意给定一个下标从 $1 \\sim n$ 的序列 $a$ ，然后进行 $m$ 次询问。 每次询问给出一对 $[l, r]$ ，找到区间中数值相等的且距离最近的两个数字 $a_i, a_j$ ，求出他们的距离。 换言之找到一组数 $(a_i, a_j)$ 满足： $a_i = a_j$ $l \\le i, j \\le r \\ \\ (i != j)$ 求出 $|i - j|$ 的最小值，如果区间不存在两个相等的数字，则输出 $-1$ 。 其中 $1 \\le n, m \\le 5 \\times 10^5, 1 \\le a_i \\le 10^9$ 。 分析距离最近的两个相同数字，在所有与他们相同的数字中一定是相邻的。 对于在位置 $i$ 上的数字 $a_i$ ，与它相等的前一个数字为 $pre_i$ ，那么如果询问区间包括这两个位置，则产生 $i - pre_i$ 的贡献，换言之，对于区间 $[l, r]$ ，我们只需要找出所有这样的贡献的最小值即可。 考虑使用线段树， $i$ 位置的贡献(权值)为 $i - pre_i$ ，那么对于区间 $[1, r]$， 只需要找出区间最小值。 考虑区间的左端点 $l$ ，位置 $[1, l]$ 上的数字不会和他们后面的数字产生贡献，令他们后面的数字贡献为 $+ \\infty$ 。 也就是说，我们的线段树需要支持单点修改和区间查询。 进行 $m$ 次 $[1, l]$ 的单点修改会 $Tle$ ，可以把查询离线下来，这样每次只需要改 $[last_l, now_l-1]$ 的元素即可，每个点只会被修改一次。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define lc p&lt;&lt;1#define rc p&lt;&lt;1|1#define mid (t[p].l + t[p].r &gt;&gt; 1)struct Node { int l, r, Min; };struct Q { int l, r, id; };const int N = 500010, INF = 0x3f3f3f3f;int n, m, d[N], ans[N]; // d(i)表示i位置元素与前面相同元素位置的差值int post[N]; // 和下标为i的数字相等的后面的数字的位置map&lt;int, int&gt; idx;Q q[N];Node t[N &lt;&lt; 2];void pushup (int p) { t[p].Min = min(t[lc].Min, t[rc].Min); }void build (int p, int l, int r){ t[p].l = l, t[p].r = r; if (l != r) build(lc, l, mid), build(rc, mid + 1, r);}void update (int p, int x, int v){ if (t[p].l == t[p].r) { t[p].Min = v; return ; } if (x &lt;= mid) update(lc, x, v); else update(rc, x, v); pushup(p);}int query (int p, int l, int r){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].Min; int Min = INF; if (l &lt;= mid) Min = min(Min, query(lc, l, r)); if (r &gt; mid) Min = min(Min, query(rc, l, r)); return Min;}int main (){ memset(d, 0x3f, sizeof d); scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); for (int i = 1; i &lt;= n; i ++ ) { int x; scanf(\"%d\", &amp;x); if (idx.count(x)) d[i] = i - idx[x], post[idx[x]] = i; idx[x] = i; } for (int i = 1; i &lt;= n; i ++ ) update(1, i, d[i]); for (int i = 1; i &lt;= m; i ++ ) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); q[i] = { l, r, i }; } sort(q + 1, q + m + 1, [&amp;](Q a, Q b){ return a.l &lt; b.l; }); for (int i = 1; i &lt;= m; i ++ ) { for (int k = max(1, q[i-1].l); k &lt;= q[i].l - 1; k ++ ) if (post[k]) update(1, post[k], INF); ans[q[i].id] = query(1, q[i].l, q[i].r); if (ans[q[i].id] == INF) ans[q[i].id] = -1; } for (int i = 1; i &lt;= m; i ++ ) printf(\"%d\\n\", ans[i]); return 0;} CCPC Harbin 2021 G. Damaged Bicycle题意校园可以被看做 $n$ 个点，$m$ 条边的无向图，其中第 $i$ 条边长度为 $w_i$ ，你的宿舍在 $1$ 号点，你想从宿舍去教学楼($n$ 号点)。你的走路速度为每秒 $t$ ，骑车速度为每秒 $s$ 。校园内一共有 $k$ 个停车点，第 $i$ 个停车点在 $a_i$ 点，但是有 $\\dfrac {p_i} {100}$ 的概率，车可能是坏的。但是你只有到达 $a_i$ 点，才知道第 $i$ 辆车是不是好的。如果车是好的，可以直接骑到终点。 问你最优策略下，你最小的到达终点的期望时间是多少。如果到达不了 $n$ 号点，输出 $-1$ 。 其中 $1 \\le t \\le r \\le 10^4, 1 \\le n, m \\le 10^5, 1 \\le w_i \\le 10^4, 0 \\le k \\le 18$ 。 分析注意 $k$ 的范围很小，最多只有 $18$ ，可以考虑对于每一个停车点，他到达其他点的最短路。 加入从 $1$ 点到达某个停车点，可以有以下策略： 车没有坏，可以直接骑到终点。 车坏了，要么直接走到终点，要么去另外一个停车点。 定义 $dp(id, st)$ 表示在 $id$ 这个停车点，且目前一共走了 $st$ 的停车场($st$ 为每个停车点的状态，即二进制表示)。 对于车坏了且直接走到终点，有期望时间： $res = p[id] \\times d[id][n] \\div t + (1-p[id]) \\times d[id][n] \\div r$ 。 其中前面表示车坏了的情况，后面表示车没坏的情况。 对于车坏了，走到另外的停车点，有期望时间： $res = p[id] \\times (d[id][a[i]] + dfs(i, status | (1 &lt;&lt; i-1))) \\div t + (1-p[id]) \\times d[id][n] \\div r$ 。 其中 $dfs$ 用来记忆化计算 $dp(id, status)$ 。 Trick：可以把第 $1$ 个点设为第 $19$ 个停车点，且车坏掉的概率为 $1$ 。这样答案就是 $dp(19, 0)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;using T = pair&lt;int, int&gt;;const int N = 100010, M = 20, INF = 0x3f3f3f3f;int n, m, r, t, k;vector&lt;T&gt; g[N];int a[M]; // 每个停车点所在的位置double p[M]; // 每个停车点的坏车概率int d[M][N]; // 从每个停车点到达其他点的最短路bool vis[N];double dp[M][1 &lt;&lt; M]; // dp(id, status)void dijkstra (int id, int st){ memset(vis, 0, sizeof vis); memset(d[id], INF, sizeof d[id]); priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; q; q.push({0, st}); d[id][st] = 0; while(q.size()) { T ver = q.top(); q.pop(); int u = ver.second, dist = ver.first; if (vis[u]) continue; vis[u] = true; for (auto &amp;[v, w]: g[u]) { if (d[id][v] &gt; dist + w) { d[id][v] = dist + w; q.push({d[id][v], v}); } } }}// 从id停车场出发，且当前经过status状态的停车场double dfs (int id, int status){ if (dp[id][status]) return dp[id][status]; // 有没有坏都直接走到终点 double res = p[id] * (double)d[id][n] / t + (1 - p[id]) * (double)d[id][n] / r; // 如果没坏，直接走到终点，否则走到另一个停车场 for (int i = 1; i &lt;= k; i ++ ) { if (status &gt;&gt; i-1 &amp; 1) continue; // i号已经走过 res = min(res, (1-p[id]) * (double)d[id][n] / r + \\ p[id] * ((double)d[id][a[i]] / t + dfs(i, status | (1 &lt;&lt; i-1)))); } return dp[id][status] = res;}int main (){ scanf(\"%d%d%d%d\", &amp;t, &amp;r, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i ++ ) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); g[u].push_back({v, w}); g[v].push_back({u, w}); } scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; i ++ ) { scanf(\"%d%lf\", &amp;a[i], &amp;p[i]); p[i] /= 100; } // 从每个停车点计算dij for (int i = 1; i &lt;= k; i ++ ) dijkstra(i, a[i]); dijkstra(19, 1); // 假设1点位一定坏的停车场 if (d[19][n] == INF) return printf(\"-1\\n\"), 0; p[19] = 1; printf(\"%.10lf\\n\", dfs(19, 0)); return 0;} 拆方块题意有 $n$ 堆方块，第 $i$ 堆方块由 $h_i$ 个方块堆积而成。 每次操作，需要把所有上下左右不全为方块或地面（即与空气接触）的方块拆除，问经过多少次操作可以把所有方块拆除。 其中 $1 \\le n \\le 10^5, 1 \\le h_i \\le 10^9$ 。 样例： 分析大概是找规律？对于每个初始的状态，都等价于 $123 \\ldots (k-1)(k)(k-1) \\ldots 321$ 。这样的状态，即最左边堆和最右边堆为 $1$ 高度，越往中间高度越高： 然后需要拆除的次数就是中间那个最高的堆的高度了。 Code123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int n, a[N];int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i ++ ) a[i] = min(a[i-1] + 1, a[i]); for (int i = n; i &gt;= 1; i -- ) a[i] = min(a[i + 1] + 1, a[i]); cout &lt;&lt; *max_element(a + 1, a + n + 1) &lt;&lt; endl; return 0;} 工作安排题意约翰有太多的工作要做。 为了让农场高效运转，他必须靠他的工作赚钱，每项工作花一个单位时间。 他的工作日从 $0$ 时刻开始，有 $10^9$ 个单位时间。 在任一时刻，他都可以选择编号 $1$ 到 $N$ 的 $N$ 项工作中的任意一项工作来完成。 每项工作又有一个截止时间，对于第 $i$ 个工作，有一个截止时间 $D_i$ ，如果他可以完成这个工作，那么他可以获利 $P_i$ 。 在给定的工作利润和截止时间下，约翰能够获得的利润最大为多少。 其中 $1 \\le N \\le 10^5, 1 \\le D_i, P_i \\le 10^9$ 。 分析原题： 超市 。 使用二叉堆贪心，在二叉堆中插入选择的工作的利润，遍历所有的工作： 当前的截止时间小于堆中选择的工作数量，直接选择这个工作。 当前截止时间等于堆中选择的工作数量，那么判断堆顶元素是否小于当前工作利润，如果小于，替换为当前工作。 使用并查集贪心，优先做利润高的工作，同时尽量在晚的时间来做工作，这样可以对其他工作有“决策包容性”，即：对于截止时间比他大的，不会受到影响；对于截止时间比他小的，它的选择不会变差。 那么可以把所有工作按照利润从大到小排序，建立一个关于“天数”的并查集，起初每一天都是独立集合。对于每一个工作，假设它在第 $d$ 天过期，那么查询 $d$ 的树根（记为 $r$），如果 $r &gt; 0$ ，那么这项工作在 $r$ 天做，并合并 $r$ 和 $r-1$ 的天数。 这个并查集本质维护：对于每一天，在他前面第一个空闲时间的位置。 注意这题数据有问题，$D_i$ 可能为 $0$ ，这个工作在开始的时候就截至了，需要特判。 Code二叉堆贪心 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;struct T { int d, p; };const int N = 100010;int n, pre;long long ans;T a[N];int main (){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d%d\", &amp;a[i].d, &amp;a[i].p); sort(a + 1, a + n + 1, [&amp;](T a, T b){ return a.d &lt; b.d; }); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 1; i &lt;= n; i ++ ) { if (!a[i].d) continue; if (a[i].d &gt; q.size()) q.push(a[i].p); else if (q.top() &lt; a[i].p) { q.pop(); q.push(a[i].p); } } while(q.size()) { ans = ans + q.top(); q.pop(); } printf(\"%lld\\n\", ans); return 0;} 并查集贪心 三角果计数题意给定 $n$ 个节点的树，三角果定义为一个包含 $3$ 个节点的集合，且他们两两之间的最短路长度 $a, b, c$ 能够构成一个三角形。 计算这棵树上有多少个不同的三角果。 其中 $1 \\le n \\le 10^5$ ，边权 $1 \\le w \\le10^5, 1 \\le u, v \\le n$ 。 分析能否组成三角形与边权无关，只要三个点在一条链上就一定不能组成三角果，不在一个链上就一定可以。 所以对每个节点，取它两棵子树上的一个节点，剩下一个节点取另外一棵子树，或者在另外的其他点取。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 100010;int n;vector&lt;int&gt; g[N];ll ans = 0;ll dfs (int u, int fa){ ll c1 = 0, c2 = 0; // c1表示取一个节点，c2表示取两个节点 for (int v: g[u]) { if (v == fa) continue; ll cc = dfs(v, u); ans += c2 * cc; c2 += c1 * cc; c1 += cc; } if (c1 + 1 &lt; n) ans += c2 * (n - c1 - 1); return c1 + 1;}int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 整齐的数组2题意Polycarp 有一个长度为 $n$ 的数组 $a_1, a_2, \\ldots, a_n$ ( $n$ 是偶数)。Polycarp 还得到了一个正整数 $k$ ，他对数组 $a$ 做如下操作：选择一个下标 $a_i$ ( $1 \\le i \\le n$ ) 使 $a_i$ 减去 $k$ 。 在 Polycarp 进行若干次操作后(可能 $0$ 次)，数组 $a$ 中的数字 至少有一半 都变成相同的了。请你找到最大的符合条件要求的 $k$ ，若 $k$ 可以为任意大，请输出 $-1$ 。 其中 $4 \\le n \\le 40, -10^6 \\le a_i \\le 10^6$ 。 分析枚举任意两个数 $a_i, a_j$ ，假设他们是最后相同的两个数字，那么 $k$ 一定是 $a_j - a_i$ 的因子，只有这样 $a_j$ 才可以通过若干次 $-k$ 得到 $a_i$ 。 枚举这个因子，再检查是否通过这个因子可以得到一半的数字，通过减去若干次 $k$ 得到 $a_i$ 即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 50;int n, a[N], k;void calc (int p, int d){ int num = 0; for (int i = p; i &lt;= n; i ++ ) if ((a[i] - a[p]) % d == 0) ++ num; if (num &gt;= n / 2) k = max(k, d);}int main (){ int _; for (cin &gt;&gt; _; _ -- ; ) { cin &gt;&gt; n; k = -1; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); // 一开始就有一半数字相同 bool ok = false; map&lt;int, int&gt; cnt; for (int i = 1; i &lt;= n; i ++ ) { ++ cnt[a[i]]; if (cnt[a[i]] &gt;= n / 2) ok = true; } if (ok) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } // 否则枚举两个数字，枚举因子 for (int i = 1; i &lt;= n; i ++ ) { // 把这个数字作为要变成相同数字的最小值 for (int j = i + 1; j &lt;= n; j ++ ) { int dif = a[j] - a[i]; // 枚举dif的因子 for (int d = 1; d &lt;= dif / d; d ++ ) { if (dif % d == 0) { calc(i, d); if (d != dif / d) calc(i, dif / d); } } } } cout &lt;&lt; k &lt;&lt; endl; } return 0;} 三进制循环题意在神奇的树の国度，叽叽发现了一棵包含 $n$ 个节点的三进制树，节点的编号是 $1 \\sim n$ 。这棵树的任意一个节点的值可能为 $0, 1, 2$ 其中的一个。她喜欢有规律而不是杂乱无章的序列，她想在这棵树上找到一个路径，要满足从路径的一端到达另一端，从第二个节点开始，每个节点的值都等于上一个节点的值 $+1$ 之后对 $3$ 取模。 换言之，把路径转化为长度为 $len$ 的序列 $G$ ，对于序列的地 $2 \\le i \\le len$ 项，要满足 $G_i = (G_{i-1} + 1) \\ \\ mod \\ \\ 3$ 。例如 $2, 0, 1, 2, 0$ 。 现在，给出这颗三进制树，你能帮她找到长度最长的满足条件的路径吗，输出最长的路径长度。 分析假设某一个节点作为链上的节点，那么它需要在一端接上一条上升链，另一端接上一条下降链，枚举子树即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010;int n, a[N], dp[N][3][2], ans; // 0表示上升链，1表示下降链vector&lt;int&gt; g[N];void dfs (int u, int fa){ dp[u][a[u]][0] = dp[u][a[u]][1] = 1; int up = 0, down = 0; for (int v: g[u]) { if (v == fa) continue; dfs(v, u); if (up &lt; dp[v][(a[u] + 2) % 3][0]) up = dp[v][(a[u] + 2) % 3][0]; if (down &lt; dp[v][(a[u] + 1) % 3][1]) down = dp[v][(a[u] + 1) % 3][1]; } dp[u][a[u]][0] += up; dp[u][a[u]][1] += down; ans = max(ans, dp[u][a[u]][0] + dp[u][a[u]][1] - 1);}int main (){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); dfs(1, 0); printf(\"%d\\n\", ans); return 0;} 树上逆序对题意对于一棵有根树，定义树上的逆序对为满足 $a_i &lt; a_{fa_i}$ 的二元对 $(i, fa_i)$ ，其中 $fa_i$ 表示节点 $i$ 的父节点。 对于一棵 $k$ 叉树，节点 $i$ 的子节点编号集合为 $[1, n] \\ \\bigcap \\ [k(i-1)+2, ki+1]$ 中的所有整数。 给定 $n$ 个节点的权值 $a_1, a_2, a_3, \\ldots , a_n$ ，对于 $k = 1, 2, \\ldots , n-1$ 求出当这 $n$ 个节点构成一棵 $k$ 叉树时树上逆序对数。 其中 $2 \\le n \\le 2 \\times 10^5, 1 \\le a_i \\le 10^9$ 。 分析对于一棵 $k$ 叉树，它的非叶子节点个数为至多 $\\lceil \\dfrac n k \\rceil$ 个。因为 $k$ 叉树除最后一层是一个满二叉树。 那么所有可能的 $k$ 叉树，非叶子节点个数总和为 $\\lceil \\dfrac n 1 \\rceil + \\lceil \\dfrac n 2 \\rceil + \\lceil \\dfrac n 3 \\rceil + \\ldots + \\lceil \\dfrac n {n-1} \\rceil = nlogn$ 个。 对于每个非叶子节点，记 $[l, r]$ 为它的儿子区间，这棵树的叉数为 $r-l+1$， 求出小于等于父节点权值的数字即为其 $k$ 叉树的贡献， 那么问题就变成了： 给定若干个区间，对于每个区间，问满足小于某个数字的数量有多少个。 对所有这样的区间做离线处理，记录 $[l, r, v]$ ，其中 $v$ 为区间的父节点权值。 对所有区间按照 $v$ 值排序，然后对所有点的权值排序，对于每个区间，将小于 $v$ 的所有点权值插入树状数组，然后查询该区间有多少点做出贡献即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 400010;struct T { ll l, r, v; };struct Msg { int v, id; };struct fenwick{ int c[N]; void add (int x, int v) { if (x) for (; x &lt; N; x += x &amp; -x) c[x] += v; } int query (int x) { int res = 0; if (x) for (; x; x -= x &amp; -x) res += c[x]; return res; } int query (int l, int r) { return query(r) - query(l-1); }};int n, ans[N];Msg a[N];vector&lt;T&gt; query;fenwick F;int main (){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i].v), a[i].id = i; for (int k = 1; k &lt;= n - 1; k ++ ) for (int u = 1; u &lt;= n; u ++ ) { ll l = (ll)k * (u - 1) + 2; ll r = (ll)k * u + 1; if (l &lt;= r) query.push_back({l, r, a[u].v}); if (r &gt;= n) break; } sort(query.begin(), query.end(), [&amp;](T a, T b){ return a.v &lt; b.v; }); sort(a + 1, a + n + 1, [&amp;](Msg a, Msg b){ return a.v &lt; b.v; }); int now = 1; for (auto Q: query) { while (now &lt;= n &amp;&amp; a[now].v &lt; Q.v) F.add(a[now ++ ].id, 1); ans[Q.r-Q.l+1] += F.query(Q.l, Q.r); } for (int i = 1; i &lt; n; i ++ ) printf(\"%d \", ans[i]); return 0;} 约分题意给定一个分数 $\\dfrac p q$ 。每次操作可以删除 $p$ 和 $q$ 共有的一个数位，问在这样的约分操作下 $\\dfrac p q$ 的最简分数为多少。 最简分数：与 $\\dfrac p q$ 等价的分数中，分子最小的那一个。 其中 $1 \\le p, q \\le 2^{63} - 1$ 。 分析数字最多有 $18$ 个数位，二进制枚举 $p$ 应该删除哪些数字，得到分子 $a$，得出等价的 $b$ ，再判断是否能通过操作得到 $b$ 。 在判断的时候需要知道 $p$ 删除了哪些数位，然后删除的前导 $0$ 一定在 $b$ 的前面，判断这样的 $b$ 是否加上了删除的数位等于 $q$ ，以及 $b$ 是否为 $q$ 的子序列即可。 具体的可以看代码。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;using ll =long long;const int N = 20;ll oa, ob;int A[N], B[N], ca, cb, cnta[10], cntb[10];ll change (int st){ ll res = 0; for (int i = 0; i &lt; ca; i ++ ) if (!(st &gt;&gt; i &amp; 1)) res = res * 10 + A[i]; return res;}bool judge (int st){ ll a = change(st), b = 1.0 * ob / oa * a + 0.001, oob = b;// cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; // 检查b是否合法 static int del[10], CB[10]; memcpy(del, cnta, sizeof cnta); memset(CB, 0, sizeof CB); for (int i = 0; i &lt; ca; i ++ ) if (!(st &gt;&gt; i &amp; 1)) -- del[A[i]]; // del保留每个数字需要被删除的情况 while(b) ++ CB[b % 10], b /= 10; for (int i = 1; i &lt;= 9; i ++ ) if (del[i] + CB[i] != cntb[i]) return false; if (CB[0] &gt; cntb[0]) return false; // 加入有自动消退的0，那么一定是在b前面 static int f[20]; memset(f, 0, sizeof f); int cc = 0, cn = cntb[0] - del[0] - CB[0]; while(oob) f[cc ++ ] = oob % 10, oob /= 10; for (int i = 0; i &lt; cn; i ++ ) f[cc ++ ] = 0; reverse(f, f + cc); int now = 0; for (int i = 0; i &lt; cb; i ++ ) { if (f[now] == B[i]) ++ now; if (now == cc) return true; } return false;}int main (){#ifdef LOCAL freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\input.txt)\", \"r\", stdin); freopen(R\"(C:\\Users\\18340\\CLionProjects\\horb7\\output.txt)\", \"w\", stdout);#endif ll a, b; cin &gt;&gt; a &gt;&gt; b; oa = a, ob = b; while(a) A[ca ++ ] = a % 10, ++ cnta[a % 10], a /= 10; while(b) B[cb ++ ] = b % 10, ++ cntb[b % 10], b /= 10; reverse(A, A + ca); reverse(B, B + cb); ll ans = oa, res = ob; // 二进制枚举删除的数字,0表示保留 for (int st = 0; st &lt; (1 &lt;&lt; ca) - 1; st ++ ) { if (judge(st)) { if (ans &gt; change(st) &amp;&amp; change(st)) { ans = change(st); res = 1.0 * ob / oa * ans + 0.001; } } } cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; res &lt;&lt; endl; return 0;} 最大公约数题意你有一个环，环上有 $n$ 个正整数。你能将环切成 $k$ 段，每段包含一个或者多个数字。 对于一个切分方案，优美程度为每段数字和的最大公约数，你想使切分方案的优美程度最大，对于 $k = 1, 2, \\ldots n$ ，输出最大的优美程度。 其中 $1 \\le n \\le 2000, 1 \\le a_i \\le 5 \\times 10^7$ 。 分析对于一种 $k$ 段的切分方案：$a_1, a_2, \\ldots a_k$ ，其中 $a_i$ 表示第 $i$ 段数字之和。 那么有 $a_i = k_i \\times g$ ，其中 $g$ 表示所有段数字和的最大公约数， $k_i$ 表示第 $i$ 段对于 $g$ 的倍数。 $\\sum_{i=1}^k a_i = g \\times \\sum_{i=1}^k k_i$ ，也就是，$g$ 一定是 $a_i$ 的总和的因子，也就是所有数字之和的因子。 数字总和上限为 $10^{11}$ ， 这个数量级下最多有 $4000$ 数量的因子，可以直接枚举因子。 由于枚举的 $g$ 一定是总和的因子，那么如果有两个位置 $pre[i] \\equiv pre[j] \\pmod g$ ，剩下的头尾相连也一定是 $g$ 的倍数。对于枚举的 $g$ ，假设可以划分为 $cnt$ 段，此时优美程度为 $g$ ，那么对于任意 $k \\le cnt$ ，也可以使用 $g$ 这个优美程度。 记录 $ans[i]$ 表示 $k = i$ 时的最大优美程度，求后缀最大值。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 2010;int n, a[N];ll pre[N], ans[N];void calc (ll g){ map&lt;int, int&gt; mp; int cnt = 0; for (int i = 1; i &lt;= n; i ++ ) { ++ mp[pre[i] % g]; cnt = max(cnt, mp[pre[i] % g]); } ans[cnt] = max(ans[cnt], g);}int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], pre[i] = pre[i-1] + a[i]; for (ll i = 1; i &lt;= pre[n] / i; i ++ ) { if (pre[n] % i == 0) { calc(i); if (i != n / i) calc(pre[n] / i); } } for (int i = n; i &gt;= 1; i -- ) ans[i] = max(ans[i], ans[i + 1]); for (int i = 1; i &lt;= n; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; \" \\n\"[i == n]; return 0;} 平方计数题意给定 $n$ 个正整数，第 $i$ 个数用 $a_i$ 表示，求出有多少对 $(i, j)$ 使得 $a_i^2 + a_j$ 为平方数。 其中 $1 \\le n \\le 10^6, 1 \\le a_i \\le 10^6$ 。 分析$a_i^2 + a_j = x^2$ ，转化可得 $a_j = x^2 - a_i^2 = (x - a_i) \\times (x + a_i)$ 。 枚举 $a_j$ 的因子 $fac_1, fac_2$ 那么有 $fac_2 - fac_1 = 2 \\times a_i$ 。 直接枚举 $a_j$ 的因子复杂度为 $O(n \\sqrt n)$ ，容易超时，可以使用枚举倍数的形式，复杂度为 $O(n log n)$ 。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int n, a[N], cnt[N];long long ans;int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], ++ cnt[a[i]]; for (int i = 1; i &lt;= 1000000; i ++ ) // 枚举其中一个因子 for (int j = i; j &lt;= 1000000; j += i) // 枚举它的倍数 { int mi = min(j / i, i), mx = max(j / i, i); int d = mx - mi; // d = 2 * a[idx] if (d % 2 == 0) ans = ans + (long long)cnt[j] * cnt[d / 2]; } cout &lt;&lt; ans / 2 &lt;&lt; endl; return 0;} 字典序最小题意从长度为 $n$ 的序列中选择长度为 $m$ 的子序列，满足这个子序列是一个 $1 \\sim m$ 的排列，求字典序最小的这样的排列。 其中 $1 \\le n \\le 10^6, 1 \\le a_i \\le m$ 。 分析使用栈来模拟求出答案的过程。 从前往后枚举每个数字，如果当前数字存在于栈中（被选定为答案），那么直接跳过。 否则将栈中所有大于它的数字弹出，注意为了使答案满足 $1 \\sim m$ 的排列，需要保证弹出的数字在后面还存在。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int n, m, a[N], last[N];bool instk[N];int main (){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]), last[a[i]] = i; stack&lt;int&gt; stk; for (int i = 1; i &lt;= n; i ++ ) { if (instk[a[i]]) continue; while(stk.size() &amp;&amp; last[stk.top()] &gt; i &amp;&amp; a[i] &lt; stk.top()) instk[stk.top()] = false, stk.pop(); stk.push(a[i]); instk[a[i]] = true; } vector&lt;int&gt; ans; while(stk.size()) ans.push_back(stk.top()), stk.pop(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; m; i ++ ) printf(\"%d%s\", ans[i], i + 1 == m ? \"\\n\" : \" \"); return 0;} 拆拆题意多组数据。 每组给定两个数 $X, Y$ ，问有多少个长度为 $Y$ 的整数序列之乘积为 $X$ ，即 \\prod_{i=1}^Y f_i = X注意：两序列不同，当且仅当至少有一个下标相同的位置不同。如 $(1, 2), (2, 1)$ 被视为不同的序列。 答案可能很大，将其模以 $10^9 + 7$ 输出。 例如：给定 $(X, Y) = (6, 2)$ ，可以将 $6$ 分成 $(\\pm 1, \\pm 6), (\\pm 2, \\pm 3), (\\pm 3, \\pm 2), (\\pm 6, \\pm 1)$ 八种长度为 $2$ 的序列，答案为 $8$ 。 分析对于乘积，先想到的是对 $X$ 进行质因数分解。 因为需要 $Y$ 个数字，可以想象成有 $Y$ 个盒子，每个盒子最开始只有数字 $1$ ，对于每种质因数，将他们分在 $Y$ 的盒子里，可以存在空盒子，这是一个隔板法模型，答案为 $C(Y + s - 1, Y - 1)$ ，其中 $s$ 为某个质因数的数量。也就是增加 $Y$ 个球，变为不能为空盒子的隔板法模型。 由于可以存在负数，所以可以把偶数个数字改为负数，不影响答案，$C(Y, 0) + C(Y, 2) + \\ldots = 2^{Y-1}$ 。根据乘法原理乘起来即可。 由于存在多组测试数组，需要预处理出 $C(n, m)$ 和 每个数字的所有质因子，枚举倍数即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;struct T { int v, s; };const int N = 1000010, mod = 1e9 + 7;int fac[N], infac[N], P[N];vector&lt;T&gt; F[N]; // 所有数字的质因子int quick_power (int a, int k){ int res = 1; for (a %= mod; k; k &gt;&gt;= 1, a = (ll)a * a % mod) if (k &amp; 1) res = (ll)res * a % mod; return res;}int inv (int x) { return quick_power(x, mod - 2); }void init (){ P[0] = 1; for (int i = 1; i &lt; N; i ++ ) P[i] = (ll)P[i-1] * 2 % mod; fac[0] = 1; for (int i = 1; i &lt; N; i ++ ) fac[i] = (ll)fac[i-1] * i % mod; infac[N-1] = inv(fac[N-1]); for (int i = N - 2; i &gt;= 0; i -- ) infac[i] = (ll)infac[i+1] * (i+1) % mod; // 调和级数求出每个数字的质因子 for (int i = 2; i &lt; N; i ++ ) { if (F[i].size()) continue; for (int j = i; j &lt; N; j += i) { int t = j, s = 0; while(t % i == 0) ++ s, t /= i; F[j].push_back({i, s}); } }}int C (int n, int m){ if (n &lt; m) return 0; return (ll)fac[n] * infac[m] % mod * infac[n-m] % mod;}void solve (){ int x, y; scanf(\"%d%d\", &amp;x, &amp;y); ll ans = 1; for (auto ps: F[x]) (ans *= C(ps.s + y - 1, y - 1)) %= mod; (ans *= P[y-1]) %= mod; printf(\"%lld\\n\", ans);}int main (){ init(); int _; for (scanf(\"%d\", &amp;_); _ -- ; ) solve(); return 0;} 区间和题意对于一个长度为 $n$ 的序列，给出 $q$ 次提示，每次给出 $[L, R]$ 区间的元素和，问能否知道整个序列的元素和。 分析对于给定的 $[L, R]$ 区间元素和，就是知道了 $sum_R - sum_{L-1}$ 的值，如果我们知道其中任意一个，就知道了另外的值。 使用并查集维护这样的关系，使得只要知道了集合内任意一个元素的值，都能知道其他元素的值。 特别的，$sum_0 = 0$ ，能求出整个序列的元素和，只有当 $0$ 和 $n$ 在同一个集合内。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int n, m, p[N];int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }int main (){ cin &gt;&gt; n &gt;&gt; m; iota(p + 1, p + n + 1, 1); while(m -- ) { int x, y; cin &gt;&gt; x &gt;&gt; y; p[find(x - 1)] = find(y); } cout &lt;&lt; (find(0) == find(n) ? \"Yes\\n\" : \"No\\n\"); return 0;}","categories":[],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://horb7.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"Django入门","slug":"Django入门","date":"2022-02-25T15:31:21.000Z","updated":"2022-02-26T06:38:35.387Z","comments":true,"path":"2022/02/25/Django入门/","link":"","permalink":"https://horb7.github.io/2022/02/25/Django%E5%85%A5%E9%97%A8/","excerpt":"","text":"前言学习资料Imooc教程：三小时带你入门Django Django中文文档 Django 介绍基本介绍：Django 是一个由Python编写的Web应用框架，本身基于MVT模型，即：模型层(Model) ，模板层(Template)，视图层(View)。 除了上面三层，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template。 用户操作流程图： 解析： 用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数： 如果不涉及函数调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。 如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。 Django 基本命令django-admin是Django用于管理任务的命令行工具，使用django-admin查看其他命令。 其中重要的命令有： startproject # 用于创建Django的一个项目 startapp # 用于创建Django的一个应用（软件包） check # 校验项目的完整性 runserver # 进入Django项目环境并启用Django项目 shell # 进入Django项目的 Python Shell环境 test # 执行Django用例测试 makemigrations # 创建模型变更的迁移文件 migrate # 执行上一个命令创建的迁移文件，即把模型等导入到数据库 dumpdate # 把数据库数据导出到文件 loaddate # 把文件数据导入到数据库 创建一个项目使用django-admin startproject django_study 创建第一个项目，我们会发现django_study作为文件被创建，且目录下有若干个初始文件： 其中 manage.py 为项目管理文件，项目中的django_study文件夹包含此项目的所有配置。 其中：settings.py为项目的总设置，urls.py 为Django项目的总路由文件，wsgi.py 为Django作为wsgi应用所需要的内容。 运行项目使用 python3 manage.py runserver 运行Django项目。 如果你的项目在本地开发 直接在浏览器输入127.0.0.1:8000 即可，如果成功则显示Django的初始化界面。 如果你的项目在服务器上开发 在命令后面加上0.0.0.0:8000，即python3 manage.py runserver 0.0.0.0:8000 (如果是Docker环境需要把端口改为映射的端口，比如我的是8080)，注意服务器的8000端口需要打开，可以去购买服务器的网站上打开，在本地使用ip:8000查看，你会发现没有成功： 这是因为Django具有保护机制，不会使其他ip地址来访问项目，如果想在本地调试，需要去\\django_study\\settings.py 文件中，设置ip为可访问ip： 再次使用python3 manage.py runserver 0.0.0.0:8000 重新部署Django项目即可。 以下都用本地开发的ip为例子，服务器开发只需要换自己的服务器的ip即可。 Django应用介绍Django应用 VS Django项目： 一个Django项目就是一个基于Django的Web应用 一个Django应用就是一个可重用的Python软件包（即可出现在若干个项目中） 每个应用可以自己管理模型、视图、模板、路由和静态文件等 一个Django项目包含一组配置和若干个Django应用 创建一个Django应用使用python3 manage.py startapp blog 创建一个应用。 此时项目文件中新建了一个blog应用(文件夹)，它有以下目录： Django应用目录介绍： views.py # 视图处理的地方 models.py # 定义应用模型的地方 admin.py # 定义Admin模块管理对象的地方 apps.py # 声明应用的地方 tests.py # 编写应用测试用例的地方 除此之外，还需要创建urls.py文件来管理应用的路由，使用touch urls.py。 Django HelloWorldDjango视图在没有框架的时代，如果要写一个hello,world网页，只需要写出html元素，但对于一个复杂的网页，不可能通过html来表达网页中所有的元素。 在一个网页中产生内容，就是Django视图的工作。 具体来说，我们在视图文件中编写一个个的逻辑函数，接受html的请求，并根据请求来生成响应数据并返回。Django视图主要用于处理项目的业务逻辑部分。 在blog应用中，我们编写其视图函数，在views.py中写入： 123456789from django.shortcuts import render# Create your views here.from django.http import HttpResponsedef hello_world(request): # request参数就是http请求的对象 return HttpResponse(\"Hello World!\") Django路由在编写完上述代码，重新部署项目，却仍然是Django的欢迎页面。 这是因为Django视图仅仅是对http的请求做出相应，而我们并没有发出这样的请求，所以没办法到达刚才的视图函数。 配置路由，可以将http以url的形式发出请求并获得响应，譬如，对于\"ip/hello_world\"，就是向服务器发出了”hello_world”这个请求。 我们需要配置应用级别的路由和项目级别的路由。 对于应用级别的路由，在blog/urls.py中写入： 123456from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world),] 对于项目级别的路由，在django_study/urls中写入： 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('blog/', include('blog.urls')),] 它表示，如果我们的请求为blog的子目录，那么通过include转发到blog.urls这个文件中（继续寻找）。 注意这里的引用模块，都是按照django_study这个项目文件来相对引用的 。 部署项目我们在django_study项目中创建了一个应用，要想让这个项目使用blog这个应用，需要在项目文件中的settings注册应用。 这里的BlogConfig是blog/apps文件中的结构体，它代表着这个应用的实体。 接下来重新部署运行Django项目，在浏览器中输入127.0.0.1:8000/blog/hello_world，发现正确响应了http的请求。 一张表解释应用路由和项目路由的关系： Django模型层模型层介绍 位于Django视图层和数据库之间 Python对象和数据库表之间的转换 在项目运行过程，不可避免地需要使用数据来交互，通过视图层，与数据库交互得到数据，然后通过返回到前端渲染。模型层夹在视图层和数据库之间，使用模型层可以屏蔽不同数据库之间的差异，让开发者更加注重业务逻辑。同时模型层提供很多便捷工具来开发。 简单来说，模型就是抽象数据类型，我们可以把它作为视图与数据库的交互对象。 模型层配置在项目设置django_study/settings.py中，可以看到项目的模型层数据库的相关配置。 其中ENGINE表示模型层所交互的数据库，默认为Django自带的sqlite3数据库，NAME为数据库名字，作为文件存储在项目文件中。 创建博客文章要创建博客文章，需要以下操作： 设计博客模型 模型层定义字段 设计博客模型博客模型有以下几个属性： 文章标题(title) 文本类型 文章摘要(brief_context) 文本类型 文章内容(context) 文本类型 唯一ID标记(article_id) int，自增，主键 发布日期(date) 日期类型 模型层定义字段 数字类型: IntegerField 文本类型: TextField 日期类型: DateTimeField 自增ID: AutoField 主键定义: primary_key属性 进入应用文件blog/models.py，写入： 12345678910from django.db import models# Create your models here.class Article(models.Model): # 继承models模型 article_id = models.AutoField(primary_key=True) title = models.TextField() brief_content = models.TextField() content = models.TextField() publish_date = models.DateTimeField(auto_now=True) # auto_now=True 表示文章的发布日期即创建时的日期 使用python3 manage.py makemigrations，将模型的变更生成迁移文件。 再使用python3 manage.py migrate，运行迁移文件，将迁移内容同步到数据库中。 Django ShellDjango Shell 介绍类似于Python Shell，Django Shell可以进入Django项目环境，操作项目中的某些对象或者方法。 对于某些临时性操作，使用Django Shell可以更加方便，比如对于创建的Article字段，我们并不清楚它是否真的可以使用，Django Shell就是调试的最好工具。 同时，Django Shell使得小范围Debug更加简单，不需要写测试文件，运行整个项目来测试。 Django Shell操作使用python3 manage.py shell来启动Django Shell，引入Article模块来测试。 其中a.save表示将a对象存入数据库中，使用Article.objects.all()即可获得数据库所有Article对象。 这篇博客详细介绍了Django Shell的使用操作。 Django Admin模块Django Admin模块介绍Django Admin是Django的后台管理工具，它可以读取定义的模型元数据(也就是具体的数据)，提供强大的管理使用页面。 使用Django Shell创建数据，不仅复杂还容易出错，尤其对于复杂的模型而言。 使用Django Admin模块，可以在后台管理增加、删除、改变模型元数据，它是基础设施中重要的部分。 Django Admin模块的使用使用python3 manage.py createsuperuser来创建超级管理员。 在浏览器中输入127.0.0.1:8000/admin进入后台管理页面。 其中Groups和users是默认的模型，但是我们定义的Article模型没有出现，这是因为没有在Admin模块注册Article模型。 进入blog/admin.py，写入： 1234567from django.contrib import admin# Register your models here.from .models import Articleadmin.site.register(Article) 刷新admin页面，就会发现多出了一个模型： 点击Article，进入Article模型的数据管理页面，发现存在一个数据元，这就是之前在Django Shell中注册的Article对象。 在Admin页面，点击Article模型右边的+号，存储第二个数据： 点击右下方的save，完成在数据库中的存储。 我们发现，这里的数据并没有显示其文章的标题(title)，这不方便之后的管理。 进入blog/models.py，为Article模型添加方法 \\_\\_str\\_\\_ ： 12345678910111213from django.db import models# Create your models here.class Article(models.Model): article_id = models.AutoField(primary_key=True) title = models.TextField() brief_content = models.TextField() content = models.TextField() publish_date = models.DateTimeField(auto_now=True) def __str__(self): return self.title 重新部署项目，刷新浏览器： 发现数据可以根据其标题显示了。 实现博客数据返回页面进入blog/views.py，写入： 1234567891011121314def article_content(request): article = Article.objects.all()[0] title = article.title brief_content = article.brief_content content = article.content article_id = article.article_id publish_date = article.publish_date return_str = 'title: %s, brief_content: %s, ' \\ 'content: %s, article_id: %s, publish_date: %s' % (title, brief_content, content, article_id, publish_date) return HttpResponse(return_str) 配置应用级别路由，进入blog/urls，写入： 1234567from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world), path('content', blog.views.article_content),] 由于项目级别已经配置，这里不需要再配置。 打开浏览器，输入127.0.0.1:8000/blog/content，成功返回文章内容。 使用Bootstrap实现静态博客布局博客主页设计 其中上方为博客标题，左下方为博客文章，右下方为最新的文章。 文章页面设计 其中上方为文章标题，下方为文章内容。 Bootstrap以及Bootstrap的栅格系统Bootstrap是来自美国Twitter的前端框架，它提供了非常多的控件并附带源码。 进入BootsTrap中文官网 。 点击上方的组件 ，即可查看各组件及其源码。 点击上方全局CSS样式，也可以查看其中的各个样式。 Bootstrap 中的栅格系统，将页面按照横坐标分割为12等分，对于博客主页，使用9:3来分割： 在blog下创建templates文件夹，用于存放模板。 在blog/templates下创建index.html作为博客主页，写入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Django Study&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\" integrity=\"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu\" crossorigin=\"anonymous\"&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\" integrity=\"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container page-header\"&gt;&lt;h1&gt;My Django Study Web &lt;small&gt; ---- by Horb7&lt;/small&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"container page-body\"&gt; &lt;div class=\"col-md-9\" role=\"main\"&gt; &lt;div class=\"body-main\"&gt; &lt;div&gt; &lt;h2&gt;文章标题1&lt;/h2&gt; &lt;p&gt;第一个文章&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;文章标题2&lt;/h2&gt; &lt;p&gt;第二个文章&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\" rold=\"complementary\"&gt; &lt;div&gt; &lt;h2&gt;最新文章&lt;/h2&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章1&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章2&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章3&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章4&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章5&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章6&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章7&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章8&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章9&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"#\"&gt;最新文章10&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中前面的引入在Bootstrap官网入门中： 效果： 对于文章主页，在blog/templates下创建detail.html来写入文章主页的html： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Django Study&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\" integrity=\"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu\" crossorigin=\"anonymous\"&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\" integrity=\"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container page-header\"&gt;&lt;h1&gt;文章标题1&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"body-main\"&gt; &lt;div&gt; &lt;p&gt;第一个文章&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Django 模板系统模板系统简介如果对于http的某一个请求，我们需要返回一个html，我们可以在视图函数中(views.py) 直接使用html元素。 但是视图文件本身不适合编写html，并且，如果html写在视图文件，那么在页面设计改变时就需要修改Python源代码，这样很不方便。 另外，页面逻辑(view)和页面视图(html)本身应该分开设计，使得视图文库可以从html中解放出来。 模板系统的表现形式为文本(字符串)，即html文件。它分离了文档了表现形式和表现内容，为此，模板系统定义了独有的标签占位符。 模板系统基本语法 变量标签：{{ 变量 }} ，如&lt;html&gt;&lt;body&gt;{{ now }}&lt;/body&gt;&lt;/html&gt; for循环标签：{% for x in list %},{% endfor %} 12345&lt;ul&gt; {% for item in list %} &lt;li&gt;{{ item }}&lt;/li&gt; {% endfor %}&lt;/ul&gt; if-else分支标签：{% if %}, {% else %}, {% endif %} 12345{% if true %} &lt;p&gt; it is a true part. &lt;/p&gt;{% else %} &lt;p&gt; it is a false part. &lt;/p&gt;{% endif %} 使用模板系统渲染博客页面根据模板系统的语法，我们在blog/templates/index.html中重新写入： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Django Study&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\" integrity=\"sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu\" crossorigin=\"anonymous\"&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\" integrity=\"sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container page-header\"&gt;&lt;h1&gt;My Django Study Web &lt;small&gt; ---- by Horb7&lt;/small&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"container page-body\"&gt; &lt;div class=\"col-md-9\" role=\"main\"&gt; &lt;div class=\"body-main\"&gt; {% for article in article_list %} &lt;div&gt; &lt;h2&gt;{{ article.title }}&lt;/h2&gt; &lt;p&gt;{{ article.content }}&lt;/p&gt; &lt;/div&gt; {% endfor %} &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\" rold=\"complementary\"&gt; &lt;div&gt; &lt;h2&gt;最新文章&lt;/h2&gt; {% for article in article_list %} &lt;h4&gt;&lt;a href=\"#\"&gt;{{ article.title }}&lt;/a&gt;&lt;/h4&gt; {% endfor %} &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样就完成了一个模板，那么里面的变量如何获取呢？由于模板是视图函数所返回的html元素，所以我们需要在视图函数中获取变量。 在blog/views.py中写入： 1234567def get_index_page(request): all_article = Article.objects.all() return render(request, 'blog/index.html', { 'article_list': all_article } ) 其中render函数可以返回经过模板渲染后的HttpResponse对象。 为了方便管理，我们将index.html和detail.html文件放入blog/templates 新创建的文件blog中。 然后进入blog/urls.py中写入路由： 12345678from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world), path('content', blog.views.article_content), path('index', blog.views.get_index_page),] 最后重新部署项目，打开浏览器，输入127.0.0.1:8000/blog/index，即可到达index.html渲染后的网页。 同理修改文章主页的模板和url即可。 在blog/views.py加入： 123456789def get_detail_page(request, article_id): curr_article = Article.objects.all()[0] section_list = curr_article.content.split('\\n') return render(request, 'blog/detail.html', { 'curr_article': curr_article, 'section_list': section_list } ) 实现文章详情页面的跳转在上述实验中，我们的ip/blog/detail只能跳转到第一篇博客，如何根据detail/id来实现根据id跳转到对应的博客？ 我们可以在urls.py中获取id参数，在blog/urls.py重新写入： 12345678910from django.urls import path, includeimport blog.viewsurlpatterns = [ path('hello_world', blog.views.hello_world), path('content', blog.views.article_content), path('index', blog.views.get_index_page), # path('detail', blog.views.get_detail_page), path('detail/&lt;int:article_id&gt;',blog.views.get_detail_page)] 然后在blog/views.py中写入： 123456789101112131415def get_detail_page(request, article_id): all_article = Article.objects.all() curr_article = None for article in all_article: if article.article_id == article_id: curr_article = article break section_list = curr_article.content.split('\\n') return render(request, 'blog/detail.html', { 'curr_article': curr_article, 'section_list': section_list } ) 据此，我们可以在博客首页的文章标题加上跳转链接： 实现上下篇文章跳转在BootsTrap中文官网，选择组件中的分页，选择默认实例作为上下篇反转按钮： 在文章主页最下方加入上述代码。 根据模板占用标签修改： 然后进入blog/views.py修改视图函数，返回previous_article和next_article即可。 1234567891011121314151617181920212223def get_detail_page(request, article_id): all_article = Article.objects.all() curr_article_index = None for index, article in enumerate(all_article): # 迭代器 if article.article_id == article_id: curr_article_index = index break curr_article = all_article[curr_article_index] previous_article = all_article[curr_article_index - 1] next_article = all_article[curr_article_index + 1] if curr_article_index == 0: previous_article = curr_article if curr_article_index == len(all_article) - 1: next_article = curr_article section_list = curr_article.content.split('\\n') return render(request, 'blog/detail.html', { 'curr_article': curr_article, 'section_list': section_list, 'previous_article': previous_article, 'next_article': next_article } ) 实现文章的分页功能Django 分页组件介绍： 在Django中有一个分页组件 Paginator ，可以在Django Shell中调试入门Paginator。 在博客主页index.html的文章块下方，加入一个分页块(使用div，与文章块并列)。 在Bootstrap中文官网的组件中找到分页，拷贝下来放入分页块中。 刷新浏览器，即可看到分页组件： 在路由中，我们采用/blog/index?page=1来实现文章的分页。 在blog/views.py中修改： 12345678910111213141516171819202122232425262728def get_index_page(request): page = request.GET.get('page') # 如果没有page参数，则page为1 if page: page = int(page) else: page = 1 all_article = Article.objects.all() paginator = Paginator(all_article, 3) page_num = paginator.num_pages page_article_list = paginator.page(page) if page_article_list.has_next(): next_page = page + 1 else: next_page = page if page_article_list.has_previous(): previous_page = page - 1 else: previous_page = page return render(request, 'blog/index.html', { 'article_list': page_article_list, 'page_num': range(1, page_num + 1), 'curr_page': page, 'next_page': next_page, 'previous_page': previous_page } ) 然后在index.html中修改每个分页按钮的链接： 12345678910111213141516171819&lt;div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"/blog/index?page={{ previous_page }}\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; {% for num in page_num %} &lt;li&gt;&lt;a href=\"/blog/index?page={{ num }}\"&gt;{{ num }}&lt;/a&gt;&lt;/li&gt; {% endfor %} &lt;li&gt; &lt;a href=\"/blog/index?page={{ next_page }}\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 刷新浏览器即可查看效果： 实现最新文章列表最新文章在所有文章中取得publish_date最大的5个，由于在分页后，每个页面(即index?page=x)的all_article为当前页面的所有文章，所以不能从这里取。 在blog/views.py修改，使其返回数据库所有文章最新的五个： 1234# 增加top5_article = Article.objects.order_by('-publish_date')[:5]# return reder()中加'top5_article': top5_article 最后再修改index.html内容，将for范围修改即可。 最后的成品：","categories":[{"name":"项目学习","slug":"项目学习","permalink":"https://horb7.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://horb7.github.io/tags/Django/"}]},{"title":"牛客秋季算法班LCA-E-华华和月月种树","slug":"牛客秋季算法班LCA-E-华华和月月种树","date":"2022-02-20T08:48:28.000Z","updated":"2022-02-24T16:57:27.471Z","comments":true,"path":"2022/02/20/牛客秋季算法班LCA-E-华华和月月种树/","link":"","permalink":"https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/","excerpt":"","text":"华华和月月种树题意维护一个动态有根树，每个点都有一个权值，开始时只有一个 $0$ 号节点，权值为 $0$ 。有以下操作： $1 \\ \\ i$ ，表示 $i$ 节点长出一个新的子节点，权值为 $0$ ，编号为目前最大编号 $+1$ 。 $2 \\ \\ i \\ \\ a$ ，表示节点 $i$ 的子树的所有节点 (包括 $i$ 节点) 权值 $+a$ 。 $3 \\ \\ i$ ，表示查询节点 $i$ 此时的权值。 分析离线 + 树状数组 先根据所有的操作建立一棵树，求得所有节点的dfs序，即可在区间上操作。 树状数组维护差分的前缀。 对于操作1，记录它在权值为 $0$ 的时候（刚被开辟出来）它的前缀和，查询该点时减去这个值即可。 对于操作2，只需要在 $[l[i], r[i]]$ 上所有点权值 $+a$ 即可，使用差分。其中 $l[i]$ 和 $r[i]$ 表示 $i$ 点的进出栈时间(dfs序) 。 对于操作3，查询前缀和即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int op[N], a[N], b[N];int val[N], c[N], l[N], r[N];vector&lt;int&gt; g[N];int cnt = 1; // 一开始有一个节点0void dfs (int u, int fa){ l[u] = ++ cnt; // 最早的timestamp for (int v : g[u]) if (u != fa) dfs(v, u); r[u] = cnt; // 最晚的timestamp}void update (int x, int v){ if (x) for (; x &lt; N; x += x &amp; -x) c[x] += v;}int query (int x){ int res = 0; if (x) for (; x; x -= x &amp; -x) res += c[x]; return res;}int main (){ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; op[i] &gt;&gt; a[i]; ++ a[i]; // 注意树状数组只能维护[1, n]的区间，不能包括0 if (op[i] == 1) { g[a[i]].push_back(++ cnt); b[i] = cnt; // b[i]表示第i个操作后，新的节点编号 } else if (op[i] == 2) cin &gt;&gt; b[i]; // b[i]表示加多少 } cnt = 0; dfs(1, 0); // 转化为dfs序，进行区间运算 // 树状数组的区间加+单点查询 for (int i = 1; i &lt;= n; i ++ ) { if (op[i] == 1) // 加新的节点 { val[l[b[i]]] += query(l[a[i]]); // val(i)表示i点加了多少 } else if (op[i] == 2) { update(l[a[i]], b[i]); update(r[a[i]] + 1, -b[i]); } else cout &lt;&lt; query(l[a[i]]) - val[l[a[i]]] &lt;&lt; endl; } return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"牛客秋季算法班LCA-D.Alliances","slug":"牛客秋季算法班LCA-D-Alliances","date":"2022-02-20T07:40:34.000Z","updated":"2022-02-20T07:52:22.424Z","comments":true,"path":"2022/02/20/牛客秋季算法班LCA-D-Alliances/","link":"","permalink":"https://horb7.github.io/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/","excerpt":"","text":"Alliances题意链接：https://ac.nowcoder.com/acm/contest/27836/D 树国是一个有 $n$ 个城市的国家，城市编号为 $1 \\sim n$ 。连接这些城市的道路网络形如一棵树， 即任意两个城市之间有恰好一条路径。城市中有k个帮派，编号为 $1 \\sim k$ 。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。 当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。 shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。 分析对于选定的首都 $V$ 和选定的帮派，假设他们所有占领的城市的 lca 为 LCA ，那么有下面两个情况： lca(V, LCA) != LCA 那么被占据城市距离 $V$ 的最短距离为 $Dist(V, LCA)$ 。 lca(V, LCA) == LCA 即首都在 LCA 的子树中。对这棵子树作 dfs 序，那么距离 $V$ 最短的为 dfn 第一个在 $V$ 前面的或者第一个在 $V$ 后面的，取最小值即可。可以使用二分降低复杂度。 这里需要注意的是被占据的城市路径上的所有城市也都被占领，他们不会影响每个帮派城市lca的预处理，但会影响第二种情况，所以求的时候还需要加一个lca。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010;int n, k;vector&lt;int&gt; g[N]; // 整图int depth[N], f[N][21];vector&lt;int&gt; q[N]; // 帮派图int dfn[N], timestamp;int top[N]; // top(i) 表示i帮派占领的城市的lcavoid dfs (int u, int fa) // 根据dfs求出dfn和st表{ dfn[u] = ++ timestamp; depth[u] = depth[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt; 21; i ++ ) f[u][i] = f[f[u][i-1]][i-1]; for (int v : g[u]) if (v != fa) dfs(v, u);}int lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); for (int i = 20; i &gt;= 0; i -- ) if (depth[f[a][i]] &gt;= depth[b]) a = f[a][i]; if (a == b) return b; for (int i = 20; i &gt;= 0; i -- ) if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i]; return f[a][0];}int dist (int a, int b){ return depth[a] + depth[b] - 2 * depth[lca(a, b)];}int main (){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n - 1; i ++ ) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); // 求出帮派图，邻接表按照dfn排序 scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; i ++ ) { int u, v; scanf(\"%d\", &amp;v); for (int j = 0; j &lt; v; j ++ ) { scanf(\"%d\", &amp;u); q[i].push_back(u); if (!j) top[i] = u; else top[i] = lca(top[i], u); } // 按照dfn排序 sort(q[i].begin(), q[i].end(), [&amp;](int a, int b){ return dfn[a] &lt; dfn[b]; }); } int Q; scanf(\"%d\", &amp;Q); while(Q -- ) { int V, LCA, u, v; scanf(\"%d%d\", &amp;V, &amp;u); // LCA为被选择的帮派的lca vector&lt;int&gt; x; // x存储被选择的帮派 for (int i = 0; i &lt; u; i ++ ) { scanf(\"%d\", &amp;v); x.push_back(v); if (!i) LCA = top[v]; else LCA = lca(LCA, top[v]); } // 如果V和LCA的lca不是LCA，那么他们的最短距离即为V和LCA的距离 if (lca(V, LCA) != LCA) { printf(\"%d\\n\", dist(V, LCA)); } // 否则离V最近的一定是dfn序中靠近V的前面一个或者后面一个 else { int ans = 2e9 + 10; for (int e : x) { int siz = q[e].size(); int l = 0, r = siz; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if (dfn[q[e][mid]] &gt;= dfn[V]) r = mid; else l = mid + 1; } if (r != 0) ans = min(ans, dist(V, lca(V, q[e][r - 1]))); if (r != siz) ans = min(ans, dist(V, lca(V, q[e][r]))); } printf(\"%d\\n\", ans); } } return 0;}","categories":[{"name":"图论","slug":"图论","permalink":"https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://horb7.github.io/tags/LCA/"}]},{"title":"2022寒假算法集训营5","slug":"2022寒假算法集训营5","date":"2022-02-17T10:24:12.000Z","updated":"2022-02-25T02:30:07.265Z","comments":true,"path":"2022/02/17/2022寒假算法集训营5/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/","excerpt":"","text":"A. 疫苗小孩题意给出长度为 $n$ 的01字符串，可以选择至多三个 $0$ ，假设它们的位置为 $i, j, k$ ，则 $W_j = w - |k-p|\\times q$ ，$W_k = w - |k-p| \\times q$ 。求问 $W_j + W_k$ 最大为多少。 其中 $p$ 表示与前一个选定的 $0$ 的位置差，$w, k, q$ 为给定值。 其中 $n \\le 10^6, 1\\le k, w, q \\le 10^9$ 。 分析对于 $W_j$ ，要使其最大需要使 $p$ 最小，即 $i$ 与 $j$ 的差值尽量接近 $k$ ，$W_k$ 同理。 枚举 $j$ 的位置，然后使用二分求得最接近 $j-k$ 的位置（有两个可能的位置），同理求出 $j+k$ 的位置即可。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = ' ' + s; vector&lt;int&gt; zeros; // 存储所有0的位置 for (int i = 1; i &lt;= n; i ++ ) if (s[i] == '0') zeros.push_back(i); long long best, w, q; cin &gt;&gt; best &gt;&gt; w &gt;&gt; q; long long ans = 0; auto check = [&amp;](int x) { return x &lt; 0 || x &gt;= zeros.size(); }; for (int i = 0; i &lt; zeros.size(); i ++ ) { int pos1 = lower_bound(zeros.begin(), zeros.end(), zeros[i] - best) - zeros.begin(); int pos2 = lower_bound(zeros.begin(), zeros.end(), zeros[i] + best) - zeros.begin(); for (int k : {-1, 0}) // 注意pos1为第一个大于等于j-k的位置，pos1-1也可能最接近j-k for (int l : {-1, 0}) // pos2同理 { if (check(pos1+k) || pos1+k &gt;= i) continue; long long now = w - abs(best - abs(zeros[i]-zeros[pos1+k])) * q; ans = max(ans, now); // 只选择前两个0 if (check(pos2+l) || pos2+l &lt;= i) continue; now = now + w - abs(best - abs(zeros[pos2+l]-zeros[i])) * q; ans = max(ans, now); // 选择三个0 } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} C. 战旗小孩题意给定 $n$ 局游戏和原始分数 $start$，每局游戏可以选择两个英雄中的一个，使用礼遇可以选择多两个可选择英雄。 每局游戏结束后的分数为原始分数加上英雄强度。 给出每局游戏结束后上榜需要的分数，以及 $m$ 次至多能够使用的礼遇次数，和每局游戏的可选英雄强度。 游戏的顺序可以任意调整，问进行 $n$ 局游戏后，最多能够上榜几次？ $1 \\le m \\le n \\le 20$ 。 分析二进制枚举哪些局需要使用礼遇，求出每局游戏结束后所选择的英雄强度。 由于游戏顺序可以任意调整，所以一定是先选择英雄强度高的那一局游戏，在选择低的，这样能尽量满足上榜分数。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start; vector&lt;int&gt; score(n); for (int &amp;x : score) cin &gt;&gt; x; vector&lt;vector&lt;int&gt;&gt; all(n, vector&lt;int&gt;(4)); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; 4; j ++ ) cin &gt;&gt; all[i][j]; int ans = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) // 枚举哪些局需要使用礼遇 { if (__builtin_popcount(i) &gt; m) continue; vector&lt;int&gt; v; for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1) v.push_back(*max_element(all[j].begin(), all[j].end())); else v.push_back(max(all[j][0], all[j][1])); sort(v.begin(), v.end(), greater&lt;int&gt;()); int now = 0, st = start; for (int i = 0; i &lt; n; i ++ ) { st += v[i]; if (st &gt;= score[i]) ++ now; } ans = max(ans, now); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} E. 复苏小孩题意三只鬼的力量分别为 $1, 1, 1$ ，遍历由 $123$ 构成的字符串时，走到 ‘$i$’ 则第 $i$ 只鬼吸收其他两只鬼一半的力量。 给定长度为 $n$ 的字符串和 $m$ 次查询，查询有以下两个操作： $1 \\ x \\ y$ ，表示将第 $x$ 个位置的字符改为 $y$ 。 $2 \\ l \\ r$ ，询问遍历 $[l, r]$ 子串后三只鬼的力量分别为多少。 其中 $1 \\le n, m \\le 10^5$ 。 答案对 998244353 取模。 分析假设走到 ‘1’ 位置，则相当于三只鬼的力量乘上矩阵： \\left[ \\begin{matrix} 1 & 0 & 0 \\\\ \\dfrac 1 2 & \\dfrac 1 2 & 0 \\\\ \\dfrac 1 2 & 0 & \\dfrac 1 2 \\\\ \\end{matrix} \\right]‘2’和’3’同理，所以可以使用线段树维护区间上矩阵的乘积。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 100010, P = 998244353;int quick_power (int a, int k) { int ret = 1; for (a %= P; k; k &gt;&gt;= 1, a = (ll)a * a % P) if (k &amp; 1) ret = (ll)ret * a % P; return ret;}const int inv = quick_power(2, P-2);struct Matrix { int a[3][3]; Matrix() { memset(a, 0, sizeof a); } void build (int x) { memset(a, 0, sizeof a); if (x == 0) { a[0][0] = 1; a[1][1] = a[2][2] = a[1][0] = a[2][0] = inv; } if (x == 1) { a[1][1] = 1; a[0][0] = a[2][2] = a[0][1] = a[2][1] = inv; } if (x == 2) { a[2][2] = 1; a[0][0] = a[1][1] = a[0][2] = a[1][2] = inv; } } void buildI () { for (int i = 0; i &lt; 3; i ++ ) a[i][i] = 1; }};Matrix operator* (const Matrix &amp;a, const Matrix &amp;b) { Matrix ans; for (int k = 0; k &lt; 3; k ++ ) for (int i = 0; i &lt; 3; i ++ ) for (int j = 0; j &lt; 3; j ++ ) ans.a[i][j] = (ans.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % P; return ans;}struct seg_tree { #define lc(x) x&lt;&lt;1 #define rc(x) x&lt;&lt;1|1 Matrix mt; // mt为[l, r]区间矩阵相乘的结果 int l, r;};seg_tree t[N&lt;&lt;2];char s[N];void pushup (int p) { t[p].mt = t[lc(p)].mt * t[rc(p)].mt;}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; if (l == r) { t[p].mt.build(s[l] - '1'); return ; } int mid = l + r &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid+1, r); pushup(p);}void update (int p, int x, int v){ if (t[p].l == t[p].r &amp;&amp; t[p].l == x) { t[p].mt.build(v-1); return ; } int mid = t[p].l + t[p].r &gt;&gt; 1; if (x &lt;= mid) update(lc(p), x, v); else update(rc(p), x, v); pushup(p);}Matrix query (int p, int l, int r){ Matrix ret; ret.buildI(); if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].mt; int mid = t[p].l + t[p].r &gt;&gt; 1; if (l &lt;= mid) ret = ret * query(lc(p), l, r); if (r &gt; mid) ret = ret * query(rc(p), l, r); return ret;}int main (){ int n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + 1); build(1, 1, n); Matrix root = t[1].mt; while(m -- ) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) update(1, x, y); else { Matrix ret = query(1, x, y); for (int i = 0, v = 0; i &lt; 3; i ++, v = 0 ) { for (int j = 0; j &lt; 3; j ++ ) v = (v + ret.a[j][i]) % P; cout &lt;&lt; v &lt;&lt; ' '; } cout &lt;&lt; endl; } } return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法训练营4","slug":"2022寒假算法集训营4","date":"2022-02-17T07:04:12.000Z","updated":"2022-02-17T04:30:00.486Z","comments":true,"path":"2022/02/17/2022寒假算法集训营4/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/","excerpt":"","text":"B. 进制题意给定长度为 $n$ 的数字串 $s$ (只有 ‘0’ ~ ‘9’ 这十种字符) ，给定 $q$ 次询问，每次询问有以下两种： $1 \\ x \\ y$ ，表示将第 $x$ 个字符修改为 $y$ ，即令 $s_x = y$ 。 $2 \\ x \\ y$ ，查询区间 $[l, r]$ 串能够代表的某个进制的最小值，输出其十进制表示，结果对 $1e9+7$ 取模。 其中 $1 \\le n, q \\le 10^5$ 。 分析对于某个固定的区间，其每个位的数码是不变的，那么位权越小，能够表示的数字越小。所以使其最小的进制为其 $max + 1$， $max$ 表示区间最大值。 所以我们可以使用线段树维护两个信息：区间的最大值、区间数字按照九种进制运算得到的十进制数值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 100010, M = N &lt;&lt; 2, mod = 1e9 + 7;int quick_power(int a, int k){ int ret = 1; for (a %= mod; k; k &gt;&gt;= 1, a = (ll)a * a % mod) if (k &amp; 1) ret = (ll)ret * a % mod; return ret;}struct tree { #define lc(x) x &lt;&lt; 1 #define rc(x) x &lt;&lt; 1 | 1 int l, r; int d[11], maxv;} t[M];int n, q, a[N];void pushup (int p){ t[p].maxv = max(t[lc(p)].maxv, t[rc(p)].maxv); for (int i = 2; i &lt;= 10; i ++ ) t[p].d[i] = ((ll)t[lc(p)].d[i] * quick_power(i, t[rc(p)].r - t[rc(p)].l + 1) % mod + t[rc(p)].d[i]) % mod;}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; if (l == r) { for (int i = 2; i &lt;= 10; i ++ ) t[p].d[i] = a[l]; t[p].maxv = a[l]; return ; } int mid = l + r &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushup(p);}void modify (int p, int x, int v){ if (t[p].l == t[p].r &amp;&amp; t[p].l == x) { a[x] = v; t[p].maxv = v; for (int i = 2; i &lt;= 10; i ++ ) t[p].d[i] = v; return ; } int mid = t[p].l + t[p].r &gt;&gt; 1; if (x &lt;= mid) modify(lc(p), x, v); else modify(rc(p), x, v); pushup(p);}int query (int p, int l, int r){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].maxv; int mid = t[p].l + t[p].r &gt;&gt; 1; int ret = -1; if (l &lt;= mid) ret = max(ret, query(lc(p), l, r)); if (r &gt; mid) ret = max(ret, query(rc(p), l, r)); return ret;}ll query (int p, int l, int r, int v){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return (ll)t[p].d[v] * quick_power(v, r - t[p].r) % mod; int mid = t[p].l + t[p].r &gt;&gt; 1; ll ret = 0; if (l &lt;= mid) (ret += query(lc(p), l, r, v)) %= mod; if (r &gt; mid) (ret += query(rc(p), l, r, v)) %= mod; return ret;}int main (){ cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i ++ ) scanf(\"%1d\", &amp;a[i]); build(1, 1, n); for (int i = 1; i &lt;= q; i ++ ) { int op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 1) modify(1, l, r); else cout &lt;&lt; query(1, l, r, query(1, l, r) + 1) &lt;&lt; endl; } return 0;} L. 在这冷漠的世界里光光哭哭题意给定一个长度为 $n$ 的仅由小写字母构成的字符串 $s$ ，给出 $q$ 次查询，每次查询给出一个区间 $[l, r]$ 和一个长度为 $3$ 的字符串 $abc$ ，问：在 $[l, r]$ 中有多少个 $abc$ 的子序列？ 分析设 $f3(k, i, j)$ 表示前 $k$ 个字符中，有多少个 $i, s[k], j$ 这样的子序列。 对于每次查询，二分算出 $b$ 字符在 $[l, r]$ 中出现的第一次位置 $pos1$ 和最后一次位置 $pos2$。 那么 $f3(pos2, a, c) - f3(pos1-1, a, c)$ 即为，当 $k$ 在 $[l, r]$ 时的所有 $abc$ 的子序列个数。 根据容斥，再将其减去 $ (a) [bc], (a) [b] (c), [ab] (c) $ 即可。其中$[ \\quad ]$ 表示其在 $[l, r]$ 范围内。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 80010, M = 27;int n, q; char s[N];ll f1[N][M]; // f(i, j)表示前i个字符中有多少个jll f2[N][M][M]; // f(i, j, k)表示前i个字符中有多少个 \"jk\"ll f3[N][M][M]; // f(k, i, j)表示前k个字符中，有多少个\"i s[k] j\"，注意k为最后一个字符ll tmp[M][M][M]; // tmp(k, i, j)表示前k个字符中，有多少个 \"i k j\"vector&lt;int&gt; g[M]; // g(c)存储字符c的所有位置ll cal (int l, int r, int a, int b) // 计算[l, r]有多少个\"ab\"{ return f2[r][a][b] - f2[l-1][a][b] - f1[l-1][a] * (f1[r][b] - f1[l-1][b]);}int main (){ scanf(\"%d%d%s\", &amp;n, &amp;q, s + 1); for (int i = 1; i &lt;= 26; i ++ ) g[i].push_back(0); for (int i = 1; i &lt;= n; i ++ ) { int id = s[i] - 'a' + 1; g[id].push_back(i); } for (int i = 1; i &lt;= 26; i ++ ) g[i].push_back(1e9); for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= 26; j ++ ) f1[i][j] = f1[i-1][j] + (j == s[i] - 'a' + 1); for (int j = 1; j &lt;= 26; j ++ ) for (int k = 1; k &lt;= 26; k ++ ) { f2[i][j][k] = f2[i-1][j][k]; if (k == s[i] - 'a' + 1) f2[i][j][k] += f1[i-1][j]; } } for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= 26; j ++ ) for (int k = 1; k &lt;= 26; k ++ ) { // \"j s[i] k\" int id = s[i] - 'a' + 1; tmp[id][j][k] += f1[i-1][j] * (f1[n][k] - f1[i][k]); f3[i][j][k] = tmp[id][j][k]; } for (int i = 1; i &lt;= q; i ++ ) { int l, r; static char op[4]; scanf(\"%d%d%s\", &amp;l, &amp;r, op + 1); int a = op[1] - 'a' + 1; int b = op[2] - 'a' + 1; int c = op[3] - 'a' + 1; if (f1[r][b] - f1[l-1][b] == 0) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } int pos1 = lower_bound(g[b].begin(), g[b].end(), l) - g[b].begin(); int pos2 = upper_bound(g[b].begin(), g[b].end(), r) - g[b].begin(); ll ans = f3[g[b][pos2-1]][a][c] - f3[g[b][pos1-1]][a][c]; // b在[l, r]时，所有的\"abc\"的数量 // 容斥，减去(a)[bc],(a)[b](c),[ab](c) ans -= f1[l-1][a] * cal(l, r, b, c) + f1[l-1][a] * (f1[r][b] - f1[l-1][b]) * (f1[n][c] - f1[r][c]) + cal(l, r, a, b) * (f1[n][c] - f1[r][c]); printf(\"%lld\\n\", ans); } return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法集训营3","slug":"2022寒假算法集训营3","date":"2022-02-17T05:34:23.000Z","updated":"2022-02-17T04:29:51.950Z","comments":true,"path":"2022/02/17/2022寒假算法集训营3/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/","excerpt":"","text":"C. 智乃买瓜(another version)题意智乃来到水果摊前买瓜，水果摊上贩卖着若干个不同的西瓜，第 $i$ 个西瓜的重量为 $w_i$ ，智乃可以买整个瓜 $w_i$ 或者把瓜劈开买半个瓜，半个瓜的重量为 $\\dfrac {w_i} 2$ 。 也就是说对于每个瓜，智乃都有三种不同的决策： 购买一整个重量为 $w_i$ 的西瓜。 把瓜劈开，购买半个重量为 $\\dfrac {w_i} 2$ 的西瓜。 不进行购买操作。 注意，每个瓜的重量都为正偶数。 现在智乃知道，购买西瓜的重量和分别为 $k = 1, 2, 3 \\ldots M$ 时，购买西瓜的方案数（对 $1e9+7$ 取模）。 请构造出一个水果摊上 $N$ 个西瓜的重量，使得满足所要求的方案数量。保证数据存在 $N \\le 10^3$ 的合法解。 分析由于西瓜的重量为正偶数，所以对于重量为 $1$ 的方案，它只能由重量为 $2$ 的西瓜劈开得到。 那么我们就可以根据 $k=1$ 的情况，去除掉所有方案数中重量为 $2$ 的西瓜对其造成的影响。 去除后，所有的方案数都不会和重量为 $2$ 的西瓜有关，那么 $k=2$ 时的方案数就只能由重量为 $4$ 的西瓜构成。 依次去除所有的西瓜即可，把去除的西瓜加到结果数组即可。 注意点： 正向dp的枚举顺序是从后往前，目的是沿用上一层的原始数据。逆向dp也需要减去原始数据，所以要从前往后，否则减去的是这一层的数据。 正向dp时 $dp[0] = 1$ ，逆向dp也需要加上去。 本题提示了西瓜的质量为正偶数，如果没有提示，也要往构造所有正偶数质量西瓜去思考。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010, p = 1e9 + 7;int n, dp[N];int mod (int x) { return (x % p + p) % p; }int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; dp[i]; dp[0] = 1; vector&lt;int&gt; ret; for (int i = 1; i &lt;= n; i ++ ) while(dp[i]) { // 把 2*i 的西瓜去除 ret.push_back(2 * i); for (int j = i; j &lt;= n; j ++ ) { dp[j] = mod(dp[j] - dp[j-i]); if (j &gt;= 2 * i) dp[j] = mod(dp[j] - dp[j-2*i]); } } cout &lt;&lt; ret.size() &lt;&lt; endl; for (int v : ret) cout &lt;&lt; v &lt;&lt; ' '; return 0;} H. 智乃的树旋转(hard version)题意给定一棵 $N$ 个节点的二叉树，智乃将其做了若干次旋转将其打乱，她想要将其还原，要求旋转操作次数不超过 $N^2$ 次。 输入描述 第一行输入正整数 $N$ ($1 \\le N \\le 10^3$) ，表示二叉树的节点数量。 接下来 $N$ 行输入二叉树一开始的样子。 每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。 当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为 $0$ 时，则表示该节点无右子树。 接下来 $N$ 行输入二叉树被打乱后的样子。 每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。 当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为$0$时，则表示该节点无右子树。 要求你将打乱后的二叉树通过一系列旋转操作还原 输出描述 首先输出一个整数 $K$ ，表示你还原二叉树进行旋转的次数，要求你给出 $K$ 的范围在 $[0,N2]$ ，接下来 $K$ 行，依次输出旋转操作的旋转轴。 由于旋转轴只能进行左旋转或者右旋转其中的一种，裁判程序将会自己判断当前需要进行的是左旋转还是右旋转。 注意：旋转过程中的根节点无法作为旋转轴进行旋转，如果你指定旋转过程中的根节点作为旋转轴，则裁判程序将直接给出WA的结果。 分析如何将打乱的树还原？可以按照原来的树的先序遍历，依次把每个节点在打乱的树上做splay，单旋情况下，每个节点最多旋转 $n-1$ 次，总次数不超过 $n^2$ 的 数量级。 所以只需要记录每次旋转时的旋转轴即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;struct tree { int fa, ch[2]; } a[N], t[N]; // 原树和打乱后的树void rot (int u) // 把u节点向上旋转一次{ int fa = t[u].fa; int gfa = t[fa].fa; int t1 = (u != t[fa].ch[0]); // u是fa的左/右孩子 int t2 = (fa != t[gfa].ch[0]); // fa是gfa的左/右孩子 int ch = t[u].ch[t1 ^ 1]; // 需要被用来和fa交换的u的孩子 t[u].fa = gfa; t[u].ch[t1 ^ 1] = fa; t[fa].ch[t1] = ch; t[fa].fa = u; t[ch].fa = fa; t[gfa].ch[t2] = u;}// 输入树，返回这个树的根int input_tree (tree * t, int n){ vector&lt;bool&gt; vis(n + 1); for (int i = 1; i &lt;= n; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; t[i].ch[0] = u; t[i].ch[1] = v; vis[u] = vis[v] = true; if (u) t[u].fa = i; if (v) t[v].fa = i; } for (int i = 1; i &lt;= n; i ++ ) if (!vis[i]) return i; return -1;}bool st[N] = { true }; // 当前点是否被旋转到根过，0设置为true，因为0是树根的favector&lt;int&gt; ret;int n, root_a, root_t;void splay (int u){ while(!st[t[u].fa]) // 父节点还没有被旋转，也就是还没有修正 { ret.push_back(u); // u需要旋转 rot(u); }}void dfs (int u) // 先序遍历{ splay(u); st[u] = true; if (a[u].ch[0]) dfs(a[u].ch[0]); if (a[u].ch[1]) dfs(a[u].ch[1]);}int main (){ cin &gt;&gt; n; root_a = input_tree(a, n); root_t = input_tree(t, n); dfs(root_a); // 对原树进行先序遍历，依次对打乱的树进行splay cout &lt;&lt; ret.size() &lt;&lt; endl; for (int v : ret) cout &lt;&lt; v &lt;&lt; endl; return 0;} J. 智乃的C语言模除方程题意给定模除方程：$x \\ \\% \\ P = Q(Q \\in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\\%$ 遵循C语言的规则。 给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。 其中 $-10^9 \\le P, l, r, L, R \\le 10^9$ 且 $P != 0, l \\le r, L \\le R$ 。 分析模除方程 $x \\ \\% \\ P = Q$ ，即 $x = k \\times P + Q$ ，$Q &lt; P$ 。 由于 $Q$ 是 $[l, r]$ 的任意整数，所以显然 $x$ 的定义域为若干个连续子段。 对于 $[L, R]$ 的查询，设 $f(X)$ 表示 $[0, abs(X)]$ 中满足条件的 $x$ 数量。 然后需要根据 $L, R$ 的大小分类。 $0 \\le L \\le R$ 答案为 $f(R) - f(L - 1)$ 。 $L \\le 0 \\le R$ 答案为 $f(R) + f(L) - f(0)$ 。 $L \\le R \\le 0$ 答案为 $f(L) - f(R + 1)$ 。 所以接下来需要求出 $f(x)$ 。这里又需要对 $x$ 的大小分类。 $x \\ge 0$ $f(x)$ 表示 $[0, x]$ 范围，算出所有子段与 $[0, x]$ 的交集。 整段一共有 $x/P$ 个，注意每一段都要和 $[l, r]$ 取交集 ，然后算出最后一段 $[0, x\\%P]$ 和 $[l, r]$ 的交集。 取交集：$x \\% P$ 的余数范围 $[0, P-1]$ ，而 $Q$ 范围 $[l, r]$ ，需要取交集。 $x \\lt 0$ $f(x)$ 表示 $[-x, 0]$ 的范围，也需要算出所有子段与 $[-x, 0]$ 的交集。 但是由于C语言模除的结果与被除数相同，所以最后的答案也为负数，所以余数范围为负数 $[-P+1, 0]$ 。 Code12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint p, l, r, L, R;int get(int a,int b) // [l, r] 与 [a, b] 的交集{ return max(0ll, min(r, b) - max(a, l) + 1);}int f(int u){ if (u &lt; 0) return abs(u/p) * get(-p+1,0) + get(u%p,0); else return u/p * get(0, p-1) + get(0, u%p);}signed main(){ cin &gt;&gt; p &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R; p = abs(p); if(L &lt;= 0 &amp;&amp; R &gt;= 0) cout &lt;&lt; f(L) + f(R) - f(0); else if(L &gt; 0 &amp;&amp; R &gt; 0) cout &lt;&lt; f(R) - f(L-1); else cout &lt;&lt; f(L) - f(R+1);} K. 智乃的C语言模除方程(another version)题意给定模除方程：$P \\ \\% \\ x = Q(Q \\in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\\%$ 遵循C语言的规则。 给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。 其中 $-10^9 \\le P, l, r, L, R \\le 10^9$ 且 $P != 0, l \\le r, L \\le R$ 。 分析本题和上题唯一的区别在于 $x$ 和 $P$ 在方程的位置交换。 对于 $P \\ \\% \\ x = Q$ ，有 $P - \\lfloor \\dfrac P x \\rfloor \\times x = Q$ 。 枚举 $x$ 的值，则可以知道 $\\lfloor \\dfrac P x \\rfloor$ 的值，令其为 $c$ ，则变为 $P - c \\times x = Q$ 。其中 $P - c \\times x$ 为等差数列。 则问题变为：给定等差数列，问其第 $L$ 项到第 $R$ 项，有多少项在 $[l, r]$ 中。 根据 $\\lfloor \\dfrac P x \\rfloor$ 的性质，可以使用整除分块来枚举 $x$ 的值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll P, l, r, L, R;ll intersect (ll l0, ll r0, ll l1, ll r1){ ll ansl = max(l0, l1); ll ansr = min(r0, r1); return max(0ll, ansr - ansl + 1);}ll cal (ll k, ll cl, ll cr){ ll ansr = min(cr,(P-l)/k); ll ansl = max(cl,(P-r+k-1)/k); ll ans = 0; ans += intersect(ansl,ansr,L,R); ans += intersect(-ansr,-ansl,L,R); return ans;}int main (){ cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R; if (P &lt; 0) { P = -P; swap(l, r); l = -l; r = -r; } l = max(0ll, l); ll ans = 0; // 先枚举x的值绝对值在P范围内的情况，即[1, P] for (ll cl = 1, cr; cl &lt;= P; cl = cr + 1) { ll k = P / cl; cr = P / k; ans += cal(k, cl, cr); // 计算x的倍数为k，且x位于[cl, cr]时的情况 } if(l &lt;= P &amp;&amp; r &gt;= P) { ans += intersect(L, R, P+1, (ll)(1e10)); ans += intersect(L, R, -(ll)(1e10), -(P+1)); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法集训营2","slug":"2022寒假算法集训营2","date":"2022-02-17T04:09:12.000Z","updated":"2022-02-17T04:29:38.529Z","comments":true,"path":"2022/02/17/2022寒假算法集训营2/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/","excerpt":"","text":"A. 小沙的炉石题意给定 $n$ 张法术攻击牌和 $m$ 张法术恢复牌，每次攻击消耗一点法力，造成 $1$ 点伤害，恢复牌不消耗法力，可以恢复一点法力。小沙一开始有 $1$ 点法力，法力没有上限。 每次使用一张法力牌，都会使后面的攻击伤害 $+1$ 。 给出 $q$ 次询问，每次给出敌人的血量，问能否将其恰好斩杀？ 恰好斩杀：正好使得敌方血量变为 $0$ 。 分析如果使用的攻击牌和恢复牌的数量一定，那么可以造成的伤害一定是一个连续的区间。 假设使用 $a$ 张攻击牌和 $b$ 张恢复牌，注意 $a \\le b + 1$ 。 此时最小攻击伤害为：攻击、恢复、攻击、恢复…… ，伤害为 $\\sum_{i=1}^a{2 \\times i - 1} = a ^ 2$ 。 每次可以将序列中的一对 [攻击，恢复] 组合调换，造成伤害 $+1$ 。 最大伤害为：恢复、恢复、恢复、……、攻击、攻击。伤害为 $\\sum_{i=1}^{a} b + i = \\dfrac {((b + 1) + (b + a)) * a} 2$ 。 对于每次询问，由于需要恰好斩杀，因此最多能够使用的攻击牌是 $min(min(n, m+1), sqrt(hp))$ 。 由于造成伤害的区间是连续的，因此只需要看最大能造成的伤害是否超过 $hp$ 即可。 不需要判断最小造成的伤害，因为取到的攻击牌数一定 $\\le$ $sqrt(hp)$ 。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longsigned main (){ int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; n = min(n, m + 1); while(q -- ) { int hp; cin &gt;&gt; hp; int R = min(n, (int)sqrt(hp)); int maxv = (m + 1 + m + R) * R / 2; if (maxv &gt;= hp) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; } return 0;} B. 小沙的魔法题意给定 $n$ 个点和 $m$ 条边，初始时每个点权值为 $x_i = 0$ 。初始时图上无边，每次可以进行以下操作中的一种： 在 $m$ 条边中选择一条没有被选择过的边加入图中。 将图中的一个极大连通子图的每个点权值 $+1$ 。 给定边可能出现重边，自环。 问最少操作多少次操作2，才能使对于任意点有 $x_i = a_i$ 。 分析要使区间增加到目标值，等价于区间每个值初始为 $a_i$ ，每次使得区间值 $-1$ ，最终使区间值全部为 $0$ 。 优先减去权值最大的，在减去权值最大点的同时，可以顺带减去和它在同一个连通子图的所有点的权值，这整个连通子图全部变为 $0$ ，代价就是权值最大的那个点的权值。 按权值对每个点的位置排序，从大到小依次遍历当前点的相邻点，把当前点和权值比它大的点合并，先把权值大的点减到和当前点相同的权值，代价为 $a_{gt} - a_{cur}$ 。 这样最后的图会形成若干个连通子图，再把这些连通子图最小的权值加起来就是最少需要的操作2，加最小权值是因为我们先把比它大的权值点先减到和它权值相同。这也意味这合并时要以权值小的点为根。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010, M = 10000010;int n, m;int h[N], e[M], ne[M], idx;int a[N];int f[N], id[N], vis[N];int find (int x) { return x == f[x] ? x : f[x] = find(f[x]); }void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}int main (){ memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; iota(f, f + n + 1, 0); iota(id, id + n + 1, 0); for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; sort(id + 1, id + n + 1, [&amp;](int x, int y) { return a[x] &gt; a[y]; }); for (int i = 1; i &lt;= m; i ++ ) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); } long long res = 0; for (int i = 1, u = id[i]; i &lt;= n; i ++, u = id[i] ) { vis[u] = true; for (int k = h[u]; ~k; k = ne[k]) { int j = e[k]; int pu = find(u), pj = find(j); if (vis[j] &amp;&amp; pu != pj) { res += a[pj] - a[u]; f[pj] = pu; } } } for (int i = 1; i &lt;= n; i ++ ) if (find(i) == i) res += a[i]; cout &lt;&lt; res &lt;&lt; endl; return 0;} E. 小沙的长路题意规定有向完全图每条边只能走一次，问：$n$ 个点的有向完全图的最长路径的最大值和最小值分别为多少？ 分析$n$ 个点的有向完全图，最长路径一定经过了 $n$ 个点。 对于最小：如果图上有环，那么经过环一定比不经过环更长，所以我们要使图上无环，这样每个点只走一次，最短为 $n-1$ 。 对于最长：尽可能走完所有边，等价于给定有向完全图，删除尽可能少的边，使得剩下的图为欧拉图。如果 $n$ 为奇数，那么每个点连接偶数条边，一定存在一个有向无环图为欧拉图。如果 $n$ 为偶数，每个点连接奇数条边，欧拉图至多有 $2$ 个奇数点，也就是要使得 $n-2$ 个点变成偶数，删除一条边改变两个点度的奇偶性，所以需要删除 $\\dfrac {n-2} 2$ 条边。 Code123456789101112#include &lt;iostream&gt;using namespace std;int main (){ long long n; cin &gt;&gt; n; long long maxv; if (n &amp; 1) maxv = n * (n - 1) / 2; else maxv = n * (n - 1) / 2 - (n - 2) / 2; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; maxv &lt;&lt; endl; return 0;} F. 小沙的算数题意给定一个算数式（只包含加法和乘法），每次询问把一个数字替换为其他数字，问替换完后的结果为多少？（询问不独立，上一次的修改会影响下一次询问）。 分析由于算数式只包含加法和乘法，而乘法具有连乘性质，所以需要维护乘法区间的乘积。 对于乘法，只需要修改连乘区间的结果即可。对于加法，直接修改即可。 维护每个区间的乘法结果，可以使用并查集，开一个 $prod$ 数组表示每个集合的乘积。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 2000010, mod = 1000000007;int n, q, ret;string s;int a[N]; bool vis[N];int p[N], prod[N];int quick_power (int a, int k){ int res = 1; for (a %= mod; k; k &gt;&gt;= 1, a = (ll)a * a % mod) if (k &amp; 1) res = (ll)res * a % mod; return res;}int inv (int x) { return quick_power(x, mod-2); }int Mod (long long x) { return (x % mod + mod) % mod; }int find (int x) { return x == p[x] ? x : p[x] = find(p[x]); }void merge (int x, int y){ x = find(x), y = find(y); prod[y] = Mod((ll)prod[y] * prod[x]); p[x] = y;}int main (){ cin &gt;&gt; n &gt;&gt; q; iota(p + 1, p + n + 1, 1); cin &gt;&gt; s; s = ' ' + s; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], prod[i] = a[i]; // 把乘积合并起来 for (int i = 1; i &lt; n; i ++ ) { if (s[i] != '*') continue; int j = i, ans = a[i]; vis[i] = true; while(j &lt; n &amp;&amp; s[j] == '*') { ans = Mod((ll)ans * a[j + 1]); vis[j + 1] = true; merge(j, j + 1); ++ j; } ret = Mod((ll)ret + ans); i = j; } for (int i = 1; i &lt;= n; i ++ ) if (!vis[i]) ret = Mod((ll)ret + a[i]); while(q -- ) { int id, to; cin &gt;&gt; id &gt;&gt; to; if (id != n &amp;&amp; s[id] == '*' || id &gt; 1 &amp;&amp; s[id-1] == '*') { // 位于乘法区间 int par = find(id); ret = Mod((ll)ret + Mod((ll)Mod((ll)prod[par] * inv(a[id])) * Mod((ll)to - a[id]))); cout &lt;&lt; ret &lt;&lt; endl; prod[par] = Mod((ll)Mod((ll)prod[par] * inv(a[id])) * to); a[id] = to; } else { // 位于加法区间 ret = Mod((ll)ret - a[id] + to); cout &lt;&lt; ret &lt;&lt; endl; a[id] = to; } } return 0;} G. 小沙的身法题意给定 $n$ 个节点的无根无向树，每个节点有权值 $a_i$ ，规定从 $i$ 节点跳到其相邻节点 $j$ 的代价为 $max(0, a_j - a_i)$ 。即从权值低的点跳到权值高的点，代价为其权值差；从权值高的点跳到权值低的点，代价为 $0$ 。 给定 $m$ 次询问，每次询问：从地面(权值为 $0$)跳到 $u$ 节点，再从 $u$ 节点跳到 $v$ 节点，再从 $v$ 节点跳到地面，最少消耗的代价为多少？ 其中 $1 \\le n \\le 10^6$ ，$1 \\le m \\le 10^5$ ，$1 \\le a_i \\le 10^9$ 。 分析对于无向树而言，两个节点之间只有一条简单路径。所以要消耗体力最小，就是走这条简单路径，即路径是唯一的。 从地面跳到 $u$ 节点，从 $v$ 节点跳到地面的代价为 $a_u$ 。 从 $u$ 点跳到 $v$ 点的代价，等价于从 $u$ 点跳到根节点的代价，加上从根节点跳到 $v$ 节点的代价，再减去从其 $lca$ 跳到根节点的代价，以及从根节点跳到 $lca$ 的代价。 由于代价不具有对称性，即从 $u$ 跳到根节点和从根节点跳到 $u$ 节点不是对称的，所以要dfs两次算出从根节点出发到其他点的代价，以及从其他点到达根节点的代价。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1000010, M = N &lt;&lt; 2;ll a[N], d[N], rd[N];namespace LCA { constexpr int SIZE = 20; int n, h[N], e[M], ne[M], idx; int fa[N][SIZE + 1], depth[N]; int q[N]; bool st[N]; void init () { fill(h, h + n + 1, -1); idx = 0; for (int i = 0; i &lt;= n; i ++ ) fill(fa[i], fa[i] + SIZE + 1, 0); fill(depth, depth + n + 1, 0); fill(st, st + n + 1, 0); } void add (int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ; } void bfs (int root = 1) { int hh = 0, tt = 0; q[0] = root; depth[root] = 1; st[root] = 1; while(hh &lt;= tt) { int u = q[hh ++ ]; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (st[j]) continue; st[j] = true; depth[j] = depth[u] + 1; fa[j][0] = u; q[++ tt] = j; } } for (int j = 1; j &lt;= SIZE; j ++ ) for (int i = 1; i &lt;= n; i ++ ) fa[i][j] = fa[fa[i][j-1]][j-1]; } int lca (int a, int b) { if (depth[a] &lt; depth[b]) swap(a, b); for (int i = SIZE; i &gt;= 0; i -- ) if (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i]; if (a == b) return b; for (int i = SIZE; i &gt;= 0; i -- ) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0]; }};using namespace LCA;void dfs (int u, int fa){ d[u] = d[fa]; if (a[u] &gt; a[fa]) d[u] += a[u] - a[fa]; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j != fa) dfs(j, u); }}void rdfs (int u, int fa){ rd[u] = rd[fa]; if (a[u] &lt; a[fa]) rd[u] += a[fa] - a[u]; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j != fa) rdfs(j, u); }}int main (){ int m; cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%lld\", &amp;a[i]); for (int i = 1, u, v; i &lt;= n - 1 &amp;&amp; scanf(\"%d%d\", &amp;u, &amp;v); i ++ ) add(u, v), add(v, u); dfs(1, 0); rdfs(1, 0); bfs(); for (int i = 1; i &lt;= m; i ++ ) { int x, y; cin &gt;&gt; x &gt;&gt; y; int f = lca(x, y); printf(\"%lld\\n\", a[x] + rd[x] + d[y] - rd[f] - d[f]); } return 0;} L &amp; M. 小沙的remake题意给定长度为 $n$ 的序列，选择若干个数字组成最长不下降子序列，使得被选中的每个元素，设其位置为 $i$ ，它前面 $b_i$ 个元素至少也有一个被选择。问这样的子序列有多少种？ 分析树状数组维护：对于每个位置而言，以它为结尾至少有多少种满足条件的子序列个数。 按元素权值从小到大排序，从前往后遍历，对于每个元素，设位置为 $i$，查询 $[i-b_i, i)$ 中每个位置的值，相加即为以当前元素为结尾的子序列的方案数。 这里的Code不按照题目要求的生成数据，方便参照。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;using T = pair&lt;int, int&gt;;using ll = long long;#define x first#define y secondconst int N = 2e6 + 10, mod = 1e9+7;int n, b[N];T a[N];int c[N]; // 树状数组void add (int x, int v){ for (; x &lt;= n; x += x &amp; -x) c[x] = ((ll)c[x] + v) % mod;}ll query (int x){ ll sum = 0; for (; x; x -= x &amp; -x ) sum = ((ll)sum + c[x]) % mod; return sum;}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i].x &gt;&gt; b[i], a[i].y = i; sort(a + 1, a + n + 1); ll res = 0; for (int i = 1; i &lt;= n; i ++ ) { ll val = query(a[i].y - 1) - query(a[i].y - b[a[i].y] - 1) + 1; val %= mod; res = (res + val + mod) % mod; add(a[i].y, val); } cout &lt;&lt; res &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"2022寒假算法集训营1","slug":"2022寒假算法集训营1","date":"2022-02-17T03:00:00.000Z","updated":"2022-02-17T04:29:29.455Z","comments":true,"path":"2022/02/17/2022寒假算法集训营1/","link":"","permalink":"https://horb7.github.io/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/","excerpt":"","text":"A. 九小时九个人九扇门题意给定 $n$ 个数字和编号为 $1 \\sim 9$ 的九扇门，规定：$k$ 个数字的组合能够打开编号为 $f$ 的门，当且仅当这 $k$ 个数字之和的数字根等于 $f$ 。问对于每一扇门，有几种组合可以打开？ 其中 $1 \\le n \\le 10^5$ ，$1 \\le a_i \\le 10^9$ 。 数字根：不断将数字 $m$ 各个位上的数字相加，直到 $m$ 为一位数。一位数的数字根就是本身。 分析数字根的性质 求数字根：根据任何数字加 $9$ 的数字的数字根不变的性质，只需要模 $9$ 即可算出数字根。 设 $dp(i)$ 表示打开模 $9$ 为 $i$ 号门的组合数量。由于状态转移时，依赖关系不好找，而被依赖的关系容易找到，所以对于每个状态，更新被这个状态依赖的关系。注意DP的初始条件，为了启动DP要使 $dp(0)$ 为 $1$ ，最后要减去。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;int main (){ int n; cin &gt;&gt; n; vector&lt;int&gt; dp(9); dp[0] = 1; for (int i = 0; i &lt; n; i ++ ) { auto nxt = dp; int a; cin &gt;&gt; a; for (int k = 0; k &lt; 9; k ++ ) (nxt[(k + a) % 9] += dp[k]) %= mod; dp.swap(nxt); } for (int i = 1; i &lt; 9; i ++ ) cout &lt;&lt; dp[i] &lt;&lt; ' '; cout &lt;&lt; (dp[0] + mod - 1) % mod &lt;&lt; endl; return 0;} B. 炸鸡块君与FIFA22题意给定长度为 $n$ 的由 ‘W’, ‘L’, ‘D’ 构成的字符串表示若干场次的结果。 ‘W’表示胜利，分数加一；’L’表示失败，分数减一；’D’表示平局，分数不变。 特别的，当分数为 $3$ 的整数倍时，失败不会减少分数。 给定 $q$ 次查询，每次查询给出 $l, r, s$ ，问，在初始分数为 $s$ 时，经过 $[l, r]$ 场次后，最终的分数为多少？ 其中 $1 \\le n, q \\le 2 \\times 10^5$ ，$1 \\le l, r \\le n$ ，$0 \\le s \\le 10^9$ 。 分析注意到如果起始分数在模 $3$ 意义下相等，那么经历区间 $[l, r]$ 后，分数的变化量是不变的。 可以使用 ST 表，倍增实现查询，复杂度为 $O(max(q, n)\\times log n))$ 。其中查询复杂度为 $q log n$ ，初始化复杂度为 $n log n$ 。 设 $st[k][i][j]$ 表示初始分数模 $3$ 意义下为 $k$ ，经历区间 $[l, r]$ 后分数的变化量。 预处理：$st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j]) \\% 3][i + (1 &lt;&lt; j)][j-1]$ ，注意经过 $2^{j-1}$ 区间后初始分数在后面的区间要变化。 对于每次查询，我们可以每次走最大的二次幂，直到走完区间。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int st[3][N][21], Lg[N];/* 预处理,st[k][i][j] 表示初始分数模3为k时，经过[i, i + 2^j - 1]区间后分数的变化量 */int main (){ int n, q; cin &gt;&gt; n &gt;&gt; q; string s; cin &gt;&gt; s; s = ' ' + s; for (int i = 2; i &lt;= n; i ++ ) Lg[i] = Lg[i &gt;&gt; 1] + 1; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt; 3; j ++ ) { if (s[i] == 'W') st[j][i][0] = 1; else if (s[i] == 'L' &amp;&amp; j) st[j][i][0] = -1; } for (int j = 1; (1 &lt;&lt; j) &lt;= n ; j ++ ) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++ ) for (int k = 0; k &lt; 3; k ++ ) st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j-1]) % 3][i + (1 &lt;&lt; j-1)][j-1]; auto query = [&amp;] (int k, int l, int r) -&gt; int { int ret = 0; while(l &lt;= r) { int g = Lg[r - l + 1]; ret += st[k][l][g]; (k += st[k][l][g]) %= 3; l = l + (1 &lt;&lt; g); } return ret; }; while (q -- ) { int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; k + query(k % 3, l, r) &lt;&lt; endl; } return 0;} C. Baby’s first attempt on CPU题意给出 $n$ 个程序语句 $(3 \\le n \\le 100)$ ，其中某些程序语句有先写后读的制约关系，如果两条程序语句存在先读后写，那么这两条语句中间至少需要三条语句来使程序不出错。我们可以加入空语句来占位。 问，要使程序不出错，至少需要加入多少条空语句？ 给出的数据保证第 $i$ 行输入 $i, j, f$ ，如果 $f = 1$ ，表示第 $i$ 条语句和第 $i - j$ 条语句有先写后读的关系。并且 $i - j &lt;= 0$ 的情况始终有 $f = 0$ 。即不存在后面的语句先写，前面的语句再读。 分析贪心，设 $has(i)$ 表示第 $i$ 条语句后加入多少条空语句。 对于第 $i$ 条语句，假设它与第 $i-j$ 条语句有先读后写的关系，判断间隔有没有三条语句，如果没有，那么只需要在第 $i-1$ 条语句后加入空语句即可。 证明也很简单，对于后面的语句 $k$ ，如果有制约关系的语句 $k - k_j \\le i - j \\quad or \\quad k - k_j \\ge i$ ，那么加在哪条语句后都不会影响，反之，我们加在第 $i-1$ 条语句后一定更好，它能最大限度地包含于 $[k - k_j, k]$ 的位置。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int has[N];int main (){ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= 3; j ++ ) { int f; cin &gt;&gt; f; if (!f) continue; int cnt = accumulate(has + i - j, has + i, j - 1); if (cnt &lt; 3) has[i-1] += 3 - cnt; } cout &lt;&lt; accumulate(has + 1, has + n, 0ll) &lt;&lt; endl; return 0;} D. 牛牛做数论题意给定数字 $n$ 和函数 $H(x) = \\dfrac {\\phi(x)} x$ ，问： 回答一个 $x_0 \\in [2, n]$ ，使得 $H(x_0)$ 最小。如果存在多个，输出 $x_0$ 最小的那个。 回答一个 $x_0 \\in [2, n]$ ，使得 $H(x_0)$ 最大。如果存在多个，输出 $x_0$ 最大的那个。 其中 $1 \\le n \\le 10^9$ 。 分析根据欧拉函数定义 ：$\\phi(x) = x \\times \\prod_{i=1}^n (1 - \\dfrac 1 p_i)$ 。其中 $n$ 为 $x$ 质因子个数，$p_i$ 为$x$ 的各个质因子。 于是，函数 $H(x) = \\prod_{i=1}^n (1 - \\dfrac 1 p_i)$ 。 所以，求最小值，只需要把所有可能的质因子都加进去累乘即可，因为每个因子都小于 $1$ 。 求最大值，一定是只有一项因子，且这项因子的 $p_i$ 尽可能大，所以取不大于 $n$ 的最大质数，暴力求出即可，因为质数在 $[1, 10^9]$ 内浓度很大。(相邻质数最多相差 $282$) 。 注意 $n \\le 10^9$ ，在这个范围内最多有 $10$ 个不同的质因子。所以只需要枚举这几个就可以。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ const int p[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; auto is_prime = [&amp;] (int x) -&gt; bool { if (x &lt;= 2) return x == 2; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) return false; return true; }; int _; for (cin &gt;&gt; _; _ --; ) { int n; cin &gt;&gt; n; if (n == 1) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } int ans = p[0], pos = 1; while((long long)ans * p[pos] &lt;= n) ans *= p[pos ++ ]; cout &lt;&lt; ans &lt;&lt; ' '; ans = n; while(!is_prime(ans)) -- ans; cout &lt;&lt; ans &lt;&lt; endl; } return 0;} E. 炸鸡块君的高中回忆题意有 $n$ 个人想要进入学校，但是只有 $m$ 个校园卡，于是他们有如下方案：先让 $m$ 个人进入学校，再由一个人带着 $m$ 个校园卡出来。反复直到全部人进入学校。 每次进入或出去学校需要 $1$ 个单位时间，问所有人进入学校至少需要多少单位时间？ 分析首先有两个特判： $n \\le m$ ，可以一次进去完，只需要 $1$ 个单位时间。 $m == 1$ ，一定无法让所有人进去学校，因为每轮实际上只有 $m-1$ 个人进入学校。 否则，我们可以先让这 $n$ 个人进入第一轮循环，之后，他们需要循环的次数为 $\\lceil \\dfrac {n - m} {m-1} \\rceil$ ，注意最后一次不需要再有人出来送校园卡，因此总时间为 $2 + 2 \\times \\lceil \\dfrac {n - m} {m-1} \\rceil - 1$ 。 Code123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for (cin &gt;&gt; _; _--; ) { int n, m; cin &gt;&gt; n &gt;&gt; m; if (n &lt;= m) { cout &lt;&lt; 1 &lt;&lt; endl; continue; } if (m == 1) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } int d = (n - m + m - 1 - 1) / (m - 1); cout &lt;&lt; 2 + d * 2 - 1 &lt;&lt; endl; } return 0;} F. 中位数切分题意给出长度为 $n$ 的序列 $a$ ，将其划分为若干个子段，使得其中每个段的数值的中位数不小于 $m$ ，问最多能划分多少段？ （偶数长度字段的中位数为两个中较小的那一个。） 不存在任意划分策略则输出 $-1$ 。 其中 $1 \\le n \\le 10^5$ ，$1 \\le m \\le 10^9$ ，$1 \\le a_i \\le 10^9$ 。 分析首先，我们按照题意将序列划分若干个子段，使得每个字段数值的中位数不小于 $m$ 。 根据题目，我们发现对于每一个子段，不小于 $m$ 的数字个数一定大于 小于 $m$ 的数字个数。 贪心考虑，如果当前枚举的区间，已经满足大于关系，即 不小于 $m$ 的数字个数比小于 $m$ 的数字个数多 $1$ 。那么我们就可以把这块区间划分出来。 可以证明这样贪心一定是最优的，因为如果在这个区间之后加入 不小于 $m$ 的数字数量小于 小于 $m$ 的数字个数，那么不满足题意；如果大于，那么不必要合并，因为两个都是满足条件的子段。当然如果等于，那么还是要加上的，但是这不影响结果，因为这个区间还是满足如上条件。 我们发现，对于划分好的最优解子段，每个子段都满足 $\\ge m$ 的数字数量比 $&lt; m$ 的数字数量多 $1$ ，所以只需要统计一下区间的两个数量差即可。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for (cin &gt;&gt; _; _ --; ) { int n, m, cnt = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { int x; cin &gt;&gt; x; if (x &gt;= m) ++ cnt; else -- cnt; } cout &lt;&lt; (cnt &lt;= 0 ? -1 : cnt) &lt;&lt; endl; } return 0;} G. ACM is all you need题意给定长度为 $n$ 的序列 $a$ ，可以选择任意整数值 $b$ ，使得序列 $a$ 中每个元素 $a_i$ 变为 $|a_i - b| + b$ 。问经过一次变换后，序列中的极小值点的数量最少为多少？ 分析变换中 $+b$ 的操作是对整个序列都加上 $b$ ，不会改变相对大小，因此无用，可以看作变换为 $a_i = |a_i - b|$ 。 同时， $b$ 的值小于等于 $0$ 的情况是完全一样的，同样不改变相对大小，我们可以用 $b = 0$ 代替所有 $b \\le 0$ 的情况。 所以确定 $b$ 的值为 $[0, inf]$ 。 对于序列中每个元素而言，如果让它变成极小值点，取得 $b$ 值的范围是连续的，可以算出所有 $n-2$ 个 $b$ 范围的区间，那么问题就变成了：给定 $n-2$ 个区间，求被区间覆盖最小次数的点的覆盖次数。 对于区间 $[l, r]$ ，可以在每个位置上 $+1$ ，那么就是求 $[0, inf]$ 上每个位置的最小值。 可以使用差分来快速实现区间加，范围比较大，使用map离散化处理即可。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ const int INF = 0x3f3f3f3f; int _; for (cin &gt;&gt; _; _ -- ; ) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int &amp; x : a) cin &gt;&gt; x; map&lt;int, int&gt; m; m[0] = 0; // 注意0位置是需要考虑的 for (int i = 1; i &lt; n - 1; i ++ ) { int l = 0, r = INF; for (int x : { a[i-1], a[i+1] }) { if (x &gt; a[i]) r = min(r, a[i] + (x - a[i] - 1) / 2); if (x &lt; a[i]) l = max(l, x + (a[i] - x) / 2 + 1); if (x == a[i]) r = l - 1; // 这个点不可能成为极小值点 } if (r &lt; l) continue; ++ m[l]; if (r != INF) -- m[r + 1]; // 注意正无穷没有右端点 } int ret = INF, sum = 0; for (auto [k, v] : m) ret = min(ret, sum += v); cout &lt;&lt; ret &lt;&lt; endl; } return 0;} H. 牛牛看云题意给出长度为 $n$ 的序列 $a$ ，求出 $\\sum_{i=1}^n\\sum_{j=i}^n|a_i + a_j - 1000|$ 。 其中 $3 \\le n \\le 10^6$ ，$0 \\le a_i \\le 1000$ 。 分析题目简化一下就是求 $|a_i + a_j - 1000|$ ，其中 $1 \\le i \\le j \\le n$ 。 容易发现，对于 $i \\lt j$ 的情况， 把 $i$ 、$j$ 调换一下式子依然不变，所以式子对 $i$ 、$j$ 有对称性。 那么我们只需要对称地求出所有情况，再除以二即可。 注意点： 式子对 $i = j$ 不具有对称性，所以在求式子结果的时候，需要给这种情况加上。 $n$ 很大， $a_i$ 很小，可以在值域上做暴力。 为什么 $i = j$ 不具有对称性？ 对于 $1, 1, 2, 2$ 这个样例，我们枚举 $1$ 和 $2$ 的时候，把前和后的状态都算了，所以有对称性。 对于 $1, 1$ ，我们枚举 $1$ 和 $1$ 的时候，对于每一个 $1$ ，在计算加自己的时候，只计算了一次，根据对称性我们要加两次，这样最后除以二的时候才算出来一次。所以我们对每个 $1$ 都要再加一遍自己的情况。 其实本质上就是，$i=j$ 代表同一个式子，而 $i != j$ 代表了两种式子，一个定义域为 $i &lt; j$ ，一个定义域为 $i &gt; j$ 。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i++)#define int long longusing namespace std;const int N = 1010;int c[N];signed main (){ int n; cin &gt;&gt; n; long long ret = 0; rep(i, 1, n) { int x; cin &gt;&gt; x; ++ c[x]; } rep(i, 0, 1000) rep(j, 0, 1000) { if (i == j) ret = ret + c[i] * (c[j] + 1) * abs(i + j - 1000); else ret = ret + c[i] * c[j] * abs(i + j - 1000); } cout &lt;&lt; ret / 2 &lt;&lt; endl; return 0;} I. B站与各唱各的歌词有 $n$ 个UP主和 $m$ 句歌词，现在他们每个人要独立完成这 $m$ 句歌词，对于每一句歌词，他们可以选择唱或者不唱。完成后，将它们拼接起来。 如果一句歌词没有人唱或者被所有人唱过，那么这句歌词算失败的，否则是成功的。 问唱成功的歌词数量的期望为多少？ 若答案为分数，需要在模数为 $10^9 + 7$ 下取逆。 分析由于每个UP都是独立完成 $m$ 句歌词，所以对于每句歌词唱与不唱的概率都为 $\\dfrac 1 2$ 。 对于任意一句歌词，没有人唱或者全部人都唱的概率为 $(\\dfrac 1 2)^n$ 。 所以每一句歌词唱成功的概率为 $1 - (\\dfrac 1 2)^n \\times 2 = 1 - (\\dfrac 1 2)^{n - 1}$ 。 每一句成功的概率乘以总歌词数量即为唱成功的歌词数量的期望，即 $(1 - (\\dfrac 1 2)^{n - 1}) \\times m$ 。 Code1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main (){ const int p = 1e9 + 7; auto quick_power = [&amp;] (int a, int k) -&gt; int { int res = 1; for (a %= p; k; k &gt;&gt;= 1, a = (ll)a * a % p) if (k &amp; 1) res = (ll) res * a % p; return res; }; int _; for (cin &gt;&gt; _; _ -- ; ) { int n, m; cin &gt;&gt; n &gt;&gt; m; int inv = quick_power(2, p-2); cout &lt;&lt; (ll)(1 - quick_power(inv, n-1) + p) % p * m % p &lt;&lt; endl; } return 0;} J. 小朋友做游戏题意班级里有 $A$ 个安静的小朋友和 $B$ 个吵闹的小朋友，现在要选出 $n$ 个小朋友围成一圈，满足不存在两个吵闹的小朋友相邻。每个小朋友有一个幸福度，选中即可为班级增加幸福度，问最大幸福度为多少？ 分析为了满足条件，安静的小朋友至少要选出 $(n + 1) / 2$ 个，否则一定存在吵闹的小朋友相邻。 可以先选出这 $(n + 1) / 2$ 个小朋友，再双指针贪心选最大的幸福度。 双指针判断比较麻烦，要先判断是否有选完的，再贪心选。可以把剩下的小朋友放在一个容器中，选出最大的幸福度即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int _; for (cin &gt;&gt; _; _ -- ; ) { int A, B, n; cin &gt;&gt; A &gt;&gt; B &gt;&gt; n; vector&lt;int&gt; a(A), b(B), all; for (auto &amp; x : a) cin &gt;&gt; x; for (auto &amp; x : b) cin &gt;&gt; x; sort(a.begin(), a.end(), greater&lt;int&gt;()); sort(b.begin(), b.end(), greater&lt;int&gt;()); if (A &lt; n - A) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } for (int i = (n + 1) / 2; i &lt; A; i ++ ) all.push_back(a[i]); for (int i = 0; i &lt; B; i ++ ) all.push_back(b[i]); sort(all.begin(), all.end(), greater&lt;int&gt;()); int ret = 0; for (int i = 0; i &lt; (n + 1) / 2; i ++ ) ret += a[i]; for (int i = 0; i &lt; n - (n + 1) / 2; i ++ ) ret += all[i]; cout &lt;&lt; ret &lt;&lt; endl; } return 0;} K. 冒险公社题意数轴上有 $n$ 座连续的岛屿，玩家从第一座岛屿出发，依次经过所有岛屿直到到达第 $n$ 座岛屿。 岛屿有三种类型：绿岛、红岛和黑岛。 在玩家到达第 $i$ 座岛屿时，如果第 $i, i-1, i-2$ 中绿岛数量大于红岛，则罗盘发出绿色；如果红岛数量大于绿岛，则发出红光；否则发出黑光。 给出在 $n$ 座岛屿上，罗盘发出的光，问这 $n$ 座岛屿最多有几座绿岛？(第 $1, 2$ 座岛屿不发光，规定为 ‘X’) 。 其中 $1 \\le n \\le 10^5$ ，发出的光的颜色为长度 $n$ 的字符串，由 ‘R’、’G’、’B’ 构成。 分析为了方便，我们设绿岛为 $0$ ，红岛为 $1$ ，黑岛为 $2$ 。 设 $dp(i, j, k, l)$ 表示对于前 $i$ 座岛屿，且最后三座岛屿为 $(j, k, l)$ 时，绿岛的最大数量。 转移方程为 $dp(i, j, k, l) = max(dp(i, j, k, l), dp(i-1, t, j, k))$ ，其中 $0 \\le t \\le 2$ 。 注意在转移前判断 $(j, k, l)$ 是否合法，以及 $dp(i-1, t, j, k)$ 是否合法。$dp = -1$ 表示这种状态是不合法的。 坑点：注意一定用 $dp(i-1, t, j, k)$ 判断，不要用 $(t, j, k)$ 判断是否为 $s[i-1]$ ，因为即使等于，也不一定合法，还和前面的岛屿有联系。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int dp[N][3][3][3];/* dp(i, j, k, l) 表示考虑前i个字符，此时最后三个岛屿为(j, k, l)时的最大绿岛数量 * 其中0表示绿岛，1表示红岛，2表示黑岛 */char get_color (int a, int b, int c){ int x1 = (a == 0) + (b == 0) + (c == 0); int x2 = (a == 1) + (b == 1) + (c == 1); if (x1 &gt; x2) return 'G'; if (x1 &lt; x2) return 'R'; return 'B';}int main (){ int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = ' ' + s; memset(dp, -1, sizeof dp); // 初始化 for (int i = 0; i &lt; 3; i ++ ) for (int j = 0; j &lt; 3; j ++ ) for (int k = 0; k &lt; 3; k ++ ) if (get_color(i, j, k) == s[3]) dp[3][i][j][k] = !i + !j + !k; for (int i = 4; i &lt;= n; i ++ ) for (int j = 0; j &lt; 3; j ++ ) for (int k = 0; k &lt; 3; k ++ ) for (int l = 0; l &lt; 3; l ++ ) for (int t = 0; t &lt; 3; t ++ ) if (~dp[i-1][t][j][k] &amp;&amp; get_color(j, k, l) == s[i]) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i-1][t][j][k] + !l); int ret = -1; for (int i = 0; i &lt; 3; i ++ ) for (int j = 0; j &lt; 3; j ++ ) for (int k = 0; k &lt; 3; k ++ ) ret = max(ret, dp[n][i][j][k]); cout &lt;&lt; ret &lt;&lt; endl; return 0;} L. 牛牛学走路题意给出字符串 $s$ ，牛牛会按照字符串给的方向走一遍，问走的位置里原点最远为多少？ 分析签到题，维护一下当前的位置即可，设原点为 $(0, 0)$ 。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int dr[] = { 0, 0, 1, -1 }, dc[] = { 1, -1, 0, 0 };void solve (){ map&lt;char, int&gt; d; d['U'] = 0; d['D'] = 1; d['R'] = 2; d['L'] = 3; int x = 0, y = 0, n; cin &gt;&gt; n; string s; cin &gt;&gt; s; double ret = -1; for (int i = 0; i &lt; n; i ++ ) { x += dr[d[s[i]]]; y += dc[d[s[i]]]; double dis = sqrt(x * x + y * y); ret = max(ret, dis); } printf(\"%.12lf\\n\", ret);}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"}]},{"title":"扩展中国剩余定理","slug":"扩展中国剩余定理","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-21T15:39:40.000Z","comments":true,"path":"2022/02/16/扩展中国剩余定理/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"","text":"扩展中国剩余定理中国剩余定理对于同余方程组： \\begin{cases} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ x \\equiv a_3 \\pmod {m_3} \\\\ ..... \\\\ x \\equiv a_n \\pmod {m_n} \\\\ \\end{cases}求出满足上述同余方程组的 $x$ 的一组解，公式满足 $m_1,m_2, m_3 … m_n$ 互质。 令 $M = \\prod_{i=1}^{n}m_i , M_i = M / m_i, M_i \\times M_i^{-1} \\equiv 1 \\pmod {m_i}$ 。 中国剩余定理构造出了这样一组解: x = \\sum_{i=1}^{n} M_i * M_i^{-1} * a_i对于每一组解 $x \\equiv a_i \\pmod {m_i}$ ，$x$ 除了 $M_i \\times M_i ^ {-1} \\times a_i$ 项之外，其余都能被 $m_i$ 整除，所以只剩下这一项。 又因为 $M_i \\times M_i^{-1} \\equiv 1 \\pmod {m_i}$ 。所以 $x \\equiv a_i \\pmod {m_i}$ 。 扩展中国剩余定理传统的中国剩余定理限制性太强，必须要满足 $m_1, m_2, m_3 … m_n$ 互质。如何求出不满足模数不互质的同余方程组的解？ 先从两个柿子看起： \\begin{cases} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ \\end{cases}首先可以得到 $x = k_1 \\times m_1 + a_1 = k_2 \\times m_2 + a_2$ 。 对这个柿子化简： $k_1 \\times m_1 + k_2 \\times (-m_2) = a_2 - a_1$ 。 对于这个柿子，我们可以用扩展欧几里得求出一组满足 $k_1 \\times m_1 + k_2 \\times (-m_2) = gcd(m_1, -m_2)$ 的 $k_1, k_2$ 解。 记 $gcd(m1, -m2) = d$ 。 根据贝祖定理，如果不满足 $d | a_2 - a_1$ ，那么不存在解。否则，我们只需要扩大 $(a_2 - a_1) / d$ 倍即可得到 $k_1$ 的一组解。 由于这是个不定方程，在求出 $k_1$ 后，我们可以得到其他满足的解一定为 $k_1 = k_1 + k \\times (m_2 / d)$ 。 我们把这个通解 $k_1$ 带入原来的柿子：$x = (k_1 + k \\times (m_2 / d)) \\times m_1 + a_1$ 。 得到： $x = k_1 \\times m_1 + a_1 + k \\times (m_1 \\times m_2) / d$ 。 $x = k_1 \\times m_1 + a_1 + k \\times lcm(m_1, m_2)$ 。 令 $m_0 = lcm(m1, m2), a_0 = k_1 \\times m_1 + a_1$ 。 那么，我们得到 $x = k \\times m_0 + a_0$ ，这个柿子满足这两个同余方程组解。 通过这样的方式，我们就可以把两个同余方程组化简成一个，最终达到化简 $n$ 个同余方程组的效果。 那么最终可以算出 $x = k \\times m + a$ ，其中 $m = lcm(m_1, m_2 … m_n)$ ，所以在 $\\pmod m$ 的意义下， $x = a$ 。 例题:Acwing 204 表达整数的奇怪方式 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;int exgcd (int a, int b, int &amp; x, int &amp; y){ if (!b) return x = 1, y = 0, a; int r = exgcd(b, a % b, x, y); tie(x, y) = make_tuple(y, x - (a / b) \\times y); return r;}int mod (int a, int b){ int res = ((a % b) + b) % b; return res;}signed main (){ int n; cin &gt;&gt; n; int a1, m1; cin &gt;&gt; a1 &gt;&gt; m1; for (int i = 1; i &lt; n; i ++ ) { int a2, m2, k1, k2; cin &gt;&gt; a2 &gt;&gt; m2; int r = exgcd(a1, -a2, k1, k2); if ((m1 - m2) % r) return cout &lt;&lt; \"-1\" &lt;&lt; endl, 0; k1 = mod(k1 \\times (m2 - m1) / r, abs(a2 / r)); m1 = k1 \\times a1 + m1; a1 = abs(a1 \\times a2 / r); } cout &lt;&lt; m1 &lt;&lt; endl; return 0;} 关于为什么取 $abs$ 的原因: 由于 $a \\% b$ 和 $a \\% -b$ 是相同的，所以我们在计算 $k_1$ 时 需要加上 $abs(a_2 / r)$ ，防止在 $mod$ 过程中加上负数，结果仍然是负数。 下一个阶段的 $a_1$ 实际上一个的 $lcm(a_1,a_2)$ ，但是在计算 $gcd(a_1, a_2)$ 时可能出现负数，导致计算 $lcm$ 时会出现负数，这里要取 $abs$ 。","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-20T01:38:04.000Z","comments":true,"path":"2022/02/16/扩展欧几里得/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"","text":"拓展欧几里得在拓展欧几里得定理之前，先介绍以下贝祖定理： 如果方程式 $ax + by = m$ 成立，那么 $gcd(a, b) | m$ 显然，我们可以把原方程式写作：$m = k1 \\times g \\times x + k2 \\times g \\times y = g(k1 \\times x + k2 \\times y)$ 根据贝祖定理，如果有 $ax + by = 1$ ，那么 $gcd(a, b) = 1$， 即 $a$ 与 $b$ 互质。 我们可以使用著名的辗转相除法算出来 $gcd(a, v=b)$ : 1234int gcd (int a, int b){ return b ? gcd(b, a % b) : a;} 拓展欧几里得给出 $ax + by = m$ ，如何求出他的一组解？ 根据贝祖定理，只要我们求出 $ax + by = gcd(a, b)$ 即可，由于 $gcd(a, b) | m$ ，所以可以求出原式的一组因子，只需要乘上 $m / gcd(a, b)$ 即为原式的一组解。 那么问题就转化为了，求 $ax + by = gcd(a, b)$ 的一组 $(a, b)$ 。 $gcd(a, b)$ 可以用欧几里得辗转相除求出，而 $a, b$ 可以在求的过程中得出。 假设我们到达了终点，此时 $a = gcd(a, b), b = 0$ ，那么有 $x = 1, y = 0$ 。 由于$gcd(a, b)$ 是递归的，当我们想要求得 $ax + by = m$ 时，我们已经求出了 $bx + (a \\% b)y = m$ 的一组解。 $a \\% b = a - \\lfloor \\dfrac a b \\rfloor \\times b$ 把已有的式子化作：$bx + (a - \\lfloor \\dfrac a b \\rfloor \\times b)y = m$ 那么，可以得到：$ay + b(x - \\lfloor \\dfrac a b \\rfloor \\times y) = m$ 所以我们发现，如果从上一层状态推下来，那么：$x = y, y = x - \\lfloor \\dfrac a b \\rfloor \\times y$ Code1234567int exgcd (int a, int b, int &amp; x, int &amp; y){ if (!b) return x = 1, y = 0, a; int r = exgcd(b, a % b, x, y); tie(x, y) = make_tuple(y, x - (a / b) * y); return r;} 由于 $ax + by \\equiv m \\pmod p$ 有无穷多组，而我们只计算出了一种，那么如何得到其他解？ 假设我们得到解为 $x_0, y_0$ ，还有另外一组解为 $x_1, y_1$ ，那么可以得到： $ax_0 + by_0 \\equiv m \\pmod p$ $ax_1 + by_1 \\equiv m \\pmod p$ 两个柿子相减，得到 $a(x_0 - x_1) \\equiv -b(y_0 - y_1) \\pmod p$ 两边同时除以 $gcd(a, b)$ ，有 $a / gcd(a, b) (x_0 - x_1) \\equiv -b / gcd(a, b)(y_0 - y_1) \\pmod p$ 此时 $a / gcd$ 与 $b / gcd$ 互质，所以一定有 $a / gcd(a, b) | (y_0 - y_1), b / gcd(a, b) | (x_0 - x_1)$ 我们记 $x_1 = x_0 + k \\times \\dfrac{b}{gcd(a, b)}$ ，同理 $y_1 = y_0 + k \\times \\dfrac{a}{gcd(a, b)}$ 。 欧几里得用途求逆元 $a \\times a^{-1} \\equiv 1 \\pmod p$ ，可以写成 $a \\times a^{-1} \\equiv kp + 1 \\pmod p$ ， 这样，我们就可以得到柿子 : $a \\times a^{-1} + kp \\equiv 1 \\pmod p$ 。 这就是拓展欧几里得公式，由于 $a, p$ 都已知，只需要用拓展欧几里得算出 $(a^{-1}, k)$ 即可。 注意拓展欧几里得可以计算 $p$ 与 $a$ 非互质情况下的逆元，而欧拉定理不能算出。 计算同余方程组扩展中国剩余定理","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"最近公共祖先","slug":"最近公共祖先","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-19T14:48:26.000Z","comments":true,"path":"2022/02/16/最近公共祖先/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"","text":"最近公共祖先 (LCA)在一个有根树中，两个结点 $a、b$ 都有若干个祖先(本身也是自己的祖先)，他们也会有公共的祖先，距离他们最近，也就是在有根树中深度最大的祖先，被称做 $a、b$ 的最近公共祖先。 求最近公共祖先向上标记法先从一个点开始向上走到根节点，再由另一个结点开始向上走，走到一个已经被标记过的结点，那么这个结点就是这两个点的最近公共祖先。 最坏情况下树为一条链，时间复杂度为 $O(n)$ 。 由于复杂度比较大，因此这个算法不常用。 倍增法倍增法基于二进制拆分，每次都尽可能向上多跳几步。 $\\displaystyle {fa(i, j})$ 表示结点 $i$ 向上走 $2^j$ 次后到达的结点。 $depth(i)$ 表示结点 $i$ 在有根树中的深度。 对于结点 $a 、 b$ ，假设 $depth(a) &lt; depth(b)$ ，我们先把 $a$ 跳到与 $b$ 相同的深度；如果此时 $a == b$ ，那么LCA就是 $y$ ；否则，我们同时让 $a、b$ 向上跳到不是 LCA 的结点，最后跳到的结点的父节点就是 LCA 。 由于每次跳的步数都是 $2$ 的整数次幂，所以时间复杂度为 $O (log n)$ 。 预处理出所有 $fa(i, j)$ 的时间复杂度为 $O (n log n)$ ，所以倍增法适用于多次查询LCA。 例题：洛谷 P3379 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010, M = N &lt;&lt; 1;int n, qus, root;int fa[N][20]; // fa(i, j) 表示i结点向上走 2^j 步到达的结点int depth[N];int q[N]; bool st[N]; // BFSint h[N], e[M], ne[M], idx;void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}void bfs (){ int hh = 0, tt = 0; q[0] = root; st[root] = true; depth[root] = 1; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i] ) { int j = e[i]; if (!st[j]) { st[j] = true; depth[j] = depth[t] + 1; q[++ tt] = j; fa[j][0] = t; // 初始化 fa(i, 0) 为父节点 } } } // 预处理 fa 数组 for (int j = 1; j &lt; 20; ++ j ) for (int i = 1; i &lt;= n; ++ i ) fa[i][j] = fa[fa[i][j-1]][j-1];}// 返回 (a, b) 的lcaint lca (int a, int b){ if (depth[a] &lt; depth[b]) swap(a, b); // 保证 a 的深度大于 b // a 跳到与 b 相同深度的结点 for (int i = 19; i &gt;= 0; -- i ) if (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i]; if (a == b) return b; // a == b ，那么 b 就是 lca // 同时跳上面 for (int i = 19; i &gt;= 0; -- i ) if (fa[a][i] != fa[b][i]) { a = fa[a][i]; b = fa[b][i]; } return fa[a][0]; // 此时 a 父节点就算 lca}int main (){ cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root; memset(h, -1, sizeof h); for (int i = 1; i &lt; n; ++ i ) { int x, y; cin &gt;&gt; x &gt;&gt; y; add (x, y); add (y, x); } bfs (); // 求出每个结点的深度及fa数组 while (qus -- ) { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca (x, y) &lt;&lt; endl; } return 0;} Tarjan离线算法Tarjan算法基于深度优先遍历，本质上是对向上标记法的优化。 遍历有根树，给每个结点分为三类。 已经遍历过并且已经回溯的点 正在被遍历的点 还没有被搜索过的点 当一个结点回溯，我们将它合并到它的父节点上，我们可以发现，如果一次查询包括当前正在被遍历的结点和已经回溯的结点，那么他们的 LCA 就是已经回溯的点所在的集合的祖先结点。而合并及查询集合祖先的操作可以使用并查集。 如图，粉色是未被搜索到的点，蓝色是正在被遍历的点，其他都是已经遍历的点(有些未回溯，所以他们处于不同的集合)。 绿色和黄色任意点的LCA都是黄色点集合的祖先结点，其他也是如此。 例题：洛谷 P3379 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010, M = N &lt;&lt; 1;typedef pair&lt;int, int&gt; PII ;int n, qus, root;int p[N];int st[N]; // 记录每个点的状态：1表示正在搜索，2表示已经回溯，0表示还没有搜索到vector&lt;PII&gt; query[N]; // query[i] -&gt; (j, id) 表示在第id个查询中，查询的结点是(i, j)int ans[N]; // 存储每个查询的结果int h[N], e[M], ne[M], idx;void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}int find (int x){ return p[x] == x ? x : p[x] = find(p[x]);}void tarjan (int u){ st[u] = 1; // 正在搜索 u 结点 for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; // 如果还没有遍历，则遍历子结点 if (!st[j]) { tarjan(j); p[j] = u; } // 回溯后记得及时合并到父节点上 } for (auto t : query[u]) { int y = t.first, id = t.second; if (st[y] == 2) ans[id] = find(y); // 如果j已经回溯 } st[u] = 2; // u 结点回溯}int main (){ cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root; memset(h, -1, sizeof h); for (int i = 1; i &lt; n; ++ i ) { int x, y; cin &gt;&gt; x &gt;&gt; y; add (x, y); add (y, x); } for (int i = 1; i &lt;= qus; ++ i ) { int x, y; cin &gt;&gt; x &gt;&gt; y; if (x != y) { query[x].push_back({y, i}); query[y].push_back({x, i}); } } for (int i = 1; i &lt;= n; ++ i ) p[i] = i; tarjan(root); for (int i = 1; i &lt;= n; ++ i ) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"tree","slug":"tree","permalink":"https://horb7.github.io/tags/tree/"}]},{"title":"环形纸牌均分问题","slug":"环形纸牌均分问题","date":"2022-02-16T14:54:28.239Z","updated":"2022-01-03T13:41:30.000Z","comments":true,"path":"2022/02/16/环形纸牌均分问题/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E7%8E%AF%E5%BD%A2%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/","excerpt":"","text":"环形纸牌均分问题 环形纸牌均分是一道很经典的贪心问题，但是每次遇到类似的都想不出来，于是就有了这篇博客记录QAQ。 问题描述有 $n$ 堆纸牌围成环形，每堆纸牌拥有 $a_i$ 个纸牌，第 $i$ 堆纸牌可以顺时针或者逆时针传播一张牌，代价为 $1$ 。问使得每堆牌的牌数数量都相等，需要的最少代价为多少？ $1 \\le n \\le 10^6, 1 \\le a_i \\le 10^9$ 。 分析假设第 $i$ 堆纸牌顺时针传播了 $s_i$ 张纸牌，那么第 $i$ 堆纸牌最终有 $a_i - s_i + s_{i-1}$ 张纸牌。 由于最终纸牌数量都相等，因此有 $\\overline a = \\dfrac {a_1 + a_2 + \\ldots + a_n} n$ 。 那么有 ： \\begin{aligned} &\\overline a = a_1 - s_1 + s_n \\\\ &\\overline a = a_2 - s_2 + s_1 \\\\ &\\overline a = a_3 - s_3 + s_2 \\\\ & \\ldots \\\\ &\\overline a = a_n - s_n + s_{n - 1} \\\\ \\end{aligned}我们把 $s_i$ 提取出来： \\begin{aligned} &s_1 = s_n - (\\overline a - a_1) \\\\ &s_2 = s_1 - (\\overline a - a_2) = s_n - (\\overline a - a_1) - (\\overline a - a_2) = s_n - (2 \\times \\overline a - (a_1 + a_2)) \\\\ &s_2 = s_2 - (\\overline a - a_3) = s_n - (2 \\times \\overline a - (a_1 + a_2)) - (\\overline a - a_3) = s_n - (3 \\times \\overline a - (a_1 + a_2 + a_3)) \\\\ & \\ldots \\\\ &s_n = s_{n} - (n \\times \\overline a - (a_1 + a_2 + \\ldots + a_n)) \\\\ \\end{aligned}题目要我们求得是 $res = \\sum_{i=1}^n |s_i|$ 。 所以 $res = |s_n - (\\overline a - a_1)| + |s_n - (2 \\times \\overline a - (a_1 + a_2))| + \\ldots + |s_n - (\\overline n \\times a - (a_1 + \\ldots a_n))|$ 。 我们令 $x = s_n, \\ i \\times \\overline a - \\sum_{j = 1}^i a_j = c_i$ 。 那么 $res = |x - c_1| + |x - c_2| + |x - c_3| + \\ldots + |x - c_n|$ 。 问题变成了仓库选址问题，选出一个点在数轴上与各点距离和最小，选择中位数即可。 Code123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;const int N = 1000010;int n;ll s[N], c[N];int main (){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; s[i], s[i] += s[i - 1]; // 求前缀和，方便计算c(i) ll A = s[n] / n; // 均值，最后到达的值 for (int i = 1; i &lt;= n; i ++ ) c[i] = i * A - s[i]; nth_element(c + 1, c + (n + 1) / 2, c + n + 1); // 求出中位数 ll x = c[(n + 1) / 2], res = 0; for (int i = 1; i &lt;= n; i ++ ) res += abs(x - c[i]); cout &lt;&lt; res &lt;&lt; endl; return 0;} 例题AcWing122.糖果传递 模板题 AcWing105.七夕祭 排序+环形均分纸牌 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;const int N = 1000010;int n, m, t;int c[N], r[N], pre[N];// 对n个人均分纸牌ll calc (int a[], int n){ int aver = t / n; for (int i = 1; i &lt;= n; i ++ ) pre[i] = pre[i - 1] + a[i] - aver; sort(pre + 1, pre + n + 1); ll ret = 0; for (int i = 1; i &lt;= n; i ++ ) ret = ret + abs(pre[i] - pre[n + 1 &gt;&gt; 1]); return ret;}int main (){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1, x, y; i &lt;= t &amp;&amp; cin &gt;&gt; x &gt;&gt; y; i ++ ) ++ c[x], ++ r[y]; if (t % n == 0 &amp;&amp; t % m == 0) cout &lt;&lt; \"both \" &lt;&lt; calc(c, n) + calc(r, m) &lt;&lt; endl; else if (t % n == 0) cout &lt;&lt; \"row \" &lt;&lt; calc(c, n) &lt;&lt; endl; else if (t % m == 0) cout &lt;&lt; \"column \" &lt;&lt; calc(r, m) &lt;&lt; endl; else cout &lt;&lt; \"impossible\" &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://horb7.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"素数筛","slug":"素数筛","date":"2022-02-16T14:54:28.239Z","updated":"2021-12-19T14:42:36.000Z","comments":true,"path":"2022/02/16/素数筛/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E7%B4%A0%E6%95%B0%E7%AD%9B/","excerpt":"","text":"质数筛选 质数筛选指在一个范围内筛去非质数，留下质数，通常用单独的质数数组保存留下的质数。 埃氏筛对于每个数字(从2开始)，筛去它所有的倍数，那么留下来的一定都是质数。 证：对于任意和数 $x$ ，一定存在一个质因数 $pj$ ，那么我们一定可以用 $pj$ 筛去 $x$ 。 时间复杂度 $O (n log n)$。 证：对于每个数字 $i$ ，内层循环会执行 $n / i$ 次。那么一共执行 n / 2 + n / 3 + ... n / n = n(1 / 2 + 1 / 3 + ... + 1 / n) = n log n次。 12345678bool st[N];int prime[N], cnt;for (int i = 2; i &lt;= n; i ++ ){ if (!st[i]) prime[++ cnt] = i; for (int j = i + i; j &lt;= n; j += i ) st[j] = true;} 我们发现，对于每个和数 $x$ ，假设存在质因数 $pj$ ，那么如果我们用和数 $x$ 来筛去的数字也一定存在质因数 $pj$ ，也就是在 $x$ 之前这些数字就已经被 $pj$ 筛去，不需要再用 $x$ 筛去。 优化版： 12345678for (int i = 2; i &lt;= n; i ++ ){ if (!st[i]) { prime[++ cnt] = i; for (int j = i + i; j &lt;= n; j += i ) st[j] = true; }} 质数定理: $1 \\sim n$ 中大约有 $n \\ / \\ ln \\ n$ 个质数，那么总执行次数大约为 $n log n / log n = n$ ，实际复杂度大约为 $O(n log log n)$。 欧拉筛又称线性筛，每次我们都只用最小质因数来筛去和数 $x$ ，这样就不会重复筛数。因此时间复杂度为 $O(n)$ 。 原理写在代码块中，例题： [洛谷3383]: https://www.luogu.com.cn/problem/P3383 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000010;int n;int prime[N], idx;bool st[N];void init (){ scanf(\"%d\", &amp;n); // O(n) 线性筛 for (int i = 2; i &lt;= n; i ++ ) { // 没有标记，是质数 if (!st[i]) prime[++ idx] = i; /* 由于被筛选的值 k 可能含有多个质因数，会被筛去多次。 我们只用k的最小质因数筛去k，这样每个数字都只会被筛去一次 k = prime[j] * i i是当前数 从小到大枚举所有质数 1. i % prime[j] == 0 prime[j]是i的最小质因数，那么prime[j]一定是k的最小质因数 2. i % prime[j] != 0 prime[j]小于i的任意质因数，那么prime[j]一定也是k的最小质因数 对于每个和数x，一定存在最小质因数pj，那么当我们枚举到x / pj时，就可以把x筛去 */ for (int j = 1; prime[j] &lt;= n / i; j ++ ) { st[i * prime[j]] = true; if (i % prime[j] == 0) break; /* 为什么这里需要break? 假设当前被筛去的数字是 i * pj，由于i是pj的倍数，那么如果继续递增pj，i的最小质因数 一定还是原来的pj，被筛去的数字最小质因数也一定是pj，那么我们再筛的话就会产生重复 */ } }}void solve (){ int k; scanf(\"%d\", &amp;k); printf(\"%d\\n\", prime[k]);}signed main () { init(); int T; scanf(\"%d\", &amp;T); while (T -- ) solve(); return 0;}","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"线段树入门","slug":"线段树入门","date":"2022-02-16T14:54:28.239Z","updated":"2022-02-18T02:04:59.359Z","comments":true,"path":"2022/02/16/线段树入门/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"线段树介绍线段树是一种基于分治思想的二叉树结构，用于在区间上进行高效的信息统计。 如图是一般的线段树结构，我们可以发现： 线段树的每个节点都代表一个区间，且按照深度递增，代表的区间逐渐缩小。 线段树是单独的一棵树，具有唯一的根节点，它代表需要统计信息的整个区间。 线段树的每个叶子节点都代表一个长度为 $1$ 的区间 $[x, x]$ 。 对于每个非叶子结点 $[l, r]$ ，它的左节点为 $[l, mid]$ ，右节点为 $[mid+1, r]$ ，其中 $mid = (l + r) / 2$ 。 如果去除最后一层，那么线段树是一棵完全二叉树，因此我们可以采用与二叉堆类似的存储形式： 根节点编号为 $1$ 。 对于非叶子节点 $p$ ，左节点为 $p \\times 2$ ，右节点为 $p \\times 2 + 1$ 。 需要注意的是，最后一层是不满的，我们需要空出数组的位置来表示空节点。 除去最后一层，由于最后第二层最多有 $n$ 个节点，因此满二叉树需要 $n + \\dfrac n 2 + \\dfrac n 4 + \\ldots + 1 = 2 \\times n - 1$ 个节点。 最后一层需要开 $n \\times 2$ 个节点，因此我们需要至少 $n \\times 4$ 的空间存储，才能保证数组不会越界。 线段树的建树线段树的基本用途是维护序列的某些属性，最基本的线段树具有查询和修改两个功能。给定长度为 $[1, n]$ 的序列，我们可以按 $[1, n]$ 的区间建一棵线段树。线段树基于分治思想，需要从上往下构建。递归完成后也可以方便地从下往上传递信息。 下面以维护区间最大值为例。 1234567891011121314151617181920212223struct seg_tree{ #define lc(p) (p&lt;&lt;1) #define rc(p) (p&lt;&lt;1|1) int l, r; // 节点的信息，维护 [l, r] 区间内的信息 int maxv; // 需要在区间上维护的信息};const int N = 100010; // 假设序列最长长度为 Nseg_tree t[N &lt;&lt; 2];int a[N]; // 原序列void build (int p, int l, int r) // 当前构建的节点及其需要维护的区间{ t[p].l = l, t[p].r = r; if (l == r) { t[p].maxv = a[l]; return; } // 到达叶子节点，不需要再往下创建节点 int mid = l + r &gt;&gt; 1; // 否则创建左节点 [l, mid] 和右节点 [mid+1, r] build(lc(p), l, mid), build(rc(p), mid+1, r); // 构建完后需要维护这个区间的信息，由于已经创建好左节点(左边一半区间)和右节点(右边一半区间)，根据这两个节点来维护 t[p].maxv = max(t[lc(p)].maxv, t[rc(p)].maxv);}build(1, 1, n); // 从根节点1开始，它维护的是整个区间[1, n] 线段树的单点修改利用线段树递归从下往上传递信息的结构，我们也可以很方便地修改某一个元素。 叶子节点代表单个长度的区间，也就是具体的某一个元素。我们可以递归地找到需要修改的叶子节点，在回溯的过程维护它的父节点(代表的区间包括自己的区间，所以也要修改)。 12345678910void modify (int p, int x, int v) // 需要把x位置的元素改为v，目前为p节点{ if (t[p].l == t[p].r) { t[p].maxv = v; return; } // 已经找到 int mid = t[p].l + t[p].r &gt;&gt; 1; // 否则判断去左区间找还是去右区间找 if (x &lt;= mid) modify(lc(p), x, v); // 左区间为[l, mid]，在这个区间内 else modify(rc(p), x, v); // 右区间为[mid+1, r] t[p].maxv = max(t[lc(p)].maxv, t[rc(p)].maxv); // 注意修改完子区间后，当前区间需要维护}modify(1, x, v); // 从根节点开始找 在线段树的单点修改过程中，每一层只会被调用一次，而线段树的高度为 $log n$ ，因此复杂度为 $log n$ 。 线段树区间查询以维护区间最大值的线段树为例，我们查找区间 $[l ,r]$ 的最大值，需要从根节点开始，递归完成： 如果 $[l, r]$ 区间完全覆盖了当前节点的范围，直接返回当前节点维护的信息。 如果左节点和 $[l, r]$ 有交叉，那么递归查询左节点。 如果右节点和 $[l, r]$ 有交叉，那么递归查询右节点。 1234567891011int query (int p, int l, int r) // 需要查询[l, r]的最大值，当前节点为p{ if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].maxv; // 完全覆盖，节点区间内所有元素都是查询区间内的元素 int mid = t[p].l + t[p].r &gt;&gt; 1; // 否则查询左节点和右节点 int maxv = -2e9; // 设为负无穷 if (l &lt;= mid) maxv = max(maxv, query(lc(p), l, r)); // [l, r]与左节点有交叉 if (r &gt; mid) maxv = max(query(rc(p), l, r)); // [l, r]与右节点有交叉 return maxv;}cout &lt;&lt; query(1, l, r) &lt;&lt; endl; // 从根节点开始查询 关于复杂度： 在任意一个节点，只查询它的左节点/右节点。 显然复杂度是 $O(log n)$ 的。 在某些节点，查询左右节点。 在左节点，显然又有两种可能，如果只查询一遍，那么可以保证 $O(log n)$ 的复杂度，如果查询左右两边，那么左边一定是被完全覆盖的，因此可以直接回溯。右节点同理。 所以查询左右节点，本质只是比查询单边多了一次查询，因此复杂度为 $O(2 log n) = O(log n)$ 。 线段树的区间修改假设现在要把 $[l, r]$ 中所有元素加上 $v$ ，一种显然的做法是对 $[l, r]$ 中所有元素执行一次单点修改，但这样的复杂度为 $O(len \\times log n)$ 的，最坏情况下修改所有元素，则需要修改整棵树，复杂度 $O(n)$ 。 可以发现，如果我们对区间 $[l, r]$ 中所有元素进行修改，但后面的查询中没有用到 $[l, r]$ 的子区间 ，那么这个修改是无意义的。也就是说，最好的办法就是在查询时才更新当前的区间 。 类似于区间查找，当我们发现某一个节点维护的区间被需要修改的区间覆盖，那么我们修改完当前节点后，直接回溯，不用对其递归修改，比如修改区间 $[1, 10]$ ，当我们递归到节点 $[1, 5]$ 时，就可以修改并回溯。同时我们要给这个节点打上标记，表示当前节点已经修改，但其子区间未修改。 在之后的查询过程中，如果需要使用其子结点，则使用标记的信息更新两个子结点，同时为子结点打上标记，再清除当前节点的标记。 类似于区间查询，区间修改会将区间划分为 $O(log n)$ 个小区间，将复杂度降为 $O(log n)$ 。 下面以例题 [模板]线段树1 为例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;// 以维护区间和为例struct seg_tree{ #define lc(x) x&lt;&lt;1 #define rc(x) x&lt;&lt;1|1 int l, r; ll sum, add; // sum为[l, r]区间元素的和，add为懒标记，记录当前这个区间，每个元素加了多少};const int N = 100010;seg_tree t[N &lt;&lt; 2];int a[N], n, m;void pushup (int p) // pushup操作：自下而上维护每个节点的sum值{ t[p].sum = t[lc(p)].sum + t[rc(p)].sum;}void pushdown (int p) // pushdown操作：将懒标记下传，将子节点变为真实值{ if (!t[p].add) return ; // 如果当前位置没有懒标记，直接返回 t[lc(p)].sum += t[p].add * (t[lc(p)].r - t[lc(p)].l + 1); // 左节点 t[rc(p)].sum += t[p].add * (t[rc(p)].r - t[rc(p)].l + 1); // 右节点 t[lc(p)].add += t[p].add; // 给左节点加懒标记，注意左节点可能已经加过懒标记 t[rc(p)].add += t[p].add; // 给右节点加懒标记，注意右节点可能已经加过懒标记 t[p].add = 0; // 清除p的懒标记}void build (int p, int l, int r){ t[p].l = l; t[p].r = r; if (l == r) { t[p].sum = a[l]; return; } // 到达叶子节点，此时区间长度为1，sum即为此位置的值 int mid = l + r &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid+1, r); pushup(p); // 使用pushup自下往上维护信息}void modify (int p, int l, int r, int v) // 为[l, r]区间所有数字增加v{ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) // 当前节点被[l, r]区间覆盖 { // 修改当前区间，打上标记并回溯 t[p].sum += (ll)v * (t[p].r - t[p].l + 1); t[p].add += v; return ; } pushdown(p); // 此时这个点的子节点需要使用，将懒标记下传 int mid = t[p].l + t[p].r &gt;&gt; 1; if (l &lt;= mid) modify(lc(p), l, r, v); // 左节点[t[p].l, mid]有部分被覆盖 if (r &gt; mid) modify(rc(p), l, r, v); // 右节点[mid+1, t[p].r]有部分被覆盖 pushup(p); // 子结点被修改，记得维护当前节点}ll query (int p, int l, int r){ if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) return t[p].sum; pushdown(p); // 子节点需要使用，记得下传懒标记 int mid = t[p].l + t[p].r &gt;&gt; 1; ll ret = 0; // 当前节点被[l, r]覆盖的元素的和 if (l &lt;= mid) ret += query(lc(p), l, r); // 左节点[t[p].l, mid]有部分被覆盖 if (r &gt; mid) ret += query(rc(p), l, r); // 右节点[mid+1, t[p].r]有部分被覆盖 return ret;}int main (){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; build(1, 1, n); // 在区间[1, n]上建立线段树 while(m -- ) { int op, l, r, v; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 1) cin &gt;&gt; v, modify(1, l, r, v); else cout &lt;&lt; query(1, l, r) &lt;&lt; endl; } return 0;} 例题 一个简单的整数问题 可以使用树状数组 一个简单的整数问题2 区间加，区间和 进制 维护所有进制 你能回答这些问题吗 比较难的题目，需要维护较多信息 区间最大公约数 更损相减法","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2022-02-16T14:54:28.239Z","updated":"2022-02-17T14:24:19.704Z","comments":true,"path":"2022/02/16/最小生成树/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"最小生成树介绍 在介绍最小生成树前，先介绍一下生成树：在一张联通无向图中，我们取图上的所有点，并取最少的边将其相连使其连通生成一棵树，这个树就被称作这张图的生成树。因为树的边数一定是点数-1，所以就是取 $n-1$ 条边来连通 $n$ 个点。 那么最小生成树(Minimum Spanning Tree)，是最小权重生成树的简称。规定树的权值为树上所有边的权值和，那么它就是一张连通加权无向图中一颗权值最小的生成树，如上图。由定义可以看出，最小生成树不一定唯一。 对于如何生成最小生成树的问题，我们有两种常见的解决方法，分别是Prim算法和Kruskal算法，两者都基于贪心。 Prim算法给定图 $G(V, E)$ ，我们逐步进行Prim算法，假设在过程中，$V_{new}$ 表示已经选中作为生成树上的结点，$E_{new}$ 表示已经选中作为最小生成树上的边。 规定Prim算法如下： 初始化一个结点 $x$ 加入 $V_{new}$ ，则 $V_{new} = {x}$ 。由于最小生成树包含所有节点，我们可以用任意一个结点初始化。 从集合 $E$ 中选择权值最小的边 $(u, v)$ ，满足 $u \\in V_{new}$ 且 $v \\notin V_{new}$ ，将 $v$ 加入集合 $V_{new}$ 中，把 $(u, v)$ 加入 $E_{new}$ 中。 重复操作，直到所有点都已经被选中加入最小生成树中，即 $V_{new} = V$ 。 根据 $V_{new}$ 和 $E_{new}$ 所得到的新图 $G_{new}(V_{new}, E_{new})$ 即为原图 $G(V, E)$ 的最小生成树。 只需要证明根据第二步所得到边一定为最优解即可。 按照Prim算法得到的第一条边一定是最小生成树上的边。 如果不是，我们把这一条边加入到最小生成树中，形成回路，我们让最小的边取代回路中比它大的边，得到权值更小的生成树。所以第一条边一定是最小生成树上的边。 假设在某一个步骤中，Prim得到的点集为 $V_{new} = \\{v1, v2, v3 \\ldots vs-1\\}$ 。 根据Prim算法，我们应该选择与这些点有交集的边中，权值最小的边。 假设这个权值最小的边连接 $V_{new}$ 中的 $vk$ ，如果不选择这条边，那么我们把这条边加入最小生成树中，形成一个回路，且这个回路包含 $vk$ ，我们假设连接 $vk$ 的那条边另一端为 $vi$ ，我们用权值最小的边替换掉 $(vk, vi)$ ，得到的生成树权值一定不大于最小生成树，因此选择这条边为最优边。 12345678910111213141516171819202122232425262728int h[N], e[M], w[M], ne[M], idx; // 邻接表存图bool st[N]; // st(x) 表示x点已经加入生成树中int dist[N]; // dist(x) 表示x点距离已经生成的树的最小距离int prim () // 返回最小生成树的权值{ int ret = 0; memset(d, 0x3f, sizeof d); d[1] = 0; // 初始化从1开始，最开始生成树上的V和E都为空 for (int i = 0; i &lt; n; i ++ ) // 要加入n个点，迭代n次，每次放进一个点 { // 找出距离当前生成树最近的点 int t = -1; for (int k = 1; k &lt;= n; k ++ ) if (!st[k] &amp;&amp; (t == -1 || dist[k] &lt; dist[t])) t = k; // 把选择的点加入生成树中 st[t] = true; ret += dist[t]; // 由于加入了一个点，那么其他点也可以通过连接这个点到达生成树，更新dist for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; dist[j] = min(dist[j], w[i]); } } return ret; // 返回最小生成树的权值} 有没有觉得Prim算法和Dijkstra算法雷同？没错，它们都是根据同样的贪心思想，唯一的区别仅仅在于更新的时候。 Prim算法复杂度：根据上述代码，复杂度为 $O(n^2 + 2E)$ ，由于图上每个点至多被更新 $1$ 次，所以图的所有边至多被更新 $2$ 次。 与Dijsktra算法一样，Prim算法可以使用二叉堆优化，复杂度降到 $O((n + 2E)logn)$ 。 Kruskal 算法如果说Prim算法是小树长成大树的过程，那么Kruskal算法就是拼图的过程。 Prim算法基于点来扩大树，而Kruskal基于边来扩大，具体来说，该算法的过程如下： 将图 $G(V, E)$ 的所有边按权值进行非递减排序。 初始化每个点都为单独的连通分量。（因为此时我们还没有选择边作为最小生成树的一部分） 从后往前检查所有边$(u, v)$ 。 $u$ 和 $v$ 在同一个连通分量里，那么加入 $(u, v)$ 会产生环，因此不能选择。 $u$ 和 $v$ 不在一个连通分量里，那么加入 $(u, v)$ 一定是最优的。如果不加入，形成生成树 $T$ ，把 $(u, v)$ 加入 $T$ 中，会形成环，环中包含 $(u, v)$ 和另外一条权值不小于 $(u, v)$ 的边，我们把这条边用 $(u, v)$ 替换，不会使结果变差，因此 $(u, v)$ 是最优的选择。 因为会考虑所有边，因此一定能构成一颗完整的最小生成树（除非原图不连通）。 在Kruskal算法中，最关键的地方在于“连通”分量的查询和合并，需要知道两个点是否在一个连通分量中，以及如果不是在一个连通分量，需要将其合并，我们可以使用并查集来支持此操作。 123456789101112131415161718192021222324252627282930struct Edge { int u, v, d; // 表示边两端的点以及边权 bool operator &lt; (const Edge &amp; rhs) const { // 重载小于号，支持比较 return d &lt; rhs.d; }}int p[N];Edge edges[M];int n, m;int find (int x) { return p[x] == x ? x : p[x] = find(p[x]); }int kruskal (){ for (int i = 1; i &lt;= n; i ++ ) p[i] = i; sort(edges + 1, edges + m + 1); // 假设边集从1开始存储 int ret = 0, cnt = 0; // cnt表示目前已经选择了多少条边（生成树只需要n-1条边） for (int i = 1; i &lt;= m &amp;&amp; cnt &lt; n - 1; i ++ ) { int u = edges[i].u, v = edges[i].v, d = edges[i].d; u = find(u), v = find(v); if (u == v) continue; ++ cnt, res += d, p[u] = v; } if (cnt != n - 1) return -1; // 原图不连通，没有生成树，何谈最小 return ret;}","categories":[{"name":"图论","slug":"图论","permalink":"https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"生成树","slug":"生成树","permalink":"https://horb7.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"Edu Codeforces Round 121","slug":"Edu-Codeforces-Round-121","date":"2022-02-16T14:54:28.238Z","updated":"2022-01-17T03:11:12.000Z","comments":true,"path":"2022/02/16/Edu-Codeforces-Round-121/","link":"","permalink":"https://horb7.github.io/2022/02/16/Edu-Codeforces-Round-121/","excerpt":"","text":"Edu Codeforces Round 121C. Monsters And Spells题意有 $n$ 只怪物需要被消灭，第 $i$ 只怪物在 $k_i$ 秒出现，有 $h_i$ 点生命值 ，必须在怪物出现的那一秒消灭他。 Monocarp 每秒可以使用一次法咒，可以选择法咒伤害为 $x + 1$ 或 $1$ ，$x$ 为上一秒使用法咒造成的伤害。 使用伤害为 $x$ 的法咒，会消耗 $x$ 点法力值。 问Monocarp至少需要消耗多少法力值才能消灭 $n$ 只怪物。 分析对于第 $i$ 只怪物，需要使用法咒的区间为 $[k_i - h_i + 1, k_i]$ 。也就是至少要从 $k_i - h_i + 1$ 位置开始使用法咒。 这个区间可能会有重复，比如两只怪物的区间为 $[l_1, r_1]$ 和 $[l_2, r_2]$ 。其中 $l_1 \\le l_2 \\le r_1$ 。 那么对于区间 $[l_2, r_2]$ 的怪物，我们需要从 $l_1$ 开始使用法咒，否则不能消灭第一只怪物。 也就是说消灭这两只怪物的区间为两个区间的合并，即 $[l_1, r_2]$ 。 推广到所有怪物，只需要把他们的区间合并即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i++)#define forr(x, s) for (auto x : s)#define all(a) begin(a), end(a)#define pb emplace_backusing namespace std;using T = pair&lt;int, int&gt;;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; k(n), h(n); forr(&amp;x, k) cin &gt;&gt; x; forr(&amp;x, h) cin &gt;&gt; x; vector&lt;T&gt; v, f; // v存储所有怪物的区间，f存储合并后的区间 rep(i, 0, n-1) v.pb(k[i] - h[i] + 1, k[i]); sort(all(v)); int ret = 0; // 合并区间 for (auto &amp; [x, y] : v) { if (f.empty() || f.back().second &lt; x) f.pb(x, y); else f.back().second = max(f.back().second, y); } for (auto &amp; [x, y] : f) { int cost = y - x + 1; ret += (1 + cost) * cost / 2; } cout &lt;&lt; ret &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} D. Martial Arts Tournament题意有 $n$ 个参赛选手，第 $i$ 个选手体重为 $a_i$ ，现在要根据选手的体重分为三个赛区，轻量、中量、重量区。 选择两个标准 $x, y$ ，所有严格小于 $x$ 重量的选手在轻量赛区，所有不小于 $y$ 重量的选手在重量赛区。 现在要使三个赛区的选手数量为 $2$ 的幂，请问至少需要加多少选手？ 分析前缀和思想，令 $f(x)$ 表示轻量赛区需要 $x$ 个人，实际上有多少人(因为间断点左右不能重量相同) 。同理 $g(x)$ 表示重量赛区需要 $x$ 个人，实际上有多少人。 枚举 $f(x)$ 和 $g(y)$ 中的 $x$ 和 $y$ 都为 $2$ 的幂次的情况，求出中量赛区需要多少人，加起来就是总共需要的人数，取最小值即可。 Code12345678910111213141516171819202122232425262728293031323334/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i++)#define per(i, x, y) for (int i = x; i &gt;= y; i--)using namespace std;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n+1), f(n+1), g(n+1); rep(i, 1, n) { int x; cin &gt;&gt; x; ++ a[x]; } int s = 0; // rep(i, 1, n) 枚举重量，s维护前缀和(人数) // 第二个循环rep(j, s, s + a[i] - 1) 其实是枚举中间的间断点，此时应该还是s，不能累加上自己，因为间断点左右不能重量相同。 rep(i, 1, n) { rep(j, s, s + a[i] - 1) f[j] = s; s += a[i]; } s = 0; per(i, n, 1) { rep(j, s, s + a[i] - 1) g[j] = s; s += a[i]; } int ret = 1e9; for (int a = 1; a &lt;= n; a &lt;&lt;= 1) for (int b = 1; b &lt;= n; b &lt;&lt;= 1) { int x = f[a], y = g[b]; int ans = 1; while(ans &lt; n - x - y) ans &lt;&lt;= 1; ret = min(ret, ans + a + b); } cout &lt;&lt; ret - n &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Linux下使用C++连接MySql","slug":"Linux下MySql的使用","date":"2022-02-16T14:54:28.238Z","updated":"2022-01-07T04:36:20.000Z","comments":true,"path":"2022/02/16/Linux下MySql的使用/","link":"","permalink":"https://horb7.github.io/2022/02/16/Linux%E4%B8%8BMySql%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装MySql在Ubuntu 20.04环境下，我们已经安装好MySql，如果想要用C++连接MySql，我们还需要mysql-client，完整的需要以下几项： sudo apt-get install mysql-server sudo apt-get install apache2 sudo apt-get install libmysqlclient-dev 安装后，检查/usr/include/mysql中是否存在mysql.h文件： 如果存在，说明安装成功，可以用C++连接MySql数据库了。 使用C++连接MySql相关API介绍在cpp文件中，我们需要引入mysql.h头文件来使用MySql相关API。 这里列出常用的函数。（注：MYSQL为结构体，存储mysql操作的处理） 函数 说明 MYSQL * mysql_init(MYSQL * mysql) 初始化MYSQL结构体，参数为NULL指针则分配+初始化 MYSQL * mysql_real_connect(MYSQL * mysql, const char * host, const char * user, const char * passwd, const char * db, unsigned int port, const char * unix_socket, unsigned long client_flag) 把mysql结构体连接到具体的服务器的某个用户上，返回非0表示连接成功 int mysql_query(MYSQL * mysql, const char * stmt_str) 执行SQL查询，若成功查询返回0，否则返回1 MYSQL_RES * mysql_store_result(MYSQL * mysql) 存储上次查询的所有结果 int mysql_next_result(MYSQL * mysql) 查看是否存在下一个结果集（一次查询可能返回多个表）并把指针放到下一个表便于查询。返回0表示存在，非0表示不存在。 unsigned int mysql_num_fields(MYSQL_RES * result) 返回结果集的列数 unsigned int mysql_num_rows(MYSQL_RES * result) 返回结果集的行数 MYSQL_ROW mysql_fetch_row(MYSQL_RES * result) 从结果集中返回下一行数据，NULL表示结束 MYSQL_FIELD mysql_fetch_field(MYSQL_RES * result) 从结果集中返回下一列数据，NULL表示结束 char * mysql_error(MYSQL * mysql) 返回上一次的报错信息 void mysql_free_result(MYSQL_RES * result) 释放结果集所占的内存 void mysql_close(MYSQL * mysql) 关闭结构体对数据库的连接 C++连接MqSql基本流程 使用mysql_init()初始化结构体 使用mysql_real_connect()建立结构体与对应数据库的连接 使用mysql_query()进行相关的数据操作 输出查询： 使用res = mysql_store_result(mysql)来获取查询的结果集 使用mysql_num_rows(res)获取行数，mysql_num_fields(res)获取列数 不断通过mysql_fetch_row(res)来获取每一行的查询数据，直到结束 释放结果集所占的内存mysql_free_result(res) mysql_close(mysql)关闭结构体与数据库的连接 注意点：由于我们使用的不是C++原有的库，所以在编译的时候要指明额外使用的库 编译命令：g++ test.cpp -o main -I/usr/include/mysql -lmysqlclient 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;mysql.h&gt;#include &lt;ctime&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define HOST \"*******\" // 此处为你的服务器ip地址，如果为本地则输入localhost#define USERNAME \"*****\" // 服务器用户名#define PASSWORD \"******\" // 用户名对应的密码#define DATABASE \"*******\" // 需要使用的数据库名字using namespace std;void operator_sql(const char * sql);void query_sql(const char * sql);int main (int argc, char * argv[]){ const char * sql_operator = \"insert into student(class, sid, sname) values('cs2001', 111111111, 'i_dont_know')\"; const char * sql_query = \"call attend_exam(1)\"; printf(\"sql_operator: %s\\n\", sql_operator); printf(\"sql_query: %s\\n\", sql_query); // operator_sql(sql_operator); query_sql(sql_query); return 0;}void operator_sql(const char * sql){ MYSQL conn; int res; mysql_init(&amp;conn); if (mysql_real_connect(&amp;conn, HOST, USERNAME, PASSWORD, DATABASE, 0, NULL, CLIENT_FOUND_ROWS)) { printf(\"connect success!\\n\"); res = mysql_query(&amp;conn, sql); if (res) printf(\"%s\\n\", mysql_error(&amp;conn)); // 如果执行不成功，输出报错信息 else printf(\"operator success!\\n\"); } mysql_close(&amp;conn);}void query_sql(const char * sql){ MYSQL my_connection; // 数据库连接 int res; // 执行sql语句后的返回标志 MYSQL_RES * res_ptr; // 指向查询结果的指针 MYSQL_FIELD * field; // 字段结构指针 MYSQL_ROW result_row; // 按行返回的查询信息 int row, column; // 查询返回的行数和列数 mysql_init(&amp;my_connection); // 初始化mysql连接my_connection if (mysql_real_connect(&amp;my_connection, HOST, USERNAME, PASSWORD, DATABASE, 0, NULL, CLIENT_FOUND_ROWS)) { printf(\"connectio success!\\n\"); // 设置查询编码为utf8 mysql_query(&amp;my_connection, \"set names utf8\"); res = mysql_query(&amp;my_connection, sql); // 查询，返回0代表成功 if (res) printf(\"Error: mysql_query!\\n\"); else { // 执行成功 printf(\"query some row\\n\"); int tables = 0; // 把返回信息的所有表都输出 do { printf(\"\\n\"); res_ptr = mysql_store_result(&amp;my_connection); if (res_ptr) // 结果不为空，说明有结果 { column = mysql_num_fields(res_ptr); // 此表的列数 row = mysql_num_rows(res_ptr); // 此表的行数 printf(\"查询到第 %d 行, 此为第 %d 张表\\n\", row + 1, ++ tables); // 输出每一列的属性 for (int i = 0; field = mysql_fetch_field(res_ptr); i ++ ) printf(\"%s\\t\", field-&gt;name); printf(\"\\n\"); while(result_row = mysql_fetch_row(res_ptr)) { for (int j = 0; j &lt; column; j ++ ) printf(\"%s\\t\", result_row[j]); printf(\"\\n\"); } } else mysql_free_result(res_ptr); // 如果以及查询完毕，则释放查询结果占用的内存 } while(!mysql_next_result(&amp;my_connection)); // 返回0则代表还有剩余的结果 } mysql_close(&amp;my_connection); // 查询结束，关闭结构体与数据库的连接 }}","categories":[{"name":"数据库","slug":"数据库","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://horb7.github.io/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"https://horb7.github.io/tags/MySql/"}]},{"title":"MySql安装与简单配置","slug":"MySql的安装和简单配置","date":"2022-02-16T14:54:28.238Z","updated":"2022-01-07T11:58:48.000Z","comments":true,"path":"2022/02/16/MySql的安装和简单配置/","link":"","permalink":"https://horb7.github.io/2022/02/16/MySql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Mysql 安装和配置纯小白开始用 mysql ，记录一下安装与配置的环节，便于以后查看。下文的 mysql 版本均为 $8.0$。 Linux版本为Ubuntu 20.04。 安装在Ubuntu 20.04上，默认情况只有最新版本的mysql包含在apt存储库里，所以要先更新服务器的软件包索引： sudo apt update 接下来安装mysql默认包。 sudo apt install mysql-server 安装完mysql后，它默认是启动的。 配置mysql初始化数据目录mysql安装完毕后，数据目录必须初始化，使用 sudo mysql_secure_installation 来自动初始化数据目录。 之后需要对mysql安装的安全选项做一些修改。 是否安装验证密码插件，用来测试mysql密码的强度。 为mysql root用户设置密码，然后确认。 之后的提示可以按 $enter$ 使用默认值。 修改用户身份验证和使用权限在 mysql8.0 中，mysql root 用户设置为使用默认的 auth_socket 插件进行身份验证，而不是密码。如果要使用外部程序来访问用户，操作会变得繁琐。 我们可以把身份验证修改为使用密码验证。即把 $auth\\_socket$ 变成 $mysql \\_ native \\_ password$ 模式。 首先进入到mysql里，sudo mysql 接下来我们可以查看mysql用户的账号使用的身份验证方式。 SELECT user, plugin, host FROM mysql.user; 由于我这里已经设置了，所以是 $mysql \\_ native \\_ password$ 模式。 我们可以使用 $ALTER \\ \\ USER$ 命令修改root用户。注意要把 $password$ 设置为选择的密码规范（满足一定强度）。 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password by 'password'; ，这里$password$ 填入你需要更改的密码。 然后需要使用 FLUSH PRIVILEGES; 来使服务器重新加载授权表并使新更改生效。 之后我们可以再次使用 SELECT user, plugin, host FROM mysql.user; 来验证是否修改了root 用户的登陆模式。 注意，如果使用了密码登录，我们可以使用 mysql -u root -p 这样的方式来访问mysql root用户。 如何更改密码规范？在我们设置密码的时候可能会出现 “mysql: Your password does not satisfy the current policy requirements” 这样的错误，这是因为密码规范比较高，而你设置的密码太简单。 如果要设置简单一点的密码，我们需要更改密码规范： 使用 show variables like 'validate_password%' 来查看当前的密码规范。 $policy$ 表示当前密码规范强度（有 $LOW$, $MEDIUM$, $HIGH$ 三种强度）。 $length$ 表示密码至少需要多少长度。 我们可以对这两个属性进行设置： set global validate_password.policy=0; set global validate_password.length=1; 接下来我们再次使用 $ALTER \\ \\ USER$ 命令即可更改用户密码。 修改用户或添加权限查看用户如果要查看用户比较少的属性，可以直接使用 use mysql; SELECT user, host FROM mysql.user 来查询。 创建新用户CREATE USER 'user_name'@'host' IDENTIFIED BY 'password' 其中： user_name 是你创建出来的用户的用户名。 host 表示这个新创建的用户登录模式，$localhost$ 表示只能从本服务器登录，$\\%$ 表示可以从远程登录。 password 为新用户的密码，可以不填。 授权用户GRANT privileges ON databasename.tablename TO 'username'@'host' 查看用户权限：SHOW GRANTS FOR USER%host 其中： privileges 表示赋予的权利，如 select，update，insert，delete等，如果要赋予全部权力，可以使用ALL。 databasename.tablename 表示某个数据库的某个表，如果可以对任意数据库的任意表做操作，可以使用 *.* 。 username@host 表示某一个用户。 撤销用户权限REVOKE privileges ON dataname.tablename FROM 'username'@'host' 撤销操作的注意点撤销语句必须和之前的授权语句一模一样，否则无法撤销权限。 删除用户DROP USER 'username'@'host' 修改用户RENAME USER 'name1'@'host1' TO 'name2'@'host2'","categories":[{"name":"数据库","slug":"数据库","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://horb7.github.io/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"https://horb7.github.io/tags/MySql/"}]},{"title":"NOIP2008传球游戏","slug":"NOIP2008传球游戏","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-19T15:09:44.000Z","comments":true,"path":"2022/02/16/NOIP2008传球游戏/","link":"","permalink":"https://horb7.github.io/2022/02/16/NOIP2008%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F/","excerpt":"","text":"NOIP2008 传球游戏题意有 $n$ 个同学围成一个圆圈，有一个球在某一个小蛮手中，每次传球可以向左右传球，问有多少种方案能够使得进行 $m$ 次传球后依然在小蛮手中。 分析每一轮，拿到球的同学都可以向左右传球。 设 $f(i, j)$ 表示第 $i$ 次传球后小球在 $j$ 同学手中的方案数量。注意环形。 Code12345678910111213141516#include &lt;iostream&gt;using namespace std;const int N = 35;int f[N][N]; // f(i, j)表示穿了i次传到j手里的方案数int main (){ int n, m; cin &gt;&gt; n &gt;&gt; m; f[0][1] = 1; for (int i = 1; i &lt;= m; i ++ ) for (int j = 1; j &lt;= n; j ++ ) f[i][j] = f[i-1][j==1?n:j-1] + f[i-1][j==n?1:j+1]; cout &lt;&lt; f[m][1] &lt;&lt; endl; return 0;}","categories":[{"name":"DP","slug":"DP","permalink":"https://horb7.github.io/categories/DP/"}],"tags":[{"name":"环形DP","slug":"环形DP","permalink":"https://horb7.github.io/tags/%E7%8E%AF%E5%BD%A2DP/"}]},{"title":"zkw树","slug":"zkw树","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-31T02:58:40.000Z","comments":true,"path":"2022/02/16/zkw树/","link":"","permalink":"https://horb7.github.io/2022/02/16/zkw%E6%A0%91/","excerpt":"","text":"zkw树zkw树，又称非递归线段树，它是一种采用自底向上构造的线段树，由于没有递归且全程使用位运算，因此它是一种代码短，常数小且容易调试的线段树写法。 为了方便调写，我们令原序列 $a$ 下标为 $[0, n)$ ，而zkw树下标（根节点）从 $1$ 开始。 zkw树原理zkw树本质是把序列化成一颗满二叉树，然后就可以采用二叉树的性质来自底向上构造线段树。比如当序列长度为 $8$ 时： 满二叉树的叶子结点编号十分有规律，假设序列长度为 $n$ ，第 $i$ 个叶子结点代表的就是 $a[i]$ ，且叶子编号为 $x + n$ 。不仅如此，满二叉树还有如下性质： 整棵树一共有 $2 \\times n - 1$ 个节点，其中最后一层有 $n$ 个节点，也就是我们的原序列。 若某节点编号为 $p$ ，那么它的父节点为 $p / 2$ ，左孩子为 $p \\times 2$ ，右孩子为 $p \\times 2 + 1$ 。 所有的兄弟节点 $p, q$ 满足 $p \\bigoplus q == 1$ 。（二进制下仅有最后一位不同） 除根节点外，编号为偶数的节点都是左兄弟，编号为奇数的都是右孩子。 根据性质 $1$ ，要构造这样一颗树，需要序列长度 $n$ 为二的整数次幂，如果不足，在后面补 $0$ 即可。 设 $N$ 为满足 $N$ 为二的整数次幂且 $N \\ge n$ 的最小整数。 那么，我们zkw树数组中，$[N, N + n - 1]$ 便是原序列（叶子节点）。 于是，我们有了十分简单的建树代码（假设目前需要维护区间和）： 12345void build (){ for (int i = 0; i &lt; n; i ++ ) t[i + N] = a[i]; // 先构造叶子节点 for (int i = N - 1; i; -- i) t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1]; // 自下而上构造} 对于单点修改，我们可以直接更新，然后往上更新父节点。 1234void update(int x, int v){ for (x += N; x; x &gt;&gt;= 1) tree[x] += v;} 是不是觉得很像堆？没错，zkw和堆本质都是二叉树。 对于区间查询，我们把 $[l, r]$ 的查询变为 $(l-1, r+1)$ 的查询，然后从下往上缩小范围。 1234567891011121314int query(int l, int r){ int ans = 0; // 结束条件是l,r为兄弟，也就是中间没有查询的元素 for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) { /* 每次上移的过程，其实是不断把端点和它的兄弟排出区间的过程 因此如果它的兄弟为区间查询的值，应该加上去 */ // 如果左端点是左儿子或右端点是右儿子，那么它的兄弟应该是答案的一部分。 if (~l &amp; 1) ans += t[l ^ 1]; // 左端点是左儿子 if (r &amp; 1) ans += t[r ^ 1]; // 右端点是右儿子 } return ans;} 对于 区间修改 ，因为没有使用递归，因此直接下传懒标记是比较麻烦的，因为树的修改是自底向上的。 比较好的方式是对标记进行永久化存储。 123456789101112void update (int l, int r, int d){ int len = 1, cntl = 0, cntr = 0; // len表示结点表示的区间长度，cntl,cntr表示左右两边实际修改的长度 for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { t[l] += cntl * d, t[r] += cntr * d; // mark(i) 表示以i为根的树，除了根节点，每个节点都需要加上 mark(i) if (~l &amp; 1) t[l ^ 1] += d * len, mark[l ^ 1] += d, cntl += len; if (r &amp; 1) t[r ^ 1] += d * len, mark[r ^ 1] += d, cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) t[l] += cntl * d, t[r] += cntr * d;} 在有懒标记的情况下，区间查询也要考虑懒标记。除了端点的兄弟需要考虑，在路径上遇到的标记也对答案有贡献，贡献依赖于实际查询的长度。 123456789101112int query (int l, int r){ int ans = 0, len = 1, cntl = 0, cntr = 0; for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { ans += cntl * mark[l] + cntr * mark[r]; if (~l &amp; 1) ans += t[l ^ 1], cntl += len; if (r &amp; 1) ans += t[r ^ 1], cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) ans += cntl * mark[l] + cntr * mark[r]; return ans;} 例题例题 线段树模板 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int M = 200010;int n, m, N;int a[M], t[M &lt;&lt; 1], mark[M &lt;&lt; 1];void build (){ for (int i = 0; i &lt; n; i ++ ) t[i + N] = a[i]; for (int i = N - 1; i; -- i) t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1];}void update (int l, int r, int d){ int len = 1, cntl = 0, cntr = 0; // len表示结点表示的区间长度，cntl,cntr表示左右两边实际修改的长度 for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { t[l] += cntl * d, t[r] += cntr * d; if (~l &amp; 1) t[l ^ 1] += d * len, mark[l ^ 1] += d, cntl += len; if (r &amp; 1) t[r ^ 1] += d * len, mark[r ^ 1] += d, cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) t[l] += cntl * d, t[r] += cntr * d;}int query (int l, int r){ int ans = 0, len = 1, cntl = 0, cntr = 0; for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1, len &lt;&lt;= 1) { ans += cntl * mark[l] + cntr * mark[r]; if (~l &amp; 1) ans += t[l ^ 1], cntl += len; if (r &amp; 1) ans += t[r ^ 1], cntr += len; } for (; l; l &gt;&gt;= 1, r &gt;&gt;= 1) ans += cntl * mark[l] + cntr * mark[r]; return ans;}signed main (){ cin &gt;&gt; n &gt;&gt; m; for (N = 1; N &lt; n; N &lt;&lt;= 1); for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; build(); int op, l, r, d; while(m -- , cin &gt;&gt; op &gt;&gt; l &gt;&gt; r) { -- l, -- r; if (op == 1) cin &gt;&gt; d, update(l, r, d); else cout &lt;&lt; query(l, r) &lt;&lt; endl; } return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://horb7.github.io/tags/%E6%A0%91/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-19T08:17:12.000Z","comments":true,"path":"2022/02/16/hello-world/","link":"","permalink":"https://horb7.github.io/2022/02/16/hello-world/","excerpt":"","text":"花了一整天总算是弄好了…","categories":[],"tags":[]},{"title":"乘法逆元","slug":"乘法逆元","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-21T16:02:22.000Z","comments":true,"path":"2022/02/16/乘法逆元/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/","excerpt":"","text":"乘法逆元 乘法逆元可以求出 $ \\displaystyle {\\frac {a}{b}} $ 在取模 $P$ 的意义下的数值。 逆元 若 $a \\times x \\equiv 1 \\pmod q$ ，且 $a$ 与 $b$ 互质，那么我们定义： $x$ 为 $a$ 的逆元，记作 $a^{-1}$ ，也可以称 $x$ 为 $a$ 在 $ \\pmod p$ 意义下的倒数。 对于 $\\displaystyle {\\frac {a} {b}} \\pmod p$ ，它的值为 $a \\times b^{-1} \\ \\ mod \\ \\ p$ 。 求解逆元快速幂 费马小定理 若 $p$ 为素数，$a$ 为正整数，且 $a、p$ 互质。则有 $a^{p-1} \\equiv 1 \\pmod p$ 。 若 $x$ 为 $a$ 的逆元，则: \\begin{aligned} a \\times x &\\equiv 1 \\pmod p \\\\ a \\times x &\\equiv a^{p-1} \\pmod p \\\\ x &\\equiv a^{p-2} \\pmod p \\end{aligned}所以我们可以使用快速幂求出 $a^{p-2} \\pmod p$ 的值，即为 $a$ 的逆元。 1234567891011int qmi (int a, int k, int mod){ int res = 1; while (k) { if (k &amp; 1) res = 1ll * a * res % mod; a = 1ll * a * a % mod; k &gt;&gt;= 1; } return res;} 拓展欧几里得在模数不为质数时，不能使用费马小定理，但是可以使用拓展欧几里得求逆元，参考此处。 线性算法线性算法可以求出连续数字 $1 \\sim n$ 对于 $\\pmod p$ 的逆元。 首先有 $1^{-1} \\equiv 1 \\pmod p$。 假设现在要求 $i$ 的逆元，显然 $p = \\lfloor{\\dfrac p i}\\rfloor \\times i + p \\% i$ 。 那么，在模 $p$ 的情况下： p = \\lfloor{\\dfrac p i}\\rfloor \\times i + p \\% i \\equiv 0 \\pmod p \\begin{equation} \\begin{split} \\lfloor{\\dfrac p i}\\rfloor \\times i &\\equiv -(p \\% i) \\pmod p \\\\ \\lfloor{\\dfrac p i}\\rfloor \\times -(p \\% i)^{-1} &\\equiv i^{-1} \\pmod p \\\\ i^{-1} &\\equiv -\\lfloor{\\dfrac p i}\\rfloor \\times (p \\% i)^{-1} \\pmod p \\\\ \\end{split} \\end{equation}注意到 $p \\% i$ 一定是小于 $i$ 的，这样我们就可以从前面推出后面了。 时间复杂度：$ O(n) $ 123inv[1] = 1;for (int i = 2; i &lt;= n; i ++ ) inv[i] = (p - p / i) * inv[p % i] % p; // 取模意义下 -a = p - a 阶乘逆元根据阶乘递推关系： \\begin{split} inv[i+1] &= \\displaystyle {\\frac{1}{(i+1)!}} \\\\ inv[i+1] \\times (i + 1) &= \\displaystyle {\\frac{1}{i!}} \\end{split}所以我们也可以先求出 $n!$ 的逆元，再逆推，就可以得到 $1! \\sim n!$ 的逆元。 递推式： $inv[i+1] \\times (i+1) = inv[i]$ 最后可以使用 $\\displaystyle {\\frac{1}{i!}} \\times (i-1)! = \\frac{1}{i}$ 。 时间复杂度为 $O(n)$ 。","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"}]},{"title":"对顶堆","slug":"对顶堆","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-26T15:45:04.000Z","comments":true,"path":"2022/02/16/对顶堆/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%AF%B9%E9%A1%B6%E5%A0%86/","excerpt":"","text":"对顶堆什么是对顶堆对顶堆是一种数据结构，它可以动态地维护某一个临界值，如前 $i$ 个数字的中位数、 前 $i$ 个数字中第 $k$ 小的值等。 对顶堆一般适用一个大根堆维护前面某个状态，小根堆维护后面不同的状态（如大于/小于中位数等）。 我们只需要调整两个堆的元素数量，即可 $O(1)$ 地取出需要维护的值。 例题动态中位数题意每次插入一个数字，当序列中数字数量为奇数时，输出序列的中位数。 分析假设当前序列长度为 $n$ 。 开一个大根堆来维护当前序列中前 $[1, n / 2]$ 小的元素，再开一个小根堆来维护当前序列前 $[n/2+1, n]$ 小的元素。 那么我们只需要维护大根堆的数量为 $n/2$ ，即可知道当前序列的中位数为小根堆的堆顶。 注意大根堆的所有元素一定比小根堆任意元素小。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main (){ int T; cin &gt;&gt; T; while( T -- ) { int id, n, cnt = 0; cin &gt;&gt; id &gt;&gt; n; cout &lt;&lt; id &lt;&lt; ' ' &lt;&lt; (n + 1) / 2 &lt;&lt; endl; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; lt; // 小根堆 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; gt; // 大根堆 for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) { if (gt.size() &amp;&amp; x &lt;= gt.top()) gt.push(x); else lt.push(x); if (i &amp; 1) { while(gt.size() &lt; i / 2) gt.push(lt.top()), lt.pop(); while(gt.size() &gt; i / 2) lt.push(gt.top()), gt.pop(); cout &lt;&lt; lt.top() &lt;&lt; \" \\n\"[((cnt += 1) %= 10) == 0]; } } if (cnt) cout &lt;&lt; endl; } return 0;} 黑匣子题意有两种操作： 向序列中插入一个数字。 求出序列中第 $k$ 小的数字。 $k$ 初始为 $0$ ，每次求第 $k$ 小值都要把 $k$ 加一。 分析对顶堆，大根堆维护前 $k-1$ 小的数字，小根堆维护后面的数字。这样小根堆的堆顶就是第 $k$ 小的数字。 每次插入操作都至多交换一次堆元素，我们可以放到查询的时候再维护堆的数字，次数与每次操作维护是一样的。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;int a[N], q[N], k;void solve (){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i ++ ) cin &gt;&gt; q[i]; int pos = 1; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pre; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; post; for (int i = 1; i &lt;= n; i ++ ) { if (post.empty() || a[i] &lt; post.top()) pre.push(a[i]); else post.push(a[i]); // 维护post堆顶为k小数 while (q[pos] == i) { ++ k; while(pre.size() &lt; k) pre.push(post.top()), post.pop(); while(pre.size() &gt;= k) post.push(pre.top()), pre.pop(); cout &lt;&lt; post.top() &lt;&lt; endl; pos ++ ; } }}signed main (){ cout.tie(0)-&gt;sync_with_stdio(false); // int _; for (cin &gt;&gt; _; _ --; ) solve(); solve(); return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://horb7.github.io/tags/%E5%A0%86/"}]},{"title":"并查集入门","slug":"并查集","date":"2022-02-16T14:54:28.238Z","updated":"2022-02-18T02:08:49.034Z","comments":true,"path":"2022/02/16/并查集/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集介绍 并查集是一种树形的数据结构，我们可以使用它来进行集合上的合并与查询等问题。具体来说，它支持两种操作： 合并：将两个集合合并成一个集合。 查询：确定某个元素处于哪个集合。 如图，$\\{3, 1, 2, 4, 0, 10\\}$ 表示一个集合，$\\{5, 7, 8, 11\\}$ 表示另一组集合。 可以看出并查集是多叉树结构，我们用根节点来表示这个根节点所在的集合(即根节点作为集合的”代表元素”)。 基础并查集初始化 在我们初始创建数据的时候，由于没有任何操作，所以每个元素都是一个独立的集合，显然，每个元素都是本身集合的根节点。 1for (int i = 0; i &lt; n; i ++ ) p[i] = i; // p(i) 表示i的父节点 查询 假设我们现在要查询元素 $0$ 的父节点，该怎么做呢？ 很简单，由于根节点的父节点就是本身（不知道的可以回顾一下初始化过程）。所以我们直接检查 $0$ 的父节点是否为 $0$ 即可。 如果 $0$ 父节点为 $0$ ，说明 $0$ 是所属集合的根节点，返回 $0$ 即可。（因为我们用根节点代表集合） 如果 $0$ 父节点不为 $0$ ，那么我们只需要递归检查它的父节点是否为 $0$ 即可。 我们发现 $0$ 的父节点是 $2$ ，那么我们继续检查 $2$ 是否为根节点($p[2] == 2$) ，不是，则继续检查 $3$ ，此时 $3$ 为根节点，于是返回 $3$ 。 查询的复杂度为被查询元素在树上的深度。 1234int find (int x) // find函数用来返回x所属集合的代表元素(根节点){ return p[x] == x ? x : find(p[x]);} 合并 如图，如何合并 $6$ 所属集合和 $3$ 所属集合？由于我们知道根节点代表整个集合，合并 $6$ 和 $3$ 即意味着它们合并后根节点相同，我们可以任意取一个子集的根节点作为合并后的根节点，比如取 $3$ 后： 我们选择了把 $2$ 作为合并后集合的根节点（代表元素）。 12345void merge (int x, int y){ x = find(x), y = find(y); // x 和 y 为根节点 p[x] = y; // 直接把其中一个集合合并到另外一个集合} 并查集优化路径压缩我们发现，由于每次查询某个元素需要查询 $r$ 次($r$ 为当前元素在树上的深度)，当树的深度很大，且我们要查询的元素在很深的地方，那么查询所需要耗费的时间就很大，有没有办法优化呢？ 答案是肯定的，我们发现，整个集合只有代表元素是’有用’的，其他元素仅能代表它在这个集合中，与它所处的位置没有关系。 于是，我们在每次查询后，就把当前元素的父节点设置为集合的根节点，根节点就是 $find$ 的返回值，所以： 1234int find (int x) // find 函数返回x所属集合代表元素{ return p[x] == x ? x : p[x] = find(p[x]); // 把x的父节点设置为根节点} 按秩合并（启发式合并）上述提到，树的深度会影响查询的速度，那么我们可以在合并的时候，把集合元素较少的合并到集合元素较大的即可。还可以按照集合树的深度与集合的元素数量评估来得到更好的合并方法。 1234567void merge (int x, int y) // 按秩合并需要用到集合内的数量{ x = find(x), y = find(y); if (siz[x] &gt; siz[y]) swap(x, y); siz[y] += siz[x]; p[x] = y;} 按秩合并在竞赛中不常用，一般来说路径压缩就已经够用了。 模板12345678910111213141516171819const int N = 200010;int p[N]; // p(i)表示i的父节点void init (int n){ for (int i = 0; i &lt; n; i ++ ) p[i] = i;}int find (int x){ return p[x] == x ? x : p[x] = find(p[x]);}void merge (int x, int y){ x = find(x), y = find(y); p[x] = y;} 习题模板 并查集 朋友 此题也可以使用维护集合数量的并查集 村村通 超市 贪心+并查集 维护集合数量的并查集有时候，我们只维护元素所属的集合是不够的，我们还需要知道集合内的数量。 只维护一个集合数量，和基础并查集无任何区别，只需要加上一个 $siz$ 数组维护每个集合内的数量即可。 唯一需要变的就是在合并集合时的操作： 123456void merge (int x, int y) // 按秩合并需要用到集合内的数量{ x = find(x), y = find(y); siz[y] += siz[x]; p[x] = y;} 带权并查集当然，维护了数量在某些情况也是不够用的，我们还需要知道集合内各个元素的关系。我们可以使用带权并查集，使用边权来维护当前元素与父节点的某种关系。 即，带权并查集可以维护元素之间的制约关系。 我们以一道经典例题 食物链 为例。 例题 食物链题意动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。 $A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。 现有 $N$ 个动物，以 $1∼N$ 编号。 每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 $X$ 和 $Y$ 是同类。 第二种说法是 2 X Y，表示 $X$ 吃 $Y$。 此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。 当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话； 当前的话表示 $X$ 吃 $X$，就是假话。 你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。 分析给出两个动物，它们有吃、被吃以及同类三种制约关系，而带权并查集可以很好地维护元素间的制约关系。 设 $d[x]$ 表示元素 $x$ 与其父节点的边的边权。 规定： $d[x] \\% 3 = 0$ 表示 $x$ 与父节点 $p[x]$ 是同类。 $d[x] \\% 3= 1$ 表示 $x$ 可以吃父节点 $p[x]$。 $d[x] \\% 3 = 2$ 表示 $x$ 可以被父节点 $p[x]$ 吃。 那么我们判定假话，只需要不满足 $d[x]$ 即可。 简单来说： 判断 $x$ 与 $y$ 为同类，但已经制约了 $x$ 和 $y$ 为异类（吃或被吃）。 判断 $x$ 吃 $y$ ，但已经制约了 $x$ 和 $y$ 是同类或者 $x$ 被 $y$ 吃。 判断 $x$ 被 $y$ 吃，但已经制约了 $x$ 和 $y$ 是同类或者 $x$ 被 $y$ 吃。（题目不会给定） 首先我们肯定要是有路径压缩来优化查询的，在路径压缩后， $x$ 对应的父节点变为集合根节点，因此 $d[x]$ 也需要做变换。 123456789101112131415int find (int x){ if (x != p[x]) { int u = find(p[x]); /* * 注意此时x还没有路径优化，父节点仍然保持原来的父节点 * 此时 x 以上的节点经过路径优化，d[p[x]] 也修改为正确值(x父节点与根节点的关系) * 那么我们只需要根据x与父节点的关系、x父节点与根节点的关系即可传递得到x与根节点的关系，再路径优化即可。 */ d[x] += d[p[x]]; p[x] = u; } return p[x];} 那么现在的问题就是，如何知道一个集合里两个元素的制约关系？ 由于我们求得 $d[x]$ 都是 $x$ 与根节点的关系，那么 $(d[x] - d[y]) \\% 3$ 即为 $x$ 与 $y$ 的制约关系。 如何合并两个关系呢？ 假设判定 $x$ 和 $y$ 的关系的边权表示为 $op$ ，由于在 $find$ 中我们可以求得 $x$ 、 $y$ 分别与其根节点的关系，且现在 $x$ 与 $y$ 的制约关系也知道了，那么根据传递性我们也可以求出两个集合根节点之间的制约关系，合并两个集合时维护好两个根节点的制约关系即可。 假设 $x$ 的根节点为 $px$ ，$y$ 的根节点为 $py$ 。现在要把 $px$ 合并到 $py$ 。 判定 $x$ 与 $y$ 同类 在合并后的集合里，$x$ 与 $y$ 的关系应该为 $(d[x] - d[y]) \\% 3 = 0$ 。由于此时的 $d[x]$ 是合并后的，所以合并前应该为 $d[x] + d[px]$ 。即 $d[x] + d[px] - d[y] = 0$ ，那么 $d[px] = d[y] - d[x]$ 。 判定 $x$ 与 $y$ 不同类 由于题目给定此时判定为 $x$ 吃 $y$ ，所以我们只需要考虑这一种。 在合并后的集合里，$x$ 与 $y$ 的关系用应该是：$d[x] - d[y] = 1$ ，即 $x$ 可以吃根节点（路径压缩后的父节点），且 根节点与 $y$ 同类，依次推类。 同样此时的 $d[x]$ 是合并后的，合并前应该是 $d[x] + d[px]$ ，所以 $d[x] + d[px] - d[y] = 1$ ，即 $d[px] = 1 + d[y] - d[x]$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;const int N = 50010;int n, m;int p[N], d[N];int find (int x) { if (p[x] != x) { int t = find(p[x]); d[x] += d[p[x]]; p[x] = t; } return p[x];}int main () { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i] = i; int res = 0; while (m--) { int t, x, y; scanf(\"%d%d%d\", &amp;t, &amp;x, &amp;y); if (x &gt; n || y &gt; n) res++; // 谎言1：动物编号超出限制 else { int px = find(x), py = find(y); if (t == 1) { if (px == py &amp;&amp; (d[x] - d[y]) % 3) res++; // 谎言2：判定同类，但已经制约x和y是异类 else if (px != py) { // 否则认为是真话，加上此制约关系 p[px] = py; d[px] = d[y] - d[x]; } } else { if (px == py &amp;&amp; (d[x] - d[y] - 1) % 3) res++; // 谎言3：判定x吃y，但已经制约x和y是同类或者x被y吃 else if(px != py) { // 否则认为是真话，加上此制约关系 p[px] = py; d[px] = d[y] + 1 - d[x]; } } } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 习题关押罪犯 也可以使用二分图解决 奇偶游戏 同样也可以使用二分图 拓展域并查集拓展域并查集和带权并查集功能相同，都是对各个元素的不同关系进行制约。由于拓展域需要对同一个元素开多个域，因此空间复杂度较高，除此之外可以完全代替带权并查集。 同样，我们使用 食物链 这个例子来实现拓展域。 对于元素 $x$ ，其他元素 $y$ 和它一共有三种关系： 与 $x$ 是同类。 被 $x$ 吃，即 $x$ 捕食 $y$ 。 吃 $x$ ，即 $x$ 天敌为 $y$ 。 对于元素 $x$ ，我们开三个域来表示这三种关系。由于一共有 $n$ 个动物，我们有一个很好的开域的方式：我们令 $p[x]$ 表示 $x$ 的天敌域， $p[x + n]$ 表示 $x$ 的同类域， $p[x + 2 * n]$ 表示 $x$ 的捕食域 ，那么谎话只有以下两种： 判定 $x$ 与 $y$ 是同类，但是 $x$ 的捕食域或者天敌域存在 $y$ 。 判定 $x$ 吃 $y$ ，但是 $x$ 的同类域或者天敌域存在 $y$ 。 在合并的过程，比如合并 $x$ 和 $y$ 是同类，那么 $x$ 的天敌也同样是 $y$ 的天敌，即也需要合并 $x$ 与 $y$ 的天敌域。捕食域同理。 通过上述分析，我们可以很简洁地写出如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;functional&gt;using namespace std;const int N = 200010;int p[N]; // 拆点，每个点有三个域，天敌域，同类域，捕食域// 每个集合里的元素都是一类int main (){ function&lt;int(int)&gt; f = [&amp;](int x) { return x == p[x] ? x : p[x] = f(p[x]); } ; function&lt;void(int, int)&gt; mg = [&amp;](int x, int y) { p[f(x)] = f(y); }; int n, k, d, x, y, ret = 0; cin &gt;&gt; n &gt;&gt; k; iota(p + 1, p + 3 * n + 1, 1); while(k -- &amp;&amp; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y) { if (x &gt; n || y &gt; n) { ret ++ ; continue; } // 假话2 if (d == 2 &amp;&amp; x == y) { ret ++ ; continue; } // 假话3 // 假话1，产生冲突 if (d == 1) { // 如果判定x和y是同类，但是x的天敌域或者捕食域有y，一定是假话 if (f(x) == f(y + n) || f(x + 2 * n) == f(y + n)) { ret ++ ; continue; } // 否则这是一句真话，记录一下 mg(x + n, y + n); mg(x, y); // x的天敌和y的天敌是同一类 mg(x + 2 * n, y + 2 * n); // x的捕食域和y的捕食域也是一类 } else { // 如果判定x捕食y，但是x同类域或天敌域有y，假话 if (f(x + n) == f(y + n) || f(x) == f(y + n)) { ret ++ ; continue; } mg(x + 2 * n, y + n); mg(x + n, y); // y的天敌域加上x的同类域 mg(x, y + 2 * n); // x的天敌域加上y的捕食域 } } cout &lt;&lt; ret &lt;&lt; endl; return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://horb7.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"并查集拓展域","slug":"并查集拓展域","date":"2022-02-16T14:54:28.238Z","updated":"2021-12-19T15:05:46.000Z","comments":true,"path":"2022/02/16/并查集拓展域/","link":"","permalink":"https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95%E5%9F%9F/","excerpt":"","text":"并查集拓展域 并查集是用来维护元素之间的制约关系，并且在更新时可以传递关系的一种数据结构，但有时候只靠是否在集合内不足以表示复杂的关系，因此引入了拓展域的关系. 例题 食物链1. 带权并查集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;functional&gt;using namespace std;const int N = 50010;int p[N], d[N];/* d(i) 表示 i 与父结点的距离。 1 -&gt; i可以吃父结点 2 -&gt; i可以被父结点吃 0 -&gt; i与父结点同类*/int main (){ function&lt;int(int)&gt; f = [&amp;](int x) { if (x != p[x]) { // 维护d数组 int u = f(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } ; // mg 对于同类和不同类的情况不同 int n, k, od, x, y, ret = 0; cin &gt;&gt; n &gt;&gt; k; iota(p+1, p+n+1, 1); while(k -- &amp;&amp; cin &gt;&gt; od &gt;&gt; x &gt;&gt; y) { if (x &gt; n || y &gt; n) { ++ ret; continue; } int px = f(x), py = f(y); if (od == 1) { if (px == py &amp;&amp; (d[x] - d[y]) % 3) { ++ ret; continue; } // 加入一个集合 if (px != py) { p[px] = py; d[px] = d[y] - d[x]; } } else { if (x == y || px == py &amp;&amp; (d[x] - d[y] - 1) % 3) { ++ ret; continue; } if (px != py) { // 加入一个集合 p[px] = py; d[px] = d[y] + 1 - d[x]; } } } cout &lt;&lt; ret &lt;&lt; endl; return 0;} 2. 拆点并查集（拓展域）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;functional&gt;using namespace std;const int N = 200010;int p[N]; // 拆点，每个点有三个域，天敌域，同类域，捕食域/* x : 维护x的所有天敌 x + n : 维护x的所有同类 x + 2 * n : 维护x的所有捕食*/// 每个集合里的元素都是一类int main (){ function&lt;int(int)&gt; f = [&amp;](int x) { return x == p[x] ? x : p[x] = f(p[x]); } ; function&lt;void(int, int)&gt; mg = [&amp;](int x, int y) { p[f(x)] = f(y); }; int n, k, d, x, y, ret = 0; cin &gt;&gt; n &gt;&gt; k; iota(p + 1, p + 3 * n + 1, 1); while(k -- &amp;&amp; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y) { if (x &gt; n || y &gt; n) { ret ++ ; continue; } // 假话2 if (d == 2 &amp;&amp; x == y) { ret ++ ; continue; } // 假话3 // 假话1，产生冲突 if (d == 1) { // 如果判定x和y是同类，但是x的天敌域或者捕食域有y，一定是假话 if (f(x) == f(y + n) || f(x + 2 * n) == f(y + n)) { ret ++ ; continue; } // 否则这是一句真话，记录一下 mg(x + n, y + n); mg(x, y); // x的天敌和y的天敌是同一类 mg(x + 2 * n, y + 2 * n); // x的捕食域和y的捕食域也是一类 } else { // 如果判定x捕食y，但是x同类域或天敌域有y，假话 if (f(x + n) == f(y + n) || f(x) == f(y + n)) { ret ++ ; continue; } mg(x + 2 * n, y + n); mg(x + n, y); // y的天敌域加上x的同类域 mg(x, y + 2 * n); // x的天敌域加上y的捕食域 } } cout &lt;&lt; ret &lt;&lt; endl; return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://horb7.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Codeforces-Global-Round-18","slug":"Codeforces-Global-Round-18","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-26T16:04:50.000Z","comments":true,"path":"2022/02/16/Codeforces-Global-Round-18/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Global-Round-18/","excerpt":"","text":"Global Round 18A. Closing The Gap题意给定 $n$ 个数字，每次操作可以选择其中两个数字 $a_i, a_j$ ，令 $a_i-1$ 且 $a_j + 1$ 。 问若干次操作后，极差最小为多少。 分析显然如果 $n | \\sum_{i=1}^na_i$ ，那么我们一定能找到方案使得每个数字都相同，那么极差为 $0$ 。 否则，我们可以取每个数字为 $\\lfloor \\dfrac {\\sum_{i=1}^n a_i} n \\rfloor$ ，剩下的数量小于 $n$ ，平均地分布在每个数字上，这样极差为 $1$ 。 Code1234567891011121314151617/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve (){ int n, sum = 0; cin &gt;&gt; n; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) sum += x; cout &lt;&lt; (sum % n ? 1 : 0) &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} B. And It’s Non-Zero题意给出范围 $[l, r]$ ，你拥有这个范围内的所有正整数。你可以删除某些数字。 问，最少删除多少数字，满足剩下的数字按位和为 $0$ 。 分析要使得一些数字的按位和不为 $0$ ，那么只需要满足存在某一个位，所有数字在这一个位上都为 $1$ 。 具体来说，我们可以枚举每一位，求出要使所有数字都在这个位上为 $1$ 的最小删除数量，求最小值即可。 预处理 $f(i, j)$ 表示前 $i$ 个数字第 $j$ 位为 $0$ 的数量。 Code123456789101112131415161718192021222324252627/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, INF = 0x3f3f3f3f;int f[N][30]; // 前i个数字第j个位为0的数量void init (){ for (int i = 1; i &lt; N; i ++ ) for (int j = 0; j &lt;= 20; j ++ ) f[i][j] = f[i-1][j] + !(i &gt;&gt; j &amp; 1);}void solve (){ int l, r, res = INF; cin &gt;&gt; l &gt;&gt; r; for (int i = 0; i &lt;= 20; i ++ ) res = min(f[r][i] - f[l-1][i], res); cout &lt;&lt; res &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (init(), cin &gt;&gt; _; _--; ) solve(); return 0;} C. Menorah题意有 $n$ 个蜡烛，给出每个蜡烛的起始状态（亮或者灭）。 每次操作可以选择一个 亮着的 蜡烛，让它保持状态不变，且其他所有蜡烛改变状态。 给出每个蜡烛的目标状态，问从起始状态到目标状态至少需要操作几次，如果无解输出 $-1$ 。 分析首先我们可以发现，对于起始状态 != 目标状态的所有蜡烛，他们被操作的次数的奇偶性是相同的；对于起始状态 == 目标状态的所有蜡烛，他们被操作的次数的奇偶性也是相同的。但是上述两类的蜡烛操作次数奇偶性不同。 证明：设 $x_i$ 表示第 $i$ 个蜡烛的操作次数。 对于第 $i$ 个蜡烛而言，它改变状态的次数为 $S = \\sum_{j=1}^{i-1}x_i + \\sum_{j=i+1}^{n}x_i$ 。 对于任意一个其他的蜡烛 $j$ ，它改变的次数为 $S’ = S + x_i - x_j$ 。 如果 $i$ 蜡烛是需要改变状态的，比如从原始的 $0$ 变成最终的 $1$ ，那么对于 $j$ 而言，如果它也需要改变状态，那么 $S’ = S = 1 \\pmod 2$ ，从而推出 $x_i = x_j \\pmod 2$ 。如果 $j$ 不需要改变状态，那么 $S’ != S \\pmod 2$ ，推出 $x_i != x_j \\pmod 2$ 。 同理如果 $i$ 蜡烛不需要改变状态，我们同理可得上述结论。 然后我们可以发现每个蜡烛如果被操作，它最多被操作一次。 所以我们实际上只有两种可能的解法。 只对所有起始和目标不同的蜡烛每个做一次操作。 只对所有起始和目标相同的蜡烛每个做一次操作。 那么如何求出解法是否可行？ 容易发现，我们的操作对象一定为 $101010101 \\ldots$ 。（这里指的是原始的状态） 我们先对原始状态的 $1$ 操作，由于这个已经操作过了，所以对剩下没有操作的蜡烛，本来是 $0$ 的现在变成 $1$ ，我们对 $1$ 操作，本质上是对原始状态的 $0$ 操作。 同时，我们对 $10$ 操作后，本质上是交换了这两个状态，其他状态没有改变。 第一种解法： ​ 假设起始和目标为 $01$ 的蜡烛数量为 $k_0$ ，起始和目标为 $10$ 的蜡烛数量为 $k_1$ 。那么我们只能每次交换一个 $01$ 。所以如果 $k_0 != k_1$ ，那么无法通过交换来达到目标，无解。否则我们交换 $2 \\times k_0$ 次即可交换所有的 $01$ 对。 第二种解法： ​ 假设起始和目标为 $00$ 的蜡烛数量为 $e_0$ ，起始和目标为 $11$ 的蜡烛数量为 $e_1$ 。那么我们需要交换 $01$ 使得他们与目标都不相同，这样如果最后只剩下一个 $1$ （也就是 $e_0 = e_1 - 1$） ，那么操作这个 $1$ 就可以把其他所有状态改变，也就是全部变成目标状态。 注意特判起始和目标相同的情况。 Code123456789101112131415161718192021222324252627282930313233/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve (){ int n; cin &gt;&gt; n; string a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) return cout &lt;&lt; 0 &lt;&lt; endl, void(); int k1 = 0, k0 = 0; int e1 = 0, e0 = 0; for (int i = 0; i &lt; n; i ++ ) { if (a[i] == '1' &amp;&amp; b[i] == '0') ++ k1; else if (a[i] == '0' &amp;&amp; b[i] == '1') ++ k0; else if (a[i] == '1' &amp;&amp; b[i] == '1') ++ e1; else if (a[i] == '0' &amp;&amp; b[i] == '0') ++ e0; } if (k1 != k0) { if (e0 == e1 - 1) return cout &lt;&lt; e0 * 2 + 1 &lt;&lt; endl, void(); return cout &lt;&lt; -1 &lt;&lt; endl, void(); } if (e0 == e1 - 1) return cout &lt;&lt; min(e0 * 2 + 1, k1 + k0) &lt;&lt; endl, void(); cout &lt;&lt; k1 + k0 &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} D. X(or)-mas Tree题意给定 $n$ 个结点的带权无根树和 $m$ 个限定条件 $(u, v, w)$ 。求出任意一个满足限制的树。 给出的边权如果为 $-1$ ，表示这个边权待定。 限定条件 $(u, v, w)$ ，表示从 $u$ 出发到达 $v$ 的路径上的所有边的异或和的 $popcount$ 的奇偶性 。 $popcount$ 指一个数字二进制位下 $1$ 的数量。 分析首先有一个等式 $popcount(x \\bigoplus y) = popcount(x) \\bigoplus popcount(y) \\pmod 2$ 。 证明：假设 $popcount(x) = k_1, popcount(y) = k_2$ 。 那么 $popcount(x \\bigoplus y) = k_1 + k_2 - cnt \\times 2$ ，其中，$cnt$ 表示在某一位上 $x = y = 1$ ，这样的位的个数。 显然 $k1 + k2 - cnt \\times 2 = k_1 + k_2 \\pmod 2$ 。 设 $a(u)$ 表示从结点 $u$ 到达根节点的路径异或和的 $popcount$ 。 对于限制条件 $(u, v, w)$ ， 其实就是 $a(u) \\bigoplus a(v) = w$ 。 对于给出的边 $(u, v, w)$ ，如果给定了边权，其实也是一个限制条件，因为 $a(u) \\bigoplus a(v) = popcount(w)$ 。 我们先把这些限制条件全部扔到另外一张图上。 容易发现，我们给边权填上 $0, 1$ 即产生两种不同的奇偶性，只需要填 $0$ 或者 $1$ 即可。 那么我们对限制图做染色法求出 $a(i)$ 即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, M = 1200010;#define pop(x) __builtin_popcount(x)int n, m;int h[N], rh[N], e[M], w[M], ne[M], idx;int a[N];bool vis[N]; // vis 用来染色bool cant;/* a(i) 表示从i到根节点路径上的异或和的popcount cant 表示无解*/void init (int n){ for (int i = 1; i &lt;= n; i ++ ) h[i] = rh[i] = -1; idx = 0; for (int i = 1; i &lt;= n; i ++ ) a[i] = vis[i] = 0; cant = 0;}void add (int h[], int a, int b, int c){ e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++ ;}void dfs (int u, int fa, int c){ if (cant) return ; a[u] = c; vis[u] = true; for (int i = rh[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; if (!vis[j]) dfs(j, u, c ^ w[i]); else if ((a[j] ^ a[u]) != w[i]) { cant = true; return; } // 如果j被染色过，需要满足限制，否则无解 }}void print (int u, int fa){ for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; if (w[i] != -1) cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; w[i] &lt;&lt; endl; else cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; (a[u] ^ a[j]) &lt;&lt; endl; print(j, u); }}void solve (){ cin &gt;&gt; n &gt;&gt; m; init(n); for (int i = 1; i &lt; n; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(h, a, b, c); add(h, b, a, c); if (c != -1) // 边不为-1，做一条限制 add(rh, a, b, pop(c) &amp; 1), add(rh, b, a, pop(c) &amp; 1); } // 后面还有m条限制 for (int i = 1; i &lt;= m; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(rh, a, b, c); add(rh, b, a, c); } // 染色 for (int i = 1; i &lt;= n; i ++ ) if (!vis[i]) dfs(i, -1, 0); if (cant) return cout &lt;&lt; \"NO\\n\", void(); cout &lt;&lt; \"YES\\n\"; print(1, -1);}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Good Bye 2021","slug":"Codeforces-Good-Bye-2021","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-31T13:26:48.000Z","comments":true,"path":"2022/02/16/Codeforces-Good-Bye-2021/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Good-Bye-2021/","excerpt":"","text":"Good Bye 2021A. Interger Diversity题意给定 $n$ 个整数，你可以选择其中的任意项，使其变成它的相反数(如把 $x$ 变成 $-x$) ，问操作后的序列中最多有多少个不同的数字。 分析记录每个数字是否出现过，如果出现过而相反数没有出现过就把它变成相反数。 Code123456789101112131415161718192021222324/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, res = 0; cin &gt;&gt; n; map&lt;int, bool&gt; ex; for (int i = 1; i &lt;= n; i ++ ) { int x; cin &gt;&gt; x; if (ex[x] &amp;&amp; ex[-x]) continue; res ++ ; if (!ex[x]) ex[x] = true; else ex[-x] = true; } cout &lt;&lt; res &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} B. Mirror in the String题意给定长度为 $n$ 的字符串 $s_1s_2 \\ldots s_n$ ，选择一个数字 $k(1 \\le k \\le n)$ ，使其变成 $s_1s_2 \\ldots s_ks_ks_{k-1} \\ldots s_1$ 。问操作后能得到的字符串的最小字典序为多少。 分析 $n = 1 \\ or \\ s_1 = s_2$ 选择 $k=1$ 即可得到字典序最小，因为选择 $k(k \\ge 2)$ 时，前两个字符依然是 $s_1s_2$ ，后面又多了字符导致字典序不是最小。 $s1 \\ != \\ s2$ 对于字符 $s_i$ ，如果 $s_{i+1} \\gt s_i$ ，那么选择 $k=i$ ，因为如果选择 $k \\gt i$ ，那么得到的字符串第 $i+1$ 位一定变大了，就不是字典序最小。 Code12345678910111213141516171819202122/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if (n == 1 || s[0] == s[1]) return cout &lt;&lt; s[0] &lt;&lt; s[0] &lt;&lt; endl, void(); int p = 0; while(p &lt; n - 1 &amp;&amp; s[p + 1] &lt;= s[p]) p ++ ; for (int i = 0; i &lt;= p; i ++ ) cout &lt;&lt; s[i]; for (int i = p; i &gt;= 0; i -- ) cout &lt;&lt; s[i]; cout &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} C. Representative Edges题意给定长度为 $n$ 的序列 $a$ ，每次操作可以修改其中某一个元素的值，问最小操作多少次，使得对于任意 $1 \\le l \\le r \\le n$ ，满足 $a_l + a_{l+1} + \\ldots + a_r = \\dfrac 1 2(a_l + a_r) \\times (r - l + 1)$ 。 分析可以发现题目要求的性质为等差数列的性质，题目变为：求最少修改多少次使得序列变为等差数列。 由于数据很小 $1 \\le n \\le 70$ 。我们可以固定数列任意两项作为要求的等差数列的一部分，求出其他满足该等差数列性质的个数。 假设固定 $i, j$ ，那么对于任意一项 $k$ ，满足等差数列性质需要: $\\dfrac {a_j - a_i} {j-i} = \\dfrac {a_k - a_i} {k - i} $ ，即 $(a_j - a_i) \\times (k - i) = (a_k - a_i) \\times (j - i)$ 。 Code123456789101112131415161718192021222324252627/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for (int i = x; i &lt;= y; i ++ )using namespace std;const int N = 1000;int a[N];void solve(){ int n, ret; cin &gt;&gt; n; ret = max(0, n - 2); for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; rep(i, 1, n) rep(j, i + 1, n) { int save = 0; rep(k, 1, n) if ((a[k] - a[i]) * (j - i) == (a[j] - a[i]) * (k - i)) ++ save; ret = min(ret, n - save); } cout &lt;&lt; ret &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} D. Keep the Average High题意给定长度为 $n$ 的序列 $a$ ，选出最多的元素，满足对于任意 $1\\le l \\lt r \\le n$ （$l, r$ 均指原序列的下标），满足以下至少一项： 存在至少一项 $l \\le k \\le r$ 没有被选择。 $a_l + a_{l+1} \\ldots a_r \\ge x \\times (r - l + 1)$ 。 问能够选择最多多少个元素。 分析对于任意 $l, r$ ，如果其中有一个没有被选择，那么一定满足限制，所以只需要考虑 $[l, r]$ 都被选择时是否满足限制。 注意第 $2$ 个限制，等价于 $(a_l - x) + (a_{l + 1} - x) + \\ldots + (a+r - x) \\ge 0$ 。 注意到 $[l, r]$ 是连续的，我们设 $p(i) = \\sum_{i=1}^i a_i - x$ ，那么上述限制等价于 $p(r) - p(l-1) \\ge 0$ 。 假设目前枚举到第 $i$ 位，那么我们需要考虑后两位，如果 $p(i + 2) - p(i) \\lt 0$ ，即 $a(i+1) + a(i+2) \\lt 0$ ，那么我们不能全部取到，否则令 $l = i+1, r=i+2$ ，不满足限制。如果满足 $p(i+2) - p(i) \\ge 0$ ，因为前面满足的序列加上第 $i+1$ 位不一定不小于 $0$ ，那么我们取最大值，把 $i+1$ 位放到待判断的序列中，即：$a_1 \\ldots a_qq_{q+1} \\ldots a_i \\ldots a_n$ ，区间 $[q, i]$ 为满足限制的区间，而 $i+1$ 进入到待选择区域。这样我们就不仅只考虑满足限制的最后一个位置后面的两个位置了。对于带选择区间 $[l, r]$ ，因为加上了 $a_r$ 导致 $p(r) - p(l-1) &lt; 0$ ，那么只需要不选择 $r$ 即可，因为 $[l, r-1]$ 加上前面满足的区间依然不小于零。 Code123456789101112131415161718192021222324252627/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 200010;int a[N], pre[N];void solve(){ int n, x, ret, mx = 0; cin &gt;&gt; n; ret = n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; cin &gt;&gt; x; for (int i = 1; i &lt;= n; i ++ ) pre[i] = pre[i-1] + a[i] - x; for (int i = 2; i &lt;= n; i ++ ) if (pre[i] &lt; mx) { -- ret; mx = pre[i]; ++ i; } else mx = max(mx, pre[i-1]); cout &lt;&lt; ret &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces-Round-762-Div-3","slug":"Codeforces-Round-762-Div-3","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-21T03:25:48.000Z","comments":true,"path":"2022/02/16/Codeforces-Round-762-Div-3/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Round-762-Div-3/","excerpt":"","text":"#762(Div.3)B. Squares and Cubes题意给定数字 $n$ ，求 $1 \\sim n$ 中有多少平方数和立方数。 分析由于只需要找平方数和立方数，我们可以暴力找出所有平方数和立方数，复杂度为 $log n$ ，注意判重。 Code1234567891011121314151617181920212223242526/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 200010;void solve (){ map&lt;int, bool&gt; ex; // 判重数组 int n, ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n / i; i ++ ) { ans ++ ; ex[i * i] = 1; } for (int i = 1; i * i &lt;= n / i; i ++ ) if (!ex[i * i * i]) ans ++ ; cout &lt;&lt; ans &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} C. Wrong Addition题意给定加法法则为：从右到左计算，每次把各位相加的结果填充到结果而不是进位。 即： $88 + 99 = 1717$ 。 给出加数、和，求另一个加数。 分析从加数、和的最后一位开始，如果在当前位，加数小于和，那么一定存在进位，否则一定不存在进位。 不存在解的情况： 在某一位上，当前加数的位数大于和的位数 在进位的时候发现和的前一位不是1 Code1234567891011121314151617181920212223242526272829303132333435363738394041/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define all(a) begin(a),end(a)using namespace std;void solve (){ string a, s, ans; cin &gt;&gt; a &gt;&gt; s; for (int p = s.size() - 1, pa = a.size() - 1; p &gt;= 0; ) { // 存在某一位，使得当前加数的数量大于和 if (pa &gt; p) return cout &lt;&lt; -1 &lt;&lt; endl, void(); if (pa &lt; 0) // 加数已经结束了，直接把和加上去 { ans += s[p--]; continue; } if (s[p] &gt;= a[pa]) // 不存在进位 { ans += s[p] - a[pa] + '0'; p -- ; pa -- ; } else // 存在进位 { // 存在进位，那么和的前一位一定是1 if (s[p - 1] != '1') return cout &lt;&lt; -1 &lt;&lt; endl, void(); ans += s[p] + 10 - a[pa] + '0'; p -= 2; pa -- ; } } reverse(all(ans)); while(ans[0] == '0') ans = ans.substr(1); cout &lt;&lt; ans &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} D. New Year’s Problem题意给出矩阵 $p_{ij}$ ，$1 \\le i \\le m, \\ 1 \\le j \\le n$ 。 选择至多 $n-1$ 行，然后在选择的行中，每一列挑选一个数字，求选择的数字的最小值的最大值。 分析要求最小值的最大值，可以想到用二分答案。 由于要选择至多 $n-1$ 行，那么我们只需要找出有 $2$ 个数字在同一行即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;#define rep(i, x, y) for(int i = x; i &lt;= y; i++)#define int long longusing namespace std;void solve (){ int n, m; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; p(m, vector&lt;int&gt;(n)); rep(i, 0, m-1) rep(j, 0, n-1) cin &gt;&gt; p[i][j]; auto check = [&amp;] (int mid) -&gt; bool { map&lt;int, bool&gt; ex; // 存储满足的商店 bool may = 0; // may表示存在两列可以选择同一行 // 使用may是为了防止后面的列中不存在大于等于mid的数字 for (int i = 0; i &lt; n; i ++ ) { bool f = 0; // 是否存在至少一个数字满足大于等于mid for (int j = 0; j &lt; m; j ++ ) if (p[j][i] &gt;= mid) { if (ex[j]) may = 1; ex[j] = 1; f = 1; } if (!f) return false; } return may; }; int l = 1, r = 1e9 + 10; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; r &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} E. MEX and increments题意给出 $n$ 个数字，每次操作可以把一个数字加1。可以操作任意次。 问：对于数字 $i \\ (0 \\le i \\le n)$ ，是否存在一种操作，可以满足序列的 $mex$ 为 $i$ 。输出它的最小操作次数。 分析对于数字 $i$ ，假设 $cnt([0, i-1]) &lt; i$ ，那么一定不能把前面 $i$ 个数字填满，一定无解。 否则，我们可以选择把离它最近的位置，填到 $i-1$ 的位置，使得序列的 $mex$ 为 $i$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;using PII = pair&lt;int, int&gt;;#define int long longconst int N = 200010;int cnt[N];void solve (){ int n; cin &gt;&gt; n; vector&lt;PII&gt; mct; // mct 用来动态记录cnt for (int i = 0; i &lt;= n; i ++ ) cnt[i] = 0; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) ++ cnt[x]; int precnt = 0, d = 0; // 对于0，特殊判断 cout &lt;&lt; cnt[0] &lt;&lt; ' '; if (cnt[0] &gt; 1) mct.push_back({0, cnt[0] - 1}); for (int i = 1; i &lt;= n; i ++ ) { precnt += cnt[i-1]; if (precnt &lt; i) { while(i ++ &lt;= n) cout &lt;&lt; -1 &lt;&lt; \" \\n\" [i - 1 == n]; return ; } // 如果i-1的位置没有元素，要把i-1铺掉 if (!cnt[i-1]) { while (!mct[mct.size() - 1].second) mct.pop_back(); -- mct[mct.size() - 1].second; d += i - 1 - mct[mct.size() - 1].first; } cout &lt;&lt; d + cnt[i] &lt;&lt; ' '; if (cnt[i] &gt; 1) mct.push_back({i, cnt[i] - 1}); } cout &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 764 (Div.3)","slug":"Codeforces-Round-764-Div-3","date":"2022-02-16T14:54:28.237Z","updated":"2022-01-12T04:47:30.000Z","comments":true,"path":"2022/02/16/Codeforces-Round-764-Div-3/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Round-764-Div-3/","excerpt":"","text":"A. Plus One on the Subset题意给定一个长度为 $n$ 的序列，每次选择若干个数字加 $1$ ，问最少操作几次可以使所有数字相同。 分析每次操作最小的数字，顺便补上其他小于最大值的数字，因此最少次数为极差。 Code12345678910111213141516171819202122/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; int maxv = -1, minv = 1e9; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) { maxv = max(maxv, x); minv = min(minv, x); } cout &lt;&lt; maxv - minv &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} Make AP题意给出三个数字，可以选择其中一个数字（也可以不选），使其乘上任意一个正数。 问能否让这三个数字成为等差数列（顺序不能换）。 分析由于只有三个数字，枚举哪个数字用来乘即可。 类似的题目： CF Good bye 2021 C题 Code12345678910111213141516171819202122232425/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longvoid solve(){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; bool ok = 0; int na = 2 * b - c; ok |= (na % a == 0 &amp;&amp; (c - b) == (b - na) &amp;&amp; (na * a) &gt; 0); int nb = (a + c) / 2; ok |= (nb % b == 0 &amp;&amp; (c - nb) == (nb - a) &amp;&amp; (nb * b) &gt; 0); int nc = (2 * b - a); ok |= (nc % c == 0 &amp;&amp; (nc - b) == (b - a) &amp;&amp; (nc * c) &gt; 0); cout &lt;&lt; (ok ? \"YES\" : \"NO\") &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} C. Division by Two and Permutation题意给定长度为 $n$ 的序列，每次可以选择一个数字 $x$ 使其变为 $\\lfloor \\dfrac x 2 \\rfloor$ 。问能否使序列变为一个 $1 \\sim n$ 的排列。 分析每个数字都必须为 $[1, n]$ 的数字，所以第一步要把所有大于 $n$ 的数字变为 $[1, n]$ 之间的数字。 从后往前遍历，由于每个数字都需要恰好 $1$ 个。那么如果当前数字没有，一定不能成功，如果有多个，留下一个并且把剩下的转化为 $\\lfloor \\dfrac x 2 \\rfloor$ 即可。 Code123456789101112131415161718192021222324252627282930/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;int cnt[N];void solve(){ memset(cnt, 0, sizeof cnt); int n; cin &gt;&gt; n; for (int i = 1, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) { while (x &gt; n) x /= 2; cnt[x] ++ ; } for (int i = n; i &gt;= 1; i -- ) { if (!cnt[i]) return cout &lt;&lt; \"NO\\n\", void(); while(cnt[i] &gt; 1) cnt[i / 2] ++, cnt[i] -- ; } cout &lt;&lt; \"YES\\n\";}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} D. Palindromes Coloring题意给出长度为 $n$ 的字符串和 $k$ 种染料，每种染料都至少染 $1$ 个字符，被染上相同染料的字符可以任意调换顺序。 给字符串染上染料，使得所有被染上相同染料的字符串（子串）为回文串。问长度最小的字符串的最大长度为多少。 分析由于可以任意调换顺序，因此字符串顺序不是考虑因素。 要把一个子串变成回文串，我们需要任意个偶数对和至多一个任意字符。 那么我们可以求出偶数对的数量以及单个的字符的数量，然后二分答案即可。 注意如果一个字符出现了奇数次，我们可以把它拆成若干个偶数对和一个单独的字符。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint even, odd, k; // 能构成偶数对的字符数量、单独的字符数量bool check (int x){ int nt = even, no = odd; if (x &amp; 1) { if (k * (x - 1) &gt; nt) return false; // 每个子串至少要 (x-1) 个even nt -= k * (x - 1); if (nt + no &lt; k) return false; // 注意可以把能构成偶数对的字符数量变成单独的字符使用 return true; } else { if (k * x &lt;= nt) return true; else return false; }}void solve(){ even = odd = 0; vector&lt;int&gt; a(26); int n; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; for (char c : s) a[c - 'a'] ++ ; for (int x : a) { if (x &amp; 1) even += x - 1, odd ++ ; else even += x; } int l = 0, r = n; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; r &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} E.Masha-forgetful题意给出 $n$ 个长度为 $m$ 的字符串，以及需要匹配的字符串 $s$ （长度也为 $m$），问能否把 $s$ 拆成任意多段（每段长度至少为 $2$），使得每一段在前 $n$ 个字符串出现过。如果满足，输出 $k$ 段，且输出每一段在其他字符串出现的首尾位置，以及它出现在哪个字符串。 分析首先，任何一个不小于 $2$ 的数字都可以由若干个 $2$ 和 $3$ 组成 。 这就意味这我们只需要把 $s$ 拆成若干个长度为 $2$ 和 $3$ 的段即可。 $dp(i)$ 表示前 $i-1$ 个字符是匹配的。 在前 $n$ 个字符串中，找出所有段长度为 $2$ 和 $3$ 的信息（即题目要求的首尾位置和出现在第几个字符串）。 然后从前往后遍历 $s$ ，求出那些位置是匹配的。最后从后往前找到路径即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;using tp = tuple&lt;int, int, int&gt;;void solve(){ tp f2[10][10], f3[10][10][10]; // f2(i, j)表示 ij 这样的段出现的信息 int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { string s; cin &gt;&gt; s; for (int j = 0; j &lt; m; j ++ ) { if (j + 1 &lt; m) f2[s[j]-'0'][s[j+1]-'0'] = {j + 1, j + 2, i + 1}; if (j + 2 &lt; m) f3[s[j]-'0'][s[j+1]-'0'][s[j+2]-'0'] = {j + 1, j + 3, i + 1}; } } string s; cin &gt;&gt; s; vector&lt;bool&gt; dp(m + 1); // dp(i)表示前面i-1个位置是否可以 dp[0] = true; for (int i = 0; i &lt; m; i ++ ) { if (!dp[i]) continue; if (i + 1 &lt; m &amp;&amp; f2[s[i]-'0'][s[i+1]-'0'] != tp(0, 0, 0)) dp[i + 2] = true; if (i + 2 &lt; m &amp;&amp; f3[s[i]-'0'][s[i+1]-'0'][s[i+2]-'0'] != tp(0, 0, 0)) dp[i + 3] = true; } if (!dp[m]) return cout &lt;&lt; \"-1\\n\", void(); int i = m; // 记录路径 vector&lt;tp&gt; ans; while(i) { if (i &gt;= 1 &amp;&amp; dp[i - 2] &amp;&amp; f2[s[i-2]-'0'][s[i-1]-'0'] != tp{0, 0, 0}) { ans.push_back(f2[s[i-2]-'0'][s[i-1]-'0']); i -= 2; } else { ans.push_back(f3[s[i-3]-'0'][s[i-2]-'0'][s[i-1]-'0']); i -= 3; } } reverse(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto t : ans) cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; ' ' &lt;&lt; get&lt;1&gt;(t) &lt;&lt; ' ' &lt;&lt; get&lt;2&gt;(t) &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} F. Interacdive Problem题意给出数字 $n$ ，要求猜出数字 $x$ ，其中 $1 \\le x \\lt n \\le 1000$ 。 可以给出询问 $+ \\ \\ c$ ，表示令 $x = x + c$ ，之后给出 $\\lfloor \\dfrac x n \\rfloor$ 。 最多可以操作 $10$ 次。 分析可以把 $x$ 写成 $x / n * n + x \\% n$ 。 二分答案，假设 $mid = x$ ，即 $mid = mid / n * n + mid \\% n$ 。 询问 $n - mid \\% n$ ，这样可以使 $x + n - mid \\% n = x / n * n + n + x \\% n - mid \\% n$ 。 发现倍数增加了，那么有 $x \\% n \\ge mid \\% n$ ，即 $mid \\le x$ 。 否则 $mid \\gt x$ 。 注意由于 $x$ 已经加上了 $n - mid \\% n$ ，那么 $l$ 和 $r$ 也要加上，保证 $l \\le x \\le r$ 。 Code12345678910111213141516171819202122232425262728293031323334353637/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ auto query = [&amp;] (int add) { cout &lt;&lt; \"+ \" &lt;&lt; add &lt;&lt; endl; return cin &gt;&gt; add, add; }; auto submit = [&amp;] (int ans) { cout &lt;&lt; \"! \" &lt;&lt; ans &lt;&lt; endl; exit(0); }; int n; cin &gt;&gt; n; int l = 1, r = n - 1; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; int to = n - mid % n, now = query(to); if (now &gt;= mid / n + 1) l = mid; else r = mid - 1; l += to, r += to; } submit(r);}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); // int _; for (cin &gt;&gt; _; _--;) solve(); return 0;} G. MinOr Tree题意给出一张无向图，求或和最小的生成树。 分析按位分析，从大到小，假设当前位为 $bit$ 。 由于要求最小或和，那么最好情况下，我们只合并所有在 $bit$ 位上为 $0$ 和点。 如果合并完发现没有用上所有点，那么说明要想生成最小生成树，必须要 $bit$ 位上为 $1$ 的点。 考虑下一位前，由于当前位已经被考虑过，所以要把所有在当前位为 $1$ 的边变为当前位为 $0$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 终点是一切概率的结束，也是一切期望的开始 */#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; u(m), v(m), w(m); for (int i = 0; i &lt; m; i ++ ) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; -- u[i], -- v[i]; } int ans = 0; for (int j = 29; j &gt;= 0; j -- ) { vector&lt;vector&lt;int&gt;&gt; E(n); for (int k = 0; k &lt; m; k ++ ) { if (w[k] &lt; (1 &lt;&lt; j)) { E[u[k]].push_back(v[k]); E[v[k]].push_back(u[k]); } } vector&lt;bool&gt; used(n, false); used[0] = true; // 从0号点开始bfs queue&lt;int&gt; Q; Q.push(0); while(!Q.empty()) { int x = Q.front(); Q.pop(); for (int y : E[x]) { if (!used[y]) { used[y] = true; Q.push(y); } } } if (used != vector&lt;bool&gt; (n, true)) { ans |= 1 &lt;&lt; j; // 这一位已经考虑过了，把j位上为1的数字去掉 for (int k = 0; k &lt; m; k ++ ) if (w[k] &gt;&gt; j &amp; 1) w[k] ^= 1 &lt;&lt; j; } } cout &lt;&lt; ans &lt;&lt; endl;}signed main(){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--;) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Codeforces Round 767(Div.2)","slug":"Codeforces-Round-767-Div-2","date":"2022-02-16T14:54:28.237Z","updated":"2022-01-23T08:05:14.000Z","comments":true,"path":"2022/02/16/Codeforces-Round-767-Div-2/","link":"","permalink":"https://horb7.github.io/2022/02/16/Codeforces-Round-767-Div-2/","excerpt":"","text":"Codeforces Round #767 (Div.2)C. Meximum Array题意给定序列 $a$ ，以下列方式构造序列 $b$ ，使得 $b$ 的字典序最大。 当序列 $a$ 不为空时： 选择一个序列 $a$ 的前缀区间。 将此前缀区间的 $mex$ 值放置 $b$ 序列的末尾，然后在 $a$ 序列中删除此前缀。 分析题目要求将 $a$ 序列进行划分，使得每个集合的 $mex$ 值按顺序拼接起来字典序最大。 根据贪心，对于每个 $mex$ ，我们一定要选择值最大的前缀，如果有多个则选择前缀区间最短的。 如何算一个区间 $mex$ ？int p = 0; while(sum[p]) ++ p; 枚举每个元素，计算以它为结尾的区间 $mex$ ，如果后面的元素不存在 $mex$ 元素，那么就不可能对此 $mex$ 产生贡献，无论加再多元素，$mex$ 值也不会变，所以直接贪心取这个 $mex$ 值即可。 具体来说，只需要开两个桶，第一个桶用来记录当前区间的元素，第二个桶用来记录后面区间的元素即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/* さあ，Games始めましょうか */#include &lt;bits/stdc++.h&gt;using namespace std;/* all表示总桶，cur表示当前桶 */const int N = 200010;int a[N], all[N], cur[N], ret[N];void solve (){ int n, cnt = 0; cin &gt;&gt; n; for (int i = 0; i &lt;= n; i ++ ) all[i] = cur[i] = 0; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i], ++ all[a[i]]; // p表示当前的mex值，last表示上一段区间的末尾位置 for (int i = 1, p = 0, last = 0; i &lt;= n; i ++ ) { ++ cur[a[i]]; while(cur[p]) ++ p; // 统计以当前元素为末尾的mex值 // 后面不存在p元素，那么后面的元素不会对mex产生贡献 if (!all[p]) { ret[++ cnt] = p; // 清空当前桶(cur)，更新记录后面元素的桶(all) for (int j = last + 1; j &lt;= i; j ++ ) cur[a[j]] = 0, -- all[a[j]]; last = i; p = 0; } } cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 1; i &lt;= cnt; i ++ ) cout &lt;&lt; ret[i] &lt;&lt; \" \\n\"[i == cnt];}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} D. Peculiar Movie Preferences题意给定 $n$ 个长度不超过 $3$ 的字符串，问是否存在一个子序列，使得其相应的字符串按顺序拼接后是一个回文串。 分析如果一个字符串本身就是回文，那么一定存在。 首先可以明确，如果存在一个子序列满足条件，那么一定存在长度为 $2$ 的子序列满足条件(因为长度最多为 $3$ ，只需要取满足条件的子序列的首尾元素即可)。 对于长度为 $2$ 的字符串，也就是 $2 + 2$ 的情况 ，只需要检查是否存在其逆序即可。 对于长度为 $3$ 的字符串，有 $3 + 3, 2 + 3, 3 + 2$ 三种情况，先检查其逆序是否存在，对于 $2 + 3$ ，把左端去掉，检查逆序是否在前面出现过即可，$3 + 2$ 同理。 Code1234567891011121314151617181920212223242526272829303132333435363738394041/* さあ，Games始めましょうか */#include &lt;bits/stdc++.h&gt;#define all(x) begin(x), end(x)using namespace std;void solve (){ int n; cin &gt;&gt; n; map&lt;string, int&gt; pre, post; vector&lt;string&gt; s(n); for (string &amp; str : s) cin &gt;&gt; str, ++ post[str]; for (string k : s) { string oth = k; reverse(all(oth)); // 2 + 2 or 3 + 3 if (pre[oth] || post[oth]) return cout &lt;&lt; \"YES\\n\", void(); if (k.size() == 3) { // 3 + 2 oth = k.substr(0, 2); reverse(all(oth)); if (post[oth]) return cout &lt;&lt; \"YES\\n\", void(); // 2 + 3 oth = k.substr(1, 2); reverse(all(oth)); if (pre[oth]) return cout &lt;&lt; \"YES\\n\", void(); } pre[k] ++ ; post[k] -- ; } cout &lt;&lt; \"NO\\n\";}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;} E. Grid Xor题意存在 $n \\times n$ 的矩阵，每个位置 $a_{ij}$ 表示一个数。 给出另一个 $n \\times n$ 的矩阵，每个位置 $b_{ij}$ 表示矩阵 $a$ 对应位置相邻格子的值的异或和(相邻指上下左右四个方向)。 问矩阵 $a$ 所有元素的异或和为多少？(矩阵 $a$ 不唯一，但是其异或和一定是唯一的)。 分析要求矩阵 $a$ 所有元素的异或和，我们只要异或每个元素的奇数次即可。 根据递推，先异或所有 $b_{1j}$ ，这样第一行的所有元素的异或次数就确定了，从第二行开始递推，如果上一行异或次数为偶数，只能从这一行来异或。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344/* さあ，Games始めましょうか */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;const int dr[] = { -1, 0, 1, 0 }, dc[] = { 0, 1, 0, -1 };int n, g[N][N];bool is_even[N][N];void solve (){ int ret = 0; auto modify = [&amp;](int x, int y) -&gt; void { for (int i = 0; i &lt; 4; i ++ ) { int dx = x + dr[i], dy = y + dc[i]; is_even[dx][dy] = !is_even[dx][dy]; } ret ^= g[x][y]; }; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) cin &gt;&gt; g[i][j], is_even[i][j] = true; // 修改第一行 for (int i = 1; i &lt;= n; i ++ ) modify(1, i); for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (is_even[i - 1][j]) modify(i, j); cout &lt;&lt; ret &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(0); int _; for (cin &gt;&gt; _; _--; ) solve(); return 0;}","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"}]},{"title":"Devu和鲜花","slug":"Devu和鲜花","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-23T05:14:40.000Z","comments":true,"path":"2022/02/16/Devu和鲜花/","link":"","permalink":"https://horb7.github.io/2022/02/16/Devu%E5%92%8C%E9%B2%9C%E8%8A%B1/","excerpt":"","text":"Devu 和鲜花题意Devu 有 $N$ 个盒子，第 $i$ 个盒子中有 $A_i$ 枝花。 同一个盒子内的花颜色相同，不同盒子内的花颜色不同。 Devu 要从这些盒子中选择 $M$ 枝花组成一束，求共有多少种方案。 若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。 结果需对 $10^9 + 7$ 取模之后方可输出。 输入格式第一行包含两个整数 $N$ 和 $M$ 。 第二行包含 $N$ 个空格隔开的整数，表示 $A_1, A_2, \\ldots , A_N$ 。 数据范围$1 \\le N \\le 20, 0 \\le M \\le 10^{14}, 0 \\le A_i \\le 10^{12}$ 。 分析 假设每个盒子的花的数量是无限的。 设 $x_i$ 为第 $i$ 个盒子取出来的花的数量。则求解 $x_1 + x_2 + \\ldots + x_N = M$ 的方案数，其中 $x_i \\ge 0$ 。 设 $y_i = x_i + 1$ 。 则问题变为 $y_1 + y_2 + \\ldots + y_n = M + N$ 的方案数，其中 $y_i \\ge 1$ 。 用隔板法求解，在 $M + N - 1$ 个间隔中插入 $N - 1$ 个隔板，则有 $C_{M + N - 1}^{N - 1}$ 中方案。 对于有限制的方案数量。 题目限制了 $x_i \\le A_i$ 。正难则反，我们用总方案数量减去不满足限制的方案数量就是满足限制的方案数量。 设 $s_i$ 表示第 $i$ 个限制不满足，即 $s_i : \\ x_i \\ge A_i + 1$ 。 记 $s_0$ 为所有方案。 那么总满足限制的方案数量为： $s_0 - |s_1 \\bigcup s_2 \\bigcup s_3 \\ldots \\bigcup s_N|= s_0 - \\sum_{1 \\le i \\le N}|s_i| + \\sum_{1 \\le i \\lt j \\le N}|s_i \\bigcap s_j| - \\ldots$ 求解 $s_i: $ 即求 $x_1 + x_2 + \\ldots + x_N = M$ ，其中 $x_i \\ge A_i + 1$ ，其他 $x \\ge 0$ 。 两边同时减 $A_i + 1$ ，则 $x_1 + x_2 + \\ldots + x_N = M - (A_i + 1)$ ，其中 $x_i \\ge 0$ 。 同理令 $y_i = x_i + 1$ 。 即 $y_1 + y_2 + \\ldots + y_N = M - (A_i + 1) + N$ ，$y_i \\ge 1$ 。 方案数量为 $C_{M - (A_i + 1) + N - 1}^{N - 1}$ 。 同理 $|s_i \\bigcap s_j| = C_{M - (A_i + 1) - (A_j + 1) + N - 1}^{N - 1}$ 。 由于 $N$ 范围很小，我们可以使用二进制枚举求出所有情况。 容斥复杂度为 $O(2^n)$ ，而每种情况处理需要 $O(n)$ 复杂度，所以总复杂度为 $O(2^n \\times n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;using ll = long long;const int N = 25, mod = 1e9 + 7;int qmi (int a, int k, int p = mod){ int res = 1; for (a %= p; k; k &gt;&gt;= 1, a = 1ll * a * a % p) if (k &amp; 1) res = 1ll * res * a % p; return res;}int down = 1;int C (ll m, int n){ if (m &lt; n) return 0; int res = 1; for (ll i = m; i &gt; m - n; i -- ) res = i % mod * res % mod; return 1ll * res * down % mod;}ll a[N];signed main (){ ll n, m, ret = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; i ++ ) down = 1ll * down * i % mod; down = qmi(down, mod-2); for (int s = 0; s &lt; 1 &lt;&lt; n; s ++ ) { int sign = 1; ll cm = m + n - 1; for (int j = 0; j &lt; n; j ++ ) if (s &gt;&gt; j &amp; 1) { cm -= a[j] + 1; sign *= -1; } ret = (ret + sign * C(cm, n-1)) % mod; } cout &lt;&lt; (ret + mod) % mod &lt;&lt; endl; return 0;}","categories":[{"name":"math","slug":"math","permalink":"https://horb7.github.io/categories/math/"}],"tags":[{"name":"容斥原理","slug":"容斥原理","permalink":"https://horb7.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}]},{"title":"C++实现简易对拍器","slug":"c++实现简易对拍器","date":"2022-02-16T14:54:28.237Z","updated":"2021-12-22T12:53:30.000Z","comments":true,"path":"2022/02/16/c++实现简易对拍器/","link":"","permalink":"https://horb7.github.io/2022/02/16/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/","excerpt":"","text":"利用C++实现简易对拍器我们有的时候写完了代码，提交到OJ上莫名其妙却wrong answer了，通常是算法写假了或者一些边界没有考虑。 为了减少手动造数据的耗时，我们可以使用对拍器自动生成数据并进行运算找到错误数据。 使用对拍器需要： 你的正确的看起来正确的代码和一份正确的代码（在比赛中可以写一份会TLE但是一定正确的代码）。 生成随机数据的文件。 用来实现对比两份代码输出结果的文件。 为了方便管理文件，不显得很乱，我把对拍器单独放进了当前目录下的一个文件夹，如图： 其中: check用来实现两份代码输出的比较 gen用来生成随机数据 force实现暴力算法 上一层目录的Horb7实现看起来正确的算法 toexe用来实现cpp文件的编译(太菜了用不来makefile) 原理根据gen文件生成随机数据至data.txt，再调用Horb7.exe和force.exe生成两份输出结果，再比较两份输出结果是否有不同，如果不同则显示 error 。 用法 编译好你写的两份代码 在gen.cpp中写入针对这道题目的数据的输入格式 运行check.exe 如果完全相同则会显示your program may be right.，否则会显示error!，并输出两份不同的输出结果。 实现由于我不会bat脚本各种原因，我选择用cpp文件实现输出比较，本质还是通过 windows.h 库调用dos命令。 check code12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;int main (){ int cnt = 32; // 比较32次 while (cnt -- ) { system(\"gen.exe &gt; data.txt\"); // 调用上一级写的可执行文件(system不支持相对路径) system(\"D:/VsCode/Code/Horb7.exe &lt; data.txt &gt; pros.txt\"); system(\"force.exe &lt; data.txt &gt; std.txt\"); if (system(\"fc pros.txt std.txt\")) { cout &lt;&lt; \"error!\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"your program may be right.\" &lt;&lt; endl; return 0;} gen code12345678910111213141516171819202122232425#include &lt;ctime&gt;#include &lt;random&gt;#include &lt;iostream&gt;using namespace std;// 获取一个[a, b]之间的整数（最大范围[0, 32757]）#define rd(a, b) (rand() % (b - a + 1) + a)int main(){ srand(time(0)); // 随机数种子 /* ---------------------------------------------------------*/ // 写出随机数据 int cases = 1; // T 组数据 cout &lt;&lt; cases &lt;&lt; endl; while(cases -- ) { // 根据题目输出具体格式的数据 for (int i = 1; i &lt;= 10; i ++ ) cout &lt;&lt; rd(1, 5) &lt;&lt; endl; }} toexe code12345678910#include &lt;windows.h&gt;int main (){ system(\"g++ check.cpp -o check\"); system(\"g++ force.cpp -o force\"); system(\"g++ gen.cpp -o gen\"); system(\"g++ D:/VsCode/Code/Horb7.cpp -o D:/VsCode/Code/Horb7\"); return 0;}","categories":[],"tags":[{"name":"project","slug":"project","permalink":"https://horb7.github.io/tags/project/"}]},{"title":"2021ICPC沈阳站","slug":"2021ICPC沈阳","date":"2022-02-16T14:54:28.236Z","updated":"2021-12-21T16:02:54.000Z","comments":true,"path":"2022/02/16/2021ICPC沈阳/","link":"","permalink":"https://horb7.github.io/2022/02/16/2021ICPC%E6%B2%88%E9%98%B3/","excerpt":"","text":"2021ICPC沈阳站B. Bitwise Exclusive-OR Sequence题意对于长度为 $n$ 的序列，给出 $m$ 个关系，第 $i$ 个关系形如 $a_j \\bigoplus a_k = w_i$ ，表示第 $j$ 个元素和第 $k$ 个元素的异或值为 $w_i$ ，问满足所有关系的条件下，这个序列的和最小为多少。如果无解，输出 $-1$ 。 分析对于关系 $a_j \\bigoplus a_k = w_i$ ，把 $j$ 点和 $k$ 点连一条边，边权为 $w_i$ 。 无解的情况下，明显一定是存在一个环，在环内各边权存在矛盾。对于每一个连通块，当我们确定其中一个点的点权，其他点的点权是确定的。 判断是否无解，我们只需要看边权是否矛盾，可以 $dfs$ 每个连通块，如果某个点的点权和邻接点的点权异或值不为边权，则无解。 对于有解的情况，枚举每个连通块的每一个位，对于其中一个点(初始点)可以为 $0$ 或 $1$ 。那么在某一位上我们只需要取这个连通块内所有点的 $min(nums_0, nums_1)$ 作为答案的贡献即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010, M = 400010;int n, m;int h[N], e[M], w[M], ne[M], idx;int val[N]; // 判断无解时用的点值bool st[N]; // dfs连通块，判断某个点是否遍历过int color[N][31]; // color(i, j) 表示第i个点在j位上的值（0 -&gt; 未涂色, 1 -&gt; 1, 2 -&gt; 0）void add (int a, int b, int c){ e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++ ;}// 判断是否无解void dfs (int u, int v){ val[u] = v; st[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (st[j]) continue; if (val[j] == -1) dfs(j, w[i] ^ val[u]); } for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if ((val[u] ^ val[j]) != w[i]) // 矛盾 { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); } }}// 找出某一位0和1的数量void dfs (int u, int &amp; one, int &amp; zero, int c, int bit){ color[u][bit] = c; st[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!color[j][bit]) { if (w[i] &gt;&gt; bit &amp; 1) { if (c == 1) ++ zero; else ++ one; dfs(j, one, zero, 3 - c, bit); } else { if (c == 1) ++ one; else ++ zero; dfs(j, one, zero, c, bit); } } }}int main (){ cout.tie(0)-&gt;sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for (int i = 0, u, v, w; i &lt; m &amp;&amp; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; i++ ) add(u, v, w), add(v, u, w); memset(val, -1, sizeof val); for (int i = 1; i &lt;= n; i ++ ) if (!st[i]) dfs(i, 1); long long res = 0; memset(st, 0, sizeof st); for (int i = 1; i &lt;= n; i ++ ) if (!st[i]) { for (int b = 30; b &gt;= 0; b -- ) { int one = 1, zero = 0; dfs(i, one, zero, 1, b); res = res + min(one, zero) * (1ll &lt;&lt; b); } } cout &lt;&lt; res &lt;&lt; endl; return 0;} F. Encoded Strings I题意给定一个长度为 $n$ 的字符串 $s$ 。对于每个前缀字符串 $pre_s$ ，将其重新编码，规则为： 设某个字符 $c$ 在 $pre_s$ 中最后一个位置为 $k$ ，$chr$ 为 $[k, len(pre_s)]$ 中不同字符的数量。那么把 $c$ 映射为第 $chr+1$ 个阿拉伯字母。 求出所有前缀字符串 $pre_s$ 最大的映射字符串。 分析$cnt$ 存储每个字符最后一位后面的不同字符。 从前往后遍历前缀，当加入一个字符时，这个字符最后一个位置变为末尾，$cnt$ 清空。对于其他在前面出现的字符，它的 $cnt$ 数组加上这个字符即可。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;int main (){ int n; cin &gt;&gt; n; string s, ret; cin &gt;&gt; s; map&lt;char, set&lt;char&gt; &gt; cnt; set&lt;char&gt; appear; for (int i = 0; i &lt; s.size(); i ++ ) { string cur; cnt[s[i]].clear(); appear.insert(s[i]); for (auto c : appear) if (s[i] != c) cnt[c].insert(s[i]); for (int j = 0; j &lt;= i; j ++ ) cur += char('a' + cnt[s[j]].size()); ret = max(ret, cur); } cout &lt;&lt; ret &lt;&lt; endl; return 0;} J. Luggage Lock题意有四位的密码锁，每次可以选择把一段连续的区间向上或者向下转动一格，问把初始状态转成目标状态至少需要多少次旋转。 分析对于某一位数字 $a_i$ ，如果要把他向上转动 $k$ 次，我们同样可以让他向下转动 $10 - k$ 次，每个数字都有两种状态（除了 $k=0$ ，也就是初始和目标相同，它可以向上转动 $10$ 次，也可以向下转动 $10$ 次，也可以选择不转动）。所以我们可以三进制枚举每一个旋转状态 $b_1b_2b_3b_4$ 。 当我们得到一个旋转状态后呢？我们需要把这个状态变为全 $0$ ，由于每次可以选择一段连续区间 $+1 \\ \\ or \\ \\ -1$ ，可以想到 差分数组 ，我们把状态变为全 $0$ 也就是意味着把差分数组变为全 $0$ 。 在一个差分数组中，变为全 $0$ 的最小代价为 $max(posi, |neg|)$ ，$posi$ 表示正数总和，$neg$ 表示负数总和。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;int rot[5], back[5];int main (){ int T; cin &gt;&gt; T; while( T -- ) { string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; 4; i ++ ) rot[i] = a[i] - b[i]; // 向上为正，向下为负 // 枚举每个数字的转动，向上或者向下（0有三种，所以要三进制枚举） int m = 3 * 3 * 3 * 3, ret = 1e9; for (int i = 0; i &lt; m; i ++ ) { int state = i; for (int j = 0; j &lt; 4; j ++ ) { if (state % 3 == 1) { // 为1，反方向旋转 if (rot[j] &gt; 0) back[j] = rot[j] - 10; else back[j] = 10 + rot[j]; } else if (state % 3 == 2 &amp;&amp; !rot[j]) { // 为2，特判rot为0，由于在模1的时候0为10，所以这里为-10 back[j] = -10; } else back[j] = rot[j]; state /= 3; } // 把旋转数组变为全0，即差分数组变为0 int posi = 0, neg = 0; // 差分数组变为0的次数：max(posi, neg) for (int j = 0; j &lt; 4; j ++ ) { int dif = (j ? back[j] - back[j-1] : back[j]); if (dif &gt; 0) posi += dif; else neg += dif; } ret = min(ret, max(posi, abs(neg))); } cout &lt;&lt; ret &lt;&lt; endl; } return 0;} J. Perfect Matchings题意对于一个 $2 * n$ 个顶点的完全图，删除给定的一颗生成树，求剩下图的完美匹配数量有多少。 完美匹配，指最大数量的边集合，集合内任意两条边都没有公共顶点。 分析 对于一个 $2 n$ 顶点的完全图，它的完美匹配数量有 $\\prod_{i=1}^{n}2i - 1$ 个。 把 $n$ 个顶点放到左边去匹配右边 $n$ 个，选择 $n$ 个顶点 $C_{2n}^{n}$ ，匹配为 $n!$ 。 然后对于每一个匹配边，它的一个结点在右边时贡献一次，左边时又贡献一次，所以要除以二。 所以完美匹配数量为 $\\dfrac{C_{2n}^{n} \\times n!}{2}$ 个。 把 $C_{2n}^{n}$ 中的偶数项除以二后与 $n!$ 抵消，所以匹配数量为 $1 \\times 3 \\times 5 \\ldots (2 \\times n - 1) = \\prod_{i=1}^{n}2*i - 1$ 。 容斥原理 用总的图的所有匹配数量减去其中有一些匹配边在生成树上的数量，枚举有几条边在生成树，减去所有不合法情况就是合法的情况。 计数dp，枚举在生成树上的不合法情况 设 $f(i, j, 0/1)$ 表示以 $i$ 为子树，匹配数量为 $j$ ，$i$ 参与/不参与匹配时的方案数量。 树上背包问题，设 $j$ 为 $i$ 的儿子，转移方程为： f(i, x + y, 0) += f(i, x, 0) * (f(j, y, 0) + f(j, y, 1)), y > 0 \\\\ f(i, x + y, 1) += f(i, x, 1) * (f(j, y, 0) + f(j, y, 1)), y > 0 \\\\ f(i, x + y + 1, 1) += f(i, x, 0) * f(j, y, 0)可以枚举每个 $i$ 子树的大小使复杂度达到 $O(n^2)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 4010, M = 8010, mod = 998244353;int n, m;int h[N], e[M], ne[M], idx;int siz[N]; // 每个子树的结点个数int f[N][N][2]; // f(i, j, k) 表示以i为根的树，取j个配对，i有无选中的方案数量int p[N]; // p(i) 表示i个结点组成的完全图可配对的数量void add (int a, int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;}void dfs (int u, int fa){ f[u][0][0] = 1; siz[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; dfs(j, u); for (int x = siz[u] / 2; x &gt;= 0; x -- ) for (int y = siz[j] / 2; y &gt;= 0; y -- ) { if (y &gt; 0) { f[u][x + y][0] = (f[u][x + y][0] + 1ll * f[u][x][0] * (f[j][y][0] + f[j][y][1]) % mod) % mod; f[u][x + y][1] = (f[u][x + y][1] + 1ll * f[u][x][1] * (f[j][y][0] + f[j][y][1]) % mod) % mod; } f[u][x + y + 1][1] = (f[u][x + y + 1][1] + 1ll * f[u][x][0] * f[j][y][0] % mod) % mod; } siz[u] += siz[j]; }}signed main (){ int n; cin &gt;&gt; n; p[0] = 1; for (int i = 1; i &lt;= n; i ++ ) p[i] = 1ll * p[i-1] * (2 * i - 1) % mod; memset(h, -1, sizeof h); for (int i = 1, u, v; i &lt; 2 * n &amp;&amp; cin &gt;&gt; u &gt;&gt; v; i ++ ) add(u, v), add(v, u); dfs(1, -1); int res = 0; for (int i = 0; i &lt;= n; i ++ ) // 枚举生成树里的配对数量 { if (i &amp; 1) res = (1ll * res - 1ll * (f[1][i][0] + f[1][i][1]) * p[n - i] % mod) % mod; else res = (1ll * res + 1ll * (f[1][i][0] + f[1][i][1]) * p[n-i] % mod) % mod; } cout &lt;&lt; (res % mod + mod) % mod &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"区域站","slug":"区域站","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%AB%99/"}]},{"title":"钉子和小球","slug":"洛谷P5750-钉子和小球","date":"2021-12-15T04:34:12.000Z","updated":"2022-02-17T04:24:32.841Z","comments":true,"path":"2021/12/15/洛谷P5750-钉子和小球/","link":"","permalink":"https://horb7.github.io/2021/12/15/%E6%B4%9B%E8%B0%B7P5750-%E9%92%89%E5%AD%90%E5%92%8C%E5%B0%8F%E7%90%83/","excerpt":"","text":"钉子和小球题意如图的三角形木板上钉着 $\\dfrac{n(n+1)}{2}$ 个钉子，还有 $(n+1)$ 个格子，钉子均匀分布，其中有一些钉子被拆掉，问最后小球落在 $m$ 格子的概率为多少？ 分析概率DP，把格子也看作钉子。 设 $f(i, j)$ 表示经过 $(i, j)$ 位置的所有路径数量，那么到达 $m$ 格子的概率就是 $f(n+1, m) / f(1, 1)$ ，这是因为任何一个路径一定经过 $(1, 1)$ ，所以 $f(1, 1)$ 为 $2^n$ 。 对于一个位置 $(i, j)$ ，如果它有钉子，那么可以转移到左下角 $(i+1, j)$ 或者右下角 $(i+1, j+1)$ ，路径数量为一半。 如果它没有钉子，那么它会直接转移到下面正对着的两行的位置 $(i+2, j+1)$ 。 我们可以从上往下枚举。 注意初始化 $f(1, 1)$ 和 $f(2, 1) 、 f(2, 2)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 55;bool ext[N][N]; // 表示在(i, j)这个位置有无钉子ll f[N][N]; // f(i, j) 表示存在(i, j)的路径的数量void solve (){ int n, m; cin &gt;&gt; n &gt;&gt; m; m += 1; f[1][1] = (1ll &lt;&lt; n+1); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) { char c; cin &gt;&gt; c; if (c == '*') ext[i][j] = true; } if (ext[1][1]) f[2][1] = f[2][2] = (1ll &lt;&lt; n); // 每个位置有三种情况 for (int i = 3; i &lt;= n + 1; i ++ ) { for (int j = 1; j &lt;= i; j ++ ) { f[i][j] = f[i-1][j-1] / 2 * ext[i-1][j-1] + \\ f[i-1][j] / 2 * ext[i-1][j] + \\ f[i-2][j-1] * (!ext[i-2][j-1]); } } ll g = __gcd(f[n+1][m], f[1][1]); cout &lt;&lt; f[n+1][m] / g &lt;&lt; '/' &lt;&lt; f[1][1] / g &lt;&lt; endl;}signed main (){ cout.tie(0)-&gt;sync_with_stdio(false); // int _; for (cin &gt;&gt; _; _ --; ) solve(); solve(); return 0;}","categories":[{"name":"DP","slug":"DP","permalink":"https://horb7.github.io/categories/DP/"}],"tags":[{"name":"期望DP","slug":"期望DP","permalink":"https://horb7.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"项目学习","slug":"项目学习","permalink":"https://horb7.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"图论","slug":"图论","permalink":"https://horb7.github.io/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数据库","slug":"数据库","permalink":"https://horb7.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"DP","slug":"DP","permalink":"https://horb7.github.io/categories/DP/"},{"name":"math","slug":"math","permalink":"https://horb7.github.io/categories/math/"}],"tags":[{"name":"区域站","slug":"区域站","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%AB%99/"},{"name":"codeforces","slug":"codeforces","permalink":"https://horb7.github.io/tags/codeforces/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://horb7.github.io/tags/Codeforces/"},{"name":"数字图像处理","slug":"数字图像处理","permalink":"https://horb7.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"线段树","slug":"线段树","permalink":"https://horb7.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"区域赛","slug":"区域赛","permalink":"https://horb7.github.io/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"},{"name":"每日一题","slug":"每日一题","permalink":"https://horb7.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Django","slug":"Django","permalink":"https://horb7.github.io/tags/Django/"},{"name":"树状数组","slug":"树状数组","permalink":"https://horb7.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"LCA","slug":"LCA","permalink":"https://horb7.github.io/tags/LCA/"},{"name":"牛客集训营","slug":"牛客集训营","permalink":"https://horb7.github.io/tags/%E7%89%9B%E5%AE%A2%E9%9B%86%E8%AE%AD%E8%90%A5/"},{"name":"math","slug":"math","permalink":"https://horb7.github.io/tags/math/"},{"name":"tree","slug":"tree","permalink":"https://horb7.github.io/tags/tree/"},{"name":"贪心","slug":"贪心","permalink":"https://horb7.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"生成树","slug":"生成树","permalink":"https://horb7.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"Linux","slug":"Linux","permalink":"https://horb7.github.io/tags/Linux/"},{"name":"MySql","slug":"MySql","permalink":"https://horb7.github.io/tags/MySql/"},{"name":"环形DP","slug":"环形DP","permalink":"https://horb7.github.io/tags/%E7%8E%AF%E5%BD%A2DP/"},{"name":"树","slug":"树","permalink":"https://horb7.github.io/tags/%E6%A0%91/"},{"name":"堆","slug":"堆","permalink":"https://horb7.github.io/tags/%E5%A0%86/"},{"name":"并查集","slug":"并查集","permalink":"https://horb7.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://horb7.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"project","slug":"project","permalink":"https://horb7.github.io/tags/project/"},{"name":"期望DP","slug":"期望DP","permalink":"https://horb7.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]}