<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>牛客秋季算法班LCA-E-华华和月月种树</title>
      <link href="/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/"/>
      <url>/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-E-%E5%8D%8E%E5%8D%8E%E5%92%8C%E6%9C%88%E6%9C%88%E7%A7%8D%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="华华和月月种树"><a href="#华华和月月种树" class="headerlink" title="华华和月月种树"></a>华华和月月种树</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>维护一个动态有根树，每个点都有一个权值，开始时只有一个 $0$ 号节点，权值为 $0$ 。有以下操作：</p><ol><li>$1 \ \ i$ ，表示 $i$ 节点长出一个新的子节点，权值为 $0$ ，编号为目前最大编号 $+1$ 。</li><li>$2 \ \ i \ \ a$ ，表示节点 $i$ 的子树的所有节点 (包括 $i$ 节点) 权值 $+a$ 。</li><li>$3 \ \ i$ ，表示查询节点 $i$ 此时的权值。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>离线 + 树状数组</strong></p><p>先根据所有的操作建立一棵树，求得所有节点的dfs序，即可在区间上操作。</p><p>树状数组维护差分的前缀。</p><p>对于操作1，记录它在权值为 $0$ 的时候（刚被开辟出来）它的前缀和，查询该点时减去这个值即可。</p><p>对于操作2，只需要在 $[l[i], r[i]]$ 上所有点权值 $+a$ 即可，使用差分。其中 $l[i]$ 和 $r[i]$ 表示 $i$ 点的进出栈时间(dfs序) 。</p><p>对于操作3，查询前缀和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> op[N], a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> val[N], c[N], l[N], r[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 一开始有一个节点0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    l[u] = ++ cnt; <span class="comment">// 最早的timestamp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (u != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    r[u] = cnt; <span class="comment">// 最晚的timestamp</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) c[x] += v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) res += c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; op[i] &gt;&gt; a[i];</span><br><span class="line">        ++ a[i]; <span class="comment">// 注意树状数组只能维护[1, n]的区间，不能包括0</span></span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            g[a[i]].<span class="built_in">push_back</span>(++ cnt);</span><br><span class="line">            b[i] = cnt; <span class="comment">// b[i]表示第i个操作后，新的节点编号</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>) cin &gt;&gt; b[i]; <span class="comment">// b[i]表示加多少</span></span><br><span class="line">    }</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 转化为dfs序，进行区间运算</span></span><br><span class="line">    <span class="comment">// 树状数组的区间加+单点查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="number">1</span>) <span class="comment">// 加新的节点</span></span><br><span class="line">        {</span><br><span class="line">            val[l[b[i]]] += <span class="built_in">query</span>(l[a[i]]); <span class="comment">// val(i)表示i点加了多少</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">update</span>(l[a[i]], b[i]);</span><br><span class="line">            <span class="built_in">update</span>(r[a[i]] + <span class="number">1</span>, -b[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(l[a[i]]) - val[l[a[i]]] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客秋季算法班LCA-D.Alliances</title>
      <link href="/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/"/>
      <url>/2022/02/20/%E7%89%9B%E5%AE%A2%E7%A7%8B%E5%AD%A3%E7%AE%97%E6%B3%95%E7%8F%ADLCA-D-Alliances/</url>
      
        <content type="html"><![CDATA[<h1 id="Alliances"><a href="#Alliances" class="headerlink" title="Alliances"></a>Alliances</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>链接：<a href="https://ac.nowcoder.com/acm/contest/27836/D">https://ac.nowcoder.com/acm/contest/27836/D</a></p><p>  树国是一个有 $n$ 个城市的国家，城市编号为 $1 \sim n$ 。连接这些城市的道路网络形如一棵树， </p><p>  即任意两个城市之间有恰好一条路径。城市中有k个帮派，编号为 $1 \sim k$ 。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。 </p><p>  当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。 </p><p>  shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于选定的首都 $V$ 和选定的帮派，假设他们所有占领的城市的 lca 为 LCA ，那么有下面两个情况：</p><ol><li><p>lca(V, LCA) != LCA</p><p>那么被占据城市距离 $V$ 的最短距离为 $Dist(V, LCA)$ 。</p></li><li><p>lca(V, LCA) == LCA</p><p>即首都在 LCA 的子树中。对这棵子树作 dfs 序，那么距离 $V$ 最短的为 dfn 第一个在 $V$ 前面的或者第一个在 $V$ 后面的，取最小值即可。可以使用二分降低复杂度。</p><p>这里需要注意的是被占据的城市路径上的所有城市也都被占领，他们不会影响每个帮派城市lca的预处理，但会影响第二种情况，所以求的时候还需要加一个lca。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N]; <span class="comment">// 整图</span></span><br><span class="line"><span class="keyword">int</span> depth[N], f[N][<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; q[N]; <span class="comment">// 帮派图</span></span><br><span class="line"><span class="keyword">int</span> dfn[N], timestamp;</span><br><span class="line"><span class="keyword">int</span> top[N]; <span class="comment">// top(i) 表示i帮派占领的城市的lca</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> <span class="comment">// 根据dfs求出dfn和st表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[u] = ++ timestamp; depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i ++ ) f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) <span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[f[a][i]] &gt;= depth[b]) a = f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> depth[a] + depth[b] - <span class="number">2</span> * depth[<span class="built_in">lca</span>(a, b)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 求出帮派图，邻接表按照dfn排序</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u); q[i].<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">if</span> (!j) top[i] = u;</span><br><span class="line">            <span class="keyword">else</span> top[i] = <span class="built_in">lca</span>(top[i], u);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 按照dfn排序</span></span><br><span class="line">        <span class="built_in">sort</span>(q[i].<span class="built_in">begin</span>(), q[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b){</span><br><span class="line">            <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> V, LCA, u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;u); <span class="comment">// LCA为被选择的帮派的lca</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; x; <span class="comment">// x存储被选择的帮派</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v); x.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (!i) LCA = top[v];</span><br><span class="line">            <span class="keyword">else</span> LCA = <span class="built_in">lca</span>(LCA, top[v]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果V和LCA的lca不是LCA，那么他们的最短距离即为V和LCA的距离</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lca</span>(V, LCA) != LCA)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">dist</span>(V, LCA));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则离V最近的一定是dfn序中靠近V的前面一个或者后面一个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e : x)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> siz = q[e].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = siz;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfn[q[e][mid]] &gt;= dfn[V]) r = mid;</span><br><span class="line">                    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="number">0</span>) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r - <span class="number">1</span>])));</span><br><span class="line">                <span class="keyword">if</span> (r != siz) ans = <span class="built_in">min</span>(ans, <span class="built_in">dist</span>(V, <span class="built_in">lca</span>(V, q[e][r])));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022寒假算法集训营5</title>
      <link href="/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/"/>
      <url>/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A55/</url>
      
        <content type="html"><![CDATA[<h1 id="A-疫苗小孩"><a href="#A-疫苗小孩" class="headerlink" title="A. 疫苗小孩"></a>A. 疫苗小孩</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的01字符串，可以选择至多三个 $0$ ，假设它们的位置为 $i, j, k$ ，则 $W_j = w - |k-p|\times q$ ，$W_k = w - |k-p| \times q$ 。求问 $W_j + W_k$ 最大为多少。</p><p>其中 $p$ 表示与前一个选定的 $0$ 的位置差，$w, k, q$ 为给定值。</p><p>其中 $n \le 10^6, 1\le k, w, q \le 10^9$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于 $W_j$ ，要使其最大需要使 $p$ 最小，即 $i$ 与 $j$ 的差值尽量接近 $k$ ，$W_k$ 同理。</p><p>枚举 $j$ 的位置，然后使用二分求得最接近 $j-k$ 的位置（有两个可能的位置），同理求出 $j+k$ 的位置即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; zeros; <span class="comment">// 存储所有0的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) zeros.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> best, w, q; cin &gt;&gt; best &gt;&gt; w &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">0</span> || x &gt;= zeros.<span class="built_in">size</span>(); };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zeros.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] - best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">lower_bound</span>(zeros.<span class="built_in">begin</span>(), zeros.<span class="built_in">end</span>(), zeros[i] + best) - zeros.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// 注意pos1为第一个大于等于j-k的位置，pos1-1也可能最接近j-k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l : {<span class="number">-1</span>, <span class="number">0</span>}) <span class="comment">// pos2同理</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos1+k) || pos1+k &gt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> now = w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[i]-zeros[pos1+k])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 只选择前两个0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(pos2+l) || pos2+l &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                now = now + w - <span class="built_in">abs</span>(best - <span class="built_in">abs</span>(zeros[pos2+l]-zeros[i])) * q;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now); <span class="comment">// 选择三个0</span></span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-战旗小孩"><a href="#C-战旗小孩" class="headerlink" title="C. 战旗小孩"></a>C. 战旗小孩</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 局游戏和原始分数 $start$，每局游戏可以选择两个英雄中的一个，使用礼遇可以选择多两个可选择英雄。</p><p>每局游戏结束后的分数为原始分数加上英雄强度。</p><p>给出每局游戏结束后上榜需要的分数，以及 $m$ 次至多能够使用的礼遇次数，和每局游戏的可选英雄强度。</p><p>游戏的顺序可以任意调整，问进行 $n$ 局游戏后，最多能够上榜几次？</p><p>$1 \le m \le n \le 20$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>二进制枚举哪些局需要使用礼遇，求出每局游戏结束后所选择的英雄强度。</p><p>由于游戏顺序可以任意调整，所以一定是先选择英雄强度高的那一局游戏，在选择低的，这样能尽量满足上榜分数。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">score</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : score) cin &gt;&gt; x;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">all</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ )</span><br><span class="line">            cin &gt;&gt; all[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ ) <span class="comment">// 枚举哪些局需要使用礼遇</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(i) &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) v.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(all[j].<span class="built_in">begin</span>(), all[j].<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="built_in">max</span>(all[j][<span class="number">0</span>], all[j][<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, st = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            st += v[i];</span><br><span class="line">            <span class="keyword">if</span> (st &gt;= score[i]) ++ now;</span><br><span class="line">        }</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-复苏小孩"><a href="#E-复苏小孩" class="headerlink" title="E. 复苏小孩"></a>E. 复苏小孩</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>三只鬼的力量分别为 $1, 1, 1$ ，遍历由 $123$ 构成的字符串时，走到 ‘$i$’ 则第 $i$ 只鬼吸收其他两只鬼一半的力量。</p><p>给定长度为 $n$ 的字符串和 $m$ 次查询，查询有以下两个操作：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个位置的字符改为 $y$ 。</li><li>$2 \ l \ r$ ，询问遍历 $[l, r]$ 子串后三只鬼的力量分别为多少。</li></ol><p>其中 $1 \le n, m \le 10^5$ 。</p><p>答案对 998244353 取模。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>假设走到 ‘1’ 位置，则相当于三只鬼的力量乘上矩阵：</p><script type="math/tex; mode=display">\left[\begin{matrix}    1 & 0 & 0 \\    \dfrac 1 2 & \dfrac 1 2 & 0 \\    \dfrac 1 2 & 0 & \dfrac 1 2 \\\end{matrix}\right]</script><p>‘2’和’3’同理，所以可以使用线段树维护区间上矩阵的乘积。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= P; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, P<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> {</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() { <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) { a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">0</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) { a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = inv; }</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span>) { a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">2</span>] = inv; }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildI</span> <span class="params">()</span> </span>{ <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) a[i][i] = <span class="number">1</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>* (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b) {</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                ans.a[i][j] = (ans.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line">    Matrix mt; <span class="comment">// mt为[l, r]区间矩阵相乘的结果</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">};</span><br><span class="line">seg_tree t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">    t[p].mt = t[<span class="built_in">lc</span>(p)].mt * t[<span class="built_in">rc</span>(p)].mt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(s[l] - <span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        t[p].mt.<span class="built_in">build</span>(v<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Matrix ret; ret.<span class="built_in">buildI</span>();</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].mt;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = ret * <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    Matrix root = t[<span class="number">1</span>].mt;</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Matrix ret = <span class="built_in">query</span>(<span class="number">1</span>, x, y);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++, v = <span class="number">0</span> )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">                    v = (v + ret.a[j][i]) % P;</span><br><span class="line">                cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客集训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022寒假算法训练营4</title>
      <link href="/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/"/>
      <url>/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A54/</url>
      
        <content type="html"><![CDATA[<h1 id="B-进制"><a href="#B-进制" class="headerlink" title="B. 进制"></a>B. 进制</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的数字串 $s$ (只有 ‘0’ ~ ‘9’ 这十种字符) ，给定 $q$ 次询问，每次询问有以下两种：</p><ol><li>$1 \ x \ y$ ，表示将第 $x$ 个字符修改为 $y$ ，即令 $s_x = y$ 。</li><li>$2 \ x \ y$ ，查询区间 $[l, r]$ 串能够代表的某个进制的最小值，输出其十进制表示，结果对 $1e9+7$ 取模。</li></ol><p>其中 $1 \le n, q \le 10^5$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于某个固定的区间，其每个位的数码是不变的，那么位权越小，能够表示的数字越小。所以使其最小的进制为其 $max + 1$， $max$ 表示区间最大值。</p><p>所以我们可以使用线段树维护两个信息：区间的最大值、区间数字按照九种进制运算得到的十进制数值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">2</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = (ll)ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">11</span>], maxv;</span><br><span class="line">} t[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ )</span><br><span class="line">        t[p].d[i] = ((ll)t[<span class="built_in">lc</span>(p)].d[i] * <span class="built_in">quick_power</span>(i, t[<span class="built_in">rc</span>(p)].r - t[<span class="built_in">rc</span>(p)].l + <span class="number">1</span>) % mod + t[<span class="built_in">rc</span>(p)].d[i]) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = a[l];</span><br><span class="line">        t[p].maxv = a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r &amp;&amp; t[p].l == x)</span><br><span class="line">    {</span><br><span class="line">        a[x] = v;</span><br><span class="line">        t[p].maxv = v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i ++ ) t[p].d[i] = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].maxv;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> (ll)t[p].d[v] * <span class="built_in">quick_power</span>(v, r - t[p].r) % mod;</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) (ret += <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) (ret += <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r, v)) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r, <span class="built_in">query</span>(<span class="number">1</span>, l, r) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-在这冷漠的世界里光光哭哭"><a href="#L-在这冷漠的世界里光光哭哭" class="headerlink" title="L. 在这冷漠的世界里光光哭哭"></a>L. 在这冷漠的世界里光光哭哭</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的仅由小写字母构成的字符串 $s$ ，给出 $q$ 次查询，每次查询给出一个区间 $[l, r]$ 和一个长度为 $3$ 的字符串 $abc$ ，问：在 $[l, r]$ 中有多少个 $abc$ 的子序列？</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>设 $f3(k, i, j)$ 表示前 $k$ 个字符中，有多少个 $i, s[k], j$ 这样的子序列。</p><p>对于每次查询，二分算出 $b$ 字符在 $[l, r]$ 中出现的第一次位置 $pos1$ 和最后一次位置 $pos2$。</p><p>那么 $f3(pos2, a, c) - f3(pos1-1, a, c)$ 即为，当 $k$ 在 $[l, r]$ 时的所有 $abc$ 的子序列个数。</p><p>根据容斥，再将其减去 $ (a) [bc], (a) [b] (c), [ab] (c) $ 即可。其中$[ \quad ]$ 表示其在 $[l, r]$ 范围内。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80010</span>, M = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> n, q; <span class="keyword">char</span> s[N];</span><br><span class="line">ll f1[N][M]; <span class="comment">// f(i, j)表示前i个字符中有多少个j</span></span><br><span class="line">ll f2[N][M][M]; <span class="comment">// f(i, j, k)表示前i个字符中有多少个 "jk"</span></span><br><span class="line">ll f3[N][M][M]; <span class="comment">// f(k, i, j)表示前k个字符中，有多少个"i s[k] j"，注意k为最后一个字符</span></span><br><span class="line">ll tmp[M][M][M]; <span class="comment">// tmp(k, i, j)表示前k个字符中，有多少个 "i k j"</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[M]; <span class="comment">// g(c)存储字符c的所有位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 计算[l, r]有多少个"ab"</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> f2[r][a][b] - f2[l<span class="number">-1</span>][a][b] - f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        g[id].<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++ ) g[i].<span class="built_in">push_back</span>(<span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ ) f1[i][j] = f1[i<span class="number">-1</span>][j] + (j == s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                f2[i][j][k] = f2[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (k == s[i] - <span class="string">'a'</span> + <span class="number">1</span>) f2[i][j][k] += f1[i<span class="number">-1</span>][j];</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; k ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// "j s[i] k"</span></span><br><span class="line">                <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">                tmp[id][j][k] += f1[i<span class="number">-1</span>][j] * (f1[n][k] - f1[i][k]);</span><br><span class="line">                f3[i][j][k] = tmp[id][j][k];</span><br><span class="line">            }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="keyword">static</span> <span class="keyword">char</span> op[<span class="number">4</span>]; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;l, &amp;r, op + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = op[<span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = op[<span class="number">2</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = op[<span class="number">3</span>] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f1[r][b] - f1[l<span class="number">-1</span>][b] == <span class="number">0</span>) { cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lower_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), l) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">upper_bound</span>(g[b].<span class="built_in">begin</span>(), g[b].<span class="built_in">end</span>(), r) - g[b].<span class="built_in">begin</span>();</span><br><span class="line">        ll ans = f3[g[b][pos2<span class="number">-1</span>]][a][c] - f3[g[b][pos1<span class="number">-1</span>]][a][c]; <span class="comment">// b在[l, r]时，所有的"abc"的数量</span></span><br><span class="line">        <span class="comment">// 容斥，减去(a)[bc],(a)[b](c),[ab](c)</span></span><br><span class="line">        ans -= f1[l<span class="number">-1</span>][a] * <span class="built_in">cal</span>(l, r, b, c) + </span><br><span class="line">            f1[l<span class="number">-1</span>][a] * (f1[r][b] - f1[l<span class="number">-1</span>][b]) * (f1[n][c] - f1[r][c]) + </span><br><span class="line">            <span class="built_in">cal</span>(l, r, a, b) * (f1[n][c] - f1[r][c]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客集训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022寒假算法集训营3</title>
      <link href="/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/"/>
      <url>/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A53/</url>
      
        <content type="html"><![CDATA[<h1 id="C-智乃买瓜-another-version"><a href="#C-智乃买瓜-another-version" class="headerlink" title="C. 智乃买瓜(another version)"></a>C. 智乃买瓜(another version)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>智乃来到水果摊前买瓜，水果摊上贩卖着若干个不同的西瓜，第 $i$ 个西瓜的重量为 $w_i$ ，智乃可以买整个瓜 $w_i$ 或者把瓜劈开买半个瓜，半个瓜的重量为 $\dfrac {w_i} 2$ 。</p><p>也就是说对于每个瓜，智乃都有三种不同的决策：</p><ol><li>购买一整个重量为 $w_i$ 的西瓜。</li><li>把瓜劈开，购买半个重量为 $\dfrac {w_i} 2$ 的西瓜。</li><li>不进行购买操作。</li></ol><p>注意，每个瓜的重量都为正偶数。</p><p>现在智乃知道，购买西瓜的重量和分别为 $k = 1, 2, 3 \ldots M$ 时，购买西瓜的方案数（对 $1e9+7$ 取模）。</p><p>请构造出一个水果摊上 $N$ 个西瓜的重量，使得满足所要求的方案数量。保证数据存在 $N \le 10^3$ 的合法解。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于<strong>西瓜的重量为正偶数</strong>，所以对于重量为 $1$ 的方案，它只能由重量为 $2$ 的西瓜劈开得到。</p><p>那么我们就可以根据 $k=1$ 的情况，<strong>去除掉所有方案数中重量为 $2$ 的西瓜对其造成的影响。</strong></p><p>去除后，所有的方案数都不会和重量为 $2$ 的西瓜有关，那么 $k=2$ 时的方案数就只能由重量为 $4$ 的西瓜构成。</p><p>依次去除所有的西瓜即可，把去除的西瓜加到结果数组即可。</p><p><strong>注意点</strong>：</p><ol><li>正向dp的枚举顺序是从后往前，目的是沿用上一层的原始数据。逆向dp也需要减去原始数据，所以要从前往后，否则减去的是这一层的数据。</li><li>正向dp时 $dp[0] = 1$ ，逆向dp也需要加上去。</li></ol><p>本题提示了西瓜的质量为正偶数，如果没有提示，也要往构造所有正偶数质量西瓜去思考。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> (x % p + p) % p; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; dp[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">while</span>(dp[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 把 2*i 的西瓜去除</span></span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">2</span> * i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">            {</span><br><span class="line">                dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j-i]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">2</span> * i) dp[j] = <span class="built_in">mod</span>(dp[j] - dp[j<span class="number">-2</span>*i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-智乃的树旋转-hard-version"><a href="#H-智乃的树旋转-hard-version" class="headerlink" title="H. 智乃的树旋转(hard version)"></a>H. 智乃的树旋转(hard version)</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $N$ 个节点的二叉树，智乃将其做了若干次旋转将其打乱，她想要将其还原，要求旋转操作次数不超过 $N^2$ 次。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote><p>第一行输入正整数 $N$ ($1 \le N \le 10^3$) ，表示二叉树的节点数量。</p><p>接下来 $N$ 行输入二叉树一开始的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为 $0$ 时，则表示该节点无右子树。</p><p>接下来 $N$ 行输入二叉树被打乱后的样子。</p><p>每行输入两个非负整数 $lch,rch(0≤lch,rch≤N)$ 表示每个节点的左右子树。</p><p>当 $lch$ 的值为 $0$ 时，则表示该节点无左子树，当 $rch$ 的值为$0$时，则表示该节点无右子树。</p><p>要求你将打乱后的二叉树通过一系列旋转操作还原</p></blockquote><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote><p>首先输出一个整数 $K$ ，表示你还原二叉树进行旋转的次数，要求你给出 $K$ 的范围在 $[0,N2]$ ，接下来 $K$ 行，依次输出旋转操作的旋转轴。</p><p>由于旋转轴只能进行左旋转或者右旋转其中的一种，裁判程序将会自己判断当前需要进行的是左旋转还是右旋转。</p><p>注意：旋转过程中的根节点无法作为旋转轴进行旋转，如果你指定旋转过程中的根节点作为旋转轴，则裁判程序将直接给出WA的结果。</p></blockquote><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>如何将打乱的树还原？可以按照原来的树的先序遍历，依次把每个节点在打乱的树上做splay，单旋情况下，每个节点最多旋转 $n-1$ 次，总次数不超过 $n^2$ 的 数量级。</p><p>所以只需要记录每次旋转时的旋转轴即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> {</span> <span class="keyword">int</span> fa, ch[<span class="number">2</span>]; } a[N], t[N]; <span class="comment">// 原树和打乱后的树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 把u节点向上旋转一次</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> fa = t[u].fa;</span><br><span class="line">    <span class="keyword">int</span> gfa = t[fa].fa;</span><br><span class="line">    <span class="keyword">int</span> t1 = (u != t[fa].ch[<span class="number">0</span>]); <span class="comment">// u是fa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> t2 = (fa != t[gfa].ch[<span class="number">0</span>]); <span class="comment">// fa是gfa的左/右孩子</span></span><br><span class="line">    <span class="keyword">int</span> ch = t[u].ch[t1 ^ <span class="number">1</span>]; <span class="comment">// 需要被用来和fa交换的u的孩子</span></span><br><span class="line">    t[u].fa = gfa;</span><br><span class="line">    t[u].ch[t1 ^ <span class="number">1</span>] = fa;</span><br><span class="line">    t[fa].ch[t1] = ch;</span><br><span class="line">    t[fa].fa = u;</span><br><span class="line">    t[ch].fa = fa;</span><br><span class="line">    t[gfa].ch[t2] = u;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入树，返回这个树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_tree</span> <span class="params">(tree * t, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        t[i].ch[<span class="number">0</span>] = u; t[i].ch[<span class="number">1</span>] = v;</span><br><span class="line">        vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (u) t[u].fa = i;</span><br><span class="line">        <span class="keyword">if</span> (v) t[v].fa = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N] = { <span class="literal">true</span> }; <span class="comment">// 当前点是否被旋转到根过，0设置为true，因为0是树根的fa</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">int</span> n, root_a, <span class="keyword">root_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(!st[t[u].fa]) <span class="comment">// 父节点还没有被旋转，也就是还没有修正</span></span><br><span class="line">    {</span><br><span class="line">        ret.<span class="built_in">push_back</span>(u); <span class="comment">// u需要旋转</span></span><br><span class="line">        <span class="built_in">rot</span>(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u)</span> <span class="comment">// 先序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">splay</span>(u); st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">0</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (a[u].ch[<span class="number">1</span>]) <span class="built_in">dfs</span>(a[u].ch[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    root_a = <span class="built_in">input_tree</span>(a, n);</span><br><span class="line">    <span class="keyword">root_t</span> = <span class="built_in">input_tree</span>(t, n);</span><br><span class="line">    <span class="built_in">dfs</span>(root_a); <span class="comment">// 对原树进行先序遍历，依次对打乱的树进行splay</span></span><br><span class="line">    cout &lt;&lt; ret.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : ret) cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-智乃的C语言模除方程"><a href="#J-智乃的C语言模除方程" class="headerlink" title="J. 智乃的C语言模除方程"></a>J. 智乃的C语言模除方程</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$x \ \% \ P = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>模除方程 $x \ \% \ P = Q$ ，即 $x = k \times P + Q$ ，$Q &lt; P$ 。</p><p>由于 $Q$ 是 $[l, r]$ 的任意整数，所以显然 $x$ 的定义域为若干个连续子段。</p><p>对于 $[L, R]$ 的查询，设 $f(X)$ 表示 $[0, abs(X)]$ 中满足条件的 $x$ 数量。</p><p>然后需要根据 $L, R$ 的大小分类。</p><ol><li><p>$0 \le L \le R$ </p><p>答案为 $f(R) - f(L - 1)$ 。</p></li><li><p>$L \le 0 \le R$</p><p>答案为 $f(R) + f(L) - f(0)$ 。</p></li><li><p>$L \le R \le 0$ </p><p>答案为 $f(L) - f(R + 1)$ 。</p></li></ol><p>所以接下来需要求出 $f(x)$ 。这里又需要对 $x$ 的大小分类。</p><ol><li><p>$x \ge 0$ </p><p>$f(x)$ 表示 $[0, x]$ 范围，算出所有子段与 $[0, x]$ 的交集。</p><p>整段一共有 $x/P$ 个，注意每一段都要和 $[l, r]$ 取交集 ，然后算出最后一段 $[0, x\%P]$ 和 $[l, r]$ 的交集。</p><p>取交集：$x \% P$ 的余数范围 $[0, P-1]$ ，而 $Q$ 范围 $[l, r]$ ，需要取交集。</p></li><li><p>$x \lt 0$ </p><p>$f(x)$ 表示 $[-x, 0]$ 的范围，也需要算出所有子段与 $[-x, 0]$ 的交集。</p><p>但是由于C语言模除的结果与被除数相同，所以最后的答案也为负数，所以余数范围为负数 $[-P+1, 0]$ 。</p></li></ol><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="comment">// [l, r] 与 [a, b] 的交集</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, <span class="built_in">min</span>(r, b) - <span class="built_in">max</span>(a, l) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(u/p) * <span class="built_in">get</span>(-p+<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">get</span>(u%p,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u/p * <span class="built_in">get</span>(<span class="number">0</span>, p<span class="number">-1</span>) + <span class="built_in">get</span>(<span class="number">0</span>, u%p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    p = <span class="built_in">abs</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= <span class="number">0</span> &amp;&amp; R &gt;= <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(L) + <span class="built_in">f</span>(R) - <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; <span class="number">0</span> &amp;&amp; R &gt; <span class="number">0</span>) cout &lt;&lt; <span class="built_in">f</span>(R) - <span class="built_in">f</span>(L<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">f</span>(L) - <span class="built_in">f</span>(R+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-智乃的C语言模除方程-another-version"><a href="#K-智乃的C语言模除方程-another-version" class="headerlink" title="K. 智乃的C语言模除方程(another version)"></a>K. 智乃的C语言模除方程(another version)</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定模除方程：$P \ \% \ x = Q(Q \in [l, r])$ 。其中 $x$ 为未知数，$P$ 为给定常数，$Q$ 为 $[l, r]$ 中的任意整数， $\%$ 遵循C语言的规则。</p><p>给定整数答案区间 $[L, R]$ ，问在 $[L, R]$ 中有多少符合条件的整数 $x$ 满足给定的方程。</p><p>其中 $-10^9 \le P, l, r, L, R \le 10^9$ 且 $P != 0, l \le r, L \le R$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>本题和上题唯一的区别在于 $x$ 和 $P$ 在方程的位置交换。</p><p>对于 $P \ \% \ x = Q$ ，有 $P - \lfloor \dfrac P x \rfloor \times x = Q$ 。</p><p>枚举 $x$ 的值，则可以知道 $\lfloor \dfrac P x \rfloor$ 的值，令其为 $c$ ，则变为 $P - c \times x = Q$ 。其中 $P - c \times x$ 为等差数列。</p><p>则问题变为：给定等差数列，问其第 $L$ 项到第 $R$ 项，有多少项在 $[l, r]$ 中。</p><p>根据 $\lfloor \dfrac P x \rfloor$ 的性质，可以使用整除分块来枚举 $x$ 的值。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">ll P, l, r, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">intersect</span> <span class="params">(ll l0, ll r0, ll l1, ll r1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(l0, l1);</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(r0, r1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, ansr - ansl + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span> <span class="params">(ll k, ll cl, ll cr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ansr = <span class="built_in">min</span>(cr,(P-l)/k);</span><br><span class="line">    ll ansl = <span class="built_in">max</span>(cl,(P-r+k<span class="number">-1</span>)/k);</span><br><span class="line">  </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ans += <span class="built_in">intersect</span>(ansl,ansr,L,R);</span><br><span class="line">    ans += <span class="built_in">intersect</span>(-ansr,-ansl,L,R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="keyword">if</span> (P &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        P = -P;</span><br><span class="line">        <span class="built_in">swap</span>(l, r);</span><br><span class="line">        l = -l;</span><br><span class="line">        r = -r;</span><br><span class="line">    }</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">0ll</span>, l);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先枚举x的值绝对值在P范围内的情况，即[1, P]</span></span><br><span class="line">    <span class="keyword">for</span> (ll cl = <span class="number">1</span>, cr; cl &lt;= P; cl = cr + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ll k = P / cl;</span><br><span class="line">        cr = P / k;</span><br><span class="line">        ans += <span class="built_in">cal</span>(k, cl, cr); <span class="comment">// 计算x的倍数为k，且x位于[cl, cr]时的情况</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= P &amp;&amp; r &gt;= P)</span><br><span class="line">    {</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, P+<span class="number">1</span>, (ll)(<span class="number">1e10</span>));</span><br><span class="line">        ans += <span class="built_in">intersect</span>(L, R, -(ll)(<span class="number">1e10</span>), -(P+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客集训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022寒假算法集训营2</title>
      <link href="/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/"/>
      <url>/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A52/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="A-小沙的炉石"><a href="#A-小沙的炉石" class="headerlink" title="A. 小沙的炉石"></a>A. 小沙的炉石</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 张法术攻击牌和 $m$ 张法术恢复牌，每次攻击消耗一点法力，造成 $1$ 点伤害，恢复牌不消耗法力，可以恢复一点法力。小沙一开始有 $1$ 点法力，法力没有上限。</p><p>每次使用一张法力牌，都会使后面的攻击伤害 $+1$ 。</p><p>给出 $q$ 次询问，每次给出敌人的血量，问能否将其<strong>恰好斩杀</strong>？</p><p>恰好斩杀：正好使得敌方血量变为 $0$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果使用的攻击牌和恢复牌的数量一定，那么可以造成的伤害一定是一个连续的区间。</p><blockquote><p>假设使用 $a$ 张攻击牌和 $b$ 张恢复牌，注意 $a \le b + 1$ 。</p><p>此时最小攻击伤害为：攻击、恢复、攻击、恢复…… ，伤害为 $\sum_{i=1}^a{2 \times i - 1} = a ^ 2$ 。</p><p>每次可以将序列中的一对 [攻击，恢复] 组合调换，造成伤害 $+1$ 。</p><p>最大伤害为：恢复、恢复、恢复、……、攻击、攻击。伤害为 $\sum_{i=1}^{a} b + i = \dfrac {((b + 1) + (b + a)) * a} 2$ 。 </p></blockquote><p>对于每次询问，由于需要恰好斩杀，因此<strong>最多</strong>能够使用的攻击牌是 $min(min(n, m+1), sqrt(hp))$ 。</p><p>由于造成伤害的区间是连续的，因此只需要看最大能造成的伤害是否超过 $hp$ 即可。</p><p>不需要判断最小造成的伤害，因为取到的攻击牌数一定 $\le$ $sqrt(hp)$ 。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    n = <span class="built_in">min</span>(n, m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> hp; cin &gt;&gt; hp;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">min</span>(n, (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(hp));</span><br><span class="line">        <span class="keyword">int</span> maxv = (m + <span class="number">1</span> + m + R) * R / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxv &gt;= hp) cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-小沙的魔法"><a href="#B-小沙的魔法" class="headerlink" title="B. 小沙的魔法"></a>B. 小沙的魔法</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个点和 $m$ 条边，初始时每个点权值为 $x_i = 0$ 。初始时图上无边，每次可以进行以下操作中的一种：</p><ol><li>在 $m$ 条边中选择一条没有被选择过的边加入图中。</li><li>将图中的一个极大连通子图的每个点权值 $+1$ 。</li></ol><p>给定边可能出现重边，自环。</p><p>问最少操作多少次操作2，才能使对于任意点有 $x_i = a_i$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>要使区间增加到目标值，等价于区间每个值初始为 $a_i$ ，每次使得区间值 $-1$ ，最终使区间值全部为 $0$ 。</p><p>优先减去权值最大的，在减去权值最大点的同时，可以顺带减去和它在同一个连通子图的所有点的权值，这整个连通子图全部变为 $0$ ，代价就是权值最大的那个点的权值。</p><p>按权值对每个点的位置排序，从大到小依次遍历当前点的相邻点，把当前点和权值比它大的点合并，先把权值大的点减到和当前点相同的权值，代价为 $a_{gt} - a_{cur}$ 。</p><p>这样最后的图会形成若干个连通子图，再把这些连通子图最小的权值加起来就是最少需要的操作2，加最小权值是因为我们先把比它大的权值点先减到和它权值相同。这也意味这合并时要以权值小的点为根。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[N], id[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">iota</span>(f, f + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">iota</span>(id, id + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) {</span><br><span class="line">        <span class="keyword">return</span> a[x] &gt; a[y]; </span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = id[i]; i &lt;= n; i ++, u = id[i] )</span><br><span class="line">    {</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = h[u]; ~k; k = ne[k])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[k];</span><br><span class="line">            <span class="keyword">int</span> pu = <span class="built_in">find</span>(u), pj = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (vis[j] &amp;&amp; pu != pj)</span><br><span class="line">            {</span><br><span class="line">                res += a[pj] - a[u];</span><br><span class="line">                f[pj] = pu;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i) res += a[i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-小沙的长路"><a href="#E-小沙的长路" class="headerlink" title="E. 小沙的长路"></a>E. 小沙的长路</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>规定有向完全图每条边只能走一次，问：$n$ 个点的有向完全图的最长路径的最大值和最小值分别为多少？</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>$n$ 个点的有向完全图，最长路径一定经过了 $n$ 个点。</p><p>对于最小：如果图上有环，那么经过环一定比不经过环更长，所以我们要使图上无环，这样每个点只走一次，最短为 $n-1$ 。</p><p>对于最长：尽可能走完所有边，等价于给定有向完全图，删除尽可能少的边，使得剩下的图为欧拉图。如果 $n$ 为奇数，那么每个点连接偶数条边，一定存在一个有向无环图为欧拉图。如果 $n$ 为偶数，每个点连接奇数条边，欧拉图至多有 $2$ 个奇数点，也就是要使得 $n-2$ 个点变成偶数，删除一条边改变两个点度的奇偶性，所以需要删除 $\dfrac {n-2} 2$ 条边。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxv;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> maxv = n * (n - <span class="number">1</span>) / <span class="number">2</span> - (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; maxv &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-小沙的算数"><a href="#F-小沙的算数" class="headerlink" title="F. 小沙的算数"></a>F. 小沙的算数</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个算数式（只包含加法和乘法），每次询问把一个数字替换为其他数字，问替换完后的结果为多少？（询问不独立，上一次的修改会影响下一次询问）。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于算数式只包含加法和乘法，而乘法具有连乘性质，所以需要维护乘法区间的乘积。</p><p>对于乘法，只需要修改连乘区间的结果即可。对于加法，直接修改即可。</p><p>维护每个区间的乘法结果，可以使用并查集，开一个 $prod$ 数组表示每个集合的乘积。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, ret;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], prod[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_power</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= mod; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> <span class="built_in">quick_power</span>(x, mod<span class="number">-2</span>); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mod</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>{ <span class="keyword">return</span> (x % mod + mod) % mod; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    prod[y] = <span class="built_in">Mod</span>((ll)prod[y] * prod[x]);</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], prod[i] = a[i];</span><br><span class="line">    <span class="comment">// 把乘积合并起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, ans = a[i];</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans = <span class="built_in">Mod</span>((ll)ans * a[j + <span class="number">1</span>]);</span><br><span class="line">            vis[j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">merge</span>(j, j + <span class="number">1</span>);</span><br><span class="line">            ++ j;</span><br><span class="line">        }</span><br><span class="line">        ret = <span class="built_in">Mod</span>((ll)ret + ans);</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) ret = <span class="built_in">Mod</span>((ll)ret + a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id, to; cin &gt;&gt; id &gt;&gt; to;</span><br><span class="line">        <span class="keyword">if</span> (id != n &amp;&amp; s[id] == <span class="string">'*'</span> || id &gt; <span class="number">1</span> &amp;&amp; s[id<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于乘法区间</span></span><br><span class="line">            <span class="keyword">int</span> par = <span class="built_in">find</span>(id);</span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret + <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * <span class="built_in">Mod</span>((ll)to - a[id])));</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            prod[par] = <span class="built_in">Mod</span>((ll)<span class="built_in">Mod</span>((ll)prod[par] * <span class="built_in">inv</span>(a[id])) * to);</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 位于加法区间</span></span><br><span class="line">            ret = <span class="built_in">Mod</span>((ll)ret - a[id] + to);</span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            a[id] = to;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-小沙的身法"><a href="#G-小沙的身法" class="headerlink" title="G. 小沙的身法"></a>G. 小沙的身法</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个节点的无根无向树，每个节点有权值 $a_i$ ，规定从 $i$ 节点跳到其相邻节点 $j$ 的代价为 $max(0, a_j - a_i)$ 。即从权值低的点跳到权值高的点，代价为其权值差；从权值高的点跳到权值低的点，代价为 $0$ 。</p><p>给定 $m$ 次询问，每次询问：从地面(权值为 $0$)跳到 $u$ 节点，再从 $u$ 节点跳到 $v$ 节点，再从 $v$ 节点跳到地面，最少消耗的代价为多少？</p><p>其中 $1 \le n \le 10^6$ ，$1 \le m \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>对于无向树而言，两个节点之间只有一条简单路径。所以要消耗体力最小，就是走这条简单路径，即路径是唯一的。</p><p>从地面跳到 $u$ 节点，从 $v$ 节点跳到地面的代价为 $a_u$ 。</p><p>从 $u$ 点跳到 $v$ 点的代价，等价于从 $u$ 点跳到根节点的代价，加上从根节点跳到 $v$ 节点的代价，再减去从其 $lca$ 跳到根节点的代价，以及从根节点跳到 $lca$ 的代价。</p><p>由于代价不具有对称性，即从 $u$ 跳到根节点和从根节点跳到 $u$ 节点不是对称的，所以要dfs两次算出从根节点出发到其他点的代价，以及从其他点到达根节点的代价。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, M = N &lt;&lt; <span class="number">2</span>;</span><br><span class="line">ll a[N], d[N], rd[N];</span><br><span class="line"><span class="keyword">namespace</span> LCA {</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> n, h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> fa[N][SIZE + <span class="number">1</span>], depth[N];</span><br><span class="line">    <span class="keyword">int</span> q[N]; <span class="keyword">bool</span> st[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">fill</span>(h, h + n + <span class="number">1</span>, <span class="number">-1</span>); idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="built_in">fill</span>(fa[i], fa[i] + SIZE + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fill</span>(depth, depth + n + <span class="number">1</span>, <span class="number">0</span>); <span class="built_in">fill</span>(st, st + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ; }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = root; depth[root] = <span class="number">1</span>; st[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt) {</span><br><span class="line">            <span class="keyword">int</span> u = q[hh ++ ];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) {</span><br><span class="line">                <span class="keyword">int</span> j = e[i]; <span class="keyword">if</span> (st[j]) <span class="keyword">continue</span>;</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                depth[j] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                fa[j][<span class="number">0</span>] = u;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= SIZE; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">                fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- ) <span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b]) a = fa[a][i];</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">        <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    d[u] = d[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &gt; a[fa]) d[u] += a[u] - a[fa];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rd[u] = rd[fa];</span><br><span class="line">    <span class="keyword">if</span> (a[u] &lt; a[fa]) rd[u] += a[fa] - a[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="built_in">rdfs</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n - <span class="number">1</span> &amp;&amp; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v); i ++ ) <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">rdfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y; <span class="keyword">int</span> f = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[x] + rd[x] + d[y] - rd[f] - d[f]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-amp-M-小沙的remake"><a href="#L-amp-M-小沙的remake" class="headerlink" title="L &amp; M. 小沙的remake"></a>L &amp; M. 小沙的remake</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，选择若干个数字组成最长不下降子序列，使得被选中的每个元素，设其位置为 $i$ ，它前面 $b_i$ 个元素至少也有一个被选择。问这样的子序列有多少种？</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>树状数组维护：对于每个位置而言，以它为结尾至少有多少种满足条件的子序列个数。</p><p>按元素权值从小到大排序，从前往后遍历，对于每个元素，设位置为 $i$，查询 $[i-b_i, i)$ 中每个位置的值，相加即为以当前元素为结尾的子序列的方案数。</p><p>这里的Code不按照题目要求的生成数据，方便参照。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b[N];</span><br><span class="line">T a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N]; <span class="comment">// 树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) c[x] = ((ll)c[x] + v) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x ) sum = ((ll)sum + c[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i].x &gt;&gt; b[i], a[i].y = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ll val = <span class="built_in">query</span>(a[i].y - <span class="number">1</span>) - <span class="built_in">query</span>(a[i].y - b[a[i].y] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        val %= mod;</span><br><span class="line">        res = (res + val + mod) % mod;</span><br><span class="line">        <span class="built_in">add</span>(a[i].y, val);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客集训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022寒假算法集训营1</title>
      <link href="/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/"/>
      <url>/2022/02/17/2022%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD%E8%90%A51/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="A-九小时九个人九扇门"><a href="#A-九小时九个人九扇门" class="headerlink" title="A. 九小时九个人九扇门"></a>A. 九小时九个人九扇门</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个数字和编号为 $1 \sim 9$ 的九扇门，规定：$k$ 个数字的组合能够打开编号为 $f$ 的门，当且仅当这 $k$ 个数字之和的数字根等于 $f$ 。问对于每一扇门，有几种组合可以打开？</p><p>其中 $1 \le n \le 10^5$ ，$1 \le a_i \le 10^9$ 。</p><p>数字根：不断将数字 $m$ 各个位上的数字相加，直到 $m$ 为一位数。一位数的数字根就是本身。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%A0%B9">数字根的性质</a></p><p>求数字根：根据<strong>任何数字加 $9$ 的数字的数字根不变</strong>的性质，只需要模 $9$ 即可算出数字根。</p><p>设 $dp(i)$ 表示打开模 $9$ 为 $i$ 号门的组合数量。由于状态转移时，依赖关系不好找，而被依赖的关系容易找到，所以对于每个状态，更新被这个状态依赖的关系。注意DP的初始条件，为了启动DP要使 $dp(0)$ 为 $1$ ，最后要减去。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">9</span>)</span></span>; dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> nxt = dp;</span><br><span class="line">        <span class="keyword">int</span> a; cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k ++ )</span><br><span class="line">            (nxt[(k + a) % <span class="number">9</span>] += dp[k]) %= mod;</span><br><span class="line">        dp.<span class="built_in">swap</span>(nxt);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i ++ ) cout &lt;&lt; dp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    cout &lt;&lt; (dp[<span class="number">0</span>] + mod - <span class="number">1</span>) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="B-炸鸡块君与FIFA22"><a href="#B-炸鸡块君与FIFA22" class="headerlink" title="B. 炸鸡块君与FIFA22"></a>B. 炸鸡块君与FIFA22</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的由 ‘W’, ‘L’, ‘D’ 构成的字符串表示若干场次的结果。</p><p>‘W’表示胜利，分数加一；’L’表示失败，分数减一；’D’表示平局，分数不变。</p><p>特别的，当分数为 $3$ 的整数倍时，失败不会减少分数。</p><p>给定 $q$ 次查询，每次查询给出 $l, r, s$ ，问，在初始分数为 $s$ 时，经过 $[l, r]$ 场次后，最终的分数为多少？</p><p>其中 $1 \le n, q \le 2 \times 10^5$ ，$1 \le l, r \le n$ ，$0 \le s \le 10^9$ 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到如果起始分数在模 $3$ 意义下相等，那么经历区间 $[l, r]$ 后，<strong>分数的变化量</strong>是不变的。</p><p>可以使用 ST 表，倍增实现查询，复杂度为 $O(max(q, n)\times log n))$ 。其中查询复杂度为 $q log n$ ，初始化复杂度为 $n log n$ 。</p><p>设 $st[k][i][j]$ 表示初始分数模 $3$ 意义下为 $k$ ，经历区间 $[l, r]$ 后<strong>分数的变化量</strong>。</p><p>预处理：$st[k][i][j] = st[k][i][j-1] + st[(k + st[k][i][j]) \% 3][i + (1 &lt;&lt; j)][j-1]$ ，注意经过 $2^{j-1}$ 区间后初始分数在后面的区间要变化。</p><p>对于每次查询，我们可以每次走最大的二次幂，直到走完区间。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][<span class="number">21</span>], Lg[N];</span><br><span class="line"><span class="comment">/* 预处理,st[k][i][j] 表示初始分数模3为k时，经过[i, i + 2^j - 1]区间后分数的变化量 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) Lg[i] = Lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'W'</span>) st[j][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'L'</span> &amp;&amp; j) st[j][i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n ; j ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                st[k][i][j] = st[k][i][j<span class="number">-1</span>] + st[(k + st[k][i][j<span class="number">-1</span>]) % <span class="number">3</span>][i + (<span class="number">1</span> &lt;&lt; j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;] (<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> g = Lg[r - l + <span class="number">1</span>];</span><br><span class="line">            ret += st[k][l][g];</span><br><span class="line">            (k += st[k][l][g]) %= <span class="number">3</span>;</span><br><span class="line">            l = l + (<span class="number">1</span> &lt;&lt; g);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; k + <span class="built_in">query</span>(k % <span class="number">3</span>, l, r) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="C-Baby’s-first-attempt-on-CPU"><a href="#C-Baby’s-first-attempt-on-CPU" class="headerlink" title="C. Baby’s first attempt on CPU"></a>C. Baby’s first attempt on CPU</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出 $n$ 个程序语句 $(3 \le n \le 100)$ ，其中某些程序语句有先写后读的制约关系，如果两条程序语句存在先读后写，那么这两条语句中间至少需要三条语句来使程序不出错。我们可以加入空语句来占位。</p><p>问，要使程序不出错，至少需要加入多少条空语句？</p><p>给出的数据保证第 $i$ 行输入 $i, j, f$ ，如果 $f = 1$ ，表示第 $i$ 条语句和第 $i - j$ 条语句有先写后读的关系。并且 $i - j &lt;= 0$ 的情况始终有 $f = 0$ 。即不存在后面的语句先写，前面的语句再读。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>贪心，设 $has(i)$ 表示第 $i$ 条语句后加入多少条空语句。</p><p>对于第 $i$ 条语句，假设它与第 $i-j$ 条语句有先读后写的关系，判断间隔有没有三条语句，如果没有，那么只需要在第 $i-1$ 条语句后加入空语句即可。</p><p>证明也很简单，对于后面的语句 $k$ ，如果有制约关系的语句 $k - k_j \le i - j \quad or \quad k - k_j \ge i$ ，那么加在哪条语句后都不会影响，反之，我们加在第 $i-1$ 条语句后一定更好，它能最大限度地包含于 $[k - k_j, k]$ 的位置。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> has[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> f; cin &gt;&gt; f; <span class="keyword">if</span> (!f) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="built_in">accumulate</span>(has + i - j, has + i, j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) has[i<span class="number">-1</span>] += <span class="number">3</span> - cnt;</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(has + <span class="number">1</span>, has + n, <span class="number">0ll</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="D-牛牛做数论"><a href="#D-牛牛做数论" class="headerlink" title="D. 牛牛做数论"></a>D. 牛牛做数论</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定数字 $n$ 和函数 $H(x) = \dfrac {\phi(x)} x$ ，问：</p><ol><li>回答一个 $x_0 \in [2, n]$ ，使得 $H(x_0)$ 最小。如果存在多个，输出 $x_0$ 最小的那个。</li><li>回答一个 $x_0 \in [2, n]$ ，使得 $H(x_0)$ 最大。如果存在多个，输出 $x_0$ 最大的那个。</li></ol><p>其中 $1 \le n \le 10^9$ 。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>根据欧拉函数定义 ：$\phi(x) = x \times \prod_{i=1}^n (1 - \dfrac 1 p_i)$ 。其中 $n$ 为 $x$ 质因子个数，$p_i$ 为$x$ 的各个质因子。</p><p>于是，函数 $H(x) = \prod_{i=1}^n (1 - \dfrac 1 p_i)$ 。</p><p>所以，求最小值，只需要把所有可能的质因子都加进去累乘即可，因为每个因子都小于 $1$ 。</p><p>求最大值，一定是只有一项因子，且这项因子的 $p_i$ 尽可能大，所以取不大于 $n$ 的最大质数，暴力求出即可，因为质数在 $[1, 10^9]$ 内浓度很大。(相邻质数最多相差 $282$) 。</p><p>注意 $n \le 10^9$ ，在这个范围内最多有 $10$ 个不同的质因子。所以只需要枚举这几个就可以。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> p[] = { <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span> };</span><br><span class="line">    <span class="keyword">auto</span> is_prime = [&amp;] (<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">2</span>) <span class="keyword">return</span> x == <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ --; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = p[<span class="number">0</span>], pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">long</span> <span class="keyword">long</span>)ans * p[pos] &lt;= n) ans *= p[pos ++ ];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        </span><br><span class="line">        ans = n;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">is_prime</span>(ans)) -- ans;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="E-炸鸡块君的高中回忆"><a href="#E-炸鸡块君的高中回忆" class="headerlink" title="E. 炸鸡块君的高中回忆"></a>E. 炸鸡块君的高中回忆</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个人想要进入学校，但是只有 $m$ 个校园卡，于是他们有如下方案：先让 $m$ 个人进入学校，再由一个人带着 $m$ 个校园卡出来。反复直到全部人进入学校。</p><p>每次进入或出去学校需要 $1$ 个单位时间，问所有人进入学校至少需要多少单位时间？</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先有两个特判：</p><ol><li>$n \le m$ ，可以一次进去完，只需要 $1$ 个单位时间。</li><li>$m == 1$ ，一定无法让所有人进去学校，因为每轮实际上只有 $m-1$ 个人进入学校。</li></ol><p>否则，我们可以先让这 $n$ 个人进入第一轮循环，之后，他们需要循环的次数为 $\lceil \dfrac {n - m} {m-1} \rceil$ ，注意最后一次不需要再有人出来送校园卡，因此总时间为 $2 + 2 \times \lceil \dfrac {n - m} {m-1} \rceil - 1$ 。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= m) { cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> d = (n - m + m - <span class="number">1</span> - <span class="number">1</span>) / (m - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> + d * <span class="number">2</span> - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="F-中位数切分"><a href="#F-中位数切分" class="headerlink" title="F. 中位数切分"></a>F. 中位数切分</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列 $a$ ，将其划分为若干个子段，使得其中每个段的<strong>数值的中位数</strong>不小于 $m$ ，问最多能划分多少段？</p><p>（偶数长度字段的中位数为两个中较小的那一个。）</p><p>不存在任意划分策略则输出 $-1$ 。</p><p>其中 $1 \le n \le 10^5$ ，$1 \le m \le 10^9$ ，$1 \le a_i \le 10^9$ 。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>首先，我们按照题意将序列划分若干个子段，使得每个字段数值的中位数不小于 $m$ 。</p><p><img src="/images/problem/cutArray.png" alt=""></p><p>根据题目，我们发现<strong>对于每一个子段，不小于 $m$ 的数字个数一定大于 小于 $m$ 的数字个数。</strong></p><p>贪心考虑，如果当前枚举的区间，已经满足大于关系，即 <strong>不小于 $m$ 的数字个数比小于 $m$ 的数字个数多 $1$</strong> 。那么我们就可以把这块区间划分出来。</p><p>可以证明这样贪心一定是最优的，因为如果在这个区间之后加入 不小于 $m$ 的数字数量小于 小于 $m$ 的数字个数，那么不满足题意；如果大于，那么不必要合并，因为两个都是满足条件的子段。当然如果等于，那么还是要加上的，但是这不影响结果，因为这个区间还是满足如上条件。</p><p>我们发现，对于划分好的最优解子段，每个子段都满足 $\ge m$ 的数字数量比 $&lt; m$ 的数字数量多 $1$ ，所以只需要统计一下区间的两个数量差即可。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ --; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m, cnt = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m) ++ cnt; <span class="keyword">else</span> -- cnt;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; (cnt &lt;= <span class="number">0</span> ? <span class="number">-1</span> : cnt) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="G-ACM-is-all-you-need"><a href="#G-ACM-is-all-you-need" class="headerlink" title="G. ACM is all you need"></a>G. ACM is all you need</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列 $a$ ，可以选择任意整数值 $b$ ，使得序列 $a$ 中每个元素 $a_i$ 变为 $|a_i - b| + b$ 。问经过一次变换后，序列中的极小值点的数量最少为多少？</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>变换中 $+b$ 的操作是对整个序列都加上 $b$ ，不会改变相对大小，因此无用，可以看作变换为 $a_i = |a_i - b|$ 。</p><p>同时， $b$ 的值小于等于 $0$ 的情况是完全一样的，同样不改变相对大小，我们可以用 $b = 0$ 代替所有 $b \le 0$ 的情况。</p><p>所以确定 $b$ 的值为 $[0, inf]$ 。</p><p>对于序列中每个元素而言，如果让它变成极小值点，取得 $b$ 值的范围是连续的，可以算出所有 $n-2$ 个 $b$ 范围的区间，那么问题就变成了：给定 $n-2$ 个区间，求被区间覆盖最小次数的点的覆盖次数。</p><p>对于区间 $[l, r]$ ，可以在每个位置上 $+1$ ，那么就是求 $[0, inf]$ 上每个位置的最小值。</p><p>可以使用差分来快速实现区间加，范围比较大，使用map离散化处理即可。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="keyword">for</span> (<span class="keyword">int</span> &amp; x : a) cin &gt;&gt; x;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; m[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 注意0位置是需要考虑的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : { a[i<span class="number">-1</span>], a[i+<span class="number">1</span>] })</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (x &gt; a[i]) r = <span class="built_in">min</span>(r, a[i] + (x - a[i] - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (x &lt; a[i]) l = <span class="built_in">max</span>(l, x + (a[i] - x) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == a[i]) r = l - <span class="number">1</span>; <span class="comment">// 这个点不可能成为极小值点</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">            ++ m[l]; <span class="keyword">if</span> (r != INF) -- m[r + <span class="number">1</span>]; <span class="comment">// 注意正无穷没有右端点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ret = INF, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : m) ret = <span class="built_in">min</span>(ret, sum += v);</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="H-牛牛看云"><a href="#H-牛牛看云" class="headerlink" title="H. 牛牛看云"></a>H. 牛牛看云</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的序列 $a$ ，求出 $\sum_{i=1}^n\sum_{j=i}^n|a_i + a_j - 1000|$ 。</p><p>其中 $3 \le n \le 10^6$ ，$0 \le a_i \le 1000$ 。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>题目简化一下就是求 $|a_i + a_j - 1000|$ ，其中 $1 \le i \le j \le n$ 。</p><p>容易发现，对于 $i \lt j$ 的情况， 把 $i$ 、$j$ 调换一下式子依然不变，所以式子对 $i$ 、$j$ 有对称性。</p><p>那么我们只需要对称地求出所有情况，再除以二即可。</p><p>注意点：</p><ol><li>式子对 $i = j$ 不具有对称性，所以在求式子结果的时候，需要给这种情况加上。</li><li>$n$ 很大， $a_i$ 很小，可以在值域上做暴力。</li></ol><blockquote><p>为什么 $i = j$ 不具有对称性？</p><p>对于 $1, 1, 2, 2$ 这个样例，我们枚举 $1$ 和 $2$ 的时候，把前和后的状态都算了，所以有对称性。</p><p>对于 $1, 1$ ，我们枚举 $1$ 和 $1$ 的时候，对于每一个 $1$ ，在计算加自己的时候，只计算了一次，根据对称性我们要加两次，这样最后除以二的时候才算出来一次。所以我们对每个 $1$ 都要再加一遍自己的情况。</p><p>其实本质上就是，$i=j$ 代表同一个式子，而 $i != j$ 代表了两种式子，一个定义域为 $i &lt; j$ ，一个定义域为 $i &gt; j$ 。</p></blockquote><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="keyword">int</span> x; cin &gt;&gt; x; ++ c[x]; }</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1000</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i == j) ret = ret + c[i] * (c[j] + <span class="number">1</span>) * <span class="built_in">abs</span>(i + j - <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">else</span> ret = ret + c[i] * c[j] * <span class="built_in">abs</span>(i + j - <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="I-B站与各唱各的"><a href="#I-B站与各唱各的" class="headerlink" title="I. B站与各唱各的"></a>I. B站与各唱各的</h1><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>有 $n$ 个UP主和 $m$ 句歌词，现在他们每个人要独立完成这 $m$ 句歌词，对于每一句歌词，他们可以选择唱或者不唱。完成后，将它们拼接起来。</p><p>如果一句歌词没有人唱或者被所有人唱过，那么这句歌词算失败的，否则是成功的。</p><p>问唱成功的歌词数量的期望为多少？</p><p>若答案为分数，需要在模数为 $10^9 + 7$ 下取逆。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>由于每个UP都是独立完成 $m$ 句歌词，所以对于每句歌词唱与不唱的概率都为 $\dfrac 1 2$ 。</p><p>对于任意一句歌词，没有人唱或者全部人都唱的概率为 $(\dfrac 1 2)^n$ 。</p><p>所以每一句歌词唱成功的概率为 $1 - (\dfrac 1 2)^n \times 2 = 1 - (\dfrac 1 2)^{n - 1}$ 。</p><p>每一句成功的概率乘以总歌词数量即为唱成功的歌词数量的期望，即 $(1 - (\dfrac 1 2)^{n - 1}) \times m$ 。</p><h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">auto</span> quick_power = [&amp;] (<span class="keyword">int</span> a, <span class="keyword">int</span> k) -&gt; <span class="keyword">int</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (a %= p; k; k &gt;&gt;= <span class="number">1</span>, a = (ll)a * a % p)</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll) res * a % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">quick_power</span>(<span class="number">2</span>, p<span class="number">-2</span>);</span><br><span class="line">        cout &lt;&lt; (ll)(<span class="number">1</span> - <span class="built_in">quick_power</span>(inv, n<span class="number">-1</span>) + p) % p * m % p &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="J-小朋友做游戏"><a href="#J-小朋友做游戏" class="headerlink" title="J. 小朋友做游戏"></a>J. 小朋友做游戏</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>班级里有 $A$ 个安静的小朋友和 $B$ 个吵闹的小朋友，现在要选出 $n$ 个小朋友围成一圈，满足不存在两个吵闹的小朋友相邻。每个小朋友有一个幸福度，选中即可为班级增加幸福度，问最大幸福度为多少？</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>为了满足条件，安静的小朋友至少要选出 $(n + 1) / 2$ 个，否则一定存在吵闹的小朋友相邻。</p><p>可以先选出这 $(n + 1) / 2$ 个小朋友，再双指针贪心选最大的幸福度。</p><p>双指针判断比较麻烦，要先判断是否有选完的，再贪心选。可以把剩下的小朋友放在一个容器中，选出最大的幸福度即可。</p><h2 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _ -- ; )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> A, B, n; cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(A)</span>, <span class="title">b</span><span class="params">(B)</span>, all</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : a) cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : b) cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span> (A &lt; n - A) { cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">continue</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n + <span class="number">1</span>) / <span class="number">2</span>; i &lt; A; i ++ ) all.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B; i ++ ) all.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">        <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; i ++ ) ret += a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - (n + <span class="number">1</span>) / <span class="number">2</span>; i ++ ) ret += all[i];</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="K-冒险公社"><a href="#K-冒险公社" class="headerlink" title="K. 冒险公社"></a>K. 冒险公社</h1><h2 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h2><p>数轴上有 $n$ 座连续的岛屿，玩家从第一座岛屿出发，依次经过所有岛屿直到到达第 $n$ 座岛屿。</p><p>岛屿有三种类型：绿岛、红岛和黑岛。</p><p>在玩家到达第 $i$ 座岛屿时，如果第 $i, i-1, i-2$ 中绿岛数量大于红岛，则罗盘发出绿色；如果红岛数量大于绿岛，则发出红光；否则发出黑光。</p><p>给出在 $n$ 座岛屿上，罗盘发出的光，问这 $n$ 座岛屿最多有几座绿岛？(第 $1, 2$ 座岛屿不发光，规定为 ‘X’) 。</p><p>其中 $1 \le n \le 10^5$ ，发出的光的颜色为长度 $n$ 的字符串，由 ‘R’、’G’、’B’ 构成。</p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>为了方便，我们设绿岛为 $0$ ，红岛为 $1$ ，黑岛为 $2$ 。</p><p>设 $dp(i, j, k, l)$ 表示对于前 $i$ 座岛屿，且最后三座岛屿为 $(j, k, l)$ 时，绿岛的最大数量。</p><p>转移方程为 $dp(i, j, k, l) = max(dp(i, j, k, l), dp(i-1, t, j, k))$ ，其中 $0 \le t \le 2$ 。</p><p>注意在转移前判断 $(j, k, l)$ 是否合法，以及 $dp(i-1, t, j, k)$ 是否合法。$dp = -1$ 表示这种状态是不合法的。</p><p>坑点：注意一定用 $dp(i-1, t, j, k)$ 判断，不要用 $(t, j, k)$ 判断是否为 $s[i-1]$ ，因为即使等于，也不一定合法，还和前面的岛屿有联系。</p><h2 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">/* dp(i, j, k, l) 表示考虑前i个字符，此时最后三个岛屿为(j, k, l)时的最大绿岛数量</span></span><br><span class="line"><span class="comment"> * 其中0表示绿岛，1表示红岛，2表示黑岛</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">get_color</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x1 = (a == <span class="number">0</span>) + (b == <span class="number">0</span>) + (c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x2 = (a == <span class="number">1</span>) + (b == <span class="number">1</span>) + (c == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) <span class="keyword">return</span> <span class="string">'G'</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) <span class="keyword">return</span> <span class="string">'R'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s; s = <span class="string">' '</span> + s;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_color</span>(i, j, k) == s[<span class="number">3</span>]) dp[<span class="number">3</span>][i][j][k] = !i + !j + !k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; t ++ )</span><br><span class="line">                        <span class="keyword">if</span> (~dp[i<span class="number">-1</span>][t][j][k] &amp;&amp; <span class="built_in">get_color</span>(j, k, l) == s[i])</span><br><span class="line">                            dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i<span class="number">-1</span>][t][j][k] + !l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++ )</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp[n][i][j][k]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="L-牛牛学走路"><a href="#L-牛牛学走路" class="headerlink" title="L. 牛牛学走路"></a>L. 牛牛学走路</h1><h2 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h2><p>给出字符串 $s$ ，牛牛会按照字符串给的方向走一遍，问走的位置里原点最远为多少？</p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>签到题，维护一下当前的位置即可，设原点为 $(0, 0)$ 。</p><h2 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> }, dc[] = { <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line">    d[<span class="string">'U'</span>] = <span class="number">0</span>; d[<span class="string">'D'</span>] = <span class="number">1</span>; d[<span class="string">'R'</span>] = <span class="number">2</span>; d[<span class="string">'L'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        x += dr[d[s[i]]]; y += dc[d[s[i]]];</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, dis);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ret);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 牛客集训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>康托展开</title>
      <link href="/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2022/02/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><blockquote><p>康托展开是一个全排列与自然数的双射，常用于构建hash表时的空间压缩。假设有 $n$ 个数(1, 2, 3, 4 …) ，  可以有 $n!$ 的排列组合，康托展开表示在某一个全排列在这些组合的名次（以0开始）。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个全排列 $A$ 的名次为 $a_1 \times (n-1)! + a_2 \times (n-2)! \ldots + a_n \times 0!$ 。</p><p>其中 $a_i$ 表示第 $i$ 个数字，$A_i &gt; A_j \ and \ i &lt; j$ 。即比当前数字小但是在它后面的数字的个数。</p><p>因为对这个位置而言，我们选择 $a_i$ 中任意一个数字填充这个位置，后面的数字任意排列都可以比原来的小，所以比它小的名次的排列数量为 $a_i \times (n - i)!$ 。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++ ) x += A[j] &lt; A[i];</span><br><span class="line">    id += x * fac[n - i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><p>由于康托展开是一个全排列和自然数的双射，因此我们也可以根据名次得出全排列。</p><p>从前往后，对于第 $i$ 个数字，我们可以得到 $a_i = id / (n-i)!$ 。</p><p>由于 $a_i$ 表示在其后面且小于它的数值的数量，所以我们要遍历得到这个位置的值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id; cin &gt;&gt; id;</span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// st(i) 表示i数字有没有出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> a = id / fac[n - i];</span><br><span class="line">    id %= fac[n - i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 没有出现过</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (!a) <span class="comment">// 已经找到a个数字比它小</span></span><br><span class="line">            { A[i] = j; st[i] = <span class="literal">true</span>; <span class="keyword">break</span>; }</span><br><span class="line">            <span class="keyword">else</span> -- a;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.luogu.com.cn/problem/P3014">洛谷 P3014 Cow Line S</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="康托展开-1"><a href="#康托展开-1" class="headerlink" title="康托展开"></a>康托展开</h3><p>注意到内层循环的目的是为了找出后面有几个数字小于当前位置的数字，我们可以采用树状数组维护，从后往前遍历即可。这样查询只需要 $O(logn)$ 的时间，总复杂度降至 $O(nlogn)$ 。</p><p><a href="https://www.luogu.com.cn/problem/P5367">洛谷P5367 模板 康托展开</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll c[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) ++ c[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">    ll id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="built_in">add</span>(a[i]), id = (id + fac[n-i] * <span class="built_in">query</span>(a[i] - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (id + <span class="number">1</span>) % mod);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="逆康托展开-1"><a href="#逆康托展开-1" class="headerlink" title="逆康托展开"></a>逆康托展开</h3><p>注意到内层循环的目的是为了找出剩下没有被选上的数字中的第 $a_i+1$ 个数字，我们可以采用线段树维护，复杂度 $O(logn)$ ，总复杂度为 $O(nlogn)$ 。</p><p>具体来说，我们维护 $[l, r]$ 中有多少数字是有效的（未被删除），每次查询找出全局第 $a_i + 1$ 小的数字即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll st; <span class="comment">// st 表示当前这个区间有多少数字未被删除</span></span><br><span class="line">};</span><br><span class="line">node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].st = t[<span class="built_in">ls</span>(p)].st + t[<span class="built_in">rs</span>(p)].st;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r; t[p].st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    -- t[p].st; <span class="comment">// 在这个区间查询后需要删除那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) <span class="keyword">return</span> t[p].l;</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].st &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), k - t[<span class="built_in">ls</span>(p)].st);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.luogu.com.cn/problem/P3014">洛谷 P3014 Cow Line S优化版</a> </p><p>记得每次初始化~</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll c[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) ++ c[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= x &amp; -x) ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll st; <span class="comment">// st 表示当前这个区间有多少数字未被删除</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].st = t[<span class="built_in">ls</span>(p)].st + t[<span class="built_in">rs</span>(p)].st;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r; t[p].st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    -- t[p].st; <span class="comment">// 在这个区间查询后需要删除那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) <span class="keyword">return</span> t[p].l;</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].st &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), k - t[<span class="built_in">ls</span>(p)].st);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, n) c[i] = <span class="number">0</span>;</span><br><span class="line">            ll id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="built_in">add</span>(a[i]), id += fac[n-i] * <span class="built_in">query</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, id + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            ll id; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;id); id -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> x = id / fac[n - i];</span><br><span class="line">                id %= fac[n - i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, <span class="built_in">query</span>(<span class="number">1</span>, x+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2021.12.31</strong> 更新，使用树状数组模板和<a href="https://horb7.github.io/2021/12/30/zkw%E6%A0%91/">zkw树</a>实现康托展开和逆康托展开。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i -- )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll fac[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> {</span></span><br><span class="line">  <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">  <span class="keyword">int</span> n; ll a[N];</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x &amp; -x; }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{ <span class="keyword">this</span>-&gt;n = n; <span class="built_in">fill</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>, <span class="number">0</span>); }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">1</span>)</span> </span>{ <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) a[x] += v; }</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ ll res = <span class="number">0</span>; <span class="keyword">if</span> (x) <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x)) res += a[x]; <span class="keyword">return</span> res; }</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">return</span> <span class="built_in">ask</span>(r) - <span class="built_in">ask</span>(l<span class="number">-1</span>); }</span><br><span class="line">};</span><br><span class="line">BIT&lt;N&gt; bit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* zkw树 */</span></span><br><span class="line"></span><br><span class="line">ll M, t[N &lt;&lt; <span class="number">1</span>]; <span class="comment">// t(i) 表示i节点表示的区间内有多少剩余的1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (ll i = M; i &lt; M + n; i ++ ) t[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = M - <span class="number">1</span>; i; i -- ) t[i] = t[i&lt;&lt;<span class="number">1</span>] + t[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span> <span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll r;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; M; )</span><br><span class="line">    {</span><br><span class="line">        -- t[r];</span><br><span class="line">        <span class="keyword">if</span> (t[r&lt;&lt;<span class="number">1</span>] &gt;= x) r &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x -= t[r&lt;&lt;<span class="number">1</span>], (r &lt;&lt;= <span class="number">1</span>) |= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -- t[r], r - M + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q); <span class="keyword">for</span> (M = <span class="number">1</span>; M &lt; n; M &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fac[i] = fac[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            bit.<span class="built_in">init</span>(n);</span><br><span class="line">            ll id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            <span class="built_in">per</span>(i, n, <span class="number">1</span>) bit.<span class="built_in">add</span>(a[i]), id += fac[n-i] * bit.<span class="built_in">ask</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, id + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            ll id; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;id); id -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> x = id / fac[n - i];</span><br><span class="line">                id %= fac[n - i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, <span class="built_in">ask</span>(x+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展中国剩余定理</title>
      <link href="/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2022/02/16/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>对于同余方程组：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\x \equiv a_3 \pmod {m_3} \\..... \\x \equiv a_n \pmod {m_n} \\\end{cases}</script><p>求出满足上述同余方程组的 $x$ 的一组解，<strong>公式满足 $m_1,m_2, m_3 … m_n$ 互质。</strong></p><p>令 $M = \prod_{i=1}^{n}m_i , M_i = M / m_i, M_i \times M_i^{-1} \equiv 1 \pmod {m_i}$ 。</p><p>中国剩余定理构造出了这样一组解:</p><script type="math/tex; mode=display">x = \sum_{i=1}^{n} M_i * M_i^{-1} * a_i</script><p>对于每一组解 $x \equiv a_i \pmod {m_i}$ ，$x$ 除了 $M_i \times M_i ^ {-1} \times a_i$ 项之外，其余都能被 $m_i$ 整除，所以只剩下这一项。</p><p>又因为 $M_i \times M_i^{-1} \equiv 1 \pmod {m_i}$ 。所以 $x \equiv a_i \pmod {m_i}$ 。</p><h2 id="扩展中国剩余定理-1"><a href="#扩展中国剩余定理-1" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h2><p>传统的中国剩余定理限制性太强，必须要满足 $m_1, m_2, m_3 … m_n$ 互质。如何求出不满足模数不互质的同余方程组的解？</p><p>先从两个柿子看起：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2} \\\end{cases}</script><p>首先可以得到 $x = k_1 \times m_1 + a_1 = k_2 \times m_2 + a_2$ 。</p><p>对这个柿子化简： $k_1 \times m_1 + k_2 \times (-m_2) = a_2 - a_1$ 。</p><p>对于这个柿子，我们可以用扩展欧几里得求出一组满足 $k_1 \times m_1 + k_2 \times (-m_2) = gcd(m_1, -m_2)$ 的 $k_1, k_2$ 解。</p><p>记 $gcd(m1, -m2) = d$ 。</p><p>根据贝祖定理，如果不满足 $d | a_2 - a_1$ ，那么不存在解。否则，我们只需要扩大 $(a_2 - a_1) / d$ 倍即可得到 $k_1$ 的一组解。</p><p>由于这是个不定方程，在求出 $k_1$ 后，我们可以得到其他满足的解一定为 $k_1 = k_1 + k \times (m_2 / d)$ 。</p><p>我们把这个通解 $k_1$ 带入原来的柿子：$x = (k_1 + k \times (m_2 / d)) \times m_1 + a_1$ 。</p><p>得到：</p><p>$x = k_1 \times m_1 + a_1 + k \times (m_1 \times m_2) / d$ 。</p><p>$x = k_1 \times m_1 + a_1 + k \times lcm(m_1, m_2)$ 。</p><p>令 $m_0 = lcm(m1, m2), a_0 = k_1 \times m_1 + a_1$ 。</p><p>那么，我们得到 $x = k \times m_0 + a_0$ ，这个柿子满足这两个同余方程组解。</p><p>通过这样的方式，我们就可以把两个同余方程组化简成一个，最终达到化简 $n$ 个同余方程组的效果。</p><p>那么最终可以算出 $x = k \times m + a$ ，其中 $m = lcm(m_1, m_2 … m_n)$ ，所以在 $\pmod m$ 的意义下， $x = a$ 。</p><p>例题:<a href="https://www.acwing.com/problem/content/description/206/">Acwing 204 表达整数的奇怪方式</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, x - (a / b) \times y);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = ((a % b) + b) % b;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a1, m1; cin &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a2, m2, k1, k2; cin &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(a1, -a2, k1, k2);</span><br><span class="line">        <span class="keyword">if</span> ((m1 - m2) % r) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl, <span class="number">0</span>;</span><br><span class="line">        k1 = <span class="built_in">mod</span>(k1 \<span class="built_in">times</span> (m2 - m1) / r, <span class="built_in">abs</span>(a2 / r));</span><br><span class="line">        m1 = k1 \times a1 + m1;</span><br><span class="line">        a1 = <span class="built_in">abs</span>(a1 \times a2 / r);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于为什么取 $abs$ 的原因:</p><ol><li>由于 $a \% b$ 和 $a \% -b$ 是相同的，所以我们在计算 $k_1$ 时 需要加上 $abs(a_2 / r)$ ，防止在 $mod$ 过程中加上负数，结果仍然是负数。</li><li>下一个阶段的 $a_1$ 实际上一个的 $lcm(a_1,a_2)$ ，但是在计算 $gcd(a_1, a_2)$ 时可能出现负数，导致计算 $lcm$ 时会出现负数，这里要取 $abs$ 。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得</title>
      <link href="/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2022/02/16/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h1><p>在拓展欧几里得定理之前，先介绍以下<strong>贝祖定理</strong>：</p><blockquote><p>如果方程式 $ax + by = m$ 成立，那么 $gcd(a, b) | m$</p></blockquote><p>显然，我们可以把原方程式写作：$m = k1 \times g \times x + k2 \times g \times y = g(k1 \times x + k2 \times y)$</p><p>根据贝祖定理，如果有 $ax + by = 1$ ，那么 $gcd(a, b) = 1$， 即 $a$ 与 $b$ 互质。</p><p>我们可以使用著名的辗转相除法算出来 $gcd(a, v=b)$ :</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拓展欧几里得-1"><a href="#拓展欧几里得-1" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><p>给出 $ax + by = m$ ，如何求出他的一组解？</p><p>根据贝祖定理，只要我们求出 $ax + by = gcd(a, b)$ 即可，由于 $gcd(a, b) | m$ ，所以可以求出原式的一组因子，只需要乘上 $m / gcd(a, b)$ 即为原式的一组解。</p><p>那么问题就转化为了，求 $ax + by = gcd(a, b)$ 的一组 $(a, b)$ 。</p><p>$gcd(a, b)$ 可以用欧几里得辗转相除求出，而 $a, b$ 可以在求的过程中得出。</p><p>假设我们到达了终点，此时 $a = gcd(a, b), b = 0$ ，那么有 $x = 1, y = 0$ 。</p><p>由于$gcd(a, b)$ 是递归的，当我们想要求得 $ax + by = m$ 时，我们已经求出了 $bx + (a \% b)y = m$ 的一组解。</p><p>$a \% b = a - \lfloor \dfrac a b \rfloor \times b$</p><p>把已有的式子化作：$bx + (a - \lfloor \dfrac a b \rfloor \times b)y = m$</p><p>那么，可以得到：$ay + b(x - \lfloor \dfrac a b \rfloor \times y) = m$</p><p>所以我们发现，如果从上一层状态推下来，那么：$x = y, y = x - \lfloor \dfrac a b \rfloor \times y$</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, x - (a / b) * y);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 $ax + by \equiv m \pmod p$ 有无穷多组，而我们只计算出了一种，那么如何得到其他解？</p><p>假设我们得到解为 $x_0, y_0$ ，还有另外一组解为 $x_1, y_1$ ，那么可以得到：</p><p>$ax_0 + by_0 \equiv m \pmod p$</p><p>$ax_1 + by_1 \equiv m \pmod p$ </p><p>两个柿子相减，得到 $a(x_0 - x_1) \equiv -b(y_0 - y_1) \pmod p$ </p><p>两边同时除以 $gcd(a, b)$ ，有 $a / gcd(a, b) (x_0 - x_1) \equiv -b / gcd(a, b)(y_0 - y_1) \pmod p$</p><p>此时 $a / gcd$ 与 $b / gcd$ 互质，所以一定有 $a / gcd(a, b) | (y_0 - y_1), b / gcd(a, b) | (x_0 - x_1)$</p><p>我们记 $x_1 = x_0 + k \times \dfrac{b}{gcd(a, b)}$ ，同理 $y_1 = y_0 + k \times \dfrac{a}{gcd(a, b)}$ 。</p><h3 id="欧几里得用途"><a href="#欧几里得用途" class="headerlink" title="欧几里得用途"></a>欧几里得用途</h3><h5 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h5><p> $a \times a^{-1} \equiv 1 \pmod p$ ，可以写成 $a \times a^{-1} \equiv kp + 1 \pmod p$ ，</p><p>这样，我们就可以得到柿子 : $a \times a^{-1} + kp \equiv 1 \pmod p$ 。</p><p>这就是拓展欧几里得公式，由于 $a, p$ 都已知，只需要用拓展欧几里得算出 $(a^{-1}, k)$ 即可。</p><p><strong>注意拓展欧几里得可以计算 $p$ 与 $a$ 非互质情况下的逆元，而欧拉定理不能算出。</strong></p><h5 id="计算同余方程组"><a href="#计算同余方程组" class="headerlink" title="计算同余方程组"></a>计算同余方程组</h5><p><a href="http://localhost:4000/2021/12/19/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">扩展中国剩余定理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整除分块</title>
      <link href="/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
      <url>/2022/02/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><h2 id="一维分块引入"><a href="#一维分块引入" class="headerlink" title="一维分块引入"></a>一维分块引入</h2><p>给定一个整数，求出</p><script type="math/tex; mode=display">\sum_{i=1}^n \lfloor \dfrac n i \rfloor</script><p>其中: $1 \le n \le 10^9$ 。</p><p>对于上述题目，$O(n)$ 的解法是很显然的，但是对于 $n$ 很大或者有多组测试样例时，这样的复杂度是不能接受的。我们需要找出更优秀的复杂度来解决上述题目。</p><p>容易发现，由于 $\dfrac n i$ 是向下取整的，因此在某一个连续的区间， $\dfrac n i$ 取值是相同的，比如 $n = 10$ 时：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">n/i</td><td style="text-align:center">10</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>每一个取值都是一个连续的块，那么只要我们直到某一个块的左右端点，就可以 $O(1)$ 地算出这个块的总和。</p><p><strong>定理1</strong>： $\dfrac n i$ 中最多有 $2 \times \sqrt{n}$ 个块。</p><blockquote><p>我们把 $\dfrac n 1, \dfrac n 2, \ldots \dfrac n n$ 分成 $2$ 个部分，前一部分为 $\dfrac n 1, \dfrac n 2, \ldots \dfrac {n} {\lfloor \sqrt n \rfloor }$ ，后一部分为 $\dfrac n {\lfloor \sqrt n \rfloor + 1}, \dfrac n {\lfloor \sqrt n \rfloor + 2}, \ldots \dfrac n n$ 。</p><p>对于前一部分，有 $\sqrt n$ 项，对于后一部分，它所有的取值为 $1, 2, \ldots \sqrt n$ ，因此不同的取值有 $\sqrt n$ 项，所以最多有 $2 \times \sqrt n$ 项不同的取值。</p></blockquote><p> 根据定理1，我们根据最好的情况，即把每一个块都 $O(1)$ 地算出结果，那么复杂度就是 $O(\sqrt n)$ 的。</p><p><strong>定理2</strong>： 如果第 $k$ 块，如果它的左端点为 $l$ ，那么它的右端点为 $\dfrac n {\lfloor \dfrac n l \rfloor}$ 。</p><blockquote><p>假设第 $k$ 段的取值为 $t$ ，取 $i$ 为 $l \le i \le r$ ，那么显然有 $\dfrac n i = \dfrac n l = t$ ，即 $i \times t \le n$ ，$i \le \dfrac n t$，由于 $r = max(i)$ ，那么 $r = \dfrac n t = \dfrac n {\lfloor \dfrac n l \rfloor}$ 。</p></blockquote><p>如此，我们便可以求出所有块的左右端点进行运算，复杂度为 $O(\sqrt n)$ 。</p><hr><p>给出整除分块模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ret += (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="约数研究"><a href="#约数研究" class="headerlink" title="约数研究"></a><a href="https://www.luogu.com.cn/problem/P1403">约数研究</a></h3><p>由于直接求 $i$ 的约数个数不好求，我们可以枚举所有的因子。</p><p>假设因子为 $i$ ，那么在 $[1, n]$ 中，因数含有 $i$ ，即 $i$ 的倍数有 $\lfloor \dfrac n i \rfloor$ 个。</p><p>因此问题转化为求 $\sum_{i=1}^n \lfloor \dfrac n i \rfloor$ ，这就是基本整除分块。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ret += (<span class="keyword">long</span> <span class="keyword">long</span>) (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="余数求和"><a href="#余数求和" class="headerlink" title="余数求和"></a><a href="https://www.luogu.com.cn/problem/P2261">余数求和</a></h3><p>首先由于 $k \ \ mod \ \ i = k - \lfloor \dfrac k i \rfloor \times i$ 。</p><p>于是我们可以把原式转化成 $\sum_{i=1}^n k - \lfloor \dfrac k i \rfloor \times i = n \times k - \sum_{i=1}^n \lfloor \dfrac k i \rfloor \times i$ 。</p><p>其中 $\lfloor \dfrac k i \rfloor$ 我们可以使用整除分块处理，这样对于每一个块而言， $\lfloor \dfrac k i \rfloor$ 都是一个常数，那么我们要求它乘以一个等差数列的值，只需要求 $i$ 在这个块的累加和即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = n * k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = <span class="built_in">min</span>(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        ret -= (<span class="keyword">long</span> <span class="keyword">long</span>)(l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span> * (k / l);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二维分块"><a href="#二维分块" class="headerlink" title="二维分块"></a>二维分块</h2><p>给定两个整数 $n, m$ ，求：</p><script type="math/tex; mode=display">\sum_{i=1}^{min(n, m)} \lfloor \dfrac n i \rfloor \times \lfloor \dfrac m i \rfloor</script><p>由一维分块，我们可以得到块数最多为 $2 \times \sqrt n + 2 \times \sqrt m$ 。</p><p>我们记 $k = min(n, m)$ 。</p><p>对于其中一个块，假设左端点为 $l$ ，那么其右端点为 $r = min(k, min(n / (n / l), m / (m / l)))$ 。因为我们要保证块里的元素相同，必须要保证 $\lfloor \dfrac n i \rfloor$ 元素相同且 $\lfloor \dfrac m i \rfloor$ 元素相同。</p><p>二维分块模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    r = <span class="built_in">min</span>(k, <span class="built_in">min</span>(n / (n / l), m / (m / l)));</span><br><span class="line">    ret += (n / l) * (m / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2022/02/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树介绍"><a href="#最小生成树介绍" class="headerlink" title="最小生成树介绍"></a>最小生成树介绍</h1><p><img src="/images/ds/mst.png" alt=""></p><p>在介绍最小生成树前，先介绍一下生成树：在一张联通无向图中，我们取图上的所有点，并取最少的边将其相连使其连通生成一棵树，这个树就被称作这张图的生成树。因为树的边数一定是点数-1，所以就是取 $n-1$ 条边来连通 $n$ 个点。</p><p>那么最小生成树(Minimum Spanning Tree)，是最小权重生成树的简称。规定树的权值为树上所有边的权值和，那么它就是一张连通加权无向图中一颗权值最小的生成树，如上图。由定义可以看出，<strong>最小生成树不一定唯一</strong>。</p><hr><p>对于如何生成最小生成树的问题，我们有两种常见的解决方法，分别是Prim算法和Kruskal算法，两者都基于贪心。</p><h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>给定图 $G(V, E)$ ，我们逐步进行Prim算法，假设在过程中，$V_{new}$ 表示已经选中作为生成树上的结点，$E_{new}$ 表示已经选中作为最小生成树上的边。</p><p>规定Prim算法如下：</p><ol><li>初始化一个结点 $x$ 加入 $V_{new}$ ，则 $V_{new} = {x}$ 。由于最小生成树包含所有节点，我们可以用任意一个结点初始化。</li><li>从集合 $E$ 中选择权值最小的边 $(u, v)$ ，满足 $u \in V_{new}$ 且 $v \notin V_{new}$ ，将 $v$ 加入集合 $V_{new}$ 中，把 $(u, v)$ 加入 $E_{new}$ 中。</li><li>重复操作，直到所有点都已经被选中加入最小生成树中，即 $V_{new} = V$ 。</li><li>根据 $V_{new}$ 和 $E_{new}$ 所得到的新图 $G_{new}(V_{new}, E_{new})$ 即为原图 $G(V, E)$ 的最小生成树。</li></ol><p>只需要证明根据第二步所得到边一定为最优解即可。</p><ol><li><p>按照Prim算法得到的第一条边一定是最小生成树上的边。</p><p>如果不是，我们把这一条边加入到最小生成树中，形成回路，我们让最小的边取代回路中比它大的边，得到权值更小的生成树。所以第一条边一定是最小生成树上的边。</p></li><li><p>假设在某一个步骤中，Prim得到的点集为 $V_{new} = \{v1, v2, v3 \ldots vs-1\}$ 。 根据Prim算法，我们应该选择与这些点有交集的边中，权值最小的边。</p><p>假设这个权值最小的边连接 $V_{new}$ 中的 $vk$ ，如果不选择这条边，那么我们把这条边加入最小生成树中，形成一个回路，且这个回路包含 $vk$ ，我们假设连接 $vk$ 的那条边另一端为 $vi$ ，我们用权值最小的边替换掉 $(vk, vi)$ ，得到的生成树权值一定不大于最小生成树，因此选择这条边为最优边。</p></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx; <span class="comment">// 邻接表存图</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// st(x) 表示x点已经加入生成树中</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">// dist(x) 表示x点距离已经生成的树的最小距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span> <span class="params">()</span> <span class="comment">// 返回最小生成树的权值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d); d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始化从1开始，最开始生成树上的V和E都为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 要加入n个点，迭代n次，每次放进一个点</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 找出距离当前生成树最近的点</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[k] &amp;&amp; (t == <span class="number">-1</span> || dist[k] &lt; dist[t])) t = k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把选择的点加入生成树中</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        ret += dist[t];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于加入了一个点，那么其他点也可以通过连接这个点到达生成树，更新dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], w[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有没有觉得Prim算法和Dijkstra算法雷同？没错，它们都是根据同样的贪心思想，唯一的区别仅仅在于更新的时候。</p><p><strong>Prim算法复杂度</strong>：根据上述代码，复杂度为 $O(n^2 + 2E)$ ，由于图上每个点至多被更新 $1$ 次，所以图的所有边至多被更新 $2$ 次。</p><p>与Dijsktra算法一样，Prim算法可以使用二叉堆优化，复杂度降到 $O((n + 2E)logn)$ 。</p><hr><h1 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h1><p>如果说Prim算法是小树长成大树的过程，那么Kruskal算法就是拼图的过程。</p><p>Prim算法基于点来扩大树，而Kruskal基于边来扩大，具体来说，该算法的过程如下：</p><ol><li>将图 $G(V, E)$ 的所有边按权值进行非递减排序。</li><li>初始化每个点都为单独的连通分量。（因为此时我们还没有选择边作为最小生成树的一部分）</li><li>从后往前检查所有边$(u, v)$ 。<ul><li>$u$ 和 $v$ 在同一个连通分量里，那么加入 $(u, v)$ 会产生环，因此不能选择。</li><li>$u$ 和 $v$ 不在一个连通分量里，那么加入 $(u, v)$ 一定是最优的。如果不加入，形成生成树 $T$ ，把 $(u, v)$ 加入 $T$ 中，会形成环，环中包含 $(u, v)$ 和另外一条权值不小于 $(u, v)$ 的边，我们把这条边用 $(u, v)$ 替换，不会使结果变差，因此 $(u, v)$ 是最优的选择。</li></ul></li></ol><p>因为会考虑所有边，因此一定能构成一颗完整的最小生成树（除非原图不连通）。</p><p>在Kruskal算法中，最关键的地方在于“连通”分量的查询和合并，需要知道两个点是否在一个连通分量中，以及如果不是在一个连通分量，需要将其合并，我们可以使用<a href="https://horb7.github.io/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/"><strong>并查集</strong></a>来支持此操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span></span><br><span class="line">    <span class="keyword">int</span> u, v, d; <span class="comment">// 表示边两端的点以及边权</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp; rhs) <span class="keyword">const</span> { <span class="comment">// 重载小于号，支持比较</span></span><br><span class="line">        <span class="keyword">return</span> d &lt; rhs.d;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">Edge edges[M];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edges + <span class="number">1</span>, edges + m + <span class="number">1</span>); <span class="comment">// 假设边集从1开始存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, cnt = <span class="number">0</span>; <span class="comment">// cnt表示目前已经选择了多少条边（生成树只需要n-1条边）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; cnt &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u = edges[i].u, v = edges[i].v, d = edges[i].d;</span><br><span class="line">        u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        ++ cnt, res += d, p[u] = v;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 原图不连通，没有生成树，何谈最小</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近公共祖先</title>
      <link href="/2022/02/16/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2022/02/16/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h1 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先 (LCA)"></a>最近公共祖先 (LCA)</h1><p>在一个有根树中，两个结点 $a、b$ 都有若干个祖先(本身也是自己的祖先)，他们也会有公共的祖先，距离他们最近，也就是在有根树中深度最大的祖先，被称做 $a、b$ 的最近公共祖先。</p><h2 id="求最近公共祖先"><a href="#求最近公共祖先" class="headerlink" title="求最近公共祖先"></a>求最近公共祖先</h2><h3 id="向上标记法"><a href="#向上标记法" class="headerlink" title="向上标记法"></a>向上标记法</h3><p>先从一个点开始向上走到根节点，再由另一个结点开始向上走，走到一个已经被标记过的结点，那么这个结点就是这两个点的最近公共祖先。</p><p>最坏情况下树为一条链，时间复杂度为 $O(n)$ 。</p><p>由于复杂度比较大，因此这个算法不常用。</p><h3 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h3><p>倍增法基于<strong>二进制拆分</strong>，每次都尽可能向上多跳几步。</p><p>$\displaystyle {fa(i, j})$ 表示结点 $i$ 向上走 $2^j$ 次后到达的结点。</p><p>$depth(i)$ 表示结点 $i$ 在有根树中的深度。</p><p>对于结点 $a 、 b$ ，假设 $depth(a) &lt; depth(b)$ ，我们先把 $a$ 跳到与 $b$ 相同的深度；如果此时 $a == b$ ，那么LCA就是 $y$ ；否则，我们同时让 $a、b$ 向上跳到不是 LCA 的结点，最后跳到的结点的父节点就是 LCA 。</p><p>由于每次跳的步数都是 $2$ 的整数次幂，所以时间复杂度为 $O (log n)$ 。</p><p>预处理出所有 $fa(i, j)$ 的时间复杂度为 $O (n log n)$ ，所以倍增法适用于多次查询LCA。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P3379">洛谷 P3379</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qus, root;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>]; <span class="comment">// fa(i, j) 表示i结点向上走 2^j 步到达的结点</span></span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="keyword">int</span> q[N]; <span class="keyword">bool</span> st[N]; <span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    st[root] = <span class="literal">true</span>; depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i] )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j])</span><br><span class="line">            {</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 初始化 fa(i, 0) 为父节点</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 预处理 fa 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; ++ j )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i )</span><br><span class="line">            fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 (a, b) 的lca</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 保证 a 的深度大于 b</span></span><br><span class="line">    <span class="comment">// a 跳到与 b 相同深度的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> b; <span class="comment">// a == b ，那么 b 就是 lca</span></span><br><span class="line">    <span class="comment">// 同时跳上面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">        {</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">            b = fa[b][i];</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>]; <span class="comment">// 此时 a 父节点就算 lca</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span> (x, y); <span class="built_in">add</span> (y, x);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">bfs</span> (); <span class="comment">// 求出每个结点的深度及fa数组</span></span><br><span class="line">    <span class="keyword">while</span> (qus -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span> (x, y) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Tarjan离线算法"><a href="#Tarjan离线算法" class="headerlink" title="Tarjan离线算法"></a>Tarjan离线算法</h3><p>Tarjan算法基于深度优先遍历，本质上是对向上标记法的优化。</p><p>遍历有根树，给每个结点分为三类。</p><ul><li>已经遍历过并且已经回溯的点</li><li>正在被遍历的点</li><li>还没有被搜索过的点</li></ul><p><strong>当一个结点回溯，我们将它合并到它的父节点上</strong>，我们可以发现，<strong>如果一次查询包括当前正在被遍历的结点和已经回溯的结点，那么他们的 LCA 就是已经回溯的点所在的集合的祖先结点</strong>。而合并及查询集合祖先的操作可以使用并查集。</p><p><img src="/images/ds/lca-tarjan.png" alt=""></p><p>如图，粉色是未被搜索到的点，蓝色是正在被遍历的点，其他都是已经遍历的点(有些未回溯，所以他们处于不同的集合)。</p><p>绿色和黄色任意点的LCA都是黄色点集合的祖先结点，其他也是如此。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P3379">洛谷 P3379</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qus, root;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> st[N]; <span class="comment">// 记录每个点的状态：1表示正在搜索，2表示已经回溯，0表示还没有搜索到</span></span><br><span class="line">vector&lt;PII&gt; query[N]; <span class="comment">// query[i] -&gt; (j, id) 表示在第id个查询中，查询的结点是(i, j)</span></span><br><span class="line"><span class="keyword">int</span> ans[N]; <span class="comment">// 存储每个查询的结果</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span> <span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    st[u] = <span class="number">1</span>; <span class="comment">// 正在搜索 u 结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">// 如果还没有遍历，则遍历子结点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) { <span class="built_in">tarjan</span>(j); p[j] = u; } <span class="comment">// 回溯后记得及时合并到父节点上</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : query[u])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> y = t.first, id = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>) ans[id] = <span class="built_in">find</span>(y); <span class="comment">// 如果j已经回溯</span></span><br><span class="line">    }</span><br><span class="line">    st[u] = <span class="number">2</span>; <span class="comment">// u 结点回溯</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; qus &gt;&gt; root;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span> (x, y); <span class="built_in">add</span> (y, x);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qus; ++ i )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        {</span><br><span class="line">            query[x].<span class="built_in">push_back</span>({y, i});</span><br><span class="line">            query[y].<span class="built_in">push_back</span>({x, i});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i ) p[i] = i;</span><br><span class="line">    <span class="built_in">tarjan</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i ) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形纸牌均分问题</title>
      <link href="/2022/02/16/%E7%8E%AF%E5%BD%A2%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/16/%E7%8E%AF%E5%BD%A2%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="环形纸牌均分问题"><a href="#环形纸牌均分问题" class="headerlink" title="环形纸牌均分问题"></a>环形纸牌均分问题</h1><blockquote><p>环形纸牌均分是一道很经典的贪心问题，但是每次遇到类似的都想不出来，于是就有了这篇博客记录QAQ。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有 $n$ 堆纸牌围成环形，每堆纸牌拥有 $a_i$ 个纸牌，第 $i$ 堆纸牌可以顺时针或者逆时针传播一张牌，代价为 $1$ 。问使得每堆牌的牌数数量都相等，需要的最少代价为多少？</p><p>$1 \le n \le 10^6, 1 \le a_i \le 10^9$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假设第 $i$ 堆纸牌顺时针传播了 $s_i$ 张纸牌，那么第 $i$ 堆纸牌最终有 $a_i - s_i + s_{i-1}$ 张纸牌。</p><p>由于最终纸牌数量都相等，因此有 $\overline a = \dfrac {a_1 + a_2 + \ldots + a_n} n$ 。</p><p>那么有 ：</p><script type="math/tex; mode=display">\begin{aligned}&\overline a = a_1 - s_1 + s_n \\&\overline a = a_2 - s_2 + s_1 \\&\overline a = a_3 - s_3 + s_2 \\& \ldots \\&\overline a = a_n - s_n + s_{n - 1} \\\end{aligned}</script><p>我们把 $s_i$ 提取出来：</p><script type="math/tex; mode=display">\begin{aligned}&s_1 = s_n - (\overline a - a_1) \\&s_2 = s_1 - (\overline a - a_2) = s_n - (\overline a - a_1) - (\overline a - a_2) = s_n - (2 \times \overline a - (a_1 + a_2)) \\&s_2 = s_2 - (\overline a - a_3) = s_n - (2 \times \overline a - (a_1 + a_2)) - (\overline a - a_3) = s_n - (3 \times \overline a - (a_1 + a_2 + a_3)) \\& \ldots \\&s_n = s_{n} - (n \times \overline a - (a_1 + a_2 + \ldots + a_n)) \\\end{aligned}</script><p>题目要我们求得是 $res = \sum_{i=1}^n |s_i|$ 。</p><p>所以 $res = |s_n - (\overline a - a_1)| + |s_n - (2 \times \overline a - (a_1 + a_2))| + \ldots + |s_n - (\overline n \times a - (a_1 + \ldots a_n))|$ 。</p><p>我们令 $x = s_n, \ i \times \overline a - \sum_{j = 1}^i a_j = c_i$ 。</p><p>那么 $res = |x - c_1| + |x - c_2| + |x - c_3| + \ldots + |x - c_n|$ 。</p><p>问题变成了仓库选址问题，选出一个点在数轴上与各点距离和最小，选择中位数即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll s[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>]; <span class="comment">// 求前缀和，方便计算c(i)</span></span><br><span class="line">    ll A = s[n] / n; <span class="comment">// 均值，最后到达的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[i] = i * A - s[i];</span><br><span class="line">    <span class="built_in">nth_element</span>(c + <span class="number">1</span>, c + (n + <span class="number">1</span>) / <span class="number">2</span>, c + n + <span class="number">1</span>); <span class="comment">// 求出中位数</span></span><br><span class="line">    ll x = c[(n + <span class="number">1</span>) / <span class="number">2</span>], res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res += <span class="built_in">abs</span>(x - c[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/124/">AcWing122.糖果传递</a>    模板题</p><p><a href="https://www.acwing.com/problem/content/107/">AcWing105.七夕祭</a>       排序+环形均分纸牌</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">int</span> c[N], r[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对n个人均分纸牌</span></span><br><span class="line"><span class="function">ll <span class="title">calc</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> aver = t / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) pre[i] = pre[i - <span class="number">1</span>] + a[i] - aver;</span><br><span class="line">    <span class="built_in">sort</span>(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>);</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) ret = ret + <span class="built_in">abs</span>(pre[i] - pre[n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= t &amp;&amp; cin &gt;&gt; x &gt;&gt; y; i ++ ) ++ c[x], ++ r[y];</span><br><span class="line">    <span class="keyword">if</span> (t % n == <span class="number">0</span> &amp;&amp; t % m == <span class="number">0</span>) cout &lt;&lt; <span class="string">"both "</span> &lt;&lt; <span class="built_in">calc</span>(c, n) + <span class="built_in">calc</span>(r, m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t % n == <span class="number">0</span>) cout &lt;&lt; <span class="string">"row "</span> &lt;&lt; <span class="built_in">calc</span>(c, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t % m == <span class="number">0</span>) cout &lt;&lt; <span class="string">"column "</span> &lt;&lt; <span class="built_in">calc</span>(r, m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">"impossible"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛</title>
      <link href="/2022/02/16/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2022/02/16/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="质数筛选"><a href="#质数筛选" class="headerlink" title="质数筛选"></a>质数筛选</h1><blockquote><p>  质数筛选指在一个范围内筛去非质数，留下质数，通常用单独的质数数组保存留下的质数。</p></blockquote><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>对于每个数字(从2开始)，筛去它所有的倍数，那么留下来的一定都是质数。</p><p>证：对于任意和数 $x$ ，一定存在一个质因数 $pj$ ，那么我们一定可以用 $pj$ 筛去 $x$ 。</p><p>时间复杂度 $O (n log n)$。</p><p>证：对于每个数字 $i$ ，内层循环会执行 $n / i$ 次。那么一共执行</p><script type="math/tex; mode=display">n / 2 + n / 3 + ... n / n = n(1 / 2 + 1 / 3 + ... + 1 / n) = n log n</script><pre><code>次。</code></pre><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!st[i]) prime[++ cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i ) st[j] = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们发现，对于每个和数 $x$ ，假设存在质因数 $pj$ ，那么如果我们用和数 $x$ 来筛去的数字也一定存在质因数 $pj$ ，也就是在 $x$ 之前这些数字就已经被 $pj$ 筛去，不需要再用 $x$ 筛去。</p><p>优化版：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!st[i])</span><br><span class="line">    {</span><br><span class="line">        prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i ) st[j] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>质数定理: $1 \sim n$ 中大约有 $n \ / \ ln \ n$ 个质数，那么总执行次数大约为 $n log n / log n = n$ ，实际复杂度大约为 $O(n log log n)$。 </p><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p>又称线性筛，每次我们都只用最小质因数来筛去和数 $x$ ，这样就不会重复筛数。因此时间复杂度为 $O(n)$ 。</p><p>原理写在代码块中，例题：</p><p>[洛谷3383]:</p><p><a href="https://www.luogu.com.cn/problem/P3383">https://www.luogu.com.cn/problem/P3383</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> prime[N], idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// O(n) 线性筛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 没有标记，是质数</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[++ idx] = i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            由于被筛选的值 k 可能含有多个质因数，会被筛去多次。</span></span><br><span class="line"><span class="comment">            我们只用k的最小质因数筛去k，这样每个数字都只会被筛去一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            k = prime[j] * i      i是当前数</span></span><br><span class="line"><span class="comment">            从小到大枚举所有质数</span></span><br><span class="line"><span class="comment">            1. i % prime[j] == 0  prime[j]是i的最小质因数，那么prime[j]一定是k的最小质因数</span></span><br><span class="line"><span class="comment">            2. i % prime[j] != 0  prime[j]小于i的任意质因数，那么prime[j]一定也是k的最小质因数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            对于每个和数x，一定存在最小质因数pj，那么当我们枚举到x / pj时，就可以把x筛去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; prime[j] &lt;= n / i; j ++ )</span><br><span class="line">        {</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                为什么这里需要break?</span></span><br><span class="line"><span class="comment">                假设当前被筛去的数字是 i * pj，由于i是pj的倍数，那么如果继续递增pj，i的最小质因数</span></span><br><span class="line"><span class="comment">                一定还是原来的pj，被筛去的数字最小质因数也一定是pj，那么我们再筛的话就会产生重复</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, prime[k]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); <span class="keyword">while</span> (T -- )</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树入门</title>
      <link href="/2022/02/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/"/>
      <url>/2022/02/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树介绍"><a href="#线段树介绍" class="headerlink" title="线段树介绍"></a>线段树介绍</h2><p>线段树是一种基于分治思想的二叉树结构，用于在区间上进行高效的信息统计。</p><p><img src="/images/ds/segment_tree_intro.png" alt=""></p><p>如图是一般的线段树结构，我们可以发现：</p><ol><li>线段树的每个节点都代表一个区间，且按照深度递增，代表的区间逐渐缩小。</li><li>线段树是单独的一棵树，具有唯一的根节点，它代表需要统计信息的整个区间。</li><li>线段树的每个叶子节点都代表一个长度为 $1$ 的区间 $[x, x]$ 。</li><li>对于每个非叶子结点 $[l, r]$ ，它的左节点为 $[l, mid]$ ，右节点为 $[mid+1, r]$ ，其中 $mid = (l + r) / 2$ 。</li></ol><p>如果去除最后一层，那么线段树是一棵完全二叉树，因此我们可以采用与二叉堆类似的存储形式：</p><ol><li>根节点编号为 $1$ 。</li><li>对于非叶子节点 $p$ ，左节点为 $p \times 2$ ，右节点为 $p \times 2 + 1$ 。</li></ol><p>需要注意的是，最后一层是不满的，我们需要空出数组的位置来表示空节点。</p><p>除去最后一层，由于最后第二层最多有 $n$ 个节点，因此满二叉树需要 $n + \dfrac n 2 + \dfrac n 4 + \ldots + 1 = 2 \times n - 1$ 个节点。</p><p>最后一层需要开 $n \times 2$ 个节点，因此我们需要至少 $n \times 4$ 的空间存储，才能保证数组不会越界。</p><hr><h2 id="线段树的建树"><a href="#线段树的建树" class="headerlink" title="线段树的建树"></a>线段树的建树</h2><p>线段树的基本用途是维护序列的某些属性，最基本的线段树具有查询和修改两个功能。给定长度为 $[1, n]$ 的序列，我们可以按 $[1, n]$ 的区间建一棵线段树。线段树基于分治思想，需要从上往下构建。递归完成后也可以方便地从下往上传递信息。</p><p>下面以维护区间最大值为例。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(p) (p&lt;&lt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(p) (p&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">// 节点的信息，维护 [l, r] 区间内的信息</span></span><br><span class="line">    <span class="keyword">int</span> maxv; <span class="comment">// 需要在区间上维护的信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>; <span class="comment">// 假设序列最长长度为 N</span></span><br><span class="line">seg_tree t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="comment">// 原序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 当前构建的节点及其需要维护的区间</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].maxv = a[l]; <span class="keyword">return</span>; } <span class="comment">// 到达叶子节点，不需要再往下创建节点</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 否则创建左节点 [l, mid] 和右节点 [mid+1, r]</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 构建完后需要维护这个区间的信息，由于已经创建好左节点(左边一半区间)和右节点(右边一半区间)，根据这两个节点来维护</span></span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">// 从根节点1开始，它维护的是整个区间[1, n]</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="线段树的单点修改"><a href="#线段树的单点修改" class="headerlink" title="线段树的单点修改"></a>线段树的单点修改</h2><p>利用线段树递归从下往上传递信息的结构，我们也可以很方便地修改某一个元素。</p><p>叶子节点代表单个长度的区间，也就是具体的某一个元素。我们可以递归地找到需要修改的叶子节点，在回溯的过程维护它的父节点(代表的区间包括自己的区间，所以也要修改)。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> <span class="comment">// 需要把x位置的元素改为v，目前为p节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) { t[p].maxv = v; <span class="keyword">return</span>; } <span class="comment">// 已经找到</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 否则判断去左区间找还是去右区间找</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), x, v); <span class="comment">// 左区间为[l, mid]，在这个区间内</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), x, v); <span class="comment">// 右区间为[mid+1, r]</span></span><br><span class="line">    t[p].maxv = <span class="built_in">max</span>(t[<span class="built_in">lc</span>(p)].maxv, t[<span class="built_in">rc</span>(p)].maxv); <span class="comment">// 注意修改完子区间后，当前区间需要维护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, x, v); <span class="comment">// 从根节点开始找</span></span><br></pre></td></tr></tbody></table></figure><p>在线段树的单点修改过程中，每一层只会被调用一次，而线段树的高度为 $log n$ ，因此复杂度为 $log n$ 。</p><hr><h2 id="线段树区间查询"><a href="#线段树区间查询" class="headerlink" title="线段树区间查询"></a>线段树区间查询</h2><p>以维护区间最大值的线段树为例，我们查找区间 $[l ,r]$ 的最大值，需要从根节点开始，递归完成：</p><ol><li>如果 $[l, r]$ 区间完全覆盖了当前节点的范围，直接返回当前节点维护的信息。</li><li>如果左节点和 $[l, r]$ 有交叉，那么递归查询左节点。</li><li>如果右节点和 $[l, r]$ 有交叉，那么递归查询右节点。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 需要查询[l, r]的最大值，当前节点为p</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="keyword">return</span> t[p].maxv; <span class="comment">// 完全覆盖，节点区间内所有元素都是查询区间内的元素</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 否则查询左节点和右节点</span></span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">-2e9</span>; <span class="comment">// 设为负无穷</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) maxv = <span class="built_in">max</span>(maxv, <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r)); <span class="comment">// [l, r]与左节点有交叉</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) maxv = <span class="built_in">max</span>(<span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r)); <span class="comment">// [l, r]与右节点有交叉</span></span><br><span class="line">    <span class="keyword">return</span> maxv;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl; <span class="comment">// 从根节点开始查询</span></span><br></pre></td></tr></tbody></table></figure><p>关于复杂度：</p><ol><li><p>在任意一个节点，只查询它的左节点/右节点。</p><p>显然复杂度是 $O(log n)$ 的。</p></li><li><p>在某些节点，查询左右节点。</p><p>在左节点，显然又有两种可能，如果只查询一遍，那么可以保证 $O(log n)$ 的复杂度，如果查询左右两边，那么左边一定是被完全覆盖的，因此可以直接回溯。右节点同理。</p><p>所以查询左右节点，本质只是比查询单边多了一次查询，因此复杂度为 $O(2 log n) = O(log n)$ 。</p></li></ol><hr><h2 id="线段树的区间修改"><a href="#线段树的区间修改" class="headerlink" title="线段树的区间修改"></a>线段树的区间修改</h2><p>假设现在要把 $[l, r]$ 中所有元素加上 $v$ ，一种显然的做法是对 $[l, r]$ 中所有元素执行一次单点修改，但这样的复杂度为 $O(len \times log n)$ 的，最坏情况下修改所有元素，则需要修改整棵树，复杂度 $O(n)$ 。</p><p>可以发现，如果我们对区间 $[l, r]$ 中所有元素进行修改，但后面的查询中没有用到 $[l, r]$ 的子区间 ，那么这个修改是无意义的。也就是说，最<strong>好的办法就是在查询时才更新当前的区间</strong> 。</p><p>类似于区间查找，当我们发现某一个节点维护的区间被需要修改的区间覆盖，那么我们修改完当前节点后，直接回溯，不用对其递归修改，比如修改区间 $[1, 10]$ ，当我们递归到节点 $[1, 5]$ 时，就可以修改并回溯。同时我们要给这个节点打上标记，表示当前节点已经修改，但其子区间未修改。</p><p>在之后的查询过程中，如果需要使用其子结点，则使用标记的信息更新两个子结点，同时为子结点打上标记，再清除当前节点的标记。</p><p>类似于区间查询，区间修改会将区间划分为 $O(log n)$ 个小区间，将复杂度降为 $O(log n)$ 。</p><p>下面以例题 <a href="https://www.luogu.com.cn/problem/P3372">[模板]线段树1</a> 为例。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以维护区间和为例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll sum, add; <span class="comment">// sum为[l, r]区间元素的和，add为懒标记，记录当前这个区间，每个元素加了多少</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">seg_tree t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span> <span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// pushup操作：自下而上维护每个节点的sum值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].sum = t[<span class="built_in">lc</span>(p)].sum + t[<span class="built_in">rc</span>(p)].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// pushdown操作：将懒标记下传，将子节点变为真实值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!t[p].add) <span class="keyword">return</span> ; <span class="comment">// 如果当前位置没有懒标记，直接返回</span></span><br><span class="line">    t[<span class="built_in">lc</span>(p)].sum += t[p].add * (t[<span class="built_in">lc</span>(p)].r - t[<span class="built_in">lc</span>(p)].l + <span class="number">1</span>); <span class="comment">// 左节点</span></span><br><span class="line">    t[<span class="built_in">rc</span>(p)].sum += t[p].add * (t[<span class="built_in">rc</span>(p)].r - t[<span class="built_in">rc</span>(p)].l + <span class="number">1</span>); <span class="comment">// 右节点</span></span><br><span class="line">    t[<span class="built_in">lc</span>(p)].add += t[p].add; <span class="comment">// 给左节点加懒标记，注意左节点可能已经加过懒标记</span></span><br><span class="line">    t[<span class="built_in">rc</span>(p)].add += t[p].add; <span class="comment">// 给右节点加懒标记，注意右节点可能已经加过懒标记</span></span><br><span class="line">    t[p].add = <span class="number">0</span>; <span class="comment">// 清除p的懒标记</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) { t[p].sum = a[l]; <span class="keyword">return</span>; } <span class="comment">// 到达叶子节点，此时区间长度为1，sum即为此位置的值</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid); <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="comment">// 使用pushup自下往上维护信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> <span class="comment">// 为[l, r]区间所有数字增加v</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="comment">// 当前节点被[l, r]区间覆盖</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 修改当前区间，打上标记并回溯</span></span><br><span class="line">        t[p].sum += (ll)v * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="comment">// 此时这个点的子节点需要使用，将懒标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">lc</span>(p), l, r, v); <span class="comment">// 左节点[t[p].l, mid]有部分被覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(<span class="built_in">rc</span>(p), l, r, v); <span class="comment">// 右节点[mid+1, t[p].r]有部分被覆盖</span></span><br><span class="line">    <span class="built_in">pushup</span>(p); <span class="comment">// 子结点被修改，记得维护当前节点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="comment">// 子节点需要使用，记得下传懒标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>; <span class="comment">// 当前节点被[l, r]覆盖的元素的和</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret += <span class="built_in">query</span>(<span class="built_in">lc</span>(p), l, r); <span class="comment">// 左节点[t[p].l, mid]有部分被覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret += <span class="built_in">query</span>(<span class="built_in">rc</span>(p), l, r); <span class="comment">// 右节点[mid+1, t[p].r]有部分被覆盖</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">// 在区间[1, n]上建立线段树</span></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> op, l, r, v;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) cin &gt;&gt; v, <span class="built_in">modify</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><a href="https://www.acwing.com/problem/content/248/">一个简单的整数问题</a> 可以使用树状数组</li><li><p><a href="https://www.acwing.com/problem/content/244/">一个简单的整数问题2</a> 区间加，区间和</p></li><li><p><a href="https://ac.nowcoder.com/acm/contest/23479/B">进制</a> 维护所有进制</p></li><li><p><a href="https://www.acwing.com/problem/content/246/">你能回答这些问题吗</a> 比较难的题目，需要维护较多信息</p></li><li><p><a href="https://www.acwing.com/problem/content/247/">区间最大公约数</a> 更损相减法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edu Codeforces Round 121</title>
      <link href="/2022/02/16/Edu-Codeforces-Round-121/"/>
      <url>/2022/02/16/Edu-Codeforces-Round-121/</url>
      
        <content type="html"><![CDATA[<h1 id="Edu-Codeforces-Round-121"><a href="#Edu-Codeforces-Round-121" class="headerlink" title="Edu Codeforces Round 121"></a>Edu Codeforces Round 121</h1><h2 id="C-Monsters-And-Spells"><a href="#C-Monsters-And-Spells" class="headerlink" title="C. Monsters And Spells"></a>C. Monsters And Spells</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 只怪物需要被消灭，第 $i$ 只怪物在 $k_i$ 秒出现，有 $h_i$ 点生命值 ，<strong>必须在怪物出现的那一秒消灭他</strong>。</p><p>Monocarp 每秒可以使用一次法咒，可以选择法咒伤害为 $x + 1$ 或 $1$ ，$x$ 为上一秒使用法咒造成的伤害。</p><p>使用伤害为 $x$ 的法咒，会消耗 $x$ 点法力值。</p><p>问Monocarp至少需要消耗多少法力值才能消灭 $n$ 只怪物。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于第 $i$ 只怪物，需要使用法咒的区间为 $[k_i - h_i + 1, k_i]$ 。也就是至少要从 $k_i - h_i + 1$ 位置开始使用法咒。</p><p>这个区间可能会有重复，比如两只怪物的区间为 $[l_1, r_1]$ 和 $[l_2, r_2]$ 。其中 $l_1 \le l_2 \le r_1$ 。</p><p>那么对于区间 $[l_2, r_2]$ 的怪物，我们需要从 $l_1$ 开始使用法咒，否则不能消灭第一只怪物。</p><p>也就是说消灭这两只怪物的区间为两个区间的合并，即 $[l_1, r_2]$ 。</p><p>推广到所有怪物，只需要把他们的<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/">区间合并</a>即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(x, s) for (auto x : s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a), end(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb emplace_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> T = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">k</span><span class="params">(n)</span>, <span class="title">h</span><span class="params">(n)</span></span>;</span><br><span class="line">    forr(&amp;x, k) cin &gt;&gt; x;</span><br><span class="line">    forr(&amp;x, h) cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    vector&lt;T&gt; v, f; <span class="comment">// v存储所有怪物的区间，f存储合并后的区间</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n<span class="number">-1</span>) v.<span class="built_in">pb</span>(k[i] - h[i] + <span class="number">1</span>, k[i]);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 合并区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [x, y] : v)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (f.<span class="built_in">empty</span>() || f.<span class="built_in">back</span>().second &lt; x) f.<span class="built_in">pb</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> f.<span class="built_in">back</span>().second = <span class="built_in">max</span>(f.<span class="built_in">back</span>().second, y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [x, y] : f)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> cost = y - x + <span class="number">1</span>;</span><br><span class="line">        ret += (<span class="number">1</span> + cost) * cost / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="D-Martial-Arts-Tournament"><a href="#D-Martial-Arts-Tournament" class="headerlink" title="D. Martial Arts Tournament"></a>D. Martial Arts Tournament</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个参赛选手，第 $i$ 个选手体重为 $a_i$ ，现在要根据选手的体重分为三个赛区，轻量、中量、重量区。</p><p>选择两个标准 $x, y$ ，所有严格小于 $x$ 重量的选手在轻量赛区，所有不小于 $y$ 重量的选手在重量赛区。</p><p>现在要使三个赛区的选手数量为 $2$ 的幂，请问至少需要加多少选手？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>前缀和思想，令 $f(x)$ 表示轻量赛区需要 $x$ 个人，实际上有多少人(因为间断点左右不能重量相同) 。同理 $g(x)$ 表示重量赛区需要 $x$ 个人，实际上有多少人。</p><p>枚举 $f(x)$ 和 $g(y)$ 中的 $x$ 和 $y$ 都为 $2$ 的幂次的情况，求出中量赛区需要多少人，加起来就是总共需要的人数，取最小值即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="keyword">int</span> x; cin &gt;&gt; x; ++ a[x]; }</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// rep(i, 1, n) 枚举重量，s维护前缀和(人数)</span></span><br><span class="line">    <span class="comment">// 第二个循环rep(j, s, s + a[i] - 1) 其实是枚举中间的间断点，此时应该还是s，不能累加上自己，因为间断点左右不能重量相同。</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) { <span class="built_in">rep</span>(j, s, s + a[i] - <span class="number">1</span>) f[j] = s; s += a[i]; }</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) { <span class="built_in">rep</span>(j, s, s + a[i] - <span class="number">1</span>) g[j] = s; s += a[i]; }</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n; a &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n; b &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x = f[a], y = g[b];</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">1</span>; <span class="keyword">while</span>(ans &lt; n - x - y) ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, ans + a + b);</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; ret - n &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用C++连接MySql</title>
      <link href="/2022/02/16/Linux%E4%B8%8BMySql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/16/Linux%E4%B8%8BMySql%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h1><p>在Ubuntu 20.04环境下，我们已经安装好MySql，如果想要用C++连接MySql，我们还需要mysql-client，完整的需要以下几项：</p><p><code>sudo apt-get install mysql-server</code></p><p><code>sudo apt-get install apache2</code></p><p><code>sudo apt-get install libmysqlclient-dev</code></p><p>安装后，检查<code>/usr/include/mysql</code>中是否存在<code>mysql.h</code>文件：</p><p><img src="/images/db/mysql_h.png" alt=""></p><p>如果存在，说明安装成功，可以用C++连接MySql数据库了。</p><hr><h1 id="使用C-连接MySql"><a href="#使用C-连接MySql" class="headerlink" title="使用C++连接MySql"></a>使用C++连接MySql</h1><h2 id="相关API介绍"><a href="#相关API介绍" class="headerlink" title="相关API介绍"></a>相关API介绍</h2><p>在cpp文件中，我们需要引入<code>mysql.h</code>头文件来使用MySql相关API。</p><p>这里列出常用的函数。（注：MYSQL为结构体，存储mysql操作的处理）</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">MYSQL * mysql_init(MYSQL * mysql)</td><td>初始化MYSQL结构体，参数为NULL指针则分配+初始化</td></tr><tr><td style="text-align:left">MYSQL * mysql_real_connect(MYSQL * mysql, const char * host, const char * user, const char * passwd, const char * db, unsigned int port, const char * unix_socket, unsigned long client_flag)</td><td>把mysql结构体连接到具体的服务器的某个用户上，返回非0表示连接成功</td></tr><tr><td style="text-align:left">int mysql_query(MYSQL * mysql, const char * stmt_str)</td><td>执行SQL查询，若成功查询返回0，否则返回1</td></tr><tr><td style="text-align:left">MYSQL_RES * mysql_store_result(MYSQL * mysql)</td><td>存储上次查询的所有结果</td></tr><tr><td style="text-align:left">int mysql_next_result(MYSQL * mysql)</td><td>查看是否存在下一个结果集（一次查询可能返回多个表）并把指针放到下一个表便于查询。返回0表示存在，非0表示不存在。</td></tr><tr><td style="text-align:left">unsigned int mysql_num_fields(MYSQL_RES * result)</td><td>返回结果集的列数</td></tr><tr><td style="text-align:left">unsigned int mysql_num_rows(MYSQL_RES * result)</td><td>返回结果集的行数</td></tr><tr><td style="text-align:left">MYSQL_ROW mysql_fetch_row(MYSQL_RES * result)</td><td>从结果集中返回下一行数据，NULL表示结束</td></tr><tr><td style="text-align:left">MYSQL_FIELD mysql_fetch_field(MYSQL_RES * result)</td><td>从结果集中返回下一列数据，NULL表示结束</td></tr><tr><td style="text-align:left">char * mysql_error(MYSQL * mysql)</td><td>返回上一次的报错信息</td></tr><tr><td style="text-align:left">void mysql_free_result(MYSQL_RES * result)</td><td>释放结果集所占的内存</td></tr><tr><td style="text-align:left">void mysql_close(MYSQL * mysql)</td><td>关闭结构体对数据库的连接</td></tr></tbody></table></div><hr><h2 id="C-连接MqSql基本流程"><a href="#C-连接MqSql基本流程" class="headerlink" title="C++连接MqSql基本流程"></a>C++连接MqSql基本流程</h2><ol><li>使用mysql_init()初始化结构体</li><li>使用mysql_real_connect()建立结构体与对应数据库的连接</li><li>使用mysql_query()进行相关的数据操作</li><li>输出查询：<ol><li>使用res = mysql_store_result(mysql)来获取查询的结果集</li><li>使用mysql_num_rows(res)获取行数，mysql_num_fields(res)获取列数</li><li>不断通过mysql_fetch_row(res)来获取每一行的查询数据，直到结束</li></ol></li><li>释放结果集所占的内存mysql_free_result(res)</li><li>mysql_close(mysql)关闭结构体与数据库的连接</li></ol><p><strong>注意点</strong>：由于我们使用的不是C++原有的库，所以在编译的时候要指明额外使用的库</p><p>编译命令：<code>g++ test.cpp -o main -I/usr/include/mysql -lmysqlclient</code></p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"*******"</span> <span class="comment">// 此处为你的服务器ip地址，如果为本地则输入localhost</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"*****"</span> <span class="comment">// 服务器用户名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"******"</span> <span class="comment">// 用户名对应的密码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATABASE <span class="meta-string">"*******"</span> <span class="comment">// 需要使用的数据库名字</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * sql_operator = <span class="string">"insert into student(class, sid, sname) values('cs2001', 111111111, 'i_dont_know')"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * sql_query = <span class="string">"call attend_exam(1)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sql_operator: %s\n"</span>, sql_operator);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sql_query: %s\n"</span>, sql_query);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator_sql(sql_operator);</span></span><br><span class="line">    <span class="built_in">query_sql</span>(sql_query);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MYSQL conn;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="built_in">mysql_init</span>(&amp;conn);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_real_connect</span>(&amp;conn, HOST, USERNAME, PASSWORD, DATABASE, <span class="number">0</span>, <span class="literal">NULL</span>, CLIENT_FOUND_ROWS))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connect success!\n"</span>);</span><br><span class="line">        res = <span class="built_in">mysql_query</span>(&amp;conn, sql);</span><br><span class="line">        <span class="keyword">if</span> (res) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">mysql_error</span>(&amp;conn)); <span class="comment">// 如果执行不成功，输出报错信息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"operator success!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">mysql_close</span>(&amp;conn);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * sql)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MYSQL my_connection; <span class="comment">// 数据库连接</span></span><br><span class="line">    <span class="keyword">int</span> res; <span class="comment">// 执行sql语句后的返回标志</span></span><br><span class="line">    MYSQL_RES * res_ptr; <span class="comment">// 指向查询结果的指针</span></span><br><span class="line">    MYSQL_FIELD * field; <span class="comment">// 字段结构指针</span></span><br><span class="line">    MYSQL_ROW result_row; <span class="comment">// 按行返回的查询信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row, column; <span class="comment">// 查询返回的行数和列数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">mysql_init</span>(&amp;my_connection); <span class="comment">// 初始化mysql连接my_connection</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_real_connect</span>(&amp;my_connection, HOST, USERNAME, PASSWORD, DATABASE, <span class="number">0</span>, <span class="literal">NULL</span>, CLIENT_FOUND_ROWS))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connectio success!\n"</span>);</span><br><span class="line">        <span class="comment">// 设置查询编码为utf8</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(&amp;my_connection, <span class="string">"set names utf8"</span>);</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">mysql_query</span>(&amp;my_connection, sql); <span class="comment">// 查询，返回0代表成功</span></span><br><span class="line">        <span class="keyword">if</span> (res) <span class="built_in">printf</span>(<span class="string">"Error: mysql_query!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 执行成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"query some row\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> tables = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 把返回信息的所有表都输出</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                res_ptr = <span class="built_in">mysql_store_result</span>(&amp;my_connection);</span><br><span class="line">                <span class="keyword">if</span> (res_ptr) <span class="comment">// 结果不为空，说明有结果</span></span><br><span class="line">                {</span><br><span class="line">                    column = <span class="built_in">mysql_num_fields</span>(res_ptr); <span class="comment">// 此表的列数</span></span><br><span class="line">                    row = <span class="built_in">mysql_num_rows</span>(res_ptr); <span class="comment">// 此表的行数</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"查询到第 %d 行, 此为第 %d 张表\n"</span>, row + <span class="number">1</span>, ++ tables);</span><br><span class="line">                    <span class="comment">// 输出每一列的属性</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; field = <span class="built_in">mysql_fetch_field</span>(res_ptr); i ++ )</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s\t"</span>, field-&gt;name);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(result_row = <span class="built_in">mysql_fetch_row</span>(res_ptr))</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j ++ )</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">"%s\t"</span>, result_row[j]);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">               <span class="keyword">else</span> <span class="built_in">mysql_free_result</span>(res_ptr); <span class="comment">// 如果以及查询完毕，则释放查询结果占用的内存</span></span><br><span class="line">            } <span class="keyword">while</span>(!<span class="built_in">mysql_next_result</span>(&amp;my_connection)); <span class="comment">// 返回0则代表还有剩余的结果</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">mysql_close</span>(&amp;my_connection); <span class="comment">// 查询结束，关闭结构体与数据库的连接</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher算法</title>
      <link href="/2022/02/16/Manacher%E7%AE%97%E6%B3%95/"/>
      <url>/2022/02/16/Manacher%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher是一种<strong>处理字符串最长回文子串</strong>的算法，由Manacher于1975年发明。</p><p>Manacher算法与KMP思想类似，都是反复对以往已经处理过的信息的再次运用，以达到减少重复计算的目的。</p><p>在朴素算法中，我们枚举了每个中心点 $i$​​ 的位置，并从中心点由0不断增长，求出以 $i$​ 为中心点时的最长回文串，而Manacher正是对此的优化。</p><p>首先，回文串有奇偶之分，在朴素算法中需要分别处理，我们可以直接在每个字符前后加一个字符串中不出现的字符(‘#’)，这样所有的回文串都变成了奇回文串，同时为了处理越界问题，需要在整个字符串前后加两个不同的字符(可以是’@’和’^’等)。</p><p>==”abac” —&gt;”@#a#b#a#c#^”==</p><p>我们用 $p[i]$​​ ​表示以 $i$​​​​ 为中心点时的<strong>最大回文半径</strong>，即，对于上述例子，$p[4] = 4(b作为中心点)$​ 。​</p><p>假设我们正在处理以第 $i+1$ 为中心点的字符串，如果前 $i$ 个字符串中，第 $j$ 个字符串向右延伸地最长，为maxRange，存在下列两种情况：</p><ol><li><p>$i+1&lt;maxRange$​​ ，那么，根据回文串的对称性，在 $i+1$​​ 关于$j$​​对称的地方$(记作k)$​，$s[i] == s[k]$，我们可以用之前计算的 $k$ 来​​给 $i$ 赋一个初值。​ </p></li><li><p>$i+1&gt;=maxRange$​，直接记第 $i+1$​ 位初始值为1即可。</p></li></ol><p><em>Code</em></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ss[<span class="number">0</span>] = <span class="string">'@'</span>; ss[++len] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">{</span><br><span class="line">    ss[++len] = s[i];</span><br><span class="line">    ss[++len] = <span class="string">'#'</span>;</span><br><span class="line">}</span><br><span class="line">ss[++len] = <span class="string">'^'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (maxRange &gt; i) p[i] = <span class="built_in">min</span>(maxRange - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">    <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i + p[i]] == s[i - p[i]]) p[i] ++ ;</span><br><span class="line">    <span class="keyword">if</span> (i + p[i] &gt; maxRange) maxRange = i + p[i], id = i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Manacher算法的时间复杂度时间复杂度为 $O(n)$，朴素算法时间复杂度为 $O(n^2)$。</p><p>时间复杂度证明：首先外层循环复杂度是 $O(n)$​ 的，只需要证明内层while循环总次数为 $O(n)$​ 级别即可。<br>对于每个中心点，如果它向右拓展了 $k$​ 次，那么对于后面的 $k$​ 个数字，每个都可以少拓展一次(赋初值)，while总循环次数为 $O(n)$​。所以总复杂度为 $O(n)$​。</p><p>例题链接: <a href="https://www.acwing.com/problem/content/description/1526/">https://www.acwing.com/problem/content/description/1526/</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">char</span> ss[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>], len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    ss[<span class="number">0</span>] = <span class="string">'@'</span>;</span><br><span class="line">    ss[++len] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        ss[++len] = s[i];</span><br><span class="line">        ss[++len] = <span class="string">'#'</span>;</span><br><span class="line">    }</span><br><span class="line">    ss[++len] = <span class="string">'^'</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRange = <span class="number">-1</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (maxRange &gt; i) p[i] = <span class="built_in">min</span>(maxRange - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss[i + p[i]] == ss[i - p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; maxRange) maxRange = i + p[i], id = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) res = <span class="built_in">max</span>(res, p[i] - <span class="number">1</span>); <span class="comment">// id仅仅是拓展到最右边的位置，这个maxRange受到 i和p[i]共同影响，不能直接用p[id]-1作为结果</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql安装与简单配置</title>
      <link href="/2022/02/16/MySql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/02/16/MySql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-安装和配置"><a href="#Mysql-安装和配置" class="headerlink" title="Mysql 安装和配置"></a>Mysql 安装和配置</h1><p>纯小白开始用 mysql ，记录一下安装与配置的环节，便于以后查看。下文的 mysql 版本均为 $8.0$。 Linux版本为Ubuntu 20.04。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Ubuntu 20.04上，默认情况只有最新版本的mysql包含在apt存储库里，所以要先更新服务器的软件包索引：</p><p><code>sudo apt update</code></p><p>接下来安装mysql默认包。</p><p><code>sudo apt install mysql-server</code></p><p>安装完mysql后，它默认是启动的。</p><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><h3 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h3><p>mysql安装完毕后，数据目录必须初始化，使用 <code>sudo mysql_secure_installation</code> 来自动初始化数据目录。</p><p>之后需要对mysql安装的安全选项做一些修改。</p><ol><li>是否安装验证密码插件，用来测试mysql密码的强度。</li><li>为mysql root用户设置密码，然后确认。</li><li>之后的提示可以按 $enter$ 使用默认值。</li></ol><h3 id="修改用户身份验证和使用权限"><a href="#修改用户身份验证和使用权限" class="headerlink" title="修改用户身份验证和使用权限"></a>修改用户身份验证和使用权限</h3><p>在 mysql8.0 中，mysql root 用户设置为使用默认的 auth_socket 插件进行身份验证，而不是密码。如果要使用外部程序来访问用户，操作会变得繁琐。</p><p>我们可以把身份验证修改为使用密码验证。即把 $auth\_socket$ 变成 $mysql \_ native \_ password$ 模式。</p><p>首先进入到mysql里，<code>sudo mysql</code></p><p>接下来我们可以查看mysql用户的账号使用的身份验证方式。</p><p><code>SELECT user, plugin, host FROM mysql.user;</code></p><p><img src="/images/db/modify_passwd.png" alt="image-20211209232523927"></p><p>由于我这里已经设置了，所以是 $mysql \_ native \_ password$ 模式。</p><p>我们可以使用 $ALTER \ \ USER$ 命令修改root用户。注意要把 $password$ 设置为选择的密码规范（满足一定强度）。</p><p><code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password by 'password';</code> ，这里$password$ 填入你需要更改的密码。</p><p>然后需要使用 <code>FLUSH PRIVILEGES;</code> 来使服务器重新加载授权表并使新更改生效。</p><p>之后我们可以再次使用 <code>SELECT user, plugin, host FROM mysql.user;</code> 来验证是否修改了root 用户的登陆模式。</p><p>注意，如果使用了密码登录，我们可以使用 <code>mysql -u root -p</code> 这样的方式来访问mysql root用户。</p><h4 id="如何更改密码规范？"><a href="#如何更改密码规范？" class="headerlink" title="如何更改密码规范？"></a>如何更改密码规范？</h4><p>在我们设置密码的时候可能会出现 “mysql: Your password does not satisfy the current policy requirements” 这样的错误，这是因为密码规范比较高，而你设置的密码太简单。</p><p>如果要设置简单一点的密码，我们需要更改密码规范：</p><p>使用 <code>show variables like 'validate_password%'</code> 来查看当前的密码规范。</p><p><img src="/images/db/modify_passwd2.png" alt=""></p><p>$policy$ 表示当前密码规范强度（有 $LOW$, $MEDIUM$, $HIGH$ 三种强度）。</p><p>$length$ 表示密码至少需要多少长度。</p><p>我们可以对这两个属性进行设置：</p><p><code>set global validate_password.policy=0;</code></p><p><code>set global validate_password.length=1;</code></p><p>接下来我们再次使用 $ALTER \ \ USER$ 命令即可更改用户密码。</p><h3 id="修改用户或添加权限"><a href="#修改用户或添加权限" class="headerlink" title="修改用户或添加权限"></a>修改用户或添加权限</h3><h4 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h4><p>如果要查看用户比较少的属性，可以直接使用</p><p><code>use mysql;</code></p><p><code>SELECT user, host FROM mysql.user</code></p><p>来查询。</p><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><p><code>CREATE USER 'user_name'@'host' IDENTIFIED BY 'password'</code> </p><p>其中：</p><p>user_name 是你创建出来的用户的用户名。</p><p>host 表示这个新创建的用户登录模式，$localhost$ 表示只能从本服务器登录，$\%$ 表示可以从远程登录。</p><p>password 为新用户的密码，可以不填。</p><h4 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h4><p><code>GRANT privileges ON databasename.tablename TO 'username'@'host'</code></p><p>查看用户权限：<code>SHOW GRANTS FOR USER%host</code></p><p>其中：</p><p>privileges 表示赋予的权利，如 select，update，insert，delete等，如果要赋予全部权力，可以使用ALL。</p><p>databasename.tablename 表示某个数据库的某个表，如果可以对任意数据库的任意表做操作，可以使用 *.* 。</p><p>username@host 表示某一个用户。</p><h4 id="撤销用户权限"><a href="#撤销用户权限" class="headerlink" title="撤销用户权限"></a>撤销用户权限</h4><p><code>REVOKE privileges ON dataname.tablename FROM 'username'@'host'</code></p><h5 id="撤销操作的注意点"><a href="#撤销操作的注意点" class="headerlink" title="撤销操作的注意点"></a>撤销操作的注意点</h5><p><strong>撤销语句必须和之前的授权语句一模一样，否则无法撤销权限。</strong></p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p><code>DROP USER 'username'@'host'</code> </p><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><p><code>RENAME USER 'name1'@'host1' TO 'name2'@'host2'</code> </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2008传球游戏</title>
      <link href="/2022/02/16/NOIP2008%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/02/16/NOIP2008%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2008-传球游戏"><a href="#NOIP2008-传球游戏" class="headerlink" title="NOIP2008 传球游戏"></a>NOIP2008 传球游戏</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个同学围成一个圆圈，有一个球在某一个小蛮手中，每次传球可以向左右传球，问有多少种方案能够使得进行 $m$ 次传球后依然在小蛮手中。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>每一轮，拿到球的同学都可以向左右传球。</p><p>设 $f(i, j)$ 表示第 $i$ 次传球后小球在 $j$ 同学手中的方案数量。注意环形。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N]; <span class="comment">// f(i, j)表示穿了i次传到j手里的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j==<span class="number">1</span>?n:j<span class="number">-1</span>] + f[i<span class="number">-1</span>][j==n?<span class="number">1</span>:j+<span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; f[m][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/16/hello-world/"/>
      <url>/2022/02/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>花了一整天总算是弄好了…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zkw树</title>
      <link href="/2022/02/16/zkw%E6%A0%91/"/>
      <url>/2022/02/16/zkw%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="zkw树"><a href="#zkw树" class="headerlink" title="zkw树"></a>zkw树</h1><p>zkw树，又称<strong>非递归线段树</strong>，它是一种采用自底向上构造的线段树，由于没有递归且全程使用位运算，因此它是一种代码短，常数小且容易调试的线段树写法。</p><p>为了方便调写，我们令原序列 $a$ 下标为 $[0, n)$ ，而zkw树下标（根节点）从 $1$ 开始。</p><h2 id="zkw树原理"><a href="#zkw树原理" class="headerlink" title="zkw树原理"></a>zkw树原理</h2><p>zkw树本质是把序列化成一颗满二叉树，然后就可以采用二叉树的性质来自底向上构造线段树。比如当序列长度为 $8$ 时：</p><p><img src="/images/ds/zkw.png" alt=""></p><p>满二叉树的叶子结点编号十分有规律，假设序列长度为 $n$ ，第 $i$ 个叶子结点代表的就是 $a[i]$ ，且叶子编号为 $x + n$ 。不仅如此，满二叉树还有如下性质：</p><ol><li>整棵树一共有 $2 \times n - 1$ 个节点，其中最后一层有 $n$ 个节点，也就是我们的原序列。</li><li>若某节点编号为 $p$ ，那么它的父节点为 $p / 2$ ，左孩子为 $p \times 2$ ，右孩子为 $p \times 2 + 1$ 。</li><li>所有的兄弟节点 $p, q$ 满足 $p \bigoplus q == 1$ 。（二进制下仅有最后一位不同）</li><li>除根节点外，编号为偶数的节点都是左兄弟，编号为奇数的都是右孩子。</li></ol><p>根据性质 $1$ ，要构造这样一颗树，需要序列长度 $n$ 为二的整数次幂，如果不足，在后面补 $0$ 即可。</p><p>设 $N$ 为满足 $N$ 为二的整数次幂且 $N \ge n$ 的最小整数。</p><p>那么，我们zkw树数组中，$[N, N + n - 1]$ 便是原序列（叶子节点）。</p><p>于是，我们有了十分简单的<strong>建树</strong>代码（假设目前需要维护区间和）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) t[i + N] = a[i]; <span class="comment">// 先构造叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; -- i) t[i] = t[i&lt;&lt;<span class="number">1</span>] + t[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; <span class="comment">// 自下而上构造</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于<strong>单点修改</strong>，我们可以直接更新，然后往上更新父节点。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (x += N; x; x &gt;&gt;= <span class="number">1</span>)  tree[x] += v;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是觉得很像堆？没错，zkw和堆本质都是二叉树。</p><p>对于<strong>区间查询</strong>，我们把 $[l, r]$ 的查询变为 $(l-1, r+1)$ 的查询，然后从下往上缩小范围。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结束条件是l,r为兄弟，也就是中间没有查询的元素</span></span><br><span class="line">    <span class="keyword">for</span> (l += N - <span class="number">1</span>, r += N + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 每次上移的过程，其实是不断把端点和它的兄弟排出区间的过程</span></span><br><span class="line"><span class="comment">           因此如果它的兄弟为区间查询的值，应该加上去 */</span></span><br><span class="line">        <span class="comment">// 如果左端点是左儿子或右端点是右儿子，那么它的兄弟应该是答案的一部分。</span></span><br><span class="line">        <span class="keyword">if</span> (~l &amp; <span class="number">1</span>) ans += t[l ^ <span class="number">1</span>]; <span class="comment">// 左端点是左儿子</span></span><br><span class="line">        <span class="keyword">if</span> (r &amp; <span class="number">1</span>) ans += t[r ^ <span class="number">1</span>]; <span class="comment">// 右端点是右儿子</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于 <strong>区间修改</strong> ，因为没有使用递归，因此直接下传懒标记是比较麻烦的，因为树的修改是自底向上的。</p><p>比较好的方式是对标记进行永久化存储。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cntl = <span class="number">0</span>, cntr = <span class="number">0</span>; <span class="comment">// len表示结点表示的区间长度，cntl,cntr表示左右两边实际修改的长度</span></span><br><span class="line">    <span class="keyword">for</span> (l += N - <span class="number">1</span>, r += N + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        t[l] += cntl * d, t[r] += cntr * d;</span><br><span class="line">        <span class="comment">// mark(i) 表示以i为根的树，除了根节点，每个节点都需要加上 mark(i)</span></span><br><span class="line">        <span class="keyword">if</span> (~l &amp; <span class="number">1</span>) t[l ^ <span class="number">1</span>] += d * len, mark[l ^ <span class="number">1</span>] += d, cntl += len;</span><br><span class="line">        <span class="keyword">if</span> (r &amp; <span class="number">1</span>) t[r ^ <span class="number">1</span>] += d * len, mark[r ^ <span class="number">1</span>] += d, cntr += len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) t[l] += cntl * d, t[r] += cntr * d;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在有懒标记的情况下，区间查询也要考虑懒标记。除了端点的兄弟需要考虑，在路径上遇到的标记也对答案有贡献，<strong>贡献依赖于实际查询的长度</strong>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, len = <span class="number">1</span>, cntl = <span class="number">0</span>, cntr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (l += N - <span class="number">1</span>, r += N + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ans += cntl * mark[l] + cntr * mark[r];</span><br><span class="line">        <span class="keyword">if</span> (~l &amp; <span class="number">1</span>) ans += t[l ^ <span class="number">1</span>], cntl += len;</span><br><span class="line">        <span class="keyword">if</span> (r &amp; <span class="number">1</span>) ans += t[r ^ <span class="number">1</span>], cntr += len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) ans += cntl * mark[l] + cntr * mark[r];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3372">例题 线段树模板</a></p><p>完整代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, N;</span><br><span class="line"><span class="keyword">int</span> a[M], t[M &lt;&lt; <span class="number">1</span>], mark[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) t[i + N] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; -- i) t[i] = t[i&lt;&lt;<span class="number">1</span>] + t[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cntl = <span class="number">0</span>, cntr = <span class="number">0</span>; <span class="comment">// len表示结点表示的区间长度，cntl,cntr表示左右两边实际修改的长度</span></span><br><span class="line">    <span class="keyword">for</span> (l += N - <span class="number">1</span>, r += N + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        t[l] += cntl * d, t[r] += cntr * d;</span><br><span class="line">        <span class="keyword">if</span> (~l &amp; <span class="number">1</span>) t[l ^ <span class="number">1</span>] += d * len, mark[l ^ <span class="number">1</span>] += d, cntl += len;</span><br><span class="line">        <span class="keyword">if</span> (r &amp; <span class="number">1</span>) t[r ^ <span class="number">1</span>] += d * len, mark[r ^ <span class="number">1</span>] += d, cntr += len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) t[l] += cntl * d, t[r] += cntr * d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, len = <span class="number">1</span>, cntl = <span class="number">0</span>, cntr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (l += N - <span class="number">1</span>, r += N + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ans += cntl * mark[l] + cntr * mark[r];</span><br><span class="line">        <span class="keyword">if</span> (~l &amp; <span class="number">1</span>) ans += t[l ^ <span class="number">1</span>], cntl += len;</span><br><span class="line">        <span class="keyword">if</span> (r &amp; <span class="number">1</span>) ans += t[r ^ <span class="number">1</span>], cntr += len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) ans += cntl * mark[l] + cntr * mark[r];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="keyword">for</span> (N = <span class="number">1</span>; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">int</span> op, l, r, d; <span class="keyword">while</span>(m -- , cin &gt;&gt; op &gt;&gt; l &gt;&gt; r)</span><br><span class="line">    {</span><br><span class="line">        -- l, -- r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) cin &gt;&gt; d, <span class="built_in">update</span>(l, r, d);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(l, r) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元</title>
      <link href="/2022/02/16/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
      <url>/2022/02/16/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><blockquote><p>乘法逆元可以求出 $ \displaystyle {\frac {a}{b}} $ 在取模 $P$ 的意义下的数值。</p></blockquote><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><blockquote><p>若 $a \times x \equiv 1 \pmod q$ ，且 $a$ 与 $b$ 互质，那么我们定义： $x$ 为 $a$ 的逆元，记作 $a^{-1}$ ，也可以称 $x$ 为 $a$ 在 $ \pmod p$ 意义下的倒数。</p><p>对于 $\displaystyle {\frac {a} {b}} \pmod p$ ，它的值为 $a \times b^{-1} \ \ mod \ \ p$ 。</p></blockquote><h2 id="求解逆元"><a href="#求解逆元" class="headerlink" title="求解逆元"></a>求解逆元</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><blockquote><p>费马小定理<br>    若 $p$ 为素数，$a$ 为正整数，且 $a、p$ 互质。则有 $a^{p-1} \equiv 1 \pmod p$ 。</p></blockquote><p>若 $x$ 为 $a$ 的逆元，则:</p><script type="math/tex; mode=display">\begin{aligned}a \times x &\equiv 1 \pmod p \\a \times x &\equiv a^{p-1} \pmod p \\x &\equiv a^{p-2} \pmod p\end{aligned}</script><p>所以我们可以使用快速幂求出 $a^{p-2} \pmod p$ 的值，即为 $a$ 的逆元。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * a * res % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>拓展欧几里得<br>在模数不为质数时，不能使用费马小定理，但是可以使用拓展欧几里得求逆元，参考<a href="https://www.cnblogs.com/Horb7/p/15581035.html">此处</a>。</p></blockquote><h3 id="线性算法"><a href="#线性算法" class="headerlink" title="线性算法"></a>线性算法</h3><p>线性算法可以求出连续数字 $1 \sim n$ 对于 $\pmod p$ 的逆元。</p><p>首先有 $1^{-1} \equiv 1 \pmod p$。</p><p>假设现在要求 $i$ 的逆元，显然 $p = \lfloor{\dfrac p i}\rfloor \times i + p \% i$ 。</p><p>那么，在模 $p$ 的情况下：</p><script type="math/tex; mode=display">p = \lfloor{\dfrac p i}\rfloor \times i + p \% i \equiv 0 \pmod p</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\lfloor{\dfrac p i}\rfloor \times i &\equiv -(p \% i) \pmod p \\\lfloor{\dfrac p i}\rfloor \times -(p \% i)^{-1} &\equiv i^{-1} \pmod p \\i^{-1} &\equiv -\lfloor{\dfrac p i}\rfloor \times (p \% i)^{-1} \pmod p \\\end{split}\end{equation}</script><p>注意到 $p \% i$ 一定是小于 $i$ 的，这样我们就可以从前面推出后面了。</p><p>时间复杂度：$ O(n) $</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    inv[i] = (p - p / i) * inv[p % i] % p; <span class="comment">// 取模意义下 -a = p - a</span></span><br></pre></td></tr></tbody></table></figure><h3 id="阶乘逆元"><a href="#阶乘逆元" class="headerlink" title="阶乘逆元"></a>阶乘逆元</h3><p>根据阶乘递推关系：</p><script type="math/tex; mode=display">\begin{split}inv[i+1] &= \displaystyle {\frac{1}{(i+1)!}} \\inv[i+1] \times (i + 1) &= \displaystyle {\frac{1}{i!}}\end{split}</script><p>所以我们也可以先求出 $n!$ 的逆元，再<strong>逆推</strong>，就可以得到 $1! \sim n!$ 的逆元。</p><p>递推式： $inv[i+1] \times (i+1) = inv[i]$</p><p>最后可以使用 $\displaystyle {\frac{1}{i!}} \times (i-1)! = \frac{1}{i}$ 。</p><p>时间复杂度为 $O(n)$ 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对顶堆</title>
      <link href="/2022/02/16/%E5%AF%B9%E9%A1%B6%E5%A0%86/"/>
      <url>/2022/02/16/%E5%AF%B9%E9%A1%B6%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="对顶堆"><a href="#对顶堆" class="headerlink" title="对顶堆"></a>对顶堆</h1><h2 id="什么是对顶堆"><a href="#什么是对顶堆" class="headerlink" title="什么是对顶堆"></a>什么是对顶堆</h2><p>对顶堆是一种数据结构，它可以动态地维护某一个临界值，如前 $i$ 个数字的中位数、 前 $i$ 个数字中第 $k$ 小的值等。</p><p>对顶堆一般适用一个大根堆维护前面某个状态，小根堆维护后面不同的状态（如大于/小于中位数等）。</p><p><img src="/images/ds/heap.png" alt=""></p><p>我们只需要调整两个堆的元素数量，即可 $O(1)$ 地取出需要维护的值。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="动态中位数"><a href="#动态中位数" class="headerlink" title="动态中位数"></a><a href="https://www.acwing.com/activity/content/problem/content/340/">动态中位数</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>每次插入一个数字，当序列中数字数量为奇数时，输出序列的中位数。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>假设当前序列长度为 $n$ 。</p><p>开一个大根堆来维护当前序列中前 $[1, n / 2]$ 小的元素，再开一个小根堆来维护当前序列前 $[n/2+1, n]$ 小的元素。</p><p>那么我们只需要维护大根堆的数量为 $n/2$ ，即可知道当前序列的中位数为小根堆的堆顶。</p><p>注意大根堆的所有元素一定比小根堆任意元素小。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T; <span class="keyword">while</span>( T -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> id, n, cnt = <span class="number">0</span>; cin &gt;&gt; id &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">' '</span> &lt;&lt; (n + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; lt; <span class="comment">// 小根堆</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; gt; <span class="comment">// 大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (gt.<span class="built_in">size</span>() &amp;&amp; x &lt;= gt.<span class="built_in">top</span>()) gt.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">else</span> lt.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">while</span>(gt.<span class="built_in">size</span>() &lt; i / <span class="number">2</span>) gt.<span class="built_in">push</span>(lt.<span class="built_in">top</span>()), lt.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(gt.<span class="built_in">size</span>() &gt; i / <span class="number">2</span>) lt.<span class="built_in">push</span>(gt.<span class="built_in">top</span>()), gt.<span class="built_in">pop</span>();</span><br><span class="line">                cout &lt;&lt; lt.<span class="built_in">top</span>() &lt;&lt; <span class="string">" \n"</span>[((cnt += <span class="number">1</span>) %= <span class="number">10</span>) == <span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cnt) cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="黑匣子"><a href="#黑匣子" class="headerlink" title="黑匣子"></a><a href="https://www.luogu.com.cn/problem/P1801">黑匣子</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>有两种操作：</p><ol><li>向序列中插入一个数字。</li><li>求出序列中第 $k$ 小的数字。</li></ol><p>$k$ 初始为 $0$ ，每次求第 $k$ 小值都要把 $k$ 加一。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>对顶堆，大根堆维护前 $k-1$ 小的数字，小根堆维护后面的数字。这样小根堆的堆顶就是第 $k$ 小的数字。</p><p>每次插入操作都至多交换一次堆元素，我们可以放到查询的时候再维护堆的数字，次数与每次操作维护是一样的。</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; pre;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; post;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (post.<span class="built_in">empty</span>() || a[i] &lt; post.<span class="built_in">top</span>()) pre.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> post.<span class="built_in">push</span>(a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护post堆顶为k小数</span></span><br><span class="line">        <span class="keyword">while</span> (q[pos] == i)</span><br><span class="line">        {</span><br><span class="line">            ++ k;</span><br><span class="line">            <span class="keyword">while</span>(pre.<span class="built_in">size</span>() &lt; k) pre.<span class="built_in">push</span>(post.<span class="built_in">top</span>()), post.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(pre.<span class="built_in">size</span>() &gt;= k) post.<span class="built_in">push</span>(pre.<span class="built_in">top</span>()), pre.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; post.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">            pos ++ ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// int _; for (cin &gt;&gt; _; _ --; ) solve();</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集入门</title>
      <link href="/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h1><p><img src="/images/ds/DSU_intro.png" alt=""></p><p>并查集是一种树形的数据结构，我们可以使用它来进行集合上的合并与查询等问题。具体来说，它支持两种操作：</p><ol><li>合并：将两个集合合并成一个集合。</li><li>查询：确定某个元素处于哪个集合。</li></ol><p>如图，$\{3, 1, 2, 4, 0, 10\}$ 表示一个集合，$\{5, 7, 8, 11\}$ 表示另一组集合。</p><p>可以看出并查集是多叉树结构，我们用根节点来表示这个根节点所在的集合(即根节点作为集合的”代表元素”)。</p><h1 id="基础并查集"><a href="#基础并查集" class="headerlink" title="基础并查集"></a>基础并查集</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><img src="/images/ds/dsu_init.png" alt=""></p><p>在我们初始创建数据的时候，由于没有任何操作，所以<strong>每个元素都是一个独立的集合</strong>，显然，每个元素都是本身集合的根节点。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) p[i] = i; <span class="comment">// p(i) 表示i的父节点</span></span><br></pre></td></tr></tbody></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><img src="/images/ds/dsu_find.png" alt=""></p><p>假设我们现在要查询元素 $0$ 的父节点，该怎么做呢？</p><p>很简单，由于<strong>根节点的父节点就是本身</strong>（不知道的可以回顾一下初始化过程）。所以我们直接检查 $0$ 的父节点是否为 $0$ 即可。</p><ol><li>如果 $0$ 父节点为 $0$ ，说明 $0$ 是所属集合的根节点，返回 $0$ 即可。（因为我们用根节点代表集合）</li><li>如果 $0$ 父节点不为 $0$ ，那么我们只需要递归检查它的父节点是否为 $0$ 即可。</li></ol><p>我们发现 $0$ 的父节点是 $2$ ，那么我们继续检查 $2$ 是否为根节点($p[2] == 2$) ，不是，则继续检查 $3$ ，此时 $3$ 为根节点，于是返回 $3$ 。</p><p>查询的复杂度为被查询元素在树上的深度。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// find函数用来返回x所属集合的代表元素(根节点)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : <span class="built_in">find</span>(p[x]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p><img src="/images/ds/dsu_merge.png" alt=""></p><p>如图，如何合并 $6$ 所属集合和 $3$ 所属集合？由于我们知道根节点代表整个集合，合并 $6$ 和 $3$ 即意味着它们<strong>合并后根节点相同</strong>，我们可以任意取一个子集的根节点作为合并后的根节点，比如取 $3$ 后：</p><p><img src="/images/ds/dsu_merge1.png" alt=""></p><p>我们选择了把 $2$ 作为合并后集合的根节点（代表元素）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y); <span class="comment">// x 和 y 为根节点</span></span><br><span class="line">    p[x] = y; <span class="comment">// 直接把其中一个集合合并到另外一个集合</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="并查集优化"><a href="#并查集优化" class="headerlink" title="并查集优化"></a>并查集优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们发现，由于每次查询某个元素需要查询 $r$ 次($r$ 为当前元素在树上的深度)，当树的深度很大，且我们要查询的元素在很深的地方，那么查询所需要耗费的时间就很大，有没有办法优化呢？</p><p>答案是肯定的，我们发现，<strong>整个集合只有代表元素是’有用’的，其他元素仅能代表它在这个集合中，与它所处的位置没有关系。</strong> 于是，我们在每次查询后，就把当前元素的父节点设置为集合的根节点，根节点就是 $find$ 的返回值，所以：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// find 函数返回x所属集合代表元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">// 把x的父节点设置为根节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="按秩合并（启发式合并）"><a href="#按秩合并（启发式合并）" class="headerlink" title="按秩合并（启发式合并）"></a>按秩合并（启发式合并）</h3><p>上述提到，树的深度会影响查询的速度，那么我们可以在合并的时候，把集合元素较少的合并到集合元素较大的即可。还可以按照集合树的深度与集合的元素数量评估来得到更好的合并方法。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 按秩合并需要用到集合内的数量</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (siz[x] &gt; siz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    siz[y] += siz[x];</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>按秩合并在竞赛中不常用，一般来说路径压缩就已经够用了。</p><hr><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">// p(i)表示i的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) p[i] = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><a href="https://www.luogu.com.cn/problem/P1551">模板 并查集</a></p><p><a href="https://www.luogu.com.cn/problem/P2078">朋友</a> 此题也可以使用维护集合数量的并查集</p><p><a href="https://www.luogu.com.cn/record/49448796">村村通</a></p><p><a href="https://www.acwing.com/problem/content/description/147/">超市</a> 贪心+并查集</p><h1 id="维护集合数量的并查集"><a href="#维护集合数量的并查集" class="headerlink" title="维护集合数量的并查集"></a>维护集合数量的并查集</h1><p>有时候，我们只维护元素所属的集合是不够的，我们还需要知道集合内的数量。</p><p>只维护一个集合数量，和基础并查集无任何区别，只需要加上一个 $siz$ 数组维护每个集合内的数量即可。</p><p>唯一需要变的就是在合并集合时的操作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 按秩合并需要用到集合内的数量</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    siz[y] += siz[x];</span><br><span class="line">    p[x] = y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h1><p>当然，维护了数量在某些情况也是不够用的，我们还需要知道<strong>集合内各个元素的关系</strong>。我们可以使用带权并查集，<strong>使用边权来维护当前元素与父节点的某种关系。</strong></p><p>即，<strong>带权并查集可以维护元素之间的制约关系</strong>。</p><p>我们以一道经典例题 <a href="https://www.acwing.com/problem/content/242/">食物链</a> 为例。</p><h2 id="例题-食物链"><a href="#例题-食物链" class="headerlink" title="例题 食物链"></a>例题 食物链</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。</p><p>$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。</p><p>现有 $N$ 个动物，以 $1∼N$ 编号。</p><p>每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 $X$ 和 $Y$ 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 $X$ 吃 $Y$。</p><p>此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；</li><li>当前的话表示 $X$ 吃 $X$，就是假话。</li></ol><p>你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>给出两个动物，它们有吃、被吃以及同类三种制约关系，而带权并查集可以很好地维护元素间的制约关系。</p><p>设 $d[x]$ 表示元素 $x$ 与其父节点的边的边权。</p><p>规定：</p><ol><li>$d[x] \% 3 = 0$ 表示 $x$ 与父节点 $p[x]$ 是同类。</li><li>$d[x] \% 3= 1$ 表示 $x$ 可以吃父节点 $p[x]$。</li><li>$d[x] \% 3 = 2$ 表示 $x$ 可以被父节点 $p[x]$ 吃。</li></ol><p>那么我们判定假话，只需要不满足 $d[x]$ 即可。</p><p>简单来说：</p><ol><li>判断 $x$ 与 $y$ 为同类，但已经制约了 $x$ 和 $y$ 为异类（吃或被吃）。</li><li>判断 $x$ 吃 $y$ ，但已经制约了 $x$ 和 $y$ 是同类或者 $x$ 被 $y$ 吃。</li><li>判断 $x$ 被 $y$ 吃，但已经制约了 $x$ 和 $y$ 是同类或者 $x$ 被 $y$ 吃。（题目不会给定）</li></ol><p>首先我们肯定要是有路径压缩来优化查询的，在路径压缩后， $x$ 对应的父节点变为集合根节点，因此 $d[x]$ 也需要做变换。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x != p[x])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 注意此时x还没有路径优化，父节点仍然保持原来的父节点</span></span><br><span class="line"><span class="comment">         * 此时 x 以上的节点经过路径优化，d[p[x]] 也修改为正确值(x父节点与根节点的关系)</span></span><br><span class="line"><span class="comment">         * 那么我们只需要根据x与父节点的关系、x父节点与根节点的关系即可传递得到x与根节点的关系，再路径优化即可。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么现在的问题就是，如何知道一个集合里两个元素的制约关系？</p><p>由于我们求得 $d[x]$ 都是 $x$ 与根节点的关系，那么 $(d[x] - d[y]) \% 3$ 即为 $x$ 与 $y$ 的制约关系。</p><p>如何合并两个关系呢？</p><p>假设判定 $x$ 和 $y$ 的关系的边权表示为 $op$ ，由于在 $find$ 中我们可以求得 $x$ 、 $y$ 分别与其根节点的关系，且现在 $x$ 与 $y$ 的制约关系也知道了，那么根据传递性我们也可以求出两个集合根节点之间的制约关系，合并两个集合时维护好两个根节点的制约关系即可。</p><p>假设 $x$ 的根节点为 $px$ ，$y$ 的根节点为 $py$ 。现在要把 $px$ 合并到 $py$ 。</p><ol><li><p>判定 $x$ 与 $y$ 同类</p><p>在合并后的集合里，$x$ 与 $y$ 的关系应该为 $(d[x] - d[y]) \% 3 = 0$ 。由于此时的 $d[x]$ 是合并后的，所以合并前应该为 $d[x] + d[px]$ 。即 $d[x] + d[px] - d[y] = 0$ ，那么 $d[px] = d[y] - d[x]$ 。</p></li><li><p>判定 $x$ 与 $y$ 不同类</p><p>由于题目给定此时判定为 $x$ 吃 $y$ ，所以我们只需要考虑这一种。</p><p>在合并后的集合里，$x$ 与 $y$ 的关系用应该是：$d[x] - d[y] = 1$ ，即 $x$ 可以吃根节点（路径压缩后的父节点），且 根节点与 $y$ 同类，依次推类。</p><p>同样此时的 $d[x]$ 是合并后的，合并前应该是 $d[x] + d[px]$ ，所以 $d[x] + d[px] - d[y] = 1$ ，即 $d[px] = 1 + d[y] - d[x]$ 。</p></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) {</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) {</span><br><span class="line">        <span class="keyword">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res++; <span class="comment">// 谎言1：动物编号超出限制</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res++; <span class="comment">// 谎言2：判定同类，但已经制约x和y是异类</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py) { <span class="comment">// 否则认为是真话，加上此制约关系</span></span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res++; <span class="comment">// 谎言3：判定x吃y，但已经制约x和y是同类或者x被y吃</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py) { <span class="comment">// 否则认为是真话，加上此制约关系</span></span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p><a href="https://www.acwing.com/problem/content/description/259/">关押罪犯</a> 也可以使用二分图解决</p><p><a href="https://www.acwing.com/problem/content/241/">奇偶游戏</a> 同样也可以使用二分图</p><h1 id="拓展域并查集"><a href="#拓展域并查集" class="headerlink" title="拓展域并查集"></a>拓展域并查集</h1><p>拓展域并查集和带权并查集功能相同，都是对各个元素的不同关系进行制约。由于拓展域需要对同一个元素开多个域，因此空间复杂度较高，除此之外可以完全代替带权并查集。</p><p>同样，我们使用 <a href="https://www.acwing.com/problem/content/242/">食物链</a> 这个例子来实现拓展域。</p><p>对于元素 $x$ ，其他元素 $y$ 和它一共有三种关系：</p><ol><li>与 $x$ 是同类。</li><li>被 $x$ 吃，即 $x$ 捕食 $y$ 。</li><li>吃 $x$ ，即 $x$ 天敌为 $y$ 。</li></ol><p>对于元素 $x$ ，我们开三个域来表示这三种关系。由于一共有 $n$ 个动物，我们有一个很好的开域的方式：<strong>我们令 $p[x]$ 表示 $x$ 的天敌域， $p[x + n]$ 表示 $x$ 的同类域， $p[x + 2 * n]$ 表示 $x$ 的捕食域</strong> ，那么谎话只有以下两种：</p><ol><li>判定 $x$ 与 $y$ 是同类，但是 $x$ 的捕食域或者天敌域存在 $y$ 。</li><li>判定 $x$ 吃 $y$ ，但是 $x$ 的同类域或者天敌域存在 $y$ 。</li></ol><p>在合并的过程，比如合并 $x$ 和 $y$ 是同类，那么 $x$ 的天敌也同样是 $y$ 的天敌，即也需要合并 $x$ 与 $y$ 的天敌域。捕食域同理。</p><p>通过上述分析，我们可以很简洁地写出如下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">// 拆点，每个点有三个域，天敌域，同类域，捕食域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个集合里的元素都是一类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">f</span>(p[x]); } ;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; mg = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) { p[<span class="built_in">f</span>(x)] = <span class="built_in">f</span>(y); };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, k, d, x, y, ret = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + <span class="number">3</span> * n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k -- &amp;&amp; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) { ret ++ ; <span class="keyword">continue</span>; } <span class="comment">// 假话2</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">2</span> &amp;&amp; x == y) { ret ++ ; <span class="keyword">continue</span>; } <span class="comment">// 假话3</span></span><br><span class="line">        <span class="comment">// 假话1，产生冲突</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果判定x和y是同类，但是x的天敌域或者捕食域有y，一定是假话</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">f</span>(x) == <span class="built_in">f</span>(y + n) || <span class="built_in">f</span>(x + <span class="number">2</span> * n) == <span class="built_in">f</span>(y + n)) { ret ++ ; <span class="keyword">continue</span>; }</span><br><span class="line">            <span class="comment">// 否则这是一句真话，记录一下</span></span><br><span class="line">            <span class="built_in">mg</span>(x + n, y + n);</span><br><span class="line">            <span class="built_in">mg</span>(x, y); <span class="comment">// x的天敌和y的天敌是同一类</span></span><br><span class="line">            <span class="built_in">mg</span>(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n); <span class="comment">// x的捕食域和y的捕食域也是一类</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果判定x捕食y，但是x同类域或天敌域有y，假话</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">f</span>(x + n) == <span class="built_in">f</span>(y + n) || <span class="built_in">f</span>(x) == <span class="built_in">f</span>(y + n)) { ret ++ ; <span class="keyword">continue</span>; }</span><br><span class="line">            <span class="built_in">mg</span>(x + <span class="number">2</span> * n, y + n);</span><br><span class="line">            <span class="built_in">mg</span>(x + n, y); <span class="comment">// y的天敌域加上x的同类域</span></span><br><span class="line">            <span class="built_in">mg</span>(x, y + <span class="number">2</span> * n); <span class="comment">// x的天敌域加上y的捕食域</span></span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集拓展域</title>
      <link href="/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95%E5%9F%9F/"/>
      <url>/2022/02/16/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集拓展域"><a href="#并查集拓展域" class="headerlink" title="并查集拓展域"></a>并查集拓展域</h1><blockquote><p>并查集是用来维护元素之间的制约关系，并且在更新时可以传递关系的一种数据结构，但有时候只靠是否在集合内不足以表示复杂的关系，因此引入了拓展域的关系.</p></blockquote><h2 id="例题-食物链"><a href="#例题-食物链" class="headerlink" title="例题 食物链"></a>例题 食物链</h2><h3 id="1-带权并查集"><a href="#1-带权并查集" class="headerlink" title="1. 带权并查集"></a>1. 带权并查集</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    d(i) 表示 i 与父结点的距离。</span></span><br><span class="line"><span class="comment">    1 -&gt; i可以吃父结点</span></span><br><span class="line"><span class="comment">    2 -&gt; i可以被父结点吃</span></span><br><span class="line"><span class="comment">    0 -&gt; i与父结点同类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> x) {</span><br><span class="line">        <span class="keyword">if</span> (x != p[x])</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 维护d数组</span></span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">f</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    } ;</span><br><span class="line">    <span class="comment">// mg 对于同类和不同类的情况不同</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, k, od, x, y, ret = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">iota</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k -- &amp;&amp; cin &gt;&gt; od &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) { ++ ret; <span class="keyword">continue</span>; }</span><br><span class="line">        <span class="keyword">int</span> px = <span class="built_in">f</span>(x), py = <span class="built_in">f</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (od == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) { ++ ret; <span class="keyword">continue</span>; }</span><br><span class="line">            <span class="comment">// 加入一个集合</span></span><br><span class="line">            <span class="keyword">if</span> (px != py)</span><br><span class="line">            {</span><br><span class="line">                p[px] = py;</span><br><span class="line">                d[px] = d[y] - d[x];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (x == y || px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) { ++ ret; <span class="keyword">continue</span>; }</span><br><span class="line">            <span class="keyword">if</span> (px != py)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 加入一个集合</span></span><br><span class="line">                p[px] = py;</span><br><span class="line">                d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-拆点并查集（拓展域）"><a href="#2-拆点并查集（拓展域）" class="headerlink" title="2. 拆点并查集（拓展域）"></a>2. 拆点并查集（拓展域）</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">// 拆点，每个点有三个域，天敌域，同类域，捕食域</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    x         : 维护x的所有天敌</span></span><br><span class="line"><span class="comment">    x + n     : 维护x的所有同类</span></span><br><span class="line"><span class="comment">    x + 2 * n : 维护x的所有捕食</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个集合里的元素都是一类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> x) { <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">f</span>(p[x]); } ;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; mg = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) { p[<span class="built_in">f</span>(x)] = <span class="built_in">f</span>(y); };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, k, d, x, y, ret = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">iota</span>(p + <span class="number">1</span>, p + <span class="number">3</span> * n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k -- &amp;&amp; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) { ret ++ ; <span class="keyword">continue</span>; } <span class="comment">// 假话2</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">2</span> &amp;&amp; x == y) { ret ++ ; <span class="keyword">continue</span>; } <span class="comment">// 假话3</span></span><br><span class="line">        <span class="comment">// 假话1，产生冲突</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果判定x和y是同类，但是x的天敌域或者捕食域有y，一定是假话</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">f</span>(x) == <span class="built_in">f</span>(y + n) || <span class="built_in">f</span>(x + <span class="number">2</span> * n) == <span class="built_in">f</span>(y + n)) { ret ++ ; <span class="keyword">continue</span>; }</span><br><span class="line">            <span class="comment">// 否则这是一句真话，记录一下</span></span><br><span class="line">            <span class="built_in">mg</span>(x + n, y + n);</span><br><span class="line">            <span class="built_in">mg</span>(x, y); <span class="comment">// x的天敌和y的天敌是同一类</span></span><br><span class="line">            <span class="built_in">mg</span>(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n); <span class="comment">// x的捕食域和y的捕食域也是一类</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果判定x捕食y，但是x同类域或天敌域有y，假话</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">f</span>(x + n) == <span class="built_in">f</span>(y + n) || <span class="built_in">f</span>(x) == <span class="built_in">f</span>(y + n)) { ret ++ ; <span class="keyword">continue</span>; }</span><br><span class="line">            <span class="built_in">mg</span>(x + <span class="number">2</span> * n, y + n);</span><br><span class="line">            <span class="built_in">mg</span>(x + n, y); <span class="comment">// y的天敌域加上x的同类域</span></span><br><span class="line">            <span class="built_in">mg</span>(x, y + <span class="number">2</span> * n); <span class="comment">// x的天敌域加上y的捕食域</span></span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Good Bye 2021</title>
      <link href="/2022/02/16/Codeforces-Good-Bye-2021/"/>
      <url>/2022/02/16/Codeforces-Good-Bye-2021/</url>
      
        <content type="html"><![CDATA[<h1 id="Good-Bye-2021"><a href="#Good-Bye-2021" class="headerlink" title="Good Bye 2021"></a>Good Bye 2021</h1><h2 id="A-Interger-Diversity"><a href="#A-Interger-Diversity" class="headerlink" title="A. Interger Diversity"></a>A. Interger Diversity</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个整数，你可以选择其中的任意项，使其变成它的相反数(如把 $x$ 变成 $-x$) ，问操作后的序列中最多有多少个不同的数字。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>记录每个数字是否出现过，如果出现过而相反数没有出现过就把它变成相反数。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, res = <span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; ex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (ex[x] &amp;&amp; ex[-x]) <span class="keyword">continue</span>;</span><br><span class="line">        res ++ ;</span><br><span class="line">        <span class="keyword">if</span> (!ex[x]) ex[x] = <span class="literal">true</span>; <span class="keyword">else</span> ex[-x] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="B-Mirror-in-the-String"><a href="#B-Mirror-in-the-String" class="headerlink" title="B. Mirror in the String"></a>B. Mirror in the String</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的字符串 $s_1s_2 \ldots s_n$ ，选择一个数字 $k(1 \le k \le n)$ ，使其变成 $s_1s_2 \ldots s_ks_ks_{k-1} \ldots s_1$ 。问操作后能得到的字符串的最小字典序为多少。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li><p>$n = 1 \ or \ s_1 = s_2$ </p><p>选择 $k=1$ 即可得到字典序最小，因为选择 $k(k \ge 2)$ 时，前两个字符依然是 $s_1s_2$ ，后面又多了字符导致字典序不是最小。</p></li><li><p>$s1 \ != \ s2$</p><p>对于字符 $s_i$ ，如果 $s_{i+1} \gt s_i$ ，那么选择 $k=i$ ，因为如果选择 $k \gt i$ ，那么得到的字符串第 $i+1$ 位一定变大了，就不是字典序最小。</p></li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || s[<span class="number">0</span>] == s[<span class="number">1</span>]) <span class="keyword">return</span> cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; n - <span class="number">1</span> &amp;&amp; s[p + <span class="number">1</span>] &lt;= s[p]) p ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p; i ++ ) cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; s[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-Representative-Edges"><a href="#C-Representative-Edges" class="headerlink" title="C. Representative Edges"></a>C. Representative Edges</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的序列 $a$ ，每次操作可以修改其中某一个元素的值，问最小操作多少次，使得对于任意 $1 \le l \le r \le n$ ，满足 $a_l + a_{l+1} + \ldots + a_r = \dfrac 1 2(a_l + a_r) \times (r - l + 1)$ 。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>可以发现题目要求的性质为等差数列的性质，题目变为：求最少修改多少次使得序列变为等差数列。</p><p>由于数据很小 $1 \le n \le 70$ 。我们可以固定数列任意两项作为要求的等差数列的一部分，求出其他满足该等差数列性质的个数。</p><p>假设固定 $i, j$ ，那么对于任意一项 $k$ ，满足等差数列性质需要: $\dfrac {a_j - a_i} {j-i} = \dfrac {a_k - a_i} {k - i} $ ，即 $(a_j - a_i) \times (k - i) = (a_k - a_i) \times (j - i)$ 。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i ++ )</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, ret; cin &gt;&gt; n; ret = <span class="built_in">max</span>(<span class="number">0</span>, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, i + <span class="number">1</span>, n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> save = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, n) <span class="keyword">if</span> ((a[k] - a[i]) * (j - i) == (a[j] - a[i]) * (k - i)) ++ save;</span><br><span class="line">        ret = <span class="built_in">min</span>(ret, n - save);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="D-Keep-the-Average-High"><a href="#D-Keep-the-Average-High" class="headerlink" title="D. Keep the Average High"></a>D. Keep the Average High</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的序列 $a$ ，选出最多的元素，满足对于任意 $1\le l \lt r \le n$ （$l, r$ 均指原序列的下标），满足以下至少一项：</p><ol><li>存在至少一项 $l \le k \le r$ 没有被选择。</li><li>$a_l + a_{l+1} \ldots a_r \ge x \times (r - l + 1)$ 。</li></ol><p>问能够选择最多多少个元素。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>对于任意 $l, r$ ，如果其中有一个没有被选择，那么一定满足限制，所以只需要考虑 $[l, r]$ 都被选择时是否满足限制。</p><p>注意第 $2$ 个限制，等价于 $(a_l - x) + (a_{l + 1} - x) + \ldots + (a+r - x) \ge 0$ 。</p><p>注意到 $[l, r]$ 是连续的，我们设 $p(i) = \sum_{i=1}^i a_i - x$ ，那么上述限制等价于 $p(r) - p(l-1) \ge 0$ 。</p><p>假设目前枚举到第 $i$ 位，那么我们需要考虑后两位，如果 $p(i + 2) - p(i) \lt 0$ ，即 $a(i+1) + a(i+2) \lt 0$ ，那么我们不能全部取到，否则令 $l = i+1, r=i+2$ ，不满足限制。如果满足 $p(i+2) - p(i) \ge 0$ ，因为前面满足的序列加上第 $i+1$ 位不一定不小于 $0$ ，那么我们取最大值，把 $i+1$ 位放到待判断的序列中，即：<br>$a_1 \ldots a_qq_{q+1} \ldots a_i \ldots a_n$ ，区间 $[q, i]$ 为满足限制的区间，而 $i+1$ 进入到待选择区域。这样我们就不仅只考虑满足限制的最后一个位置后面的两个位置了。对于带选择区间 $[l, r]$ ，因为加上了 $a_r$ 导致 $p(r) - p(l-1) &lt; 0$ ，那么只需要不选择 $r$ 即可，因为 $[l, r-1]$ 加上前面满足的区间依然不小于零。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, x, ret, mx = <span class="number">0</span>; cin &gt;&gt; n; ret = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) pre[i] = pre[i<span class="number">-1</span>] + a[i] - x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (pre[i] &lt; mx) { -- ret; mx = pre[i]; ++ i; }</span><br><span class="line">        <span class="keyword">else</span> mx = <span class="built_in">max</span>(mx, pre[i<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces-Round-762-Div-3</title>
      <link href="/2022/02/16/Codeforces-Round-762-Div-3/"/>
      <url>/2022/02/16/Codeforces-Round-762-Div-3/</url>
      
        <content type="html"><![CDATA[<h1 id="762-Div-3"><a href="#762-Div-3" class="headerlink" title="#762(Div.3)"></a>#762(Div.3)</h1><h2 id="B-Squares-and-Cubes"><a href="#B-Squares-and-Cubes" class="headerlink" title="B. Squares and Cubes"></a>B. Squares and Cubes</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定数字 $n$ ，求 $1 \sim n$ 中有多少平方数和立方数。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由于只需要找平方数和立方数，我们可以暴力找出所有平方数和立方数，复杂度为 $log n$ ，注意判重。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; ex; <span class="comment">// 判重数组</span></span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ans ++ ;</span><br><span class="line">        ex[i * i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!ex[i * i * i]) ans ++ ;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-Wrong-Addition"><a href="#C-Wrong-Addition" class="headerlink" title="C. Wrong Addition"></a>C. Wrong Addition</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定加法法则为：从右到左计算，每次把各位相加的结果填充到结果而不是进位。</p><p>即： $88 + 99 = 1717$ 。</p><p>给出加数、和，求另一个加数。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>从加数、和的最后一位开始，如果在当前位，加数小于和，那么一定存在进位，否则一定不存在进位。</p><p>不存在解的情况：</p><ol><li>在某一位上，当前加数的位数大于和的位数</li><li>在进位的时候发现和的前一位不是1</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) begin(a),end(a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string a, s, ans; cin &gt;&gt; a &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = s.<span class="built_in">size</span>() - <span class="number">1</span>, pa = a.<span class="built_in">size</span>() - <span class="number">1</span>; p &gt;= <span class="number">0</span>; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 存在某一位，使得当前加数的数量大于和</span></span><br><span class="line">        <span class="keyword">if</span> (pa &gt; p) <span class="keyword">return</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">if</span> (pa &lt; <span class="number">0</span>) <span class="comment">// 加数已经结束了，直接把和加上去</span></span><br><span class="line">        {</span><br><span class="line">            ans += s[p--];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s[p] &gt;= a[pa]) <span class="comment">// 不存在进位</span></span><br><span class="line">        {</span><br><span class="line">            ans += s[p] - a[pa] + <span class="string">'0'</span>;</span><br><span class="line">            p -- ; pa -- ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 存在进位</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 存在进位，那么和的前一位一定是1</span></span><br><span class="line">            <span class="keyword">if</span> (s[p - <span class="number">1</span>] != <span class="string">'1'</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">            ans += s[p] + <span class="number">10</span> - a[pa] + <span class="string">'0'</span>;</span><br><span class="line">            p -= <span class="number">2</span>; pa -- ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(ans));</span><br><span class="line">    <span class="keyword">while</span>(ans[<span class="number">0</span>] == <span class="string">'0'</span>) ans = ans.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="D-New-Year’s-Problem"><a href="#D-New-Year’s-Problem" class="headerlink" title="D. New Year’s Problem"></a>D. New Year’s Problem</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出矩阵 $p_{ij}$ ，$1 \le i \le m, \ 1 \le j \le n$ 。</p><p>选择至多 $n-1$ 行，然后在选择的行中，每一列挑选一个数字，求选择的数字的最小值的最大值。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>要求最小值的最大值，可以想到用二分答案。</p><p>由于要选择至多 $n-1$ 行，那么我们只需要找出有 $2$ 个数字在同一行即可。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for(int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">p</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, m<span class="number">-1</span>) <span class="built_in">rep</span>(j, <span class="number">0</span>, n<span class="number">-1</span>) cin &gt;&gt; p[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;] (<span class="keyword">int</span> mid) -&gt; <span class="keyword">bool</span></span><br><span class="line">    {</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; ex; <span class="comment">// 存储满足的商店</span></span><br><span class="line">        <span class="keyword">bool</span> may = <span class="number">0</span>; <span class="comment">// may表示存在两列可以选择同一行</span></span><br><span class="line">        <span class="comment">// 使用may是为了防止后面的列中不存在大于等于mid的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">bool</span> f = <span class="number">0</span>; <span class="comment">// 是否存在至少一个数字满足大于等于mid</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (p[j][i] &gt;= mid)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (ex[j]) may = <span class="number">1</span>;</span><br><span class="line">                    ex[j] = <span class="number">1</span>; f = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> may;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="E-MEX-and-increments"><a href="#E-MEX-and-increments" class="headerlink" title="E. MEX and increments"></a>E. MEX and increments</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出 $n$ 个数字，每次操作可以把一个数字加1。可以操作任意次。</p><p>问：对于数字 $i \ (0 \le i \le n)$ ，是否存在一种操作，可以满足序列的 $mex$ 为 $i$ 。输出它的最小操作次数。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>对于数字 $i$ ，假设 $cnt([0, i-1]) &lt; i$ ，那么一定不能把前面 $i$ 个数字填满，一定无解。</p><p>否则，我们可以选择把离它最近的位置，填到 $i-1$ 的位置，使得序列的 $mex$ 为 $i$ 。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    vector&lt;PII&gt; mct; <span class="comment">// mct 用来动态记录cnt</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) ++ cnt[x];</span><br><span class="line">    <span class="keyword">int</span> precnt = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对于0，特殊判断</span></span><br><span class="line">    cout &lt;&lt; cnt[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt; <span class="number">1</span>) mct.<span class="built_in">push_back</span>({<span class="number">0</span>, cnt[<span class="number">0</span>] - <span class="number">1</span>});</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        precnt += cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (precnt &lt; i)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(i ++ &lt;= n) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">" \n"</span> [i - <span class="number">1</span> == n];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果i-1的位置没有元素，要把i-1铺掉</span></span><br><span class="line">        <span class="keyword">if</span> (!cnt[i<span class="number">-1</span>])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span> (!mct[mct.<span class="built_in">size</span>() - <span class="number">1</span>].second) mct.<span class="built_in">pop_back</span>();</span><br><span class="line">            -- mct[mct.<span class="built_in">size</span>() - <span class="number">1</span>].second;</span><br><span class="line">            d += i - <span class="number">1</span> - mct[mct.<span class="built_in">size</span>() - <span class="number">1</span>].first;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; d + cnt[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] &gt; <span class="number">1</span>) mct.<span class="built_in">push_back</span>({i, cnt[i] - <span class="number">1</span>});</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces-Global-Round-18</title>
      <link href="/2022/02/16/Codeforces-Global-Round-18/"/>
      <url>/2022/02/16/Codeforces-Global-Round-18/</url>
      
        <content type="html"><![CDATA[<h1 id="Global-Round-18"><a href="#Global-Round-18" class="headerlink" title="Global Round 18"></a>Global Round 18</h1><h2 id="A-Closing-The-Gap"><a href="#A-Closing-The-Gap" class="headerlink" title="A. Closing The Gap"></a>A. Closing The Gap</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数字，每次操作可以选择其中两个数字 $a_i, a_j$ ，令 $a_i-1$ 且 $a_j + 1$ 。</p><p>问若干次操作后，极差最小为多少。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>显然如果 $n | \sum_{i=1}^na_i$ ，那么我们一定能找到方案使得每个数字都相同，那么极差为 $0$ 。</p><p>否则，我们可以取每个数字为 $\lfloor \dfrac {\sum_{i=1}^n a_i} n \rfloor$ ，剩下的数量小于 $n$ ，平均地分布在每个数字上，这样极差为 $1$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ ) sum += x;</span><br><span class="line">    cout &lt;&lt; (sum % n ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="B-And-It’s-Non-Zero"><a href="#B-And-It’s-Non-Zero" class="headerlink" title="B. And It’s Non-Zero"></a>B. And It’s Non-Zero</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出范围 $[l, r]$ ，你拥有这个范围内的所有正整数。你可以删除某些数字。</p><p>问，最少删除多少数字，满足剩下的数字按位和为 $0$ 。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>要使得一些数字的按位和不为 $0$ ，那么只需要满足存在某一个位，所有数字在这一个位上都为 $1$ 。</p><p>具体来说，我们可以枚举每一位，求出要使所有数字都在这个位上为 $1$ 的最小删除数量，求最小值即可。</p><p>预处理 $f(i, j)$ 表示前 $i$ 个数字第 $j$ 位为 $0$ 的数量。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">30</span>]; <span class="comment">// 前i个数字第j个位为0的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">20</span>; j ++ )</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] + !(i &gt;&gt; j &amp; <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> l, r, res = INF; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i ++ ) res = <span class="built_in">min</span>(f[r][i] - f[l<span class="number">-1</span>][i], res);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (<span class="built_in">init</span>(), cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-Menorah"><a href="#C-Menorah" class="headerlink" title="C. Menorah"></a>C. Menorah</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个蜡烛，给出每个蜡烛的起始状态（亮或者灭）。</p><p>每次操作可以选择一个 <strong>亮着的</strong> 蜡烛，让它保持状态不变，且其他所有蜡烛改变状态。</p><p>给出每个蜡烛的目标状态，问从起始状态到目标状态至少需要操作几次，如果无解输出 $-1$ 。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先我们可以发现，对于起始状态 != 目标状态的所有蜡烛，他们被操作的次数的奇偶性是相同的；对于起始状态 == 目标状态的所有蜡烛，他们被操作的次数的奇偶性也是相同的。但是上述两类的蜡烛操作次数奇偶性不同。</p><blockquote><p>证明：设 $x_i$ 表示第 $i$ 个蜡烛的操作次数。</p><p>对于第 $i$ 个蜡烛而言，它改变状态的次数为 $S = \sum_{j=1}^{i-1}x_i + \sum_{j=i+1}^{n}x_i$ 。</p><p>对于任意一个其他的蜡烛 $j$ ，它改变的次数为 $S’ = S + x_i - x_j$ 。</p><p>如果 $i$ 蜡烛是需要改变状态的，比如从原始的 $0$ 变成最终的 $1$ ，那么对于 $j$ 而言，如果它也需要改变状态，那么 $S’ = S = 1 \pmod 2$ ，从而推出 $x_i = x_j \pmod 2$ 。如果 $j$ 不需要改变状态，那么 $S’ != S \pmod 2$ ，推出 $x_i != x_j \pmod 2$ 。</p><p>同理如果 $i$ 蜡烛不需要改变状态，我们同理可得上述结论。</p></blockquote><p>然后我们可以发现每个蜡烛如果被操作，它最多被操作一次。</p><p>所以我们实际上只有两种可能的解法。</p><ol><li>只对所有起始和目标不同的蜡烛每个做一次操作。</li><li>只对所有起始和目标相同的蜡烛每个做一次操作。</li></ol><p>那么如何求出解法是否可行？</p><p>容易发现，我们的操作对象一定为 $101010101 \ldots$ 。（这里指的是原始的状态）</p><blockquote><p> 我们先对原始状态的 $1$ 操作，由于这个已经操作过了，所以对剩下没有操作的蜡烛，本来是 $0$ 的现在变成 $1$ ，我们对 $1$ 操作，本质上是对原始状态的 $0$ 操作。</p></blockquote><p>同时，我们对 $10$ 操作后，本质上是交换了这两个状态，其他状态没有改变。</p><p>第一种解法：</p><p>​    假设起始和目标为 $01$ 的蜡烛数量为 $k_0$ ，起始和目标为 $10$ 的蜡烛数量为 $k_1$ 。那么我们只能每次交换一个 $01$ 。所以如果 $k_0 != k_1$ ，那么无法通过交换来达到目标，无解。否则我们交换 $2 \times k_0$ 次即可交换所有的 $01$ 对。</p><p>第二种解法：</p><p>​    假设起始和目标为 $00$ 的蜡烛数量为 $e_0$ ，起始和目标为 $11$ 的蜡烛数量为 $e_1$ 。那么我们需要交换 $01$ 使得他们与目标都不相同，这样如果最后只剩下一个 $1$ （也就是 $e_0 = e_1 - 1$） ，那么操作这个 $1$ 就可以把其他所有状态改变，也就是全部变成目标状态。</p><p>注意特判起始和目标相同的情况。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">int</span> k1 = <span class="number">0</span>, k0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> e1 = <span class="number">0</span>, e0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'1'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) ++ k1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'1'</span>) ++ k0;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">'1'</span> &amp;&amp; b[i] == <span class="string">'1'</span>) ++ e1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) ++ e0;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (k1 != k0)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (e0 == e1 - <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; e0 * <span class="number">2</span> + <span class="number">1</span> &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">return</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (e0 == e1 - <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="built_in">min</span>(e0 * <span class="number">2</span> + <span class="number">1</span>, k1 + k0) &lt;&lt; endl, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    cout &lt;&lt; k1 + k0 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="D-X-or-mas-Tree"><a href="#D-X-or-mas-Tree" class="headerlink" title="D. X(or)-mas Tree"></a>D. X(or)-mas Tree</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个结点的带权无根树和 $m$ 个限定条件 $(u, v, w)$ 。求出任意一个满足限制的树。</p><p>给出的边权如果为 $-1$ ，表示这个边权待定。</p><p>限定条件 $(u, v, w)$ ，表示从 $u$ 出发到达 $v$ 的路径上的所有边的异或和的 $popcount$ 的奇偶性 。</p><p>$popcount$ 指一个数字二进制位下 $1$ 的数量。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>首先有一个等式 $popcount(x \bigoplus y) = popcount(x) \bigoplus popcount(y) \pmod 2$ 。</p><blockquote><p>证明：假设 $popcount(x) = k_1, popcount(y) = k_2$ 。</p><p>那么 $popcount(x \bigoplus y) = k_1 + k_2 - cnt \times 2$ ，其中，$cnt$ 表示在某一位上 $x = y = 1$ ，这样的位的个数。</p><p>显然 $k1 + k2 - cnt \times 2 = k_1 + k_2 \pmod 2$ 。</p></blockquote><p>设 $a(u)$ 表示从结点 $u$ 到达根节点的路径异或和的 $popcount$ 。</p><p>对于限制条件 $(u, v, w)$ ， 其实就是 $a(u) \bigoplus a(v) = w$ 。</p><p>对于给出的边 $(u, v, w)$ ，如果给定了边权，其实也是一个限制条件，因为 $a(u) \bigoplus a(v) = popcount(w)$ 。</p><p>我们先把这些限制条件全部扔到另外一张图上。</p><p>容易发现，我们给边权填上 $0, 1$ 即产生两种不同的奇偶性，只需要填 $0$ 或者 $1$ 即可。</p><p>那么我们对限制图做染色法求出 $a(i)$ 即可。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = <span class="number">1200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop(x) __builtin_popcount(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], rh[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]; <span class="comment">// vis 用来染色</span></span><br><span class="line"><span class="keyword">bool</span> cant;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a(i) 表示从i到根节点路径上的异或和的popcount</span></span><br><span class="line"><span class="comment">    cant 表示无解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) h[i] = rh[i] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) a[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">    cant = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> h[], <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (cant) <span class="keyword">return</span> ;</span><br><span class="line">    a[u] = c; vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = rh[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[j]) <span class="built_in">dfs</span>(j, u, c ^ w[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a[j] ^ a[u]) != w[i]) { cant = <span class="literal">true</span>; <span class="keyword">return</span>; }</span><br><span class="line">        <span class="comment">// 如果j被染色过，需要满足限制，否则无解</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (w[i] != <span class="number">-1</span>) cout &lt;&lt; u &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="string">' '</span> &lt;&lt; w[i] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; u &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="string">' '</span> &lt;&lt; (a[u] ^ a[j]) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">print</span>(j, u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b, c); <span class="built_in">add</span>(h, b, a, c);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">-1</span>) <span class="comment">// 边不为-1，做一条限制</span></span><br><span class="line">            <span class="built_in">add</span>(rh, a, b, <span class="built_in">pop</span>(c) &amp; <span class="number">1</span>), <span class="built_in">add</span>(rh, b, a, <span class="built_in">pop</span>(c) &amp; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 后面还有m条限制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(rh, a, b, c); <span class="built_in">add</span>(rh, b, a, c);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cant) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"NO\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 764 (Div.3)</title>
      <link href="/2022/02/16/Codeforces-Round-764-Div-3/"/>
      <url>/2022/02/16/Codeforces-Round-764-Div-3/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Plus-One-on-the-Subset"><a href="#A-Plus-One-on-the-Subset" class="headerlink" title="A. Plus One on the Subset"></a>A. Plus One on the Subset</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的序列，每次选择若干个数字加 $1$ ，问最少操作几次可以使所有数字相同。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>每次操作最小的数字，顺便补上其他小于最大值的数字，因此最少次数为极差。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">-1</span>, minv = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ )</span><br><span class="line">    {</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, x);</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, x);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; maxv - minv &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Make-AP"><a href="#Make-AP" class="headerlink" title="Make AP"></a>Make AP</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出三个数字，可以选择其中一个数字（也可以不选），使其乘上任意一个正数。</p><p>问能否让这三个数字成为等差数列（顺序不能换）。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>由于只有三个数字，枚举哪个数字用来乘即可。</p><p>类似的题目： <a href="https://horb7.github.io/2021/12/31/Codeforces-Good-Bye-2021/">CF Good bye 2021 C题</a></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> na = <span class="number">2</span> * b - c;</span><br><span class="line">    ok |= (na % a == <span class="number">0</span> &amp;&amp; (c - b) == (b - na) &amp;&amp; (na * a) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> nb = (a + c) / <span class="number">2</span>;</span><br><span class="line">    ok |= (nb % b == <span class="number">0</span> &amp;&amp; (c - nb) == (nb - a) &amp;&amp; (nb * b) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> nc = (<span class="number">2</span> * b - a);</span><br><span class="line">    ok |= (nc % c == <span class="number">0</span> &amp;&amp; (nc - b) == (b - a) &amp;&amp; (nc * c) &gt; <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; (ok ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="C-Division-by-Two-and-Permutation"><a href="#C-Division-by-Two-and-Permutation" class="headerlink" title="C. Division by Two and Permutation"></a>C. Division by Two and Permutation</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的序列，每次可以选择一个数字 $x$ 使其变为 $\lfloor \dfrac x 2 \rfloor$ 。问能否使序列变为一个 $1 \sim n$ 的排列。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>每个数字都必须为 $[1, n]$ 的数字，所以第一步要把所有大于 $n$ 的数字变为 $[1, n]$ 之间的数字。</p><p>从后往前遍历，由于每个数字都需要恰好 $1$ 个。那么如果当前数字没有，一定不能成功，如果有多个，留下一个并且把剩下的转化为 $\lfloor \dfrac x 2 \rfloor$ 即可。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n &amp;&amp; cin &gt;&gt; x; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> (x &gt; n) x /= <span class="number">2</span>;</span><br><span class="line">        cnt[x] ++ ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!cnt[i]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"NO\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">while</span>(cnt[i] &gt; <span class="number">1</span>) cnt[i / <span class="number">2</span>] ++, cnt[i] -- ;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="D-Palindromes-Coloring"><a href="#D-Palindromes-Coloring" class="headerlink" title="D. Palindromes Coloring"></a>D. Palindromes Coloring</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出长度为 $n$ 的字符串和 $k$ 种染料，每种染料都至少染 $1$ 个字符，被染上相同染料的字符可以任意调换顺序。</p><p>给字符串染上染料，使得所有被染上相同染料的字符串（子串）为回文串。问长度最小的字符串的最大长度为多少。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于可以任意调换顺序，因此字符串顺序不是考虑因素。</p><p>要把一个子串变成回文串，我们需要任意个偶数对和至多一个任意字符。</p><p>那么我们可以求出偶数对的数量以及单个的字符的数量，然后二分答案即可。</p><p>注意如果一个字符出现了奇数次，我们可以把它拆成若干个偶数对和一个单独的字符。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> even, odd, k; <span class="comment">// 能构成偶数对的字符数量、单独的字符数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> nt = even, no = odd;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k * (x - <span class="number">1</span>) &gt; nt) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 每个子串至少要 (x-1) 个even</span></span><br><span class="line">        nt -= k * (x - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nt + no &lt; k) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意可以把能构成偶数对的字符数量变成单独的字符使用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k * x &lt;= nt) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    even = odd = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) a[c - <span class="string">'a'</span>] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) even += x - <span class="number">1</span>, odd ++ ;</span><br><span class="line">        <span class="keyword">else</span> even += x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="E-Masha-forgetful"><a href="#E-Masha-forgetful" class="headerlink" title="E.Masha-forgetful"></a>E.Masha-forgetful</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出 $n$ 个长度为 $m$ 的字符串，以及需要匹配的字符串 $s$ （长度也为 $m$），问能否把 $s$ 拆成任意多段（每段长度至少为 $2$），使得每一段在前 $n$ 个字符串出现过。<br>如果满足，输出 $k$ 段，且输出每一段在其他字符串出现的首尾位置，以及它出现在哪个字符串。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p><strong>首先，任何一个不小于 $2$ 的数字都可以由若干个 $2$ 和 $3$ 组成</strong> 。</p><p>这就意味这我们只需要把 $s$ 拆成若干个长度为 $2$ 和 $3$ 的段即可。</p><p>$dp(i)$ 表示前 $i-1$ 个字符是匹配的。</p><p>在前 $n$ 个字符串中，找出所有段长度为 $2$ 和 $3$ 的信息（即题目要求的首尾位置和出现在第几个字符串）。</p><p>然后从前往后遍历 $s$ ，求出那些位置是匹配的。最后从后往前找到路径即可。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> tp = tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    tp f2[<span class="number">10</span>][<span class="number">10</span>], f3[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">// f2(i, j)表示 ij 这样的段出现的信息</span></span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        string s; cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m) f2[s[j]-<span class="string">'0'</span>][s[j+<span class="number">1</span>]-<span class="string">'0'</span>] = {j + <span class="number">1</span>, j + <span class="number">2</span>, i + <span class="number">1</span>};</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">2</span> &lt; m) f3[s[j]-<span class="string">'0'</span>][s[j+<span class="number">1</span>]-<span class="string">'0'</span>][s[j+<span class="number">2</span>]-<span class="string">'0'</span>] = {j + <span class="number">1</span>, j + <span class="number">3</span>, i + <span class="number">1</span>};</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>)</span></span>; <span class="comment">// dp(i)表示前面i-1个位置是否可以</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!dp[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m &amp;&amp; f2[s[i]-<span class="string">'0'</span>][s[i+<span class="number">1</span>]-<span class="string">'0'</span>] != <span class="built_in">tp</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) dp[i + <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">2</span> &lt; m &amp;&amp; f3[s[i]-<span class="string">'0'</span>][s[i+<span class="number">1</span>]-<span class="string">'0'</span>][s[i+<span class="number">2</span>]-<span class="string">'0'</span>] != <span class="built_in">tp</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) dp[i + <span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dp[m]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"-1\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = m; <span class="comment">// 记录路径</span></span><br><span class="line">    vector&lt;tp&gt; ans;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; dp[i - <span class="number">2</span>] &amp;&amp; f2[s[i<span class="number">-2</span>]-<span class="string">'0'</span>][s[i<span class="number">-1</span>]-<span class="string">'0'</span>] != tp{<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>})</span><br><span class="line">        {</span><br><span class="line">            ans.<span class="built_in">push_back</span>(f2[s[i<span class="number">-2</span>]-<span class="string">'0'</span>][s[i<span class="number">-1</span>]-<span class="string">'0'</span>]);</span><br><span class="line">            i -= <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ans.<span class="built_in">push_back</span>(f3[s[i<span class="number">-3</span>]-<span class="string">'0'</span>][s[i<span class="number">-2</span>]-<span class="string">'0'</span>][s[i<span class="number">-1</span>]-<span class="string">'0'</span>]);</span><br><span class="line">            i -= <span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : ans) cout &lt;&lt; get&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">' '</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">' '</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(t) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="F-Interacdive-Problem"><a href="#F-Interacdive-Problem" class="headerlink" title="F. Interacdive Problem"></a>F. Interacdive Problem</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出数字 $n$ ，要求猜出数字 $x$ ，其中 $1 \le x \lt n \le 1000$ 。</p><p>可以给出询问 $+ \ \ c$ ，表示令 $x = x + c$ ，之后给出 $\lfloor \dfrac x n \rfloor$ 。</p><p>最多可以操作 $10$ 次。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>可以把 $x$ 写成 $x / n * n + x \% n$ 。</p><p>二分答案，假设 $mid = x$ ，即 $mid = mid / n * n + mid \% n$ 。</p><p>询问 $n - mid \% n$ ，这样可以使 $x + n - mid \% n = x / n * n + n + x \% n - mid \% n$ 。</p><p>发现倍数增加了，那么有 $x \% n \ge mid \% n$ ，即 $mid \le x$ 。</p><p>否则 $mid \gt x$ 。</p><p>注意由于 $x$ 已经加上了 $n - mid \% n$ ，那么 $l$ 和 $r$ 也要加上，保证 $l \le x \le r$ 。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;] (<span class="keyword">int</span> add)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"+ "</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> cin &gt;&gt; add, add;</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">auto</span> submit = [&amp;] (<span class="keyword">int</span> ans)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"! "</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> to = n - mid % n, now = <span class="built_in">query</span>(to);</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= mid / n + <span class="number">1</span>) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        l += to, r += to;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">submit</span>(r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// int _; for (cin &gt;&gt; _; _--;)</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="G-MinOr-Tree"><a href="#G-MinOr-Tree" class="headerlink" title="G. MinOr Tree"></a>G. MinOr Tree</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给出一张无向图，求或和最小的生成树。</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>按位分析，从大到小，假设当前位为 $bit$ 。</p><p>由于要求最小或和，那么最好情况下，我们只合并所有在 $bit$ 位上为 $0$ 和点。</p><p>如果合并完发现没有用上所有点，那么说明要想生成最小生成树，必须要 $bit$ 位上为 $1$ 的点。</p><p>考虑下一位前，由于当前位已经被考虑过，所以要把所有在当前位为 $1$ 的边变为当前位为 $0$ 。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 终点是一切概率的结束，也是一切期望的开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(m)</span>, <span class="title">v</span><span class="params">(m)</span>, <span class="title">w</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">        -- u[i], -- v[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">29</span>; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">    {</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">E</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (w[k] &lt; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">            {</span><br><span class="line">                E[u[k]].<span class="built_in">push_back</span>(v[k]);</span><br><span class="line">                E[v[k]].<span class="built_in">push_back</span>(u[k]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        used[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 从0号点开始bfs</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q; Q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y : E[x])</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (!used[y])</span><br><span class="line">                {</span><br><span class="line">                    used[y] = <span class="literal">true</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(y);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (used != vector&lt;<span class="keyword">bool</span>&gt; (n, <span class="literal">true</span>))</span><br><span class="line">        {</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            <span class="comment">// 这一位已经考虑过了，把j位上为1的数字去掉</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k ++ )</span><br><span class="line">                <span class="keyword">if</span> (w[k] &gt;&gt; j &amp; <span class="number">1</span>) w[k] ^= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--;) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 767(Div.2)</title>
      <link href="/2022/02/16/Codeforces-Round-767-Div-2/"/>
      <url>/2022/02/16/Codeforces-Round-767-Div-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-767-Div-2"><a href="#Codeforces-Round-767-Div-2" class="headerlink" title="Codeforces Round #767 (Div.2)"></a>Codeforces Round #767 (Div.2)</h1><h2 id="C-Meximum-Array"><a href="#C-Meximum-Array" class="headerlink" title="C. Meximum Array"></a>C. Meximum Array</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定序列 $a$ ，以下列方式构造序列 $b$ ，使得 $b$ 的字典序最大。</p><p>当序列 $a$ 不为空时：</p><ul><li>选择一个序列 $a$ 的前缀区间。</li><li>将此前缀区间的 $mex$ 值放置 $b$ 序列的末尾，然后在 $a$ 序列中删除此前缀。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目要求将 $a$ 序列进行划分，使得每个集合的 $mex$ 值按顺序拼接起来字典序最大。</p><p>根据贪心，对于每个 $mex$ ，我们一定要选择值最大的前缀，如果有多个则选择前缀区间最短的。</p><p>如何算一个区间 $mex$ ？<code>int p = 0; while(sum[p]) ++ p;</code></p><p>枚举每个元素，计算以它为结尾的区间 $mex$ ，<strong>如果后面的元素不存在 $mex$ 元素，那么就不可能对此 $mex$ 产生贡献</strong>，无论加再多元素，$mex$ 值也不会变，所以直接贪心取这个 $mex$ 值即可。</p><p>具体来说，只需要开两个桶，第一个桶用来记录当前区间的元素，第二个桶用来记录后面区间的元素即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* さあ，Games始めましょうか */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* all表示总桶，cur表示当前桶 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], all[N], cur[N], ret[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) all[i] = cur[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i], ++ all[a[i]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p表示当前的mex值，last表示上一段区间的末尾位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>, last = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        ++ cur[a[i]];</span><br><span class="line">        <span class="keyword">while</span>(cur[p]) ++ p; <span class="comment">// 统计以当前元素为末尾的mex值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后面不存在p元素，那么后面的元素不会对mex产生贡献</span></span><br><span class="line">        <span class="keyword">if</span> (!all[p])</span><br><span class="line">        {</span><br><span class="line">            ret[++ cnt] = p;</span><br><span class="line">            <span class="comment">// 清空当前桶(cur)，更新记录后面元素的桶(all)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = last + <span class="number">1</span>; j &lt;= i; j ++ ) cur[a[j]] = <span class="number">0</span>, -- all[a[j]];</span><br><span class="line">            last = i;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++ ) cout &lt;&lt; ret[i] &lt;&lt; <span class="string">" \n"</span>[i == cnt];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="D-Peculiar-Movie-Preferences"><a href="#D-Peculiar-Movie-Preferences" class="headerlink" title="D. Peculiar Movie Preferences"></a>D. Peculiar Movie Preferences</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个长度不超过 $3$ 的字符串，问是否存在一个子序列，使得其相应的字符串按顺序拼接后是一个回文串。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果一个字符串本身就是回文，那么一定存在。</p><p>首先可以明确，如果存在一个子序列满足条件，那么一定存在长度为 $2$ 的子序列满足条件(因为长度最多为 $3$ ，只需要取满足条件的子序列的首尾元素即可)。</p><p>对于长度为 $2$ 的字符串，也就是 $2 + 2$ 的情况 ，只需要检查是否存在其逆序即可。</p><p>对于长度为 $3$ 的字符串，有 $3 + 3, 2 + 3, 3 + 2$ 三种情况，先检查其逆序是否存在，对于 $2 + 3$ ，<strong>把左端去掉</strong>，检查逆序是否<strong>在前面出现过</strong>即可，$3 + 2$ 同理。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* さあ，Games始めましょうか */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    map&lt;string, <span class="keyword">int</span>&gt; pre, post;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (string &amp; str : s) cin &gt;&gt; str, ++ post[str];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (string k : s)</span><br><span class="line">    {</span><br><span class="line">        string oth = k;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">all</span>(oth));</span><br><span class="line">        <span class="comment">// 2 + 2 or 3 + 3</span></span><br><span class="line">        <span class="keyword">if</span> (pre[oth] || post[oth]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"YES\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">if</span> (k.<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 3 + 2</span></span><br><span class="line">            oth = k.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">reverse</span>(<span class="built_in">all</span>(oth));</span><br><span class="line">            <span class="keyword">if</span> (post[oth]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"YES\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 + 3</span></span><br><span class="line">            oth = k.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">reverse</span>(<span class="built_in">all</span>(oth));</span><br><span class="line">            <span class="keyword">if</span> (pre[oth]) <span class="keyword">return</span> cout &lt;&lt; <span class="string">"YES\n"</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        }</span><br><span class="line">        pre[k] ++ ; post[k] -- ;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="E-Grid-Xor"><a href="#E-Grid-Xor" class="headerlink" title="E. Grid Xor"></a>E. Grid Xor</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>存在 $n \times n$ 的矩阵，每个位置 $a_{ij}$ 表示一个数。</p><p>给出另一个 $n \times n$ 的矩阵，每个位置 $b_{ij}$ 表示矩阵 $a$ 对应位置<strong>相邻格子</strong>的值的异或和(相邻指上下左右四个方向)。</p><p>问矩阵 $a$ 所有元素的异或和为多少？(矩阵 $a$ 不唯一，但是其异或和一定是唯一的)。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>要求矩阵 $a$ 所有元素的异或和，我们只要异或每个元素的<strong>奇数次</strong>即可。</p><p>根据递推，先异或所有 $b_{1j}$ ，这样第一行的所有元素的异或次数就确定了，从第二行开始递推，如果上一行异或次数为偶数，只能从这一行来异或。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* さあ，Games始めましょうか */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[] = { <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> }, dc[] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> };</span><br><span class="line"><span class="keyword">int</span> n, g[N][N];</span><br><span class="line"><span class="keyword">bool</span> is_even[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">void</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> dx = x + dr[i], dy = y + dc[i];</span><br><span class="line">            is_even[dx][dy] = !is_even[dx][dy];</span><br><span class="line">        }</span><br><span class="line">        ret ^= g[x][y];</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j], is_even[i][j] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">modify</span>(<span class="number">1</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (is_even[i - <span class="number">1</span>][j]) <span class="built_in">modify</span>(i, j);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> _; <span class="keyword">for</span> (cin &gt;&gt; _; _--; ) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devu和鲜花</title>
      <link href="/2022/02/16/Devu%E5%92%8C%E9%B2%9C%E8%8A%B1/"/>
      <url>/2022/02/16/Devu%E5%92%8C%E9%B2%9C%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="Devu-和鲜花"><a href="#Devu-和鲜花" class="headerlink" title="Devu 和鲜花"></a>Devu 和鲜花</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Devu 有 $N$ 个盒子，第 $i$ 个盒子中有 $A_i$ 枝花。</p><p>同一个盒子内的花颜色相同，不同盒子内的花颜色不同。</p><p>Devu 要从这些盒子中选择 $M$ 枝花组成一束，求共有多少种方案。</p><p>若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。</p><p>结果需对 $10^9 + 7$ 取模之后方可输出。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数 $N$ 和 $M$ 。</p><p>第二行包含 $N$ 个空格隔开的整数，表示 $A_1, A_2, \ldots , A_N$ 。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le N \le 20, 0 \le M \le 10^{14}, 0 \le A_i \le 10^{12}$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li><p>假设每个盒子的花的数量是无限的。</p><p>设 $x_i$ 为第 $i$ 个盒子取出来的花的数量。则求解 $x_1 + x_2 + \ldots + x_N = M$ 的方案数，其中 $x_i \ge 0$ 。</p><p>设 $y_i = x_i + 1$ 。</p><p>则问题变为 $y_1 + y_2 + \ldots + y_n = M + N$  的方案数，其中 $y_i \ge 1$ 。</p><p>用隔板法求解，在 $M + N - 1$ 个间隔中插入 $N - 1$ 个隔板，则有 $C_{M + N - 1}^{N - 1}$ 中方案。</p></li><li><p>对于有限制的方案数量。</p><p>题目限制了 $x_i \le A_i$ 。正难则反，我们用总方案数量减去不满足限制的方案数量就是满足限制的方案数量。</p><p>设 $s_i$ 表示第 $i$ 个限制不满足，即 $s_i : \ x_i \ge A_i + 1$ 。</p><p>记 $s_0$ 为所有方案。</p><p>那么总满足限制的方案数量为：</p><p>$s_0 - |s_1 \bigcup s_2 \bigcup s_3 \ldots \bigcup s_N|<br>= s_0 - \sum_{1 \le i \le N}|s_i| + \sum_{1 \le i \lt j \le N}|s_i \bigcap s_j| - \ldots$</p><p>求解 $s_i: $ 即求 $x_1 + x_2 + \ldots + x_N = M$ ，其中 $x_i \ge A_i + 1$ ，其他 $x \ge 0$ 。</p><p>两边同时减 $A_i + 1$ ，则 $x_1 + x_2 + \ldots + x_N = M - (A_i + 1)$ ，其中 $x_i \ge 0$ 。</p><p>同理令 $y_i = x_i + 1$ 。</p><p>即 $y_1 + y_2 + \ldots + y_N = M - (A_i + 1) + N$ ，$y_i \ge 1$ 。</p><p>方案数量为 $C_{M - (A_i + 1) + N - 1}^{N - 1}$ 。</p><p>同理 $|s_i \bigcap s_j| = C_{M - (A_i + 1) - (A_j + 1) + N - 1}^{N - 1}$ 。</p><p>由于 $N$ 范围很小，我们可以使用二进制枚举求出所有情况。</p><p>容斥复杂度为 $O(2^n)$ ，而每种情况处理需要 $O(n)$ 复杂度，所以总复杂度为 $O(2^n \times n)$ 。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p = mod)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= p; k; k &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % p)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span> <span class="params">(ll m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = m; i &gt; m - n; i -- ) res = i % mod * res % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * res * down % mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n, m, ret = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) down = <span class="number">1ll</span> * down * i % mod;</span><br><span class="line">    down = <span class="built_in">qmi</span>(down, mod<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        ll cm = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (s &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                cm -= a[j] + <span class="number">1</span>;</span><br><span class="line">                sign *= <span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        ret = (ret + sign * <span class="built_in">C</span>(cm, n<span class="number">-1</span>)) % mod;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; (ret + mod) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现简易对拍器</title>
      <link href="/2022/02/16/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/"/>
      <url>/2022/02/16/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="利用C-实现简易对拍器"><a href="#利用C-实现简易对拍器" class="headerlink" title="利用C++实现简易对拍器"></a>利用C++实现简易对拍器</h1><p>我们有的时候写完了代码，提交到OJ上<del>莫名其妙</del>却wrong answer了，通常是算法写假了或者一些边界没有考虑。</p><p>为了减少手动造数据的耗时，我们可以使用对拍器自动生成数据并进行运算找到错误数据。</p><p>使用对拍器需要：</p><ol><li>你的<del>正确的</del>看起来正确的代码和一份正确的代码（在比赛中可以写一份会TLE但是一定正确的代码）。</li><li>生成随机数据的文件。</li><li>用来实现对比两份代码输出结果的文件。</li></ol><hr><p>为了方便管理文件，不显得很乱，我把对拍器单独放进了当前目录下的一个文件夹，如图：</p><p><img src="/images/project/duipai.png" alt=""></p><p>其中:</p><ul><li>check用来实现两份代码输出的比较</li><li>gen用来生成随机数据</li><li>force实现暴力算法</li><li>上一层目录的Horb7实现看起来正确的算法</li><li>toexe用来实现cpp文件的编译(太菜了用不来makefile)</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>根据gen文件生成随机数据至data.txt，再调用Horb7.exe和force.exe生成两份输出结果，再比较两份输出结果是否有不同，如果不同则显示 <code>error</code> 。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol><li>编译好你写的两份代码</li><li>在gen.cpp中写入针对这道题目的数据的输入格式</li><li>运行check.exe</li></ol><p>如果完全相同则会显示<code>your program may be right.</code>，否则会显示<code>error!</code>，并输出两份不同的输出结果。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于<del>我不会bat脚本</del>各种原因，我选择用cpp文件实现输出比较，本质还是通过 <code>windows.h</code> 库调用dos命令。</p><h3 id="check-code"><a href="#check-code" class="headerlink" title="check code"></a>check code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">32</span>; <span class="comment">// 比较32次</span></span><br><span class="line">    <span class="keyword">while</span> (cnt -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">"gen.exe &gt; data.txt"</span>);</span><br><span class="line">        <span class="comment">// 调用上一级写的可执行文件(system不支持相对路径)</span></span><br><span class="line">        <span class="built_in">system</span>(<span class="string">"D:/VsCode/Code/Horb7.exe &lt; data.txt &gt; pros.txt"</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">"force.exe &lt; data.txt &gt; std.txt"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">"fc pros.txt std.txt"</span>))</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="string">"error!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"your program may be right."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="gen-code"><a href="#gen-code" class="headerlink" title="gen code"></a>gen code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个[a, b]之间的整数（最大范围[0, 32757]）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd(a, b) (rand() % (b - a + 1) + a)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// 随机数种子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ---------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">// 写出随机数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">1</span>; <span class="comment">// T 组数据</span></span><br><span class="line">    cout &lt;&lt; cases &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cases -- )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 根据题目输出具体格式的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i ++ ) cout &lt;&lt; <span class="built_in">rd</span>(<span class="number">1</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="toexe-code"><a href="#toexe-code" class="headerlink" title="toexe code"></a>toexe code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"g++ check.cpp -o check"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"g++ force.cpp -o force"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"g++ gen.cpp -o gen"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"g++ D:/VsCode/Code/Horb7.cpp -o D:/VsCode/Code/Horb7"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021ICPC沈阳站</title>
      <link href="/2022/02/16/2021ICPC%E6%B2%88%E9%98%B3/"/>
      <url>/2022/02/16/2021ICPC%E6%B2%88%E9%98%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="2021ICPC沈阳站"><a href="#2021ICPC沈阳站" class="headerlink" title="2021ICPC沈阳站"></a>2021ICPC沈阳站</h1><h2 id="B-Bitwise-Exclusive-OR-Sequence"><a href="#B-Bitwise-Exclusive-OR-Sequence" class="headerlink" title="B. Bitwise Exclusive-OR Sequence"></a>B. Bitwise Exclusive-OR Sequence</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于长度为 $n$ 的序列，给出 $m$ 个关系，第 $i$ 个关系形如 $a_j \bigoplus a_k = w_i$ ，表示第 $j$ 个元素和第 $k$ 个元素的异或值为 $w_i$ ，问满足所有关系的条件下，这个序列的和最小为多少。如果无解，输出 $-1$ 。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于关系 $a_j \bigoplus a_k = w_i$ ，把 $j$ 点和 $k$ 点连一条边，边权为 $w_i$ 。</p><p>无解的情况下，明显一定是存在一个环，在环内各边权存在矛盾。对于每一个连通块，当我们确定其中一个点的点权，其他点的点权是确定的。</p><p>判断是否无解，我们只需要看边权是否矛盾，可以 $dfs$ 每个连通块，如果某个点的点权和邻接点的点权异或值不为边权，则无解。</p><p>对于有解的情况，枚举每个连通块的每一个位，对于其中一个点(初始点)可以为 $0$ 或 $1$ 。那么在某一位上我们只需要取这个连通块内所有点的 $min(nums_0, nums_1)$ 作为答案的贡献即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> val[N]; <span class="comment">// 判断无解时用的点值</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// dfs连通块，判断某个点是否遍历过</span></span><br><span class="line"><span class="keyword">int</span> color[N][<span class="number">31</span>]; <span class="comment">// color(i, j) 表示第i个点在j位上的值（0 -&gt; 未涂色, 1 -&gt; 1, 2 -&gt; 0）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否无解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    val[u] = v; st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (st[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (val[j] == <span class="number">-1</span>) <span class="built_in">dfs</span>(j, w[i] ^ val[u]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> ((val[u] ^ val[j]) != w[i]) <span class="comment">// 矛盾</span></span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出某一位0和1的数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> &amp; one, <span class="keyword">int</span> &amp; zero, <span class="keyword">int</span> c, <span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    color[u][bit] = c; st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j][bit])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt;&gt; bit &amp; <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">1</span>) ++ zero; <span class="keyword">else</span> ++ one;</span><br><span class="line">                <span class="built_in">dfs</span>(j, one, zero, <span class="number">3</span> - c, bit);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">1</span>) ++ one; <span class="keyword">else</span> ++ zero;</span><br><span class="line">                <span class="built_in">dfs</span>(j, one, zero, c, bit);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m &amp;&amp; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;  i++ )</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">-1</span>, <span class="keyword">sizeof</span> val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="keyword">if</span> (!st[i]) <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">30</span>; b &gt;= <span class="number">0</span>; b -- )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> one = <span class="number">1</span>, zero = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i, one, zero, <span class="number">1</span>, b);</span><br><span class="line">                res = res + <span class="built_in">min</span>(one, zero) * (<span class="number">1ll</span> &lt;&lt; b);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="F-Encoded-Strings-I"><a href="#F-Encoded-Strings-I" class="headerlink" title="F. Encoded Strings I"></a>F. Encoded Strings I</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的字符串 $s$ 。对于每个前缀字符串 $pre_s$ ，将其重新编码，规则为：</p><p>设某个字符 $c$ 在 $pre_s$ 中<strong>最后一个位置</strong>为 $k$ ，$chr$ 为 $[k, len(pre_s)]$ 中不同字符的数量。那么把 $c$ 映射为第 $chr+1$ 个阿拉伯字母。</p><p>求出所有前缀字符串 $pre_s$ 最大的映射字符串。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>$cnt$ 存储每个字符最后一位后面的不同字符。</p><p>从前往后遍历前缀，当加入一个字符时，这个字符最后一个位置变为末尾，$cnt$ 清空。对于其他在前面出现的字符，它的 $cnt$ 数组加上这个字符即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    string s, ret; cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, set&lt;<span class="keyword">char</span>&gt; &gt; cnt;</span><br><span class="line">    set&lt;<span class="keyword">char</span>&gt; appear;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    {</span><br><span class="line">        string cur;</span><br><span class="line">        cnt[s[i]].<span class="built_in">clear</span>();</span><br><span class="line">        appear.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : appear) <span class="keyword">if</span> (s[i] != c) cnt[c].<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">            cur += <span class="built_in"><span class="keyword">char</span></span>(<span class="string">'a'</span> + cnt[s[j]].<span class="built_in">size</span>());</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, cur);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="J-Luggage-Lock"><a href="#J-Luggage-Lock" class="headerlink" title="J. Luggage Lock"></a>J. Luggage Lock</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有四位的密码锁，每次可以选择把一段连续的区间向上或者向下转动一格，问把初始状态转成目标状态至少需要多少次旋转。</p><p><img src="https://uploadfiles.nowcoder.com/images/20211120/393492_1637408086513/A6BD269127AA5F0284354062D342EFCC" alt=""></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>对于某一位数字 $a_i$ ，如果要把他向上转动 $k$ 次，我们同样可以让他向下转动 $10 - k$ 次，每个数字都有两种状态（除了 $k=0$ ，也就是初始和目标相同，它可以向上转动 $10$ 次，也可以向下转动 $10$ 次，也可以选择不转动）。所以我们可以三进制枚举每一个旋转状态 $b_1b_2b_3b_4$ 。</p><p>当我们得到一个旋转状态后呢？我们需要把这个状态变为全 $0$ ，由于每次可以选择一段连续区间 $+1 \ \ or \ \ -1$ ，可以想到 <strong>差分数组</strong> ，我们把状态变为全 $0$ 也就是意味着把差分数组变为全 $0$ 。</p><p>在一个差分数组中，变为全 $0$ 的最小代价为 $max(posi, |neg|)$ ，$posi$ 表示正数总和，$neg$ 表示负数总和。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rot[<span class="number">5</span>], back[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T; <span class="keyword">while</span>( T -- )</span><br><span class="line">    {</span><br><span class="line">        string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">            rot[i] = a[i] - b[i]; <span class="comment">// 向上为正，向下为负</span></span><br><span class="line">        <span class="comment">// 枚举每个数字的转动，向上或者向下（0有三种，所以要三进制枚举）</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">3</span> * <span class="number">3</span> * <span class="number">3</span> * <span class="number">3</span>, ret = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> state = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (state % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// 为1，反方向旋转</span></span><br><span class="line">                    <span class="keyword">if</span> (rot[j] &gt; <span class="number">0</span>) back[j] = rot[j] - <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">else</span> back[j] = <span class="number">10</span> + rot[j];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (state % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; !rot[j])</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// 为2，特判rot为0，由于在模1的时候0为10，所以这里为-10</span></span><br><span class="line">                    back[j] = <span class="number">-10</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> back[j] = rot[j];</span><br><span class="line">                state /= <span class="number">3</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 把旋转数组变为全0，即差分数组变为0</span></span><br><span class="line">            <span class="keyword">int</span> posi = <span class="number">0</span>, neg = <span class="number">0</span>; <span class="comment">// 差分数组变为0的次数：max(posi, neg)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">int</span> dif = (j ? back[j] - back[j<span class="number">-1</span>] : back[j]);</span><br><span class="line">                <span class="keyword">if</span> (dif &gt; <span class="number">0</span>) posi += dif;</span><br><span class="line">                <span class="keyword">else</span> neg += dif;</span><br><span class="line">            }</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, <span class="built_in">max</span>(posi, <span class="built_in">abs</span>(neg)));</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="J-Perfect-Matchings"><a href="#J-Perfect-Matchings" class="headerlink" title="J. Perfect Matchings"></a>J. Perfect Matchings</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>对于一个 $2 * n$ 个顶点的完全图，删除给定的一颗生成树，求剩下图的完美匹配数量有多少。</p><p>完美匹配，指最大数量的边集合，集合内任意两条边都没有公共顶点。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ol><li><p>对于一个 $2 <em> n$ 顶点的完全图，它的完美匹配数量有 $\prod_{i=1}^{n}2</em>i - 1$ 个。</p><blockquote><p>把 $n$ 个顶点放到左边去匹配右边 $n$ 个，选择 $n$ 个顶点 $C_{2n}^{n}$ ，匹配为 $n!$ 。</p><p>然后对于每一个匹配边，它的一个结点在右边时贡献一次，左边时又贡献一次，所以要除以二。</p><p>所以完美匹配数量为 $\dfrac{C_{2n}^{n} \times n!}{2}$ 个。</p><p>把 $C_{2n}^{n}$ 中的偶数项除以二后与 $n!$ 抵消，所以匹配数量为 $1 \times 3 \times 5 \ldots (2 \times n - 1) = \prod_{i=1}^{n}2*i - 1$ 。</p></blockquote></li><li><p>容斥原理</p><blockquote><p>用总的图的所有匹配数量减去其中有一些匹配边在生成树上的数量，枚举有几条边在生成树，减去所有不合法情况就是合法的情况。</p></blockquote></li><li><p>计数dp，枚举在生成树上的不合法情况</p><blockquote><p>设 $f(i, j, 0/1)$ 表示以 $i$ 为子树，匹配数量为 $j$ ，$i$ 参与/不参与匹配时的方案数量。</p><p>树上背包问题，设 $j$ 为 $i$ 的儿子，转移方程为：</p><script type="math/tex; mode=display">f(i, x + y, 0) += f(i, x, 0) * (f(j, y, 0) + f(j, y, 1)), y > 0 \\f(i, x + y, 1) += f(i, x, 1) * (f(j, y, 0) + f(j, y, 1)), y > 0 \\f(i, x + y + 1, 1) += f(i, x, 0) * f(j, y, 0)</script><p>可以枚举每个 $i$ 子树的大小使复杂度达到 $O(n^2)$ 。</p></blockquote></li></ol><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4010</span>, M = <span class="number">8010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> siz[N]; <span class="comment">// 每个子树的结点个数</span></span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">2</span>]; <span class="comment">// f(i, j, k) 表示以i为根的树，取j个配对，i有无选中的方案数量</span></span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">// p(i) 表示i个结点组成的完全图可配对的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    e[idx] = b; ne[idx] = h[a]; h[a] = idx ++ ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = siz[u] / <span class="number">2</span>; x &gt;= <span class="number">0</span>; x -- )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = siz[j] / <span class="number">2</span>; y &gt;= <span class="number">0</span>; y -- )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (y &gt; <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    f[u][x + y][<span class="number">0</span>] = (f[u][x + y][<span class="number">0</span>] + <span class="number">1ll</span> * f[u][x][<span class="number">0</span>] * (f[j][y][<span class="number">0</span>] + f[j][y][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">                    f[u][x + y][<span class="number">1</span>] = (f[u][x + y][<span class="number">1</span>] + <span class="number">1ll</span> * f[u][x][<span class="number">1</span>] * (f[j][y][<span class="number">0</span>] + f[j][y][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">                }</span><br><span class="line">                f[u][x + y + <span class="number">1</span>][<span class="number">1</span>] = (f[u][x + y + <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1ll</span> * f[u][x][<span class="number">0</span>] * f[j][y][<span class="number">0</span>] % mod) % mod;</span><br><span class="line">            }</span><br><span class="line">        siz[u] += siz[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = <span class="number">1ll</span> * p[i<span class="number">-1</span>] * (<span class="number">2</span> * i - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; <span class="number">2</span> * n &amp;&amp; cin &gt;&gt; u &gt;&gt; v; i ++ ) <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="comment">// 枚举生成树里的配对数量</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) res = (<span class="number">1ll</span> * res - <span class="number">1ll</span> * (f[<span class="number">1</span>][i][<span class="number">0</span>] + f[<span class="number">1</span>][i][<span class="number">1</span>]) * p[n - i] % mod) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (<span class="number">1ll</span> * res + <span class="number">1ll</span> * (f[<span class="number">1</span>][i][<span class="number">0</span>] + f[<span class="number">1</span>][i][<span class="number">1</span>]) * p[n-i] % mod) % mod;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; (res % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 区域站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钉子和小球</title>
      <link href="/2021/12/15/%E6%B4%9B%E8%B0%B7P5750-%E9%92%89%E5%AD%90%E5%92%8C%E5%B0%8F%E7%90%83/"/>
      <url>/2021/12/15/%E6%B4%9B%E8%B0%B7P5750-%E9%92%89%E5%AD%90%E5%92%8C%E5%B0%8F%E7%90%83/</url>
      
        <content type="html"><![CDATA[<h1 id="钉子和小球"><a href="#钉子和小球" class="headerlink" title="钉子和小球"></a>钉子和小球</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>如图的三角形木板上钉着 $\dfrac{n(n+1)}{2}$ 个钉子，还有 $(n+1)$ 个格子，钉子均匀分布，其中有一些钉子被拆掉，问最后小球落在 $m$ 格子的概率为多少？</p><p><img src="/images/dp/5750.png" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>概率DP，把格子也看作钉子。</p><p>设 $f(i, j)$ 表示经过 $(i, j)$ 位置的所有路径数量，那么到达 $m$ 格子的概率就是 $f(n+1, m) / f(1, 1)$ ，这是因为任何一个路径一定经过 $(1, 1)$ ，所以 $f(1, 1)$ 为 $2^n$ 。</p><p>对于一个位置 $(i, j)$ ，如果它有钉子，那么可以转移到左下角 $(i+1, j)$ 或者右下角 $(i+1, j+1)$ ，路径数量为一半。</p><p>如果它没有钉子，那么它会直接转移到下面正对着的两行的位置 $(i+2, j+1)$ 。</p><p>我们可以从上往下枚举。</p><p>注意初始化 $f(1, 1)$ 和 $f(2, 1) 、 f(2, 2)$ 。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ext[N][N]; <span class="comment">// 表示在(i, j)这个位置有无钉子</span></span><br><span class="line">ll f[N][N]; <span class="comment">// f(i, j) 表示存在(i, j)的路径的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m; m += <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = (<span class="number">1ll</span> &lt;&lt; n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">char</span> c; cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'*'</span>) ext[i][j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">if</span> (ext[<span class="number">1</span>][<span class="number">1</span>]) f[<span class="number">2</span>][<span class="number">1</span>] = f[<span class="number">2</span>][<span class="number">2</span>] = (<span class="number">1ll</span> &lt;&lt; n);</span><br><span class="line">    <span class="comment">// 每个位置有三种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        {</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>] / <span class="number">2</span> * ext[i<span class="number">-1</span>][j<span class="number">-1</span>] + \</span><br><span class="line">                f[i<span class="number">-1</span>][j] / <span class="number">2</span> * ext[i<span class="number">-1</span>][j] + \</span><br><span class="line">                f[i<span class="number">-2</span>][j<span class="number">-1</span>] * (!ext[i<span class="number">-2</span>][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ll g = __gcd(f[n+<span class="number">1</span>][m], f[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; f[n+<span class="number">1</span>][m] / g &lt;&lt; <span class="string">'/'</span> &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>] / g &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// int _; for (cin &gt;&gt; _; _ --; ) solve();</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期望DP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
